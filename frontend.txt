Directory Structure:
================================================================================
core/
    changelog/
        @unreleased/
            .gitkeep
            pr-6724.v2.yml
            pr-6771.v2.yml
            pr-6788.v2.yml
            pr-6810.v2.yml
            pr-6811.v2.yml
            pr-6854.v2.yml
            pr-6895.v2.yml
    src/
        blueprint.scss
        deprecatedTypeAliases.ts
        index.ts
        tsconfig.json
        _dark-theme.scss
        _reset.scss
        _typography.scss
        accessibility/
            focusStyleManager.ts
            _focus-states.scss
        common/
            abstractComponent.ts
            abstractPureComponent.ts
            alignment.ts
            boundary.ts
            classes.ts
            context.ts
            elevation.ts
            errors.ts
            index.ts
            intent.ts
            interactionMode.ts
            keyCodes.ts
            position.ts
            props.ts
            refs.ts
            _color-aliases.scss
            _flex.scss
            _mixins.scss
            _react-transition.scss
            _typography-colors.scss
            _variables-extended.scss
            _variables.scss
            utils/
                compareUtils.ts
                domUtils.ts
                functionUtils.ts
                index.ts
                isDarkTheme.ts
                jsUtils.ts
                keyboardUtils.ts
                mountOptions.ts
                reactUtils.ts
                typeUtils.ts
        components/
            components.md
            index.ts
            _index.scss
            alert/
                alert.md
                alert.tsx
                _alert.scss
            breadcrumbs/
                breadcrumb.tsx
                breadcrumbs.md
                breadcrumbs.tsx
                _breadcrumbs.scss
            button/
                button-group.md
                buttonGroup.tsx
                buttonProps.ts
                buttons.md
                buttons.tsx
                _button-group.scss
                _button.scss
                _common.scss
            callout/
                callout.md
                callout.tsx
                _callout.scss
            card/
                card.md
                card.tsx
                _card-variables.scss
                _card.scss
            card-list/
                card-list.md
                card-list.scss
                cardList.tsx
            collapse/
                collapse.md
                collapse.tsx
                _collapse.scss
            context-menu/
                context-menu-popover.md
                context-menu.md
                contextMenu.tsx
                contextMenuPopover.tsx
                contextMenuShared.ts
                contextMenuSingleton.tsx
                _context-menu.scss
            control-card/
                checkboxCard.tsx
                control-card.md
                controlCard.tsx
                radioCard.tsx
                switchCard.tsx
                useCheckedControl.ts
                _control-card.scss
            dialog/
                dialog.md
                dialog.tsx
                dialogBody.tsx
                dialogFooter.tsx
                dialogStep.tsx
                dialogStepButton.tsx
                multistepDialog.tsx
                _dialog-body.scss
                _dialog-footer.scss
                _dialog.scss
                _multistep-dialog.scss
            divider/
                divider.md
                divider.tsx
                _divider.scss
            drawer/
                drawer.md
                drawer.tsx
                _drawer.scss
            editable-text/
                editable-text.md
                editableText.tsx
                _editable-text.scss
            entity-title/
                entity-title.md
                entityTitle.tsx
                _entity-title.scss
            forms/
                asyncControllableInput.tsx
                asyncControllableTextArea.tsx
                checkbox.md
                control-group.md
                controlGroup.tsx
                controlProps.ts
                controls.tsx
                file-input.md
                fileInput.tsx
                form-group.md
                formGroup.tsx
                input-group.md
                inputGroup.tsx
                inputSharedProps.ts
                label.md
                numeric-input.md
                numericInput.tsx
                numericInputUtils.ts
                radio.md
                radioGroup.tsx
                switch.md
                text-area.md
                textArea.tsx
                _common.scss
                _control-group.scss
                _controls.scss
                _file-input.scss
                _form-group.scss
                _index.scss
                _input-group.scss
                _input.scss
                _label.scss
                _numeric-input.scss
            hotkeys/
                hotkey.tsx
                hotkeyParser.ts
                hotkeys-target2.md
                hotkeys.tsx
                hotkeysDialog2.tsx
                hotkeysTarget2.tsx
                index.ts
                keyComboTag.tsx
                _hotkeys.scss
            html/
                html.md
                html.tsx
            html-select/
                html-select.md
                htmlSelect.tsx
                _common.scss
                _html-select.scss
            html-table/
                html-table.md
                htmlTable.tsx
                _html-table.scss
            icon/
                icon.md
                icon.tsx
                _icon-mixins.scss
                _icon.scss
            menu/
                menu.md
                menu.tsx
                menuDivider.tsx
                menuItem.tsx
                _common.scss
                _menu.scss
                _submenu.scss
            navbar/
                navbar.md
                navbar.tsx
                navbarDivider.tsx
                navbarGroup.tsx
                navbarHeading.tsx
                _navbar.scss
            non-ideal-state/
                non-ideal-state.md
                nonIdealState.tsx
                _non-ideal-state.scss
            overflow-list/
                overflow-list.md
                overflowList.tsx
                _overflow-list.scss
            overlay/
                overlay.md
                overlay.tsx
                overlayProps.ts
                overlayUtils.ts
                _overlay.scss
            overlay2/
                overlay2.md
                overlay2.tsx
                overlayInstance.ts
            panel-stack/
                panel-stack.md
                panelProps.ts
                panelStack.tsx
                panelView.tsx
                _panel-stack.scss
            panel-stack2/
                panel-stack2.md
                panelStack2.tsx
                panelTypes.ts
                panelView2.tsx
                _panel-stack2.scss
            popover/
                customModifiers.ts
                menu-item.md
                popover.md
                popover.tsx
                popoverArrow.tsx
                popoverPlacementUtils.ts
                popoverPosition.ts
                popoverSharedProps.ts
                popperUtils.ts
                popupKind.ts
                tooltipContext.tsx
                _common.scss
                _popover-in-button-group.scss
                _popover-in-control-group.scss
                _popover-in-label.scss
                _popover-in-submenu.scss
                _popover-in-tree.scss
                _popover.scss
            portal/
                portal.md
                portal.tsx
                _portal.scss
            progress-bar/
                progress-bar.md
                progressBar.tsx
                _common.scss
                _progress-bar.scss
            resize-sensor/
                resize-sensor.md
                resizeSensor.tsx
            section/
                section.md
                section.tsx
                sectionCard.tsx
                _section.scss
            segmented-control/
                segmented-control.md
                segmentedControl.tsx
                _segmented-control.scss
            skeleton/
                skeleton.md
                _common.scss
                _skeleton.scss
            slider/
                handle.tsx
                handleProps.tsx
                multiSlider.tsx
                rangeSlider.tsx
                slider.tsx
                sliders.md
                sliderUtils.ts
                _common.scss
                _slider.scss
            spinner/
                spinner.md
                spinner.tsx
                _spinner.scss
            tabs/
                tab.tsx
                tabs.md
                tabs.tsx
                tabTitle.tsx
                _tabs.scss
            tag/
                compound-tag.md
                compoundTag.tsx
                tag.md
                tag.tsx
                tagRemoveButton.tsx
                tagSharedProps.ts
                _common.scss
                _compound-tag.scss
                _tag.scss
            tag-input/
                resizableInput.tsx
                tag-input.md
                tagInput.tsx
                _resizable-input.scss
                _tag-input.scss
            text/
                text.md
                text.tsx
            toast/
                overlayToaster.tsx
                overlayToasterProps.ts
                toast.md
                toast.tsx
                toast2.tsx
                toaster.ts
                toastProps.ts
                _toast.scss
            tooltip/
                tooltip.md
                tooltip.tsx
                _common.scss
                _tooltip.scss
            tree/
                tree.md
                tree.tsx
                treeNode.tsx
                treeTypes.ts
                _tree.scss
        context/
            blueprint-provider.md
            blueprintProvider.tsx
            context.md
            index.ts
            hotkeys/
                hotkeys-provider.md
                hotkeysProvider.tsx
            overlays/
                overlays-provider.md
                overlaysProvider.tsx
            portal/
                portal-provider.md
                portalProvider.tsx
        docs/
            accessibility.md
            classes.md
            colors.md
            index.md
            typography.md
            variables.md
        hooks/
            hooks.md
            index.ts
            useAsyncControllableValue.ts
            useIsomorphicLayoutEffect.ts
            usePrevious.ts
            useTimeout.ts
            hotkeys/
                hotkeyConfig.ts
                use-hotkeys.md
                useHotkeys.ts
            overlays/
                use-overlay-stack.md
                useLegacyOverlayStack.ts
                useOverlayStack.ts
        legacy/
            contextMenuLegacy.tsx
            contextMenuTargetLegacy.tsx
            hotkeys-legacy.md
            hotkeysDialogLegacy.tsx
            hotkeysEvents.ts
            hotkeysTargetLegacy.tsx
            legacy.md
            legacyCommon.ts
    test/
        index.ts
        isotest.mjs
        tsconfig.json
        utils.ts
        alert/
            alertTests.tsx
        breadcrumbs/
            breadcrumbsTests.tsx
            breadcrumbTests.tsx
        buttons/
            abstractButtonTests.tsx
            buttonTests.tsx
        callout/
            calloutTests.tsx
        card/
            cardTests.tsx
        card-list/
            cardListTests.tsx
        collapse/
            collapseTests.tsx
        common/
            propsTests.ts
            utilsTests.tsx
            utils/
                compareUtilsTests.ts
        context-menu/
            contextMenuSingletonTests.tsx
            contextMenuTests.tsx
        control-card/
            controlCardTests.tsx
        controls/
            controlsTests.tsx
            inputGroupTests.tsx
            numericInputTests.tsx
            radioGroupTests.tsx
        dialog/
            dialogTests.tsx
        drawer/
            drawerTests.tsx
        editable-text/
            editableTextTests.tsx
        entity-title/
            entityTitleTests.tsx
        forms/
            asyncControllableInputTests.tsx
            fileInputTests.tsx
            formGroupTests.tsx
            textAreaTests.tsx
        hooks/
            useHotkeysTests.tsx
            useOverlayStackTests.tsx
        hotkeys/
            hotkeysParserTests.ts
            hotkeyTests.tsx
            keyComboTagTests.tsx
        html/
            htmlTests.tsx
        html-select/
            htmlSelectTests.tsx
        icon/
            iconTests.tsx
        menu/
            menuItemTests.tsx
            menuTests.tsx
        multistep-dialog/
            multistepDialogTests.tsx
        non-ideal-state/
            nonIdealStateTests.tsx
        overflow-list/
            overflowListTests.tsx
        overlay/
            overlayTests.tsx
        overlay2/
            overlay2-test-debugging.scss
            overlay2Tests.tsx
        panel-stack/
            panelStackTests.tsx
        panel-stack2/
            panelStack2Tests.tsx
        popover/
            popoverTests.tsx
            popperUtilTests.ts
        portal/
            portalTests.tsx
        progress/
            progressBarTests.tsx
        resize-sensor/
            resizeSensorTests.tsx
        section/
            sectionTests.tsx
        segmented-control/
            segmentedControlTests.tsx
        slider/
            handleTests.tsx
            multiSliderTests.tsx
            rangeSliderTests.tsx
            sliderTests.tsx
            sliderTestUtils.ts
        spinner/
            spinnerTests.tsx
        tabs/
            tabsTests.tsx
        tag/
            compoundTagTests.tsx
            tagTests.tsx
        tag-input/
            tagInputTests.tsx
        text/
            textTests.tsx
        toast/
            overlayToasterTests.tsx
            toast2Tests.tsx
            toasterTests.tsx
            toastTests.tsx
        tooltip/
            tooltipTests.tsx
        tree/
            treeTests.tsx
================================================================================

File: changelog\@unreleased\.gitkeep
--------------------------------------------------------------------------------

================================================================================

File: changelog\@unreleased\pr-6724.v2.yml
--------------------------------------------------------------------------------
type: feature
feature:
  description: |-
    Add more dark theme color alias variables to prepare for dark theme adjustments coming in a future minor version of Blueprint:

    - `$pt-app-secondary-background-color`
    - `$pt-dark-app-secondary-background-color`
    - `$pt-app-elevated-background-color`
    - `$pt-dark-app-elevated-background-color`
  links:
  - https://github.com/palantir/blueprint/pull/6724

================================================================================

File: changelog\@unreleased\pr-6771.v2.yml
--------------------------------------------------------------------------------
type: fix
fix:
  description: Fix a case where a control card component (e.g. `<RadioCard>`) may
    have rendered with a `checked` state that does not match its `checked` prop. This
    can happen if that prop was changed outside of an `onChange` handler and in an
    `onClick` handler instead.
  links:
  - https://github.com/palantir/blueprint/pull/6771

================================================================================

File: changelog\@unreleased\pr-6788.v2.yml
--------------------------------------------------------------------------------
type: improvement
improvement:
  description: '[Button Group] Add outlined prop'
  links:
  - https://github.com/palantir/blueprint/pull/6788

================================================================================

File: changelog\@unreleased\pr-6810.v2.yml
--------------------------------------------------------------------------------
type: fix
fix:
  description: '[core] fix: FormGroup sub label dark theme'
  links:
  - https://github.com/palantir/blueprint/pull/6810

================================================================================

File: changelog\@unreleased\pr-6811.v2.yml
--------------------------------------------------------------------------------
type: improvement
improvement:
  description: Do not colour FormGroup sub label based on intent
  links:
  - https://github.com/palantir/blueprint/pull/6811

================================================================================

File: changelog\@unreleased\pr-6854.v2.yml
--------------------------------------------------------------------------------
type: improvement
improvement:
  description: Update focus indicator colors to meet WCAG 2.2 contrast standards
  links:
  - https://github.com/palantir/blueprint/pull/6854

================================================================================

File: changelog\@unreleased\pr-6895.v2.yml
--------------------------------------------------------------------------------
type: improvement
improvement:
  description: Correct Tabs typo
  links:
  - https://github.com/palantir/blueprint/pull/6895

================================================================================

File: src\blueprint.scss
--------------------------------------------------------------------------------
/*

Copyright 2021-present Palantir Technologies, Inc. All rights reserved.
Licensed under the Apache License, Version 2.0.

*/

// Import files in the same order that they are documented in the docs
@import "@blueprintjs/colors/lib/scss/colors";
@import "common/variables";
@import "common/variables-extended";
@import "common/mixins";

@import "reset";
@import "typography";
@import "accessibility/focus-states";
@import "dark-theme";
@import "components/index";

================================================================================

File: src\deprecatedTypeAliases.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @fileoverview type aliases for backwards-compatibility with @blueprintjs/core v4.x */

export {
    /** @deprecated use AbstractComponent */
    AbstractComponent as AbstractComponent2,
} from "./common/abstractComponent";

export {
    /** @deprecated use AbstractPureComponent */
    AbstractPureComponent as AbstractPureComponent2,
} from "./common/abstractPureComponent";

export type {
    /** @deprecated use InputGroupProps */
    InputGroupProps as InputGroupProps2,
} from "./components/forms/inputGroup";

export type {
    /** @deprecated use Toaster */
    Toaster as ToasterInstance,
} from "./components/toast/toaster";

================================================================================

File: src\index.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { FocusStyleManager } from "./accessibility/focusStyleManager";
export * from "./common";
export * from "./components";
export * from "./context";
export * from "./hooks";

/* eslint-disable deprecation/deprecation */
export * from "./deprecatedTypeAliases";

export {
    HotkeysTargetLegacy as HotkeysTarget,
    type HotkeysTargetLegacyComponent as IHotkeysTargetComponent,
} from "./legacy/hotkeysTargetLegacy";
export {
    isHotkeysDialogShowing,
    setHotkeysDialogProps,
    showHotkeysDialog,
    hideHotkeysDialog,
    hideHotkeysDialogAfterDelay,
} from "./legacy/hotkeysDialogLegacy";
export { ContextMenuTargetLegacy, type ContextMenuTargetLegacyComponent } from "./legacy/contextMenuTargetLegacy";

================================================================================

File: src\tsconfig.json
--------------------------------------------------------------------------------
{
    "extends": "../../../config/tsconfig.web",
    "compilerOptions": {
        "outDir": "../lib/esm",
    },
}

================================================================================

File: src\_dark-theme.scss
--------------------------------------------------------------------------------
// Copyright 2021 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

.#{$ns}-dark {
  // this tells the browser to use a dark theme UI, which is most useful for enabling
  // dark scrollbars (only works in Chrome and Edge, not IE or Firefox)
  color-scheme: dark;
}

================================================================================

File: src\_reset.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "common/variables";
@import "common/mixins";

// Apply a natural box layout model to all elements, but allow components to change as necessary
html {
  box-sizing: border-box;
}

// adjust box-sizing for every element ever
*,
*::before,
*::after {
  box-sizing: inherit;
}

// Style resets on top of Normalize.css

body {
  @include base-typography();
  color: $pt-text-color;
  font-family: $pt-font-family;
}

p {
  margin-bottom: $pt-grid-size;
  margin-top: 0;
}

small {
  font-size: $pt-font-size-small;
}

strong {
  font-weight: 600;
}

// consistent cross-browser text selection
::selection {
  background: $pt-text-selection-color;
}

================================================================================

File: src\_typography.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "common/variables";
@import "common/variables-extended";
@import "common/mixins";
@import "common/typography-colors";
@import "components/icon/icon";
@include pt-typography-colors();

/*
Headings

Markup:
<div>
  <h1 class="@ns-heading {{.modifier}}">H1 heading</h1>
  <h2 class="@ns-heading {{.modifier}}">H2 heading</h2>
  <h3 class="@ns-heading {{.modifier}}">H3 heading</h3>
  <h4 class="@ns-heading {{.modifier}}">H4 heading</h4>
  <h5 class="@ns-heading {{.modifier}}">H5 heading</h5>
  <h6 class="@ns-heading {{.modifier}}">H6 heading</h6>
</div>

.#{$ns}-text-muted - Change text color to a gentler gray.

Styleguide headings
*/

.#{$ns}-heading {
  @include heading-typography();
  margin: 0 0 $pt-grid-size;
  padding: 0;
}

// tag: (font-size, line-height)
$headings: (
  "h1": (36px, 40px),
  "h2": (28px, 32px),
  "h3": (22px, 25px),
  "h4": (18px, 21px),
  "h5": (16px, 19px),
  "h6": (14px, 16px)
) !default;

@each $tag, $props in $headings {
  %#{$tag} {
    font-size: nth($props, 1);
    line-height: nth($props, 2);
  }

  #{$tag}.#{$ns}-heading {
    @extend %#{$tag};
  }
}

/*
UI text

Markup:
<div class="{{.modifier}}">
  More than a decade ago, we set out to create products that would transform
  the way organizations use their data. Today, our products are deployed at
  the most critical government, commercial, and non-profit institutions in
  the world to solve problems we hadn’t even dreamed of back then.
</div>

.#{$ns}-ui-text - Default Blueprint font styles, applied to the `<body>` tag and available as a class for nested resets.
.#{$ns}-monospace-text - Use a monospace font (ideal for code).
.#{$ns}-running-text - Increase line height ideal for longform text. See [Running text](#core/typography.running-text) below for additional features.
.#{$ns}-text-large - Use a larger font size.
.#{$ns}-text-small - Use a smaller font size.
.#{$ns}-text-muted - Change text color to a gentler gray.
.#{$ns}-text-disabled - Change text color to a transparent, faded gray.
.#{$ns}-text-overflow-ellipsis - Truncate a single line of text with an ellipsis if it overflows its container.

Styleguide ui-text
*/

.#{$ns}-ui-text {
  @include base-typography();
}

.#{$ns}-monospace-text {
  @include monospace-typography();
}

// NOTE: .#{$ns}-text-large defined below after .#{$ns}-running-text

.#{$ns}-text-overflow-ellipsis {
  @include overflow-ellipsis();
}

/*
Running text

Markup:
<div class="@ns-running-text {{.modifier}}">
  <p>
    We build products that make people better at their most important
    work — the kind of work you read about on the front page of the
    newspaper, not just the technology section.
  </p>
  <ul>
    <li>Item the <code>first</code>.</li>
    <li>Item the <strong>second</strong>.</li>
    <li>Item the <a href="#core/typography.running-text">third</a>.</li>
  </ul>
  <h3>Scale, Speed, Agility</h3>
  <p>
    A successful data transformation requires the whole organization — users, the IT shop, and
    leadership — to operate in lockstep. With Foundry, the enterprise comes together to
    transform the organization and turn data into a competitive advantage.
  </p>
</div>

.#{$ns}-text-large - Use larger font size.

Styleguide running-text
*/

.#{$ns}-running-text {
  @include running-typography();

  @each $tag, $props in $headings {
    #{$tag} {
      @extend %#{$tag};
      @include heading-typography();
      margin-bottom: $pt-grid-size * 2;
      margin-top: $pt-grid-size * 4;
    }
  }

  hr {
    border: none;
    border-bottom: 1px solid $pt-divider-black;
    margin: ($pt-grid-size * 2) 0;
  }

  p {
    margin: 0 0 $pt-grid-size;
    padding: 0;
  }

  blockquote {
    @extend %blockquote;
  }

  code {
    @extend %code;
  }

  kbd {
    @extend %keyboard;
  }

  pre {
    @extend %code-block;
  }

  table {
    @extend %html-table;
  }

  ul,
  ol {
    @extend %list;
  }
}

// NOTE: these must be defined after .@ns-running-text in order to override font-size.
.#{$ns}-text-large {
  font-size: $pt-font-size-large;
  // line-height comes from .@ns-(ui|running)-text
}

.#{$ns}-text-small {
  font-size: $pt-font-size-small;
  // line-height comes from .@ns-(ui|running)-text
}

/*
Links

Simply use an `<a href="">` tag as you normally would. No class is necessary for Blueprint styles.
Links are underlined only when hovered.

Putting an icon inside a link will cause it to inherit the link's text color.

Styleguide typography.links
*/

a {
  text-decoration: none;

  &:hover {
    cursor: pointer;
    text-decoration: underline;
  }
}

/*
Preformatted text

Markup:
<div>
  <p>Use the <code class="@ns-code">&lt;code></code> tag for snippets of code.</p>
  <pre class="@ns-code-block">Use the &lt;pre> tag for blocks of code.</pre>
  <pre class="@ns-code-block"><code>// code sample
export function hasModifier(
  modifiers: ts.ModifiersArray,
  ...modifierKinds: ts.SyntaxKind[],
) {
  if (modifiers == null || modifierKinds == null) {
    return false;
  }
  return modifiers.some(m => modifierKinds.some(k => m.kind === k));
}</code></pre>
</div>

Styleguide preformatted
*/

%code {
  @include monospace-typography();
  border-radius: $pt-border-radius;
  font-size: smaller;
  padding: 2px 5px;
}

%code-block {
  @include monospace-typography();
  border-radius: $pt-border-radius;

  display: block;
  font-size: $pt-font-size - 1px;
  line-height: 1.4;
  margin: $pt-grid-size 0;
  padding: ($pt-grid-size * 1.3) ($pt-grid-size * 1.5) ($pt-grid-size * 1.2);
  word-break: break-all;
  word-wrap: break-word;

  > code {
    font-size: inherit;
    padding: 0;
  }
}

.#{$ns}-code {
  @extend %code;
}

.#{$ns}-code-block {
  @extend %code-block;
}

%keyboard {
  align-items: center;
  border-radius: $pt-border-radius;
  display: inline-flex;
  font-family: inherit;
  font-size: $pt-font-size-small;
  height: $pt-button-height-small;
  justify-content: center;
  line-height: $pt-button-height-small;
  min-width: $pt-button-height-small;
  padding: $pt-border-radius ($pt-border-radius * 2);
  vertical-align: middle;

  #{$icon-classes} {
    margin-right: $pt-grid-size * 0.5;
  }
}

.#{$ns}-key {
  @extend %keyboard;
}

/*
Block quotes

Markup:
<blockquote class="@ns-blockquote">
  Premium Aerotec is a key supplier for Airbus, producing 30 million parts per year,
  which is huge complexity. Skywise helps us manage all the production steps.
  It gives Airbus much better visibility into where the product is in the supply chain,
  and it lets us immediately see our weak points so we can react on the spot.
</blockquote>

Styleguide blockquote
*/

%blockquote {
  border-left: solid 4px rgba($gray4, 0.5);
  margin: 0 0 $pt-grid-size;
  padding: 0 ($pt-grid-size * 2);

  .#{$ns}-dark & {
    border-color: rgba($gray2, 0.5);
  }
}

.#{$ns}-blockquote {
  @extend %blockquote;
}

/*
Lists

Markup:
<ol class="{{.modifier}}">
  <li>Item the first</li>
  <li>Item the second</li>
  <li>
    Item the third
    <ul class="{{.modifier}}">
      <li>Item the fourth</li>
      <li>Item the fifth</li>
    </ul>
  </li>
</ol>

.#{$ns}-list - Add a little spacing between items for readability.
.#{$ns}-list-unstyled - Remove all list styling (including indicators) so you can add your own.

Styleguide lists
*/

%list {
  margin: $pt-grid-size 0;
  padding-left: $pt-grid-size * 3;

  li:not(:last-child) {
    margin-bottom: $pt-grid-size * 0.5;
  }

  // nested lists
  ol,
  ul {
    margin-top: $pt-grid-size * 0.5;
  }
}

.#{$ns}-list {
  @extend %list;
}

.#{$ns}-list-unstyled {
  list-style: none;
  margin: 0;
  padding: 0;

  li {
    padding: 0;
  }
}

/*
Right-to-left text

Markup:
<h5 class="@ns-heading">Arabic:</h5>
<p class="@ns-rtl">
  لكل لأداء بمحاولة من. مدينة الواقعة يبق أي, وإعلان وقوعها، حول كل, حدى عجّل مشروط الخاسرة قد.
  من الذود تكبّد بين, و لها واحدة الأراضي. عل الصفحة والروسية يتم, أي للحكومة استعملت شيء. أم وصل زهاء اليا
</p>
<h5 class="@ns-heading">Hebrew:</h5>
<p class="@ns-rtl">
  כדי על עזרה יידיש הבהרה, מלא באגים טכניים דת. תנך או ברית ביולי. כתב בה הטבע למנוע, דת כלים פיסיקה החופשית זכר.
  מתן החלל מאמרשיחהצפה ב. הספרות אנציקלופדיה אם זכר, על שימושי שימושיים תאולוגיה עזה
</p>

Styleguide rtl
*/

.#{$ns}-rtl {
  text-align: right;
}


/*
Dark theme
*/

.#{$ns}-dark {
  @include pt-dark-typography-colors();
}

================================================================================

File: src\accessibility\focusStyleManager.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { FOCUS_DISABLED } from "../common/classes";
import { InteractionModeEngine } from "../common/interactionMode";

const fakeFocusEngine = {
    isActive: () => true,
    start: () => true,
    stop: () => true,
};

const focusEngine =
    typeof document !== "undefined"
        ? new InteractionModeEngine(document.documentElement, FOCUS_DISABLED)
        : fakeFocusEngine;

export const FocusStyleManager = {
    alwaysShowFocus: () => focusEngine.stop(),
    isActive: () => focusEngine.isActive(),
    onlyShowFocusOnTabs: () => focusEngine.start(),
};

================================================================================

File: src\accessibility\_focus-states.scss
--------------------------------------------------------------------------------
// Copyright 2016 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

:focus {
  @include focus-outline();
}

// override any focus outline anywhere unless specifically ignored
.#{$ns}-focus-disabled :focus:not(.#{$ns}-focus-style-manager-ignore *) {
  /* stylelint-disable declaration-no-important */
  outline: none !important;

  // special override for checkbox etc which render focus on a separate element
  ~ .#{$ns}-control-indicator {
    outline: none !important;
  }
}

================================================================================

File: src\common\abstractComponent.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2019 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

import { isNodeEnv } from "./utils";

/**
 * An abstract component that Blueprint components can extend
 * in order to add some common functionality like runtime props validation.
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export abstract class AbstractComponent<P, S = {}, SS = {}> extends React.Component<P, S, SS> {
    // unsafe lifecycle methods
    public componentWillUpdate!: never;

    public componentWillReceiveProps!: never;

    public componentWillMount!: never;

    // this should be static, not an instance method
    public getDerivedStateFromProps!: never;

    /** Component displayName should be `public static`. This property exists to prevent incorrect usage. */
    protected displayName!: never;

    // Not bothering to remove entries when their timeouts finish because clearing invalid ID is a no-op
    private timeoutIds: number[] = [];

    private requestIds: number[] = [];

    constructor(props: P) {
        super(props);
        if (!isNodeEnv("production")) {
            this.validateProps(this.props);
        }
    }

    public componentDidUpdate(_prevProps: P, _prevState: S, _snapshot?: SS) {
        if (!isNodeEnv("production")) {
            this.validateProps(this.props);
        }
    }

    public componentWillUnmount() {
        this.clearTimeouts();
        this.cancelAnimationFrames();
    }

    /**
     * Request an animation frame and remember its ID.
     * All pending requests will be canceled when component unmounts.
     *
     * @returns a "cancel" function that will cancel the request when invoked.
     */
    public requestAnimationFrame(callback: () => void) {
        const handle = window.requestAnimationFrame(callback);
        this.requestIds.push(handle);
        return () => window.cancelAnimationFrame(handle);
    }

    /**
     * Set a timeout and remember its ID.
     * All stored timeouts will be cleared when component unmounts.
     *
     * @returns a "cancel" function that will clear timeout when invoked.
     */
    public setTimeout(callback: () => void, timeout?: number) {
        const handle = window.setTimeout(callback, timeout);
        this.timeoutIds.push(handle);
        return () => window.clearTimeout(handle);
    }

    /**
     * Clear all known timeouts.
     */
    public clearTimeouts = () => {
        if (this.timeoutIds.length > 0) {
            for (const timeoutId of this.timeoutIds) {
                window.clearTimeout(timeoutId);
            }
            this.timeoutIds = [];
        }
    };

    /**
     * Clear all known animation frame requests.
     */
    public cancelAnimationFrames = () => {
        if (this.requestIds.length > 0) {
            for (const requestId of this.requestIds) {
                window.cancelAnimationFrame(requestId);
            }
            this.requestIds = [];
        }
    };

    /**
     * Ensures that the props specified for a component are valid.
     * Implementations should check that props are valid and usually throw an Error if they are not.
     * Implementations should not duplicate checks that the type system already guarantees.
     *
     * This method should be used instead of React's
     * [propTypes](https://facebook.github.io/react/docs/reusable-components.html#prop-validation) feature.
     * Like propTypes, these runtime checks run only in development mode.
     */
    protected validateProps(_props: P) {
        // implement in subclass
    }
}

================================================================================

File: src\common\abstractPureComponent.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2019 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

import { isNodeEnv } from "./utils";

/**
 * An abstract component that Blueprint components can extend
 * in order to add some common functionality like runtime props validation.
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export abstract class AbstractPureComponent<P, S = {}, SS = {}> extends React.PureComponent<P, S, SS> {
    // unsafe lifecycle method
    public componentWillUpdate!: never;

    public componentWillReceiveProps!: never;

    public componentWillMount!: never;

    // this should be static, not an instance method
    public getDerivedStateFromProps!: never;

    /** Component displayName should be `public static`. This property exists to prevent incorrect usage. */
    protected displayName!: never;

    // Not bothering to remove entries when their timeouts finish because clearing invalid ID is a no-op
    private timeoutIds: number[] = [];

    private requestIds: number[] = [];

    constructor(props: P) {
        super(props);
        if (!isNodeEnv("production")) {
            this.validateProps(this.props);
        }
    }

    public componentDidUpdate(_prevProps: P, _prevState: S, _snapshot?: SS) {
        if (!isNodeEnv("production")) {
            this.validateProps(this.props);
        }
    }

    public componentWillUnmount() {
        this.clearTimeouts();
        this.cancelAnimationFrames();
    }

    /**
     * Request an animation frame and remember its ID.
     * All pending requests will be canceled when component unmounts.
     *
     * @returns a "cancel" function that will cancel the request when invoked.
     */
    public requestAnimationFrame(callback: () => void) {
        const handle = window.requestAnimationFrame(callback);
        this.requestIds.push(handle);
        return () => window.cancelAnimationFrame(handle);
    }

    /**
     * Set a timeout and remember its ID.
     * All pending timeouts will be cleared when component unmounts.
     *
     * @returns a "cancel" function that will clear timeout when invoked.
     */
    public setTimeout(callback: () => void, timeout?: number) {
        const handle = window.setTimeout(callback, timeout);
        this.timeoutIds.push(handle);
        return () => window.clearTimeout(handle);
    }

    /**
     * Clear all known timeouts.
     */
    public clearTimeouts = () => {
        if (this.timeoutIds.length > 0) {
            for (const timeoutId of this.timeoutIds) {
                window.clearTimeout(timeoutId);
            }
            this.timeoutIds = [];
        }
    };

    /**
     * Clear all known animation frame requests.
     */
    public cancelAnimationFrames = () => {
        if (this.requestIds.length > 0) {
            for (const requestId of this.requestIds) {
                window.cancelAnimationFrame(requestId);
            }
            this.requestIds = [];
        }
    };

    /**
     * Ensures that the props specified for a component are valid.
     * Implementations should check that props are valid and usually throw an Error if they are not.
     * Implementations should not duplicate checks that the type system already guarantees.
     *
     * This method should be used instead of React's
     * [propTypes](https://facebook.github.io/react/docs/reusable-components.html#prop-validation) feature.
     * Like propTypes, these runtime checks run only in development mode.
     */
    protected validateProps(_props: P) {
        // implement in subclass
    }
}

================================================================================

File: src\common\alignment.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Alignment along the horizontal axis. */
export const Alignment = {
    CENTER: "center" as const,
    LEFT: "left" as const,
    RIGHT: "right" as const,
};
// eslint-disable-next-line @typescript-eslint/no-redeclare
export type Alignment = (typeof Alignment)[keyof typeof Alignment];

================================================================================

File: src\common\boundary.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Boundary of a one-dimensional interval. */
export const Boundary = {
    START: "start" as const,
    // tslint:disable-next-line:object-literal-sort-keys
    END: "end" as const,
};
// eslint-disable-next-line @typescript-eslint/no-redeclare
export type Boundary = (typeof Boundary)[keyof typeof Boundary];

================================================================================

File: src\common\classes.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Alignment } from "./alignment";
import { Elevation } from "./elevation";
import { Intent } from "./intent";
import { Position } from "./position";

// injected by webpack.DefinePlugin
declare let BLUEPRINT_NAMESPACE: string | undefined;
declare let REACT_APP_BLUEPRINT_NAMESPACE: string | undefined;

let NS = "bp5";

if (typeof BLUEPRINT_NAMESPACE !== "undefined") {
    NS = BLUEPRINT_NAMESPACE;
} else if (typeof REACT_APP_BLUEPRINT_NAMESPACE !== "undefined") {
    NS = REACT_APP_BLUEPRINT_NAMESPACE;
}

// modifiers
export const ACTIVE = `${NS}-active`;
export const ALIGN_LEFT = `${NS}-align-left`;
export const ALIGN_RIGHT = `${NS}-align-right`;
export const COMPACT = `${NS}-compact`;
export const DARK = `${NS}-dark`;
export const DISABLED = `${NS}-disabled`;
export const FILL = `${NS}-fill`;
export const FIXED = `${NS}-fixed`;
export const FIXED_TOP = `${NS}-fixed-top`;
export const INLINE = `${NS}-inline`;
export const INTERACTIVE = `${NS}-interactive`;
export const LARGE = `${NS}-large`;
export const LOADING = `${NS}-loading`;
export const MINIMAL = `${NS}-minimal`;
export const OUTLINED = `${NS}-outlined`;
export const PADDED = `${NS}-padded`;
export const MULTILINE = `${NS}-multiline`;
export const READ_ONLY = `${NS}-read-only`;
export const ROUND = `${NS}-round`;
export const SELECTED = `${NS}-selected`;
export const SMALL = `${NS}-small`;
export const VERTICAL = `${NS}-vertical`;
export const POSITION_TOP = positionClass(Position.TOP);
export const POSITION_BOTTOM = positionClass(Position.BOTTOM);
export const POSITION_LEFT = positionClass(Position.LEFT);
export const POSITION_RIGHT = positionClass(Position.RIGHT);

export const ELEVATION_0 = elevationClass(Elevation.ZERO);
export const ELEVATION_1 = elevationClass(Elevation.ONE);
export const ELEVATION_2 = elevationClass(Elevation.TWO);
export const ELEVATION_3 = elevationClass(Elevation.THREE);
export const ELEVATION_4 = elevationClass(Elevation.FOUR);

export const INTENT_PRIMARY = intentClass(Intent.PRIMARY)!;
export const INTENT_SUCCESS = intentClass(Intent.SUCCESS)!;
export const INTENT_WARNING = intentClass(Intent.WARNING)!;
export const INTENT_DANGER = intentClass(Intent.DANGER)!;

export const FOCUS_DISABLED = `${NS}-focus-disabled`;
export const FOCUS_STYLE_MANAGER_IGNORE = `${NS}-focus-style-manager-ignore`;

// text utilities
export const UI_TEXT = `${NS}-ui-text`;
export const RUNNING_TEXT = `${NS}-running-text`;
export const MONOSPACE_TEXT = `${NS}-monospace-text`;
export const TEXT_LARGE = `${NS}-text-large`;
export const TEXT_SMALL = `${NS}-text-small`;
export const TEXT_MUTED = `${NS}-text-muted`;
export const TEXT_DISABLED = `${NS}-text-disabled`;
export const TEXT_OVERFLOW_ELLIPSIS = `${NS}-text-overflow-ellipsis`;

// textual elements
export const BLOCKQUOTE = `${NS}-blockquote`;
export const CODE = `${NS}-code`;
export const CODE_BLOCK = `${NS}-code-block`;
export const HEADING = `${NS}-heading`;
export const LIST = `${NS}-list`;
export const LIST_UNSTYLED = `${NS}-list-unstyled`;
export const RTL = `${NS}-rtl`;

// components
export const ALERT = `${NS}-alert`;
export const ALERT_BODY = `${ALERT}-body`;
export const ALERT_CONTENTS = `${ALERT}-contents`;
export const ALERT_FOOTER = `${ALERT}-footer`;

export const BREADCRUMB = `${NS}-breadcrumb`;
export const BREADCRUMB_CURRENT = `${BREADCRUMB}-current`;
export const BREADCRUMBS = `${BREADCRUMB}s`;
export const BREADCRUMBS_COLLAPSED = `${BREADCRUMB}s-collapsed`;

export const BUTTON = `${NS}-button`;
export const BUTTON_GROUP = `${BUTTON}-group`;
export const BUTTON_SPINNER = `${BUTTON}-spinner`;
export const BUTTON_TEXT = `${BUTTON}-text`;

export const CALLOUT = `${NS}-callout`;
export const CALLOUT_HAS_BODY_CONTENT = `${CALLOUT}-has-body-content`;
export const CALLOUT_ICON = `${CALLOUT}-icon`;

export const CARD = `${NS}-card`;
export const CONTROL_CARD = `${NS}-control-card`;
export const CONTROL_CARD_LABEL = `${CONTROL_CARD}-label`;
export const SWITCH_CONTROL_CARD = `${NS}-switch-control-card`;
export const CHECKBOX_CONTROL_CARD = `${NS}-checkbox-control-card`;
export const RADIO_CONTROL_CARD = `${NS}-radio-control-card`;

export const CARD_LIST = `${NS}-card-list`;
export const CARD_LIST_BORDERED = `${CARD_LIST}-bordered`;

export const COLLAPSE = `${NS}-collapse`;
export const COLLAPSE_BODY = `${COLLAPSE}-body`;

export const CONTEXT_MENU = `${NS}-context-menu`;
export const CONTEXT_MENU_VIRTUAL_TARGET = `${CONTEXT_MENU}-virtual-target`;
export const CONTEXT_MENU_POPOVER = `${CONTEXT_MENU}-popover`;
export const CONTEXT_MENU_BACKDROP = `${CONTEXT_MENU}-backdrop`;

export const CONTROL_GROUP = `${NS}-control-group`;

export const DIALOG = `${NS}-dialog`;
export const DIALOG_CONTAINER = `${DIALOG}-container`;
export const DIALOG_HEADER = `${DIALOG}-header`;
export const DIALOG_BODY = `${DIALOG}-body`;
export const DIALOG_BODY_SCROLL_CONTAINER = `${DIALOG}-body-scroll-container`;
export const DIALOG_CLOSE_BUTTON = `${DIALOG}-close-button`;
export const DIALOG_FOOTER = `${DIALOG}-footer`;
export const DIALOG_FOOTER_FIXED = `${DIALOG}-footer-fixed`;
export const DIALOG_FOOTER_MAIN_SECTION = `${DIALOG}-footer-main-section`;
export const DIALOG_FOOTER_ACTIONS = `${DIALOG}-footer-actions`;

export const DIALOG_STEP = `${NS}-dialog-step`;
export const DIALOG_STEP_CONTAINER = `${DIALOG_STEP}-container`;
export const DIALOG_STEP_TITLE = `${DIALOG_STEP}-title`;
export const DIALOG_STEP_ICON = `${DIALOG_STEP}-icon`;
export const DIALOG_STEP_VIEWED = `${DIALOG_STEP}-viewed`;

export const DIVIDER = `${NS}-divider`;

export const DRAWER = `${NS}-drawer`;
export const DRAWER_BODY = `${DRAWER}-body`;
export const DRAWER_FOOTER = `${DRAWER}-footer`;
export const DRAWER_HEADER = `${DRAWER}-header`;

export const EDITABLE_TEXT = `${NS}-editable-text`;
export const EDITABLE_TEXT_CONTENT = `${EDITABLE_TEXT}-content`;
export const EDITABLE_TEXT_EDITING = `${EDITABLE_TEXT}-editing`;
export const EDITABLE_TEXT_INPUT = `${EDITABLE_TEXT}-input`;
export const EDITABLE_TEXT_PLACEHOLDER = `${EDITABLE_TEXT}-placeholder`;

export const ENTITY_TITLE = `${NS}-entity-title`;
export const ENTITY_TITLE_ELLIPSIZE = `${NS}-entity-title-ellipsize`;
export const ENTITY_TITLE_HAS_SUBTITLE = `${ENTITY_TITLE}-has-subtitle`;
export const ENTITY_TITLE_ICON_CONTAINER = `${ENTITY_TITLE}-icon-container`;
export const ENTITY_TITLE_SUBTITLE = `${ENTITY_TITLE}-subtitle`;
export const ENTITY_TITLE_TAGS_CONTAINER = `${ENTITY_TITLE}-tags-container`;
export const ENTITY_TITLE_TEXT = `${ENTITY_TITLE}-text`;
export const ENTITY_TITLE_TITLE = `${ENTITY_TITLE}-title`;
export const ENTITY_TITLE_TITLE_AND_TAGS = `${ENTITY_TITLE}-title-and-tags`;

export const FLEX_EXPANDER = `${NS}-flex-expander`;

export const HTML_SELECT = `${NS}-html-select`;
/** @deprecated use `<HTMLSelect>` component or `Classes.HTML_SELECT` instead */
export const SELECT = `${NS}-select`;

export const HTML_TABLE = `${NS}-html-table`;
export const HTML_TABLE_BORDERED = `${HTML_TABLE}-bordered`;
export const HTML_TABLE_STRIPED = `${HTML_TABLE}-striped`;

export const INPUT = `${NS}-input`;
export const INPUT_GHOST = `${INPUT}-ghost`;
export const INPUT_GROUP = `${INPUT}-group`;
export const INPUT_LEFT_CONTAINER = `${INPUT}-left-container`;
export const INPUT_ACTION = `${INPUT}-action`;

export const RESIZABLE_INPUT_SPAN = `${NS}-resizable-input-span`;

export const TEXT_AREA = `${NS}-text-area`;
export const TEXT_AREA_AUTO_RESIZE = `${TEXT_AREA}-auto-resize`;

export const CONTROL = `${NS}-control`;
export const CONTROL_INDICATOR = `${CONTROL}-indicator`;
export const CONTROL_INDICATOR_CHILD = `${CONTROL_INDICATOR}-child`;
export const CHECKBOX = `${NS}-checkbox`;
export const RADIO = `${NS}-radio`;
export const RADIO_GROUP = `${NS}-radio-group`;
export const SWITCH = `${NS}-switch`;
export const SWITCH_INNER_TEXT = `${SWITCH}-inner-text`;
export const FILE_INPUT = `${NS}-file-input`;
export const FILE_INPUT_HAS_SELECTION = `${NS}-file-input-has-selection`;
export const FILE_UPLOAD_INPUT = `${NS}-file-upload-input`;
export const FILE_UPLOAD_INPUT_CUSTOM_TEXT = `${NS}-file-upload-input-custom-text`;

export const KEY = `${NS}-key`;
export const KEY_COMBO = `${KEY}-combo`;
export const MODIFIER_KEY = `${NS}-modifier-key`;

export const HOTKEY = `${NS}-hotkey`;
export const HOTKEY_LABEL = `${HOTKEY}-label`;
export const HOTKEY_COLUMN = `${HOTKEY}-column`;
export const HOTKEY_DIALOG = `${HOTKEY}-dialog`;

export const LABEL = `${NS}-label`;
export const FORM_GROUP = `${NS}-form-group`;
export const FORM_CONTENT = `${NS}-form-content`;
export const FORM_HELPER_TEXT = `${NS}-form-helper-text`;
export const FORM_GROUP_SUB_LABEL = `${NS}-form-group-sub-label`;

export const MENU = `${NS}-menu`;
export const MENU_ITEM = `${MENU}-item`;
export const MENU_ITEM_IS_SELECTABLE = `${MENU_ITEM}-is-selectable`;
export const MENU_ITEM_SELECTED_ICON = `${MENU_ITEM}-selected-icon`;
export const MENU_ITEM_ICON = `${MENU_ITEM}-icon`;
export const MENU_ITEM_LABEL = `${MENU_ITEM}-label`;
export const MENU_SUBMENU = `${NS}-submenu`;
export const MENU_SUBMENU_ICON = `${MENU_SUBMENU}-icon`;
export const MENU_DIVIDER = `${MENU}-divider`;
export const MENU_HEADER = `${MENU}-header`;

export const MULTISTEP_DIALOG = `${NS}-multistep-dialog`;
export const MULTISTEP_DIALOG_PANELS = `${MULTISTEP_DIALOG}-panels`;
export const MULTISTEP_DIALOG_LEFT_PANEL = `${MULTISTEP_DIALOG}-left-panel`;
export const MULTISTEP_DIALOG_RIGHT_PANEL = `${MULTISTEP_DIALOG}-right-panel`;
export const MULTISTEP_DIALOG_NAV_TOP = `${MULTISTEP_DIALOG}-nav-top`;
export const MULTISTEP_DIALOG_NAV_RIGHT = `${MULTISTEP_DIALOG}-nav-right`;

export const SECTION = `${NS}-section`;
export const SECTION_COLLAPSED = `${SECTION}-collapsed`;
export const SECTION_HEADER = `${SECTION}-header`;
export const SECTION_HEADER_LEFT = `${SECTION_HEADER}-left`;
export const SECTION_HEADER_TITLE = `${SECTION_HEADER}-title`;
export const SECTION_HEADER_SUB_TITLE = `${SECTION_HEADER}-sub-title`;
export const SECTION_HEADER_DIVIDER = `${SECTION_HEADER}-divider`;
export const SECTION_HEADER_TABS = `${SECTION_HEADER}-tabs`;
export const SECTION_HEADER_RIGHT = `${SECTION_HEADER}-right`;
export const SECTION_CARD = `${SECTION}-card`;

export const NAVBAR = `${NS}-navbar`;
export const NAVBAR_GROUP = `${NAVBAR}-group`;
export const NAVBAR_HEADING = `${NAVBAR}-heading`;
export const NAVBAR_DIVIDER = `${NAVBAR}-divider`;

export const NON_IDEAL_STATE = `${NS}-non-ideal-state`;
export const NON_IDEAL_STATE_VISUAL = `${NON_IDEAL_STATE}-visual`;
export const NON_IDEAL_STATE_TEXT = `${NON_IDEAL_STATE}-text`;

export const NUMERIC_INPUT = `${NS}-numeric-input`;

export const OVERFLOW_LIST = `${NS}-overflow-list`;
export const OVERFLOW_LIST_SPACER = `${OVERFLOW_LIST}-spacer`;

export const OVERLAY = `${NS}-overlay`;
export const OVERLAY_BACKDROP = `${OVERLAY}-backdrop`;
export const OVERLAY_CONTAINER = `${OVERLAY}-container`;
export const OVERLAY_CONTENT = `${OVERLAY}-content`;
export const OVERLAY_INLINE = `${OVERLAY}-inline`;
export const OVERLAY_OPEN = `${OVERLAY}-open`;
export const OVERLAY_SCROLL_CONTAINER = `${OVERLAY}-scroll-container`;
export const OVERLAY_START_FOCUS_TRAP = `${OVERLAY}-start-focus-trap`;
export const OVERLAY_END_FOCUS_TRAP = `${OVERLAY}-end-focus-trap`;

export const PANEL_STACK = `${NS}-panel-stack`;
export const PANEL_STACK_HEADER = `${PANEL_STACK}-header`;
export const PANEL_STACK_HEADER_BACK = `${PANEL_STACK}-header-back`;
export const PANEL_STACK_VIEW = `${PANEL_STACK}-view`;

export const PANEL_STACK2 = `${NS}-panel-stack2`;
export const PANEL_STACK2_HEADER = `${PANEL_STACK}-header`;
export const PANEL_STACK2_HEADER_BACK = `${PANEL_STACK}-header-back`;
export const PANEL_STACK2_VIEW = `${PANEL_STACK}-view`;

export const POPOVER = `${NS}-popover`;
export const POPOVER_ARROW = `${POPOVER}-arrow`;
export const POPOVER_BACKDROP = `${POPOVER}-backdrop`;
export const POPOVER_CAPTURING_DISMISS = `${POPOVER}-capturing-dismiss`;
export const POPOVER_CONTENT = `${POPOVER}-content`;
export const POPOVER_CONTENT_PLACEMENT = `${POPOVER}-placement`;
export const POPOVER_CONTENT_SIZING = `${POPOVER_CONTENT}-sizing`;
export const POPOVER_DISMISS = `${POPOVER}-dismiss`;
export const POPOVER_DISMISS_OVERRIDE = `${POPOVER_DISMISS}-override`;
export const POPOVER_MATCH_TARGET_WIDTH = `${POPOVER}-match-target-width`;
export const POPOVER_OPEN = `${POPOVER}-open`;
export const POPOVER_POPPER_ESCAPED = `${POPOVER}-popper-escaped`;
export const POPOVER_REFERENCE_HIDDEN = `${POPOVER}-reference-hidden`;
export const POPOVER_TARGET = `${POPOVER}-target`;
export const POPOVER_TRANSITION_CONTAINER = `${POPOVER}-transition-container`;
/** @deprecated, no longer used in Blueprint v5.x */
export const POPOVER_WRAPPER = `${POPOVER}-wrapper`;

export const PROGRESS_BAR = `${NS}-progress-bar`;
export const PROGRESS_METER = `${NS}-progress-meter`;
export const PROGRESS_NO_STRIPES = `${NS}-no-stripes`;
export const PROGRESS_NO_ANIMATION = `${NS}-no-animation`;

export const PORTAL = `${NS}-portal`;

export const SKELETON = `${NS}-skeleton`;

export const SLIDER = `${NS}-slider`;
export const SLIDER_AXIS = `${SLIDER}-axis`;
export const SLIDER_HANDLE = `${SLIDER}-handle`;
export const SLIDER_LABEL = `${SLIDER}-label`;
export const SLIDER_TRACK = `${SLIDER}-track`;
export const SLIDER_PROGRESS = `${SLIDER}-progress`;
export const START = `${NS}-start`;
export const END = `${NS}-end`;

export const SPINNER = `${NS}-spinner`;
export const SPINNER_ANIMATION = `${SPINNER}-animation`;
export const SPINNER_HEAD = `${SPINNER}-head`;
export const SPINNER_NO_SPIN = `${NS}-no-spin`;
export const SPINNER_TRACK = `${SPINNER}-track`;

export const SEGMENTED_CONTROL = `${NS}-segmented-control`;

export const TAB = `${NS}-tab`;
export const TAB_ICON = `${TAB}-icon`;
export const TAB_TAG = `${TAB}-tag`;
export const TAB_INDICATOR = `${TAB}-indicator`;
export const TAB_INDICATOR_WRAPPER = `${TAB_INDICATOR}-wrapper`;
export const TAB_LIST = `${TAB}-list`;
export const TAB_PANEL = `${TAB}-panel`;
export const TABS = `${TAB}s`;

export const TAG = `${NS}-tag`;
export const TAG_REMOVE = `${TAG}-remove`;
export const COMPOUND_TAG = `${NS}-compound-tag`;
export const COMPOUND_TAG_LEFT = `${COMPOUND_TAG}-left`;
export const COMPOUND_TAG_LEFT_CONTENT = `${COMPOUND_TAG}-left-content`;
export const COMPOUND_TAG_RIGHT = `${COMPOUND_TAG}-right`;
export const COMPOUND_TAG_RIGHT_CONTENT = `${COMPOUND_TAG}-right-content`;

export const TAG_INPUT = `${NS}-tag-input`;
export const TAG_INPUT_ICON = `${TAG_INPUT}-icon`;
export const TAG_INPUT_VALUES = `${TAG_INPUT}-values`;

export const TOAST = `${NS}-toast`;
export const TOAST_CONTAINER = `${TOAST}-container`;
export const TOAST_MESSAGE = `${TOAST}-message`;

export const TOOLTIP = `${NS}-tooltip`;
export const TOOLTIP_INDICATOR = `${TOOLTIP}-indicator`;

export const TREE = `${NS}-tree`;
export const TREE_NODE = `${NS}-tree-node`;
export const TREE_NODE_CARET = `${TREE_NODE}-caret`;
export const TREE_NODE_CARET_CLOSED = `${TREE_NODE_CARET}-closed`;
export const TREE_NODE_CARET_NONE = `${TREE_NODE_CARET}-none`;
export const TREE_NODE_CARET_OPEN = `${TREE_NODE_CARET}-open`;
export const TREE_NODE_CONTENT = `${TREE_NODE}-content`;
export const TREE_NODE_EXPANDED = `${TREE_NODE}-expanded`;
export const TREE_NODE_ICON = `${TREE_NODE}-icon`;
export const TREE_NODE_LABEL = `${TREE_NODE}-label`;
export const TREE_NODE_LIST = `${TREE_NODE}-list`;
export const TREE_NODE_SECONDARY_LABEL = `${TREE_NODE}-secondary-label`;
export const TREE_NODE_SELECTED = `${TREE_NODE}-selected`;
export const TREE_ROOT = `${NS}-tree-root`;

export const ICON = `${NS}-icon`;
export const ICON_STANDARD = `${ICON}-standard`;
export const ICON_LARGE = `${ICON}-large`;
export const ICON_MUTED = `${ICON}-muted`;

/**
 * Returns the namespace prefix for all Blueprint CSS classes.
 * Customize this namespace at build time by defining it with `webpack.DefinePlugin`.
 */
export function getClassNamespace() {
    return NS;
}

/** Return CSS class for alignment. */
export function alignmentClass(alignment: Alignment | undefined) {
    switch (alignment) {
        case Alignment.LEFT:
            return ALIGN_LEFT;
        case Alignment.RIGHT:
            return ALIGN_RIGHT;
        default:
            return undefined;
    }
}

export function elevationClass(elevation: Elevation): string;
export function elevationClass(elevation: undefined): undefined;
export function elevationClass(elevation: Elevation | undefined): string | undefined;
export function elevationClass(elevation: Elevation | undefined) {
    if (elevation === undefined) {
        return undefined;
    }
    return `${NS}-elevation-${elevation}`;
}

/**
 * Returns CSS class for icon name.
 */
export function iconClass(iconName: string): string;
export function iconClass(iconName: undefined): undefined;
export function iconClass(iconName: string | undefined): string | undefined;
export function iconClass(iconName: string | undefined) {
    if (iconName == null) {
        return undefined;
    }
    return iconName.indexOf(`${NS}-icon-`) === 0 ? iconName : `${NS}-icon-${iconName}`;
}

/** Return CSS class for intent. */
export function intentClass(intent: Intent): string;
export function intentClass(intent: typeof Intent.NONE | undefined): undefined;
export function intentClass(intent: Intent | undefined): Intent | undefined;
export function intentClass(intent: Intent | undefined) {
    if (intent == null || intent === Intent.NONE) {
        return undefined;
    }
    return `${NS}-intent-${intent.toLowerCase()}`;
}

export function positionClass(position: Position): string;
export function positionClass(position: undefined): undefined;
export function positionClass(position: Position | undefined): string | undefined;
export function positionClass(position: Position | undefined) {
    if (position === undefined) {
        return undefined;
    }
    return `${NS}-position-${position}`;
}

================================================================================

File: src\common\context.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2020 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// simplified typings copied from @types/prop-types, to avoid that explicit dependency

export type Validator<K> = (
    props: { [key: string]: any },
    propName: K,
    componentName: string,
    location: string,
    propFullName: string,
) => Error | undefined;

export type ValidationMap<T> = { [K in keyof T]?: Validator<K> };

================================================================================

File: src\common\elevation.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// tslint:disable:object-literal-sort-keys
export const Elevation = {
    ZERO: 0 as const,
    ONE: 1 as const,
    TWO: 2 as const,
    THREE: 3 as const,
    FOUR: 4 as const,
};
// eslint-disable-next-line @typescript-eslint/no-redeclare
export type Elevation = (typeof Elevation)[keyof typeof Elevation];

================================================================================

File: src\common\errors.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const ns = "[Blueprint]";

export const CLAMP_MIN_MAX = ns + ` clamp: max cannot be less than min`;

export const ALERT_WARN_CANCEL_PROPS = ns + ` <Alert> cancelButtonText and onCancel should be set together.`;
export const ALERT_WARN_CANCEL_ESCAPE_KEY =
    ns + ` <Alert> canEscapeKeyCancel enabled without onCancel or onClose handler.`;
export const ALERT_WARN_CANCEL_OUTSIDE_CLICK =
    ns + ` <Alert> canOutsideClickCancel enabled without onCancel or onClose handler.`;

export const HOTKEYS_HOTKEY_CHILDREN = ns + ` <Hotkeys> only accepts <Hotkey> children.`;

export const HOTKEYS_PROVIDER_NOT_FOUND =
    ns +
    ` useHotkeys() was used outside of a <HotkeysProvider> context. These hotkeys will not be shown in the hotkeys help dialog.`;
export const HOTKEYS_TARGET_CHILDREN_LOCAL_HOTKEYS =
    ns +
    ` <HotkeysTarget2> was configured with local hotkeys, but you did not use the generated event handlers to bind their event handlers. Try using a render function as the child of this component.`;

export const INPUT_WARN_LEFT_ELEMENT_LEFT_ICON_MUTEX =
    ns + ` <InputGroup> leftElement and leftIcon prop are mutually exclusive, with leftElement taking priority.`;

export const NUMERIC_INPUT_MIN_MAX = ns + ` <NumericInput> requires min to be no greater than max if both are defined.`;
export const NUMERIC_INPUT_MINOR_STEP_SIZE_BOUND =
    ns + ` <NumericInput> requires minorStepSize to be no greater than stepSize.`;
export const NUMERIC_INPUT_MAJOR_STEP_SIZE_BOUND =
    ns + ` <NumericInput> requires stepSize to be no greater than majorStepSize.`;
export const NUMERIC_INPUT_MINOR_STEP_SIZE_NON_POSITIVE =
    ns + ` <NumericInput> requires minorStepSize to be strictly greater than zero.`;
export const NUMERIC_INPUT_MAJOR_STEP_SIZE_NON_POSITIVE =
    ns + ` <NumericInput> requires majorStepSize to be strictly greater than zero.`;
export const NUMERIC_INPUT_STEP_SIZE_NON_POSITIVE =
    ns + ` <NumericInput> requires stepSize to be strictly greater than zero.`;
export const NUMERIC_INPUT_CONTROLLED_VALUE_INVALID =
    ns + ` <NumericInput> controlled value prop does not adhere to stepSize, min, and/or max constraints.`;

export const PANEL_STACK_INITIAL_PANEL_STACK_MUTEX =
    ns + ` <PanelStack> requires exactly one of initialPanel and stack prop`;
export const PANEL_STACK_REQUIRES_PANEL = ns + ` <PanelStack> requires at least one panel in the stack`;

export const OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED =
    ns + ` <OverflowList> does not support changing observeParents after mounting.`;

export const POPOVER_REQUIRES_TARGET = `${ns} <Popover> requires renderTarget prop or a child element.`;
export const POPOVER_HAS_BACKDROP_INTERACTION = `${ns} <Popover hasBackdrop={true}> requires interactionKind="click".`;
export const POPOVER_WARN_TOO_MANY_CHILDREN = `${ns} <Popover> supports only one child which is rendered as its target; additional children are ignored.`;
export const POPOVER_WARN_DOUBLE_TARGET =
    ns + ` <Popover> with children ignores renderTarget prop; use either prop or children.`;
export const POPOVER_WARN_EMPTY_CONTENT = ns + ` Disabling <Popover> with empty/whitespace content...`;
export const POPOVER_WARN_HAS_BACKDROP_INLINE = ns + ` <Popover usePortal={false}> ignores hasBackdrop`;
export const POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX =
    ns + ` <Popover> supports either placement or position prop, not both.`;
export const POPOVER_WARN_UNCONTROLLED_ONINTERACTION = ns + ` <Popover> onInteraction is ignored when uncontrolled.`;
export const POPOVER_WARN_TARGET_PROPS_WITH_RENDER_TARGET =
    ns + ` <Popover> targetProps value is ignored when renderTarget API is used.`;

export const PORTAL_CONTEXT_CLASS_NAME_STRING = ns + ` <Portal> context blueprintPortalClassName must be string`;
export const PORTAL_LEGACY_CONTEXT_API =
    ns + ` setting blueprintPortalClassName via legacy React context API is deprecated, use <PortalProvider> instead.`;

export const RADIOGROUP_WARN_CHILDREN_OPTIONS_MUTEX =
    ns + ` <RadioGroup> children and options prop are mutually exclusive, with options taking priority.`;

export const SLIDER_ZERO_STEP = ns + ` <Slider> stepSize must be greater than zero.`;
export const SLIDER_ZERO_LABEL_STEP = ns + ` <Slider> labelStepSize must be greater than zero.`;
export const SLIDER_MIN = ns + ` <Slider> min prop must be a finite number.`;
export const SLIDER_MAX = ns + ` <Slider> max prop must be a finite number.`;
export const RANGESLIDER_NULL_VALUE = ns + ` <RangeSlider> value prop must be an array of two non-null numbers.`;
export const MULTISLIDER_INVALID_CHILD = ns + ` <MultiSlider> children must be <SliderHandle>s or <SliderTrackStop>s`;
export const MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX =
    ns +
    ` <MultiSlider> labelStepSize and labelValues prop are mutually exclusive, with labelStepSize taking priority.`;

export const SPINNER_WARN_CLASSES_SIZE = ns + ` <Spinner> Classes.SMALL/LARGE are ignored if size prop is set.`;

export const TOASTER_CREATE_NULL =
    ns +
    ` OverlayToaster.create() is not supported inside React lifecycle methods in React 16.` +
    ` See usage example on the docs site. https://blueprintjs.com/docs/#core/components/toast.example`;
export const TOASTER_CREATE_ASYNC_NULL =
    ns +
    ` OverlayToaster.createAsync() received a null component ref. This can happen if called inside React lifecycle ` +
    `methods in React 16. See usage example on the docs site. ` +
    `https://blueprintjs.com/docs/#core/components/toast.example`;
export const TOASTER_MAX_TOASTS_INVALID =
    ns + ` <OverlayToaster> maxToasts is set to an invalid number, must be greater than 0`;
export const TOASTER_WARN_INLINE =
    ns + ` OverlayToaster.create() ignores inline prop as it always creates a new element.`;

export const DIALOG_WARN_NO_HEADER_ICON = ns + ` <Dialog> iconName is ignored if title is omitted.`;
export const DIALOG_WARN_NO_HEADER_CLOSE_BUTTON =
    ns + ` <Dialog> isCloseButtonShown prop is ignored if title is omitted.`;

export const DRAWER_ANGLE_POSITIONS_ARE_CASTED =
    ns + ` <Drawer> all angle positions are casted into pure position (TOP, BOTTOM, LEFT or RIGHT)`;

export const OVERLAY2_REQUIRES_OVERLAY_PROVDER =
    ns +
    ` <Overlay2> was used outside of a <OverlaysProvider> context. This will no longer be supported in ` +
    `Blueprint v6. See https://github.com/palantir/blueprint/wiki/Overlay2-migration`;
export const OVERLAY_CHILD_REF_AND_REFS_MUTEX =
    ns + ` <Overlay2> cannot use childRef and childRefs props simultaneously`;
export const OVERLAY_WITH_MULTIPLE_CHILDREN_REQUIRES_CHILD_REFS =
    ns + ` <Overlay2> requires childRefs prop when rendering multiple child elements`;
export const OVERLAY_CHILD_REQUIRES_KEY =
    ns + ` <Overlay2> requires each child element to have a unique key prop when childRefs is used`;

================================================================================

File: src\common\index.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { Colors } from "@blueprintjs/colors";

export { AbstractComponent } from "./abstractComponent";
export { AbstractPureComponent } from "./abstractPureComponent";
export { Alignment } from "./alignment";
export { Boundary } from "./boundary";
export { Elevation } from "./elevation";
export { Intent } from "./intent";
// eslint-disable-next-line deprecation/deprecation
export { KeyCodes as Keys } from "./keyCodes";
export { Position } from "./position";
export {
    type ActionProps,
    // eslint-disable-next-line deprecation/deprecation
    type ControlledProps,
    type ControlledValueProps,
    type IntentProps,
    type LinkProps,
    type OptionProps,
    type Props,
    removeNonHTMLProps,
    DISPLAYNAME_PREFIX,
    type HTMLDivProps,
    type HTMLInputProps,
    type MaybeElement,
} from "./props";
export { getRef, isRefCallback, isRefObject, mergeRefs, refHandler, setRef } from "./refs";

import * as Classes from "./classes";
import * as Utils from "./utils";
export { Classes, Utils };
// NOTE: Errors is not exported in public API

================================================================================

File: src\common\intent.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// tslint:disable:object-literal-sort-keys

/**
 * The four basic intents.
 */
export const Intent = {
    NONE: "none" as const,
    PRIMARY: "primary" as const,
    SUCCESS: "success" as const,
    WARNING: "warning" as const,
    DANGER: "danger" as const,
};
// eslint-disable-next-line @typescript-eslint/no-redeclare
export type Intent = (typeof Intent)[keyof typeof Intent];

================================================================================

File: src\common\interactionMode.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* istanbul ignore next */

/**
 * A nifty little class that maintains event handlers to add a class to the container element
 * when entering "mouse mode" (on a `mousedown` event) and remove it when entering "keyboard mode"
 * (on a `tab` key `keydown` event).
 */
export class InteractionModeEngine {
    private isRunning = false;

    constructor(
        private container: HTMLElement,
        private className: string,
    ) {}

    /** Returns whether the engine is currently running. */
    public isActive() {
        return this.isRunning;
    }

    /** Enable behavior which applies the given className when in mouse mode. */
    public start() {
        this.container.addEventListener("mousedown", this.handleMouseDown);
        this.isRunning = true;
    }

    /** Disable interaction mode behavior and remove className from container. */
    public stop() {
        this.reset();
        this.isRunning = false;
    }

    private reset() {
        this.container.classList.remove(this.className);
        this.container.removeEventListener("keydown", this.handleKeyDown);
        this.container.removeEventListener("mousedown", this.handleMouseDown);
    }

    private handleKeyDown = (e: KeyboardEvent) => {
        if (e.key === "Tab") {
            this.reset();
            this.container.addEventListener("mousedown", this.handleMouseDown);
        }
    };

    private handleMouseDown = () => {
        this.reset();
        this.container.classList.add(this.className);
        this.container.addEventListener("keydown", this.handleKeyDown);
    };
}

================================================================================

File: src\common\keyCodes.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// tslint:disable object-literal-sort-keys

/** @deprecated use named keys instead of key codes */
export const KeyCodes = {
    BACKSPACE: 8 as const,
    TAB: 9 as const,
    ENTER: 13 as const,
    SHIFT: 16 as const,
    ESCAPE: 27 as const,
    SPACE: 32 as const,
    ARROW_LEFT: 37 as const,
    ARROW_UP: 38 as const,
    ARROW_RIGHT: 39 as const,
    ARROW_DOWN: 40 as const,
    DELETE: 46 as const,
};

================================================================================

File: src\common\position.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export const Position = {
    BOTTOM: "bottom" as const,
    BOTTOM_LEFT: "bottom-left" as const,
    BOTTOM_RIGHT: "bottom-right" as const,
    LEFT: "left" as const,
    LEFT_BOTTOM: "left-bottom" as const,
    LEFT_TOP: "left-top" as const,
    RIGHT: "right" as const,
    RIGHT_BOTTOM: "right-bottom" as const,
    RIGHT_TOP: "right-top" as const,
    TOP: "top" as const,
    TOP_LEFT: "top-left" as const,
    TOP_RIGHT: "top-right" as const,
};
// eslint-disable-next-line @typescript-eslint/no-redeclare
export type Position = (typeof Position)[keyof typeof Position];

export function isPositionHorizontal(position: Position) {
    /* istanbul ignore next */
    return (
        position === Position.TOP ||
        position === Position.TOP_LEFT ||
        position === Position.TOP_RIGHT ||
        position === Position.BOTTOM ||
        position === Position.BOTTOM_LEFT ||
        position === Position.BOTTOM_RIGHT
    );
}

export function isPositionVertical(position: Position) {
    /* istanbul ignore next */
    return (
        position === Position.LEFT ||
        position === Position.LEFT_TOP ||
        position === Position.LEFT_BOTTOM ||
        position === Position.RIGHT ||
        position === Position.RIGHT_TOP ||
        position === Position.RIGHT_BOTTOM
    );
}

export function getPositionIgnoreAngles(position: Position) {
    if (position === Position.TOP || position === Position.TOP_LEFT || position === Position.TOP_RIGHT) {
        return Position.TOP;
    } else if (
        position === Position.BOTTOM ||
        position === Position.BOTTOM_LEFT ||
        position === Position.BOTTOM_RIGHT
    ) {
        return Position.BOTTOM;
    } else if (position === Position.LEFT || position === Position.LEFT_TOP || position === Position.LEFT_BOTTOM) {
        return Position.LEFT;
    } else {
        return Position.RIGHT;
    }
}

================================================================================

File: src\common\props.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type * as React from "react";

import type { IconName } from "@blueprintjs/icons";

import type { Intent } from "./intent";

export const DISPLAYNAME_PREFIX = "Blueprint5";

/**
 * Alias for all valid HTML props for `<div>` element.
 * Does not include React's `ref` or `key`.
 */
export type HTMLDivProps = React.HTMLAttributes<HTMLDivElement>;

/**
 * Alias for all valid HTML props for `<input>` element.
 * Does not include React's `ref` or `key`.
 */
export type HTMLInputProps = React.InputHTMLAttributes<HTMLInputElement>;

/**
 * Alias for a `React.JSX.Element` or a value that renders nothing.
 *
 * In React, `boolean`, `null`, and `undefined` do not produce any output.
 */
export type MaybeElement = React.JSX.Element | false | null | undefined;

/**
 * A shared base interface for all Blueprint component props.
 */
export interface Props {
    /** A space-delimited list of class names to pass along to a child element. */
    className?: string;
}

export interface IntentProps {
    /** Visual intent color to apply to element. */
    intent?: Intent;
}

/**
 * Interface for a clickable action, such as a button or menu item.
 * These props can be spready directly to a `<Button>` or `<MenuItem>` element.
 *
 * @template T type of the DOM element rendered by this component
 */
export interface ActionProps<T extends HTMLElement = HTMLElement> extends IntentProps, Props {
    /** Whether this action is non-interactive. */
    disabled?: boolean;

    /** Name of a Blueprint UI icon (or an icon element) to render before the text. */
    icon?: IconName | MaybeElement;

    /** Click event handler. */
    onClick?: (event: React.MouseEvent<T>) => void;

    /** Focus event handler. */
    onFocus?: (event: React.FocusEvent<T>) => void;

    /** Action text. Can be any single React renderable. */
    text?: React.ReactNode;
}

/** Interface for a link, with support for customizing target window. */
export interface LinkProps {
    /** Link URL. */
    href?: string;

    /** Link target attribute. Use `"_blank"` to open in a new window. */
    target?: React.HTMLAttributeAnchorTarget;
}

/**
 * Interface for a controlled or uncontrolled component, typically a form control.
 */
export interface ControlledValueProps<T, E extends HTMLElement = HTMLElement> {
    /**
     * Initial value for uncontrolled usage. Mutually exclusive with `value` prop.
     */
    defaultValue?: T;

    /**
     * Controlled value. Mutually exclusive with `defaultValue` prop.
     */
    value?: T;

    /**
     * Callback invoked when the component value changes, typically via user interaction, in both controlled and
     * uncontrolled mode.
     *
     * Using this prop instead of `onChange` can help avoid common bugs in React 16 related to Event Pooling
     * where developers forget to save the text value from a change event or call `event.persist()`.
     *
     * @see https://legacy.reactjs.org/docs/legacy-event-pooling.html
     */
    onValueChange?: (value: T, targetElement: E | null) => void;
}

/** @deprecated use `ControlledValueProps` */
export type ControlledProps = Omit<ControlledValueProps<string, HTMLInputElement>, "onChange">;

export interface OptionProps<T extends string | number = string | number> extends Props {
    /** Whether this option is non-interactive. */
    disabled?: boolean;

    /** Label text for this option. If omitted, `value` is used as the label. */
    label?: string;

    /** Value of this option. */
    value: T;
}

/** A collection of curated prop keys used across our Components which are not valid HTMLElement props. */
const INVALID_PROPS = [
    "active",
    "alignText",
    "asyncControl", // InputGroupProps
    "containerRef",
    "current",
    "elementRef", // not used anymore in Blueprint v5.x, but kept for backcompat if consumers use this naming pattern
    "ellipsizeText", // ButtonProps
    "fill",
    "icon",
    "iconSize",
    "inputClassName",
    "inputRef",
    "intent",
    "inline",
    "large",
    "loading",
    "leftElement",
    "leftIcon",
    "minimal",
    "onRemove", // TagProps, TagInputProps
    "outlined", // ButtonProps
    "panel", // TabProps
    "panelClassName", // TabProps
    "popoverProps",
    "rightElement",
    "rightIcon",
    "round",
    "size",
    "small",
    "tagName",
    "text",
    "textClassName", // ButtonProps
];

/**
 * Typically applied to HTMLElements to filter out disallowed props. When applied to a Component,
 * can filter props from being passed down to the children. Can also filter by a combined list of
 * supplied prop keys and the denylist (only appropriate for HTMLElements).
 *
 * @param props The original props object to filter down.
 * @param {string[]} invalidProps If supplied, overwrites the default denylist.
 * @param {boolean} shouldMerge If true, will merge supplied invalidProps and denylist together.
 */
export function removeNonHTMLProps(
    props: { [key: string]: any },
    invalidProps = INVALID_PROPS,
    shouldMerge = false,
): { [key: string]: any } {
    if (shouldMerge) {
        invalidProps = invalidProps.concat(INVALID_PROPS);
    }

    return invalidProps.reduce(
        (prev, curr) => {
            // Props with hyphens (e.g. data-*) are always considered html props
            if (curr.indexOf("-") !== -1) {
                return prev;
            }

            if (prev.hasOwnProperty(curr)) {
                delete (prev as any)[curr];
            }
            return prev;
        },
        { ...props },
    );
}

================================================================================

File: src\common\refs.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2020 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type * as React from "react";

export function isRefObject<T>(value: React.Ref<T> | undefined): value is React.RefObject<T> {
    return value != null && typeof value !== "function";
}

export function isRefCallback<T>(value: React.Ref<T> | undefined): value is React.RefCallback<T> {
    return typeof value === "function";
}

/**
 * Assign the given ref to a target, either a React ref object or a callback which takes the ref as its first argument.
 */
export function setRef<T>(refTarget: React.Ref<T> | undefined, ref: T | null): void {
    if (isRefObject<T>(refTarget)) {
        // HACKHACK: .current property is readonly
        (refTarget.current as T | null) = ref;
    } else if (isRefCallback(refTarget)) {
        refTarget(ref);
    }
}

/**
 * Utility for merging refs into one singular callback ref.
 * If using in a functional component, would recomend using `useMemo` to preserve function identity.
 */
export function mergeRefs<T>(...refs: Array<React.Ref<T>>): React.RefCallback<T> {
    return value => {
        refs.forEach(ref => {
            setRef(ref, value);
        });
    };
}

export function getRef<T>(ref: T | React.RefObject<T> | null): T | null {
    if (ref === null) {
        return null;
    }

    if (typeof (ref as React.RefObject<T>).current === "undefined") {
        return ref as T;
    }

    return (ref as React.RefObject<T>).current;
}

/**
 * Creates a ref handler which assigns the ref returned by React for a mounted component to a field on the target object.
 * The target object is usually a component class.
 *
 * If provided, it will also update the given `refProp` with the value of the ref.
 */
export function refHandler<T extends HTMLElement, K extends string>(
    refTargetParent: { [k in K]: T | null },
    refTargetKey: K,
    refProp?: React.Ref<T> | undefined,
): React.RefCallback<T> {
    return (ref: T | null) => {
        refTargetParent[refTargetKey] = ref;
        setRef(refProp, ref);
    };
}

================================================================================

File: src\common\_color-aliases.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

// ----------------------------------------------------------------------------
// This file is part of the public Sass API of @blueprintjs/core.
// As such, it comes with important considerations:
//
// -  Changes to these variable names and values are generally considered breaking changes.
// -  A limited subset of Sass syntax is supported. All syntax inluded here must be able to get parsed by the
//    `generate-css-variables` script in @blueprintjs/node-build-scripts. For example, "sass:math" is unsupported.
// ----------------------------------------------------------------------------

$pt-intent-primary: $blue3 !default;
$pt-intent-success: $green3 !default;
$pt-intent-warning: $orange3 !default;
$pt-intent-danger: $red3 !default;

$pt-app-background-color: $light-gray5 !default;
$pt-dark-app-background-color: $dark-gray2 !default;

$pt-app-secondary-background-color: $white !default;
$pt-dark-app-secondary-background-color: $dark-gray1 !default;

$pt-app-elevated-background-color: $light-gray4 !default;
$pt-dark-app-elevated-background-color: $dark-gray3 !default;

$pt-outline-color: rgba($blue3, 0.6) !default;
// 0.752 opacity to meet WCCAG 2.2 minimum contrast guidelines with all light-gray backgrounds in light theme
// and all dark-gray backgrounds in dark theme
$pt-focus-indicator-color: rgba($blue2, 0.752) !default;
// dark theme opacity could be less and still meet minimum contrast, but keep 0.752 to stay consistent
$pt-dark-focus-indicator-color: rgba($blue5, 0.752) !default;

$pt-text-color: $dark-gray1 !default;
$pt-text-color-muted: $gray1 !default;
$pt-text-color-disabled: rgba($gray1, 0.6) !default;
$pt-heading-color: $pt-text-color !default;
$pt-link-color: $blue2 !default;
$pt-dark-text-color: $light-gray5 !default;
$pt-dark-text-color-muted: $gray4 !default;
$pt-dark-text-color-disabled: rgba($gray4, 0.6) !default;
$pt-dark-heading-color: $pt-dark-text-color !default;
$pt-dark-link-color: $blue5 !default;
// Default text selection color using #7dbcff with 60% opacity
$pt-text-selection-color: rgba(125, 188, 255, 60%) !default;

$pt-icon-color: $pt-text-color-muted !default;
$pt-icon-color-hover: $pt-text-color !default;
$pt-icon-color-disabled: $pt-text-color-disabled !default;
$pt-icon-color-selected: $pt-intent-primary !default;
$pt-dark-icon-color: $pt-dark-text-color-muted !default;
$pt-dark-icon-color-hover: $pt-dark-text-color !default;
$pt-dark-icon-color-disabled: $pt-dark-text-color-disabled !default;
$pt-dark-icon-color-selected: $pt-intent-primary !default;

$pt-divider-black: rgba($black, 0.15) !default;
$pt-divider-black-muted: rgba($black, 0.1) !default;
$pt-dark-divider-black: rgba($black, 0.4) !default;
$pt-dark-divider-white: rgba($white, 0.2) !default;
$pt-dark-divider-white-muted: rgba($white, 0.1) !default;

$pt-code-text-color: $pt-text-color-muted !default;
$pt-dark-code-text-color: $pt-dark-text-color-muted !default;
$pt-code-background-color: rgba($white, 0.7) !default;
$pt-dark-code-background-color: rgba($black, 0.3) !default;

================================================================================

File: src\common\_flex.scss
--------------------------------------------------------------------------------
// Copyright 2018 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

// this element becomes a flex container in the given direction.
// supply `$margin` to put space between each child.
// supply `$inline: inline` to use `display: flex-inline`.
// customize `flex: 1 1` child selector with $fill.
@mixin pt-flex-container($direction: row, $margin: none, $inline: none, $fill: ".#{$ns}-fill") {
  @if $inline == inline or $inline == true {
    display: inline-flex;
  } @else {
    display: flex;
  }
  flex-direction: $direction;

  > * {
    flex-grow: 0;
    flex-shrink: 0;
  }

  > #{$fill} {
    flex-grow: 1;
    flex-shrink: 1;
  }

  @if $margin != none {
    @include pt-flex-margin($direction, $margin);
  }
}

// applies margin along axis of direction between every direct child, with no margins on either end.
// $direction: row | column
// $margin: margin[-right|-bottom] value
@mixin pt-flex-margin($direction, $margin) {
  $margin-prop: if($direction == row, margin-right, margin-bottom);

  // CSS API support
  &::before,
  > * {
    // space after all children
    #{$margin-prop}: $margin;
  }

  // remove space after last child
  &:empty::before,
  > :last-child {
    #{$margin-prop}: 0;
  }
}

================================================================================

File: src\common\_mixins.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@use "sass:math";
@import "@blueprintjs/colors/lib/scss/colors";
@import "flex";

$pt-intent-colors: (
  "primary": $pt-intent-primary,
  "success": $pt-intent-success,
  "warning": $pt-intent-warning,
  "danger" : $pt-intent-danger,
) !default;

$pt-intent-text-colors: (
  "primary": $blue2,
  "success": $green2,
  "warning": $orange2,
  "danger" : $red2,
) !default;

$pt-intent-active-text-colors: (
  "primary": $blue1,
  "success": $green1,
  "warning": $orange1,
  "danger": $red1
) !default;

$pt-dark-intent-text-colors: (
  "primary": $blue5,
  "success": $green5,
  "warning": $orange5,
  "danger" : $red5,
) !default;

@mixin intent-color($intentName) {
  color: map-get($pt-intent-colors, $intentName);
}

@mixin position-all($position, $value) {
  bottom: $value;
  left: $value;
  position: $position;
  right: $value;
  top: $value;
}

@mixin base-typography() {
  font-size: $pt-font-size;
  font-weight: 400;
  letter-spacing: 0;
  line-height: $pt-line-height;
  text-transform: none;
}

@mixin running-typography() {
  font-size: $pt-font-size;
  line-height: 1.5;
}

@mixin heading-typography() {
  color: $pt-heading-color;
  font-weight: 600;

  .#{$ns}-dark & {
    color: $pt-dark-heading-color;
  }

  &.#{$ns}-text-muted {
    color: $pt-text-color-muted;

    .#{$ns}-dark & {
      color: $pt-dark-text-color-muted;
    }
  }
}

@mixin monospace-typography() {
  font-family: $pt-font-family-monospace;
  text-transform: none;
}

@mixin overflow-ellipsis() {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  word-wrap: normal;
}

@mixin focus-outline($offset: 2px) {
  outline: $pt-focus-indicator-color solid 2px;
  outline-offset: $offset;
  -moz-outline-radius: 6px;

  .#{$ns}-dark & {
    outline-color: $pt-dark-focus-indicator-color;
  }
}

@function border-shadow($alpha, $color: $black, $size: 1px) {
  @return 0 0 0 $size rgba($color, $alpha);
}

// returns the padding necessary to center text in a container of the given height.
// default line-height is that of base typography, 18px assuming 14px font-size.

@function centered-text($height, $line-height: floor($pt-font-size * $pt-line-height)) {
  @return floor(($height - $line-height) * 0.5);
}

// Removes the unit from a Sass numeric value (if present): `strip-unit(12px) => 12`
// @see https://css-tricks.com/snippets/sass/strip-unit-function/

@function strip-unit($number) {
  @if type-of($number) == "number" and not unitless($number) {
    @return math.div($number, $number * 0 + 1);
  }

  @return $number;
}

// Isolates z-indices

@mixin new-render-layer() {
  transform: translateZ(0);
}

================================================================================

File: src\common\_react-transition.scss
--------------------------------------------------------------------------------
// Copyright 2016 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

/*
A mixin to generate the classes for a React CSSTransition which animates any number of CSS
properties at once.

Transitioned properties are specificed as a map of property names to lists of (inital value, final
value). For enter & appear transitions, each property will transition from its initial to its final
value. For exit transitions, each property will transition in reverse, from final to initial.

**Simple example:**
`@include react-transition("popover", (opacity: 0 1), $before: "&");`
Transition named "popover" moves opacity from 0 to 1. `"&"` indicates that the
Transition classes are expected to be applied to this element, where the mixin is invoked.

**Params:**
$name: React transitionName prop
$properties: map of CSS property to (initial, final) values
$duration: transition duration
$easing: transition easing function
$delay: transition delay
$before: selector text to insert before transition name (often to select self: &)
$after: selector text to insert after transiton name (to select children)
*/
@mixin react-transition(
  $name,
  $properties,
  $duration: $pt-transition-duration,
  $easing: $pt-transition-ease,
  $delay: 0,
  $before: "",
  $after: ""
) {
  @include each-prop($properties, 2);
  @include react-transition-phase(
    $name, "enter", $properties,
    $duration, $easing, $delay,
    $before, $after
  );
  @include react-transition-phase(
    $name, "exit", $properties,
    $duration, $easing, $delay,
    $before, $after
  );
}

/*
A mixin to generate the classes for one phase of a React CSSTransition.
`$phase` must be `appear` or `enter` or `exit`.
If `enter` phase is given then `appear` phase will be generated at the same time.
If `exit` phase is given then property values are animated in reverse, from final to initial.

**Example:**
@include react-transition-phase(toast, enter, $enter-translate, $before: "&");
@include react-transition-phase(toast, leave, $leave-blur, $pt-transition-duration * 3, $before: "&");
*/
@mixin react-transition-phase(
  $name,
  $phase,
  $properties,
  $duration: $pt-transition-duration,
  $easing: $pt-transition-ease,
  $delay: 0,
  $before: "",
  $after: ""
) {
  $start-index: 1;
  $end-index: 2;

  @if ($phase == "exit") {
    $start-index: 2;
    $end-index: 1;
  } @else if ($phase != "enter" and $phase != "appear") {
    @error "Unknown transition phase: #{$phase}. Expected appear|enter|exit.";
  }

  #{transition-name($phase, $name, $before, $after)} {
    @include each-prop($properties, $start-index);
  }

  #{transition-name(#{$phase}-active, $name, $before, $after)} {
    @include each-prop($properties, $end-index);
    transition-delay: $delay;
    transition-duration: $duration;
    transition-property: map-keys($properties);
    /* stylelint-disable-next-line declaration-block-no-redundant-longhand-properties */
    transition-timing-function: $easing;
  }
}

/*
Given map of properties to values, set each property to the value at the given index.
(remember that sass indices are 1-based).

Example: `each-prop((opacity: 0 1), 2)` will print "opacity: 1"
*/
@mixin each-prop($properties, $index) {
  @each $prop, $values in $properties {
    #{$prop}: nth($values, $index);
  }
}

/*
Format transition class name with all the bits.
"enter" phase will include "appear" phase in returned name.
*/
@function transition-name($phase, $name, $before, $after) {
  $full-name: "#{$before}.#{$name}-#{$phase}#{$after}";

  @if ($phase == "enter") {
    @return ($full-name, transition-name("appear", $name, $before, $after));
  } @else if ($phase == "enter-active") {
    @return ($full-name, transition-name("appear-active", $name, $before, $after));
  } @else {
    @return $full-name;
  }
}

================================================================================

File: src\common\_typography-colors.scss
--------------------------------------------------------------------------------
// Copyright 2022 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "variables";
@import "variables-extended";
@import "mixins";

@mixin pt-typography-colors() {
  // N.B. we can't declare any global colors here because this mixin is @included at
  // the root, outside of any selector, but _reset.scss sets the body text color for us.

  .#{$ns}-text-muted {
    color: $pt-text-color-muted;
  }

  .#{$ns}-text-disabled {
    color: $pt-text-color-disabled;
  }

  .#{$ns}-running-text {
    hr {
      border-color: $pt-divider-black;
    }
  }

  a {
    color: $pt-link-color;

    &:hover {
      color: $pt-link-color;
    }

    #{$icon-classes} {
      color: inherit;
    }

    code {
      color: inherit;
    }
  }

  .#{$ns}-code,
  .#{$ns}-running-text code {
    background: $pt-code-background-color;
    box-shadow: inset border-shadow(0.2);
    color: $pt-code-text-color;

    a > & {
      // <code> in links. markdown: [`code`](http://url)
      // $pt-link-color does not have good contrast with non-link <code>'s in light theme, so we use a brighter hue
      color: $pt-intent-primary;
    }
  }

  .#{$ns}-code-block,
  .#{$ns}-running-text pre {
    background: $pt-code-background-color;
    box-shadow: inset 0 0 0 1px $pt-divider-black;
    color: $pt-text-color;

    > code {
      background: none;
      box-shadow: none;
      color: inherit;
    }

    @media (forced-colors: active) and (prefers-color-scheme: dark) {
      // Windows High Contrast dark theme
      border: 1px solid $pt-high-contrast-mode-border-color;
      box-shadow: none;
    }
  }

  .#{$ns}-key,
  .#{$ns}-running-text kbd {
    background: $white;
    box-shadow: $pt-elevation-shadow-1;
    color: $pt-text-color-muted;
  }

  #{$icon-classes} {
    @each $intent, $color in $pt-intent-text-colors {
      &.#{$ns}-intent-#{$intent} {
        color: $color;
      }
    }
  }
}

@mixin pt-dark-typography-colors() {
  color: $pt-dark-text-color;

  .#{$ns}-text-muted {
    color: $pt-dark-text-color-muted;
  }

  .#{$ns}-text-disabled {
    color: $pt-dark-text-color-disabled;
  }

  .#{$ns}-running-text {
    hr {
      border-color: $pt-dark-divider-white;
    }
  }

  a {
    color: $pt-dark-link-color;

    &:hover {
      color: $pt-dark-link-color;
    }

    #{$icon-classes} {
      color: inherit;
    }

    code {
      color: inherit;
    }
  }

  .#{$ns}-code,
  .#{$ns}-running-text code {
    background: $pt-dark-code-background-color;
    box-shadow: inset border-shadow(0.4);
    color: $pt-dark-code-text-color;

    a > & {
      color: inherit;
    }
  }

  .#{$ns}-code-block,
  .#{$ns}-running-text pre {
    background: $pt-dark-code-background-color;
    box-shadow: inset 0 0 0 1px $pt-dark-divider-black;
    color: $pt-dark-text-color;

    > code {
      background: none;
      box-shadow: none;
      color: inherit;
    }
  }

  .#{$ns}-key,
  .#{$ns}-running-text kbd {
    background: $dark-gray4;
    box-shadow: $pt-dark-elevation-shadow-1;
    color: $pt-dark-text-color-muted;
  }

  #{$icon-classes} {
    @each $intent, $color in $pt-dark-intent-text-colors {
      &.#{$ns}-intent-#{$intent} {
        color: $color;
      }
    }
  }
}

================================================================================

File: src\common\_variables-extended.scss
--------------------------------------------------------------------------------
// Copyright 2022 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "variables";

// ----------------------------------------------------------------------------
// This file contains additional common variables which we do not want to export in public API via variables.scss,
// or they contain syntax which does not parse easily with our generate-css-variables script and thus cannot be easily
// exported.
// ----------------------------------------------------------------------------

$half-grid-size: $pt-grid-size * 0.5 !default;

// Extended color palette
$blue0: #11376b !default;
$green0: #0f3e25 !default;
$orange0: #5f380b !default;
$red0: #782326 !default;
$blue6: #99c4ff !default;
$green6: #7cd7a2 !default;
$orange6: #f5c186 !default;
$red6: #ffa1a4 !default;

$icon-classes: (
  ".#{$ns}-icon",
  ".#{$ns}-icon-standard",
  ".#{$ns}-icon-large"
) !default;

$elevation-shadows: (
  $pt-elevation-shadow-0
  $pt-elevation-shadow-1
  $pt-elevation-shadow-2
  $pt-elevation-shadow-3
  $pt-elevation-shadow-4
);
$dark-elevation-shadows: (
  $pt-dark-elevation-shadow-0
  $pt-dark-elevation-shadow-1
  $pt-dark-elevation-shadow-2
  $pt-dark-elevation-shadow-3
  $pt-dark-elevation-shadow-4
);

================================================================================

File: src\common\_variables.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "color-aliases";
@import "mixins";

// ----------------------------------------------------------------------------
// This file is part of the public Sass API of @blueprintjs/core.
// As such, it comes with important considerations:
//
// -  Changes to these variable names and values are generally considered breaking changes.
// -  A limited subset of Sass syntax is supported. All syntax inluded here must be able to get parsed by the
//    `generate-css-variables` script in @blueprintjs/node-build-scripts. For example, "sass:math" is unsupported.
// ----------------------------------------------------------------------------

// Namespace appended to the beginning of each CSS class: `.#{$ns}-button`.
// N.B. No quotes around this string value, for Less syntax compatibility. Also, this cannot be overriden
// (the JS components have this class prefix hard-coded), so it does not have the `!default` modifier.
$ns: bp5;
// Alias for BP users outside this repo
$bp-ns: $ns;

// easily the most important variable, so it comes up top
// (so other variables can use it to define themselves)
$pt-grid-size: 10px !default;

// Icon variables

$icons16-family: "blueprint-icons-16" !default;
$icons20-family: "blueprint-icons-20" !default;

$pt-icon-size-standard: 16px !default;
$pt-icon-size-large: 20px !default;

// Typography

// see https://bitsofco.de/the-new-system-font-stack/
$pt-font-family: -apple-system,
                 "BlinkMacSystemFont",
                 "Segoe UI",
                 "Roboto",
                 "Oxygen",
                 "Ubuntu",
                 "Cantarell",
                 "Open Sans",
                 "Helvetica Neue",
                 $icons16-family, // support inline Blueprint icons
                 sans-serif !default;

$pt-font-family-monospace: monospace !default;

$pt-font-size: $pt-grid-size * 1.4 !default;
$pt-font-size-large: $pt-grid-size * 1.6 !default;
$pt-font-size-small: $pt-grid-size * 1.2 !default;

// a little bit extra to ensure the height comes out to just over 18px (and browser rounds to 18px)
// equivalent to: math.div($pt-grid-size * 1.8, $pt-font-size) + 0.0001
$pt-line-height: 1.28581 !default;

// Grids & dimensions

// equivalent to: floor(math.div($pt-grid-size, 5))
$pt-border-radius: 2px !default;

// Buttons
$pt-button-height: $pt-grid-size * 3 !default;
$pt-button-height-small: $pt-grid-size * 2.4 !default;
$pt-button-height-smaller: $pt-grid-size * 2 !default;
$pt-button-height-large: $pt-grid-size * 4 !default;

// Inputs
$pt-input-height: $pt-grid-size * 3 !default;
$pt-input-height-large: $pt-grid-size * 4 !default;
$pt-input-height-small: $pt-grid-size * 2.4 !default;

// Others
$pt-navbar-height: $pt-grid-size * 5 !default;

// Z-indices
$pt-z-index-base: 0 !default;
$pt-z-index-content: $pt-z-index-base + 10 !default;
$pt-z-index-overlay: $pt-z-index-content + 10 !default;
$pt-z-index-dialog-header: $pt-z-index-overlay + 10 !default;

// Shadow opacities
$pt-border-shadow-opacity: 0.1 !default;
$pt-drop-shadow-opacity: 0.2 !default;
$pt-dark-border-shadow-opacity: $pt-border-shadow-opacity * 2 !default;
$pt-dark-drop-shadow-opacity: $pt-drop-shadow-opacity * 2 !default;

// Elevations
$pt-elevation-shadow-0: 0 0 0 1px $pt-divider-black !default;
$pt-elevation-shadow-1: border-shadow($pt-border-shadow-opacity),
                        0 1px 1px rgba($black, $pt-drop-shadow-opacity) !default;
$pt-elevation-shadow-2: border-shadow($pt-border-shadow-opacity),
                        0 1px 1px rgba($black, $pt-drop-shadow-opacity),
                        0 2px 6px rgba($black, $pt-drop-shadow-opacity) !default;
$pt-elevation-shadow-3: border-shadow($pt-border-shadow-opacity),
                        0 2px 4px rgba($black, $pt-drop-shadow-opacity),
                        0 8px 24px rgba($black, $pt-drop-shadow-opacity) !default;
$pt-elevation-shadow-4: border-shadow($pt-border-shadow-opacity),
                        0 4px 8px rgba($black, $pt-drop-shadow-opacity),
                        0 18px 46px 6px rgba($black, $pt-drop-shadow-opacity) !default;

$pt-dark-elevation-shadow-0: inset 0 0 0 1px rgba($white, 0.2) !default;
$pt-dark-elevation-shadow-1: inset 0 0 0 1px rgba($white, 0.2),
                             0 1px 1px 0 rgba($black, $pt-dark-drop-shadow-opacity) !default;
$pt-dark-elevation-shadow-2: inset 0 0 0 1px rgba($white, 0.2),
                             0 1px 1px rgba($black, $pt-dark-drop-shadow-opacity),
                             0 2px 6px rgba($black, $pt-dark-drop-shadow-opacity) !default;
$pt-dark-elevation-shadow-3: inset 0 0 0 1px rgba($white, 0.2),
                             0 2px 4px rgba($black, $pt-dark-drop-shadow-opacity),
                             0 8px 24px rgba($black, $pt-dark-drop-shadow-opacity) !default;
$pt-dark-elevation-shadow-4: inset 0 0 0 1px rgba($white, 0.2),
                             0 4px 8px rgba($black, $pt-dark-drop-shadow-opacity),
                             0 18px 46px 6px rgba($black, $pt-dark-drop-shadow-opacity) !default;

// Transitions
$pt-transition-ease: cubic-bezier(0.4, 1, 0.75, 0.9) !default;
$pt-transition-ease-bounce: cubic-bezier(0.54, 1.12, 0.38, 1.11) !default;
$pt-transition-duration: 100ms !default;

// Light theme styles

$pt-input-box-shadow: inset 0 0 0 1px rgba($black, 0.2),
                      inset 0 1px 1px rgba($black, 0.3) !default;

$pt-dialog-box-shadow: $pt-elevation-shadow-3 !default;
$pt-popover-box-shadow: $pt-elevation-shadow-3 !default;
$pt-tooltip-box-shadow: $pt-popover-box-shadow !default;
// Equivalent to $pt-dark-elevation-shadow-3, but swaps the outset border for an inset one
$pt-toast-box-shadow: inset border-shadow(0.2),
                      0 2px 4px rgba($black, $pt-drop-shadow-opacity),
                      0 8px 24px rgba($black, $pt-drop-shadow-opacity) !default;

// Dark theme styles

$pt-dark-input-box-shadow: inset 0 0 0 1px rgba($white, 0.2),
                           inset 0 -1px 1px 0 rgba($white, 0.3) !default;
$pt-dark-input-intent-box-shadow-colors: (
  "primary": $blue4,
  "success": $green4,
  "warning": $orange4,
  "danger": $red4,
) !default;

$pt-dark-dialog-box-shadow: $pt-dark-elevation-shadow-3 !default;
// Dark popover borders are outset, so they can't use rgba($white, 0.3).
// They also can't use $gray1 because its blue tint is noticeably different from other white borders in dark theme.
// Instead, we create a new color tuned to match semi-transparent white borders on a dark theme background.
$pt-dark-popover-border-color: hsl(215deg, 3%, 38%) !default;
$pt-dark-popover-box-shadow: 0 0 0 1px $pt-dark-popover-border-color,
                             $pt-dark-elevation-shadow-3 !default;
// Equivalent to $pt-dark-elevation-shadow-3 without the inset border
$pt-dark-tooltip-box-shadow: 0 2px 4px rgba($black, $pt-dark-drop-shadow-opacity),
                             0 8px 24px rgba($black, $pt-dark-drop-shadow-opacity) !default;
$pt-dark-toast-box-shadow: $pt-dark-elevation-shadow-3 !default;

// Colors used for Windows high contrast mode
// Because high contrast mode doesn't actually obey any colors we define, but uses system colors,
// we define these variables in terms of System colors so that it's easier to understand the intent.
// See https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/system_color_keywords for more info on system colors.
$pt-high-contrast-mode-border-color: buttonborder;
$pt-high-contrast-mode-active-background-color: highlight;
$pt-high-contrast-mode-active-text-color: highlight;
$pt-high-contrast-mode-disabled-border-color: graytext;
$pt-high-contrast-mode-disabled-text-color: graytext;
$pt-high-contrast-mode-disabled-background-color: graytext;

================================================================================

File: src\common\utils\compareUtils.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// we use the empty object {} a lot in this public API
/* eslint-disable @typescript-eslint/ban-types */

export interface KeyAllowlist<T> {
    include: Array<keyof T>;
}

export interface KeyDenylist<T> {
    exclude: Array<keyof T>;
}

/**
 * Returns true if the arrays are equal. Elements will be shallowly compared by
 * default, or they will be compared using the custom `compare` function if one
 * is provided.
 */
export function arraysEqual(arrA: any[], arrB: any[], compare = (a: any, b: any) => a === b) {
    // treat `null` and `undefined` as the same
    if (arrA == null && arrB == null) {
        return true;
    } else if (arrA == null || arrB == null || arrA.length !== arrB.length) {
        return false;
    } else {
        return arrA.every((a, i) => compare(a, arrB[i]));
    }
}

/**
 * Shallow comparison between objects. If `keys` is provided, just that subset
 * of keys will be compared; otherwise, all keys will be compared.
 *
 * @returns true if items are equal.
 */
export function shallowCompareKeys<T extends {}>(
    objA: T | null | undefined,
    objB: T | null | undefined,
    keys?: KeyDenylist<T> | KeyAllowlist<T>,
) {
    // treat `null` and `undefined` as the same
    if (objA == null && objB == null) {
        return true;
    } else if (objA == null || objB == null) {
        return false;
    } else if (Array.isArray(objA) || Array.isArray(objB)) {
        return false;
    } else if (keys != null) {
        return shallowCompareKeysImpl(objA, objB, keys);
    } else {
        // shallowly compare all keys from both objects
        const keysA = Object.keys(objA) as Array<keyof T>;
        const keysB = Object.keys(objB) as Array<keyof T>;
        return (
            shallowCompareKeysImpl(objA, objB, { include: keysA }) &&
            shallowCompareKeysImpl(objA, objB, { include: keysB })
        );
    }
}

/**
 * Deep comparison between objects. If `keys` is provided, just that subset of
 * keys will be compared; otherwise, all keys will be compared.
 *
 * @returns true if items are equal.
 */
export function deepCompareKeys(objA: any, objB: any, keys?: Array<string | number | symbol>): boolean {
    if (objA === objB) {
        return true;
    } else if (objA == null && objB == null) {
        // treat `null` and `undefined` as the same
        return true;
    } else if (objA == null || objB == null) {
        return false;
    } else if (Array.isArray(objA) || Array.isArray(objB)) {
        return arraysEqual(objA, objB, deepCompareKeys);
    } else if (isSimplePrimitiveType(objA) || isSimplePrimitiveType(objB)) {
        return objA === objB;
    } else if (keys != null) {
        return deepCompareKeysImpl(objA, objB, keys);
    } else if (objA.constructor !== objB.constructor) {
        return false;
    } else {
        const keysA = Object.keys(objA);
        const keysB = Object.keys(objB);
        if (keysA == null || keysB == null) {
            return false;
        }
        if (keysA.length === 0 && keysB.length === 0) {
            return true;
        }
        return arraysEqual(keysA, keysB) && deepCompareKeysImpl(objA, objB, keysA);
    }
}

/**
 * Returns a descriptive object for each key whose values are deeply unequal
 * between two provided objects. Useful for debugging shouldComponentUpdate.
 */
export function getDeepUnequalKeyValues<T extends {}>(
    objA: T = {} as any as T,
    objB: T = {} as any as T,
    keys?: Array<keyof T>,
) {
    const filteredKeys = keys == null ? unionKeys(objA, objB) : keys;
    return getUnequalKeyValues(objA, objB, filteredKeys, (a, b, key) => {
        return deepCompareKeys(a, b, [key]);
    });
}

// Private helpers
// ===============

/**
 * Partial shallow comparison between objects using the given list of keys.
 */
function shallowCompareKeysImpl<T extends object>(objA: T, objB: T, keys: KeyDenylist<T> | KeyAllowlist<T>) {
    return filterKeys(objA, objB, keys).every(key => {
        return objA.hasOwnProperty(key) === objB.hasOwnProperty(key) && objA[key] === objB[key];
    });
}

/**
 * Partial deep comparison between objects using the given list of keys.
 */
function deepCompareKeysImpl(objA: any, objB: any, keys: Array<string | number | symbol>): boolean {
    return keys.every(key => {
        return objA.hasOwnProperty(key) === objB.hasOwnProperty(key) && deepCompareKeys(objA[key], objB[key]);
    });
}

function isSimplePrimitiveType(value: any) {
    return typeof value === "number" || typeof value === "string" || typeof value === "boolean";
}

function filterKeys<T extends object>(objA: T, objB: T, keys: KeyDenylist<T> | KeyAllowlist<T>) {
    if (isAllowlist(keys)) {
        return keys.include;
    } else if (isDenylist(keys)) {
        const keysA = Object.keys(objA);
        const keysB = Object.keys(objB);

        // merge keys from both objects into a big set for quick access
        const keySet = arrayToObject(keysA.concat(keysB));

        // delete denied keys from the key set
        keys.exclude.forEach(key => delete keySet[key]);

        // return the remaining keys as an array
        return Object.keys(keySet) as Array<keyof T>;
    }

    return [];
}

function isAllowlist<T>(keys: any): keys is KeyAllowlist<T> {
    return keys != null && (keys as KeyAllowlist<T>).include != null;
}

function isDenylist<T>(keys: any): keys is KeyDenylist<T> {
    return keys != null && (keys as KeyDenylist<T>).exclude != null;
}

function arrayToObject(arr: any[]) {
    return arr.reduce((obj: any, element: any) => {
        obj[element] = true;
        return obj;
    }, {});
}

function getUnequalKeyValues<T extends {}>(
    objA: T,
    objB: T,
    keys: Array<keyof T>,
    compareFn: (objA: any, objB: any, key: keyof T) => boolean,
) {
    const unequalKeys = keys.filter(key => !compareFn(objA, objB, key));
    const unequalKeyValues = unequalKeys.map(key => ({
        key,
        valueA: objA[key],
        valueB: objB[key],
    }));
    return unequalKeyValues;
}

function unionKeys<T extends {}>(objA: T, objB: T) {
    const keysA = Object.keys(objA);
    const keysB = Object.keys(objB);

    const concatKeys = keysA.concat(keysB);
    const keySet = arrayToObject(concatKeys);

    return Object.keys(keySet) as Array<keyof T>;
}

================================================================================

File: src\common\utils\domUtils.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2020 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @returns true if React is running in a client environment, and false if it's in a server */
export function hasDOMEnvironment(): boolean {
    return typeof window !== "undefined" && window.document != null;
}

export function elementIsOrContains(element: HTMLElement, testElement: HTMLElement) {
    return element === testElement || element.contains(testElement);
}

/**
 * Checks whether the given element is inside something that looks like a text input.
 * This is particularly useful to determine if a keyboard event inside this element should take priority over hotkey
 * bindings / keyboard shortcut handlers.
 *
 * @returns true if the element is inside a text input
 */
export function elementIsTextInput(elem: HTMLElement) {
    // we check these cases for unit testing, but this should not happen
    // during normal operation
    if (elem == null || elem.closest == null) {
        return false;
    }

    const editable = elem.closest("input, textarea, [contenteditable=true]");

    if (editable == null) {
        return false;
    }

    // don't let checkboxes, switches, and radio buttons prevent hotkey behavior
    if (editable.tagName.toLowerCase() === "input") {
        const inputType = (editable as HTMLInputElement).type;
        if (inputType === "checkbox" || inputType === "radio") {
            return false;
        }
    }

    // don't let read-only fields prevent hotkey behavior
    if ((editable as HTMLInputElement).readOnly) {
        return false;
    }

    return true;
}

/**
 * Gets the active element in the document or shadow root (if an element is provided, and it's in the shadow DOM).
 */
export function getActiveElement(element?: HTMLElement | null, options?: GetRootNodeOptions) {
    if (element == null) {
        return document.activeElement;
    }

    const rootNode = (element.getRootNode(options) ?? document) as DocumentOrShadowRoot & Node;
    return rootNode.activeElement;
}

/**
 * Throttle an event on an EventTarget by wrapping it in a
 * `requestAnimationFrame` call. Returns the event handler that was bound to
 * given eventName so you can clean up after yourself.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/Events/scroll
 */
/* istanbul ignore next */
export function throttleEvent(target: EventTarget, eventName: string, newEventName: string) {
    const throttledFunc = throttleImpl((event: Event) => {
        target.dispatchEvent(new CustomEvent(newEventName, event));
    });
    target.addEventListener(eventName, throttledFunc);
    return throttledFunc;
}

export interface ThrottledReactEventOptions {
    preventDefault?: boolean;
}

/**
 * Throttle a callback by wrapping it in a `requestAnimationFrame` call. Returns
 * the throttled function.
 *
 * @see https://www.html5rocks.com/en/tutorials/speed/animations/
 */
export function throttleReactEventCallback<E extends React.SyntheticEvent = React.SyntheticEvent>(
    callback: (event: E, ...otherArgs: any[]) => any,
    options: ThrottledReactEventOptions = {},
) {
    const throttledFunc = throttleImpl(
        callback,
        (event2: E) => {
            if (options.preventDefault) {
                event2.preventDefault();
            }
        },
        // prevent React from reclaiming the event object before we reference it
        (event2: E) => event2.persist(),
    );
    return throttledFunc;
}

/**
 * Throttle a method by wrapping it in a `requestAnimationFrame` call. Returns
 * the throttled function.
 */
/* istanbul ignore next */
// eslint-disable-next-line @typescript-eslint/ban-types
export function throttle<T extends Function>(method: T): T {
    return throttleImpl(method);
}

// eslint-disable-next-line @typescript-eslint/ban-types
function throttleImpl<T extends Function>(
    onAnimationFrameRequested: T,
    onBeforeIsRunningCheck?: T,
    onAfterIsRunningCheck?: T,
) {
    let isRunning = false;
    const func = (...args: any[]) => {
        onBeforeIsRunningCheck?.(...args);

        if (isRunning) {
            return;
        }
        isRunning = true;

        onAfterIsRunningCheck?.(...args);

        requestAnimationFrame(() => {
            onAnimationFrameRequested(...args);
            isRunning = false;
        });
    };
    return func as any as T;
}

export function clickElementOnKeyPress(keys: string[]) {
    return (e: React.KeyboardEvent) => {
        if (keys.some(key => e.key === key)) {
            // Prevent spacebar from scrolling the page unless we're in a text field
            if (!elementIsTextInput(e.target as HTMLElement)) {
                e.preventDefault();
            }

            e.target.dispatchEvent(new MouseEvent("click", { ...e, view: undefined }));
        }
    };
}

================================================================================

File: src\common\utils\functionUtils.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2020 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Returns whether the value is a function. Acts as a type guard. */
/* istanbul ignore next */
// eslint-disable-next-line @typescript-eslint/ban-types
export function isFunction(value: any): value is Function {
    return typeof value === "function";
}

================================================================================

File: src\common\utils\index.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * from "./compareUtils";
export {
    clickElementOnKeyPress,
    elementIsOrContains,
    elementIsTextInput,
    getActiveElement,
    throttle,
    throttleEvent,
    throttleReactEventCallback,
} from "./domUtils";
export { isFunction } from "./functionUtils";
export * from "./jsUtils";
export * from "./reactUtils";
export { isArrowKey, isKeyboardClick } from "./keyboardUtils";
export type { Extends } from "./typeUtils";
export { isDarkTheme } from "./isDarkTheme";

// ref utils used to live in this folder, but got refactored and moved elsewhere.
// we keep this export here for backwards compatibility
export { setRef, getRef } from "../refs";

================================================================================

File: src\common\utils\isDarkTheme.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as Classes from "../classes";

export function isDarkTheme(element: Element | Text | null | undefined): boolean {
    return element != null && element instanceof Element && element.closest(`.${Classes.DARK}`) != null;
}

================================================================================

File: src\common\utils\jsUtils.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2020 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { CLAMP_MIN_MAX } from "../errors";

// injected by webpack.DefinePlugin
// only accessible within this file, so use `Utils.isNodeEnv(env)` from the outside.
declare let NODE_ENV: string;

/** Returns whether bundler-injected variable `NODE_ENV` equals `env`. */
export function isNodeEnv(env: string) {
    return typeof NODE_ENV !== "undefined" && NODE_ENV === env;
}

/**
 * Returns the difference in length between two arrays. A `null` argument is
 * considered an empty list. The return value will be positive if `a` is longer
 * than `b`, negative if the opposite is true, and zero if their lengths are
 * equal.
 */
export function arrayLengthCompare(a: any[] = [], b: any[] = []) {
    return a.length - b.length;
}

/**
 * Returns true if the two numbers are within the given tolerance of each other.
 * This is useful to correct for floating point precision issues, less useful
 * for integers.
 */
export function approxEqual(a: number, b: number, tolerance = 0.00001) {
    return Math.abs(a - b) <= tolerance;
}

/**
 * Clamps the given number between min and max values. Returns value if within
 * range, or closest bound.
 */
export function clamp(val: number, min: number, max: number) {
    if (val == null) {
        return val;
    }
    if (max < min) {
        throw new Error(CLAMP_MIN_MAX);
    }
    return Math.min(Math.max(val, min), max);
}

/** Returns the number of decimal places in the given number. */
export function countDecimalPlaces(num: number) {
    if (!isFinite(num)) {
        return 0;
    }
    let e = 1;
    let p = 0;
    while (Math.round(num * e) / e !== num) {
        e *= 10;
        p++;
    }
    return p;
}

const uniqueCountForNamespace = new Map<string, number>();
/** Generate a unique ID within a given namespace, using a simple counter-based implementation to avoid collisions. */
export function uniqueId(namespace: string) {
    const curCount = uniqueCountForNamespace.get(namespace) ?? 0;
    uniqueCountForNamespace.set(namespace, curCount + 1);
    return `${namespace}-${curCount}`;
}

/**
 * @returns `true` if the value is an empty string after trimming whitespace
 */
export function isEmptyString(val: any) {
    return typeof val === "string" && val.trim().length === 0;
}

================================================================================

File: src\common\utils\keyboardUtils.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns whether the keyboard event was triggered by Enter or Space, the two keys that are expected to trigger
 * interactive elements like buttons.
 */
export function isKeyboardClick(event: React.KeyboardEvent<HTMLElement>) {
    return event.key === "Enter" || event.key === " ";
}

export function isArrowKey(event: React.KeyboardEvent<HTMLElement>) {
    return ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].indexOf(event.key) >= 0;
}

================================================================================

File: src\common\utils\mountOptions.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type * as React from "react";

/**
 * Generic options interface for Blueprint APIs which imperatively mount a React component to the
 * DOM using `"react-dom"`: `OverlayToaster.create`, `showContextMenu`, etc.
 *
 * The `domRenderer` currently defaults to React 16's `ReactDOM.render()`; a future version of Blueprint
 * will default to using React 18's `createRoot()` instead, but it's possible to configure this
 * function to use the newer API by overriding the default.
 */
export interface DOMMountOptions<P> {
    /**
     * A new DOM element will be created and appended to this container.
     *
     * @default document.body
     */
    container?: HTMLElement;

    /**
     * A function to render the React component onto a newly created DOM element.
     *
     * @default ReactDOM.render
     */
    domRenderer?: (
        element: React.ReactElement<P>,
        container: Element | DocumentFragment,
    ) => React.Component<P, any> | Element | void;

    /**
     * A function to unmount the React component from its DOM element.
     *
     * @default ReactDOM.unmountComponentAtNode
     */
    domUnmounter?: (container: Element | DocumentFragment) => void;
}

================================================================================

File: src\common\utils\reactUtils.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2020 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

import { isEmptyString } from "./jsUtils";

/**
 * Returns true if `node` is null/undefined, false, empty string, or an array
 * composed of those. If `node` is an array, only one level of the array is
 * checked, for performance reasons.
 */
export function isReactNodeEmpty(node?: React.ReactNode, skipArray = false): boolean {
    return (
        node == null ||
        node === "" ||
        node === false ||
        (!skipArray &&
            Array.isArray(node) &&
            // only recurse one level through arrays, for performance
            (node.length === 0 || node.every(n => isReactNodeEmpty(n, true))))
    );
}

/**
 * Returns true if children are a mappable children array
 *
 * @internal
 */
export function isReactChildrenElementOrElements(
    children: React.ReactNode,
): children is React.JSX.Element[] | React.JSX.Element {
    return !isReactNodeEmpty(children, true) && children !== true;
}

/**
 * Converts a React node to an element. Non-empty strings, numbers, and Fragments will be wrapped in given tag name;
 * empty strings and booleans will be discarded.
 *
 * @param child     the React node to convert
 * @param tagName   the HTML tag name to use when a wrapper element is needed
 * @param props     additional props to spread onto the element, if any. If the child is a React element and this argument
 *                  is defined, the child will be cloned and these props will be merged in.
 */
export function ensureElement(
    child: React.ReactNode | undefined,
    tagName: keyof React.JSX.IntrinsicElements = "span",
    props: React.HTMLProps<HTMLElement> = {},
) {
    if (child == null || typeof child === "boolean" || isEmptyString(child)) {
        return undefined;
    } else if (
        typeof child === "string" ||
        typeof child === "number" ||
        isReactFragment(child) ||
        isReactNodeArray(child)
    ) {
        // wrap the child element
        return React.createElement(tagName, props, child);
    } else if (isReactElement(child)) {
        if (Object.keys(props).length > 0) {
            // clone the element and merge props
            return React.cloneElement(child, props);
        } else {
            // nothing to do, it's a valid ReactElement
            return child;
        }
    } else {
        // child is inferred as {}
        return undefined;
    }
}

export function isReactElement<T = any>(child: React.ReactNode): child is React.ReactElement<T> {
    return (
        typeof child === "object" &&
        typeof (child as any).type !== "undefined" &&
        typeof (child as any).props !== "undefined"
    );
}

function isReactFragment(child: React.ReactNode): child is React.ReactFragment {
    // bit hacky, but generally works
    return typeof (child as any).type === "symbol";
}

function isReactNodeArray(child: React.ReactNode): child is React.ReactNodeArray {
    return Array.isArray(child);
}

/**
 * Returns true if the given JSX element matches the given component type.
 *
 * NOTE: This function only checks equality of `displayName` for performance and
 * to tolerate multiple minor versions of a component being included in one
 * application bundle.
 *
 * @param element JSX element in question
 * @param ComponentType desired component type of element
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export function isElementOfType<P = {}>(
    element: any,
    ComponentType: React.ComponentType<P>,
): element is React.ReactElement<P> {
    return (
        element != null &&
        element.type != null &&
        element.type.displayName != null &&
        element.type.displayName === ComponentType.displayName
    );
}

export function isReact18(): boolean {
    return React.version.startsWith("18");
}

================================================================================

File: src\common\utils\typeUtils.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Useful to create a subset of a string union type */
export type Extends<T, U extends T> = U;

================================================================================

File: src\components\components.md
--------------------------------------------------------------------------------
@# Components

<!-- Exact ordering of items in the navbar: -->

@page breadcrumbs
@page buttons
@page button-group
@page callout
@page card
@page card-list
@page control-card
@page collapse
@page divider
@page editable-text
@page entity-title
@page html
@page html-table
@page hotkeys-target2
@page icon
@page menu
@page navbar
@page non-ideal-state
@page overflow-list
@page panel-stack
@page panel-stack2
@page progress-bar
@page resize-sensor
@page section
@page skeleton
@page spinner
@page tabs
@page tag
@page compound-tag
@page text
@page tree

@## Form controls

@page form-group
@page control-group
@page label
@page checkbox
@page radio
@page html-select
@page segmented-control
@page sliders
@page switch

@## Form inputs

@page input-group
@page text-area
@page file-input
@page numeric-input
@page tag-input

@## Overlays

@page overlay
@page overlay2
@page portal
@page alert
@page context-menu
@page context-menu-popover
@page dialog
@page drawer
@page popover
@page toast
@page tooltip

================================================================================

File: src\components\index.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { Alert, type AlertProps } from "./alert/alert";
export { Breadcrumb, type BreadcrumbProps } from "./breadcrumbs/breadcrumb";
export { Breadcrumbs, type BreadcrumbsProps } from "./breadcrumbs/breadcrumbs";
export { AnchorButton, Button } from "./button/buttons";
export type {
    AnchorButtonProps,
    ButtonProps,
    ButtonSharedProps,
    ButtonSharedPropsAndAttributes,
} from "./button/buttonProps";
export { ButtonGroup, type ButtonGroupProps } from "./button/buttonGroup";
export { Callout, type CalloutProps } from "./callout/callout";
export { Card, type CardProps } from "./card/card";
export { CardList, type CardListProps } from "./card-list/cardList";
export { Collapse, type CollapseProps } from "./collapse/collapse";
export {
    ContextMenu,
    type ContextMenuProps,
    type ContextMenuChildrenProps,
    type ContextMenuContentProps,
} from "./context-menu/contextMenu";
export { ContextMenuPopover, type ContextMenuPopoverProps } from "./context-menu/contextMenuPopover";
export { showContextMenu, hideContextMenu } from "./context-menu/contextMenuSingleton";
export { Dialog, type DialogProps } from "./dialog/dialog";
export { DialogBody, type DialogBodyProps } from "./dialog/dialogBody";
export { DialogFooter, type DialogFooterProps } from "./dialog/dialogFooter";
export type { DialogStepButtonProps } from "./dialog/dialogStepButton";
export { DialogStep, type DialogStepId, type DialogStepProps } from "./dialog/dialogStep";
export { MultistepDialog, type MultistepDialogNavPosition, type MultistepDialogProps } from "./dialog/multistepDialog";
export { Divider, type DividerProps } from "./divider/divider";
export { Drawer, type DrawerProps, DrawerSize } from "./drawer/drawer";
export { EditableText, type EditableTextProps } from "./editable-text/editableText";
export { ControlGroup, type ControlGroupProps } from "./forms/controlGroup";
export { Checkbox, type CheckboxProps, Radio, type RadioProps, Switch, type SwitchProps } from "./forms/controls";
export type { ControlProps } from "./forms/controlProps";
export { EntityTitle, type EntityTitleProps } from "./entity-title/entityTitle";
export { FileInput, type FileInputProps } from "./forms/fileInput";
export { FormGroup, type FormGroupProps } from "./forms/formGroup";
export { InputGroup, type InputGroupProps } from "./forms/inputGroup";
export { NumericInput, type NumericInputProps } from "./forms/numericInput";
export { RadioGroup, type RadioGroupProps } from "./forms/radioGroup";
export { TextArea, type TextAreaProps } from "./forms/textArea";
export { Blockquote, Code, H1, H2, H3, H4, H5, H6, Label, OL, Pre, UL } from "./html/html";
export { HTMLSelect, type HTMLSelectIconName, type HTMLSelectProps } from "./html-select/htmlSelect";
export { HTMLTable, type HTMLTableProps } from "./html-table/htmlTable";
export * from "./hotkeys";
export { type DefaultIconProps, Icon, type IconComponent, type IconName, type IconProps, IconSize } from "./icon/icon";
export { Menu, type MenuProps } from "./menu/menu";
export { MenuDivider, type MenuDividerProps } from "./menu/menuDivider";
export { MenuItem, type MenuItemProps } from "./menu/menuItem";
export { Navbar, type NavbarProps } from "./navbar/navbar";
export { NavbarDivider, type NavbarDividerProps } from "./navbar/navbarDivider";
export { NavbarGroup, type NavbarGroupProps } from "./navbar/navbarGroup";
export { NavbarHeading, type NavbarHeadingProps } from "./navbar/navbarHeading";
export { NonIdealState, type NonIdealStateProps, NonIdealStateIconSize } from "./non-ideal-state/nonIdealState";
export { OverflowList, type OverflowListProps } from "./overflow-list/overflowList";
// eslint-disable-next-line deprecation/deprecation
export { Overlay } from "./overlay/overlay";
export type { OverlayLifecycleProps, OverlayProps, OverlayableProps } from "./overlay/overlayProps";
export { Overlay2, type Overlay2Props } from "./overlay2/overlay2";
export type { OverlayInstance } from "./overlay2/overlayInstance";
export { Text, type TextProps } from "./text/text";
// eslint-disable-next-line deprecation/deprecation
export { PanelStack, type PanelStackProps } from "./panel-stack/panelStack";
// eslint-disable-next-line deprecation/deprecation
export type { IPanel, IPanelProps } from "./panel-stack/panelProps";
export { PanelStack2, type PanelStack2Props } from "./panel-stack2/panelStack2";
export type { Panel, PanelProps } from "./panel-stack2/panelTypes";
export { type PopoverProps, Popover, PopoverInteractionKind } from "./popover/popover";
export { PopoverPosition } from "./popover/popoverPosition";
export type {
    DefaultPopoverTargetHTMLProps,
    PopoverSharedProps,
    PopoverTargetProps,
    PopoverClickTargetHandlers,
    PopoverHoverTargetHandlers,
    PopperBoundary,
    PopperCustomModifier,
    PopperModifierOverrides,
    Placement,
    StrictModifierNames,
} from "./popover/popoverSharedProps";
export { PopperPlacements } from "./popover/popperUtils";
export { PopupKind } from "./popover/popupKind";
export { Portal, type PortalProps, type PortalLegacyContext } from "./portal/portal";
export { ProgressBar, type ProgressBarProps } from "./progress-bar/progressBar";
export { type ResizeEntry, ResizeSensor, type ResizeSensorProps } from "./resize-sensor/resizeSensor";
export { type HandleHtmlProps, HandleInteractionKind, type HandleProps, HandleType } from "./slider/handleProps";
export { MultiSlider, type MultiSliderProps, type SliderBaseProps } from "./slider/multiSlider";
export { type NumberRange, RangeSlider, type RangeSliderProps } from "./slider/rangeSlider";
export { Section, type SectionElevation, type SectionProps } from "./section/section";
export { SectionCard, type SectionCardProps } from "./section/sectionCard";
export {
    SegmentedControl,
    type SegmentedControlIntent,
    type SegmentedControlProps,
} from "./segmented-control/segmentedControl";
export { Slider, type SliderProps } from "./slider/slider";
export { Spinner, type SpinnerProps, SpinnerSize } from "./spinner/spinner";
export type { ControlCardProps } from "./control-card/controlCard";
export { CheckboxCard, type CheckboxCardProps } from "./control-card/checkboxCard";
export { RadioCard, type RadioCardProps } from "./control-card/radioCard";
export { SwitchCard, type SwitchCardProps } from "./control-card/switchCard";
export { Tab, type TabId, type TabProps } from "./tabs/tab";
// eslint-disable-next-line deprecation/deprecation
export { Tabs, type TabsProps, TabsExpander, Expander } from "./tabs/tabs";
export { CompoundTag, type CompoundTagProps } from "./tag/compoundTag";
export { Tag, type TagProps } from "./tag/tag";
export { TagInput, type TagInputProps, type TagInputAddMethod } from "./tag-input/tagInput";
export { OverlayToaster, type OverlayToasterCreateOptions } from "./toast/overlayToaster";
export type { OverlayToasterProps, ToasterPosition } from "./toast/overlayToasterProps";
// eslint-disable-next-line deprecation/deprecation
export { Toast } from "./toast/toast";
export { Toast2 } from "./toast/toast2";
export type { ToastProps } from "./toast/toastProps";
export { Toaster, type ToastOptions } from "./toast/toaster";
export { type TooltipProps, Tooltip } from "./tooltip/tooltip";
export { Tree, type TreeProps } from "./tree/tree";
export type { TreeNodeInfo, TreeEventHandler } from "./tree/treeTypes";
export { TreeNode, type TreeNodeProps } from "./tree/treeNode";

================================================================================

File: src\components\_index.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "alert/alert";
@import "breadcrumbs/breadcrumbs";
@import "button/button";
@import "button/button-group";
@import "callout/callout";
@import "card/card";
@import "card-list/card-list";
@import "collapse/collapse";
@import "context-menu/context-menu";
@import "control-card/control-card";
@import "divider/divider";
@import "dialog/dialog";
@import "dialog/dialog-body";
@import "dialog/dialog-footer";
@import "dialog/multistep-dialog";
@import "drawer/drawer";
@import "editable-text/editable-text";
@import "entity-title/entity-title";
@import "forms/index";
@import "html-select/html-select";
@import "html-table/html-table";
@import "hotkeys/hotkeys";
@import "icon/icon";
@import "menu/menu";
@import "navbar/navbar";
@import "non-ideal-state/non-ideal-state";
@import "overflow-list/overflow-list";
@import "overlay/overlay";
@import "panel-stack/panel-stack";
@import "panel-stack2/panel-stack2";
@import "popover/popover";
@import "portal/portal";
@import "progress-bar/progress-bar";
@import "section/section";
@import "segmented-control/segmented-control";
@import "skeleton/skeleton";
@import "slider/slider";
@import "spinner/spinner";
@import "tabs/tabs";
@import "tag/tag";
@import "tag/compound-tag";
@import "tag-input/tag-input";
@import "tag-input/resizable-input";
@import "toast/toast";
@import "tooltip/tooltip";
@import "tree/tree";

================================================================================

File: src\components\alert\alert.md
--------------------------------------------------------------------------------
@# Alert

__Alerts__ notify users of important information and force them to acknowledge the alert content before continuing.

Although similar to [__Dialog__](#core/components/dialog), an alert is more restrictive and should only be used for
important information. By default, the user can only exit the alert by clicking one of the confirmation buttons;
clicking the overlay or pressing the `esc` key will not close the alert. These interactions can be enabled via props.

@reactExample AlertExample

@## Props interface

__Alert__ only supports controlled usage through the `isOpen` prop. Use the `onConfirm` and `onCancel` props to respond
to those interactions separately, or use `onClose` to handle both at the same time.

@interface AlertProps

================================================================================

File: src\components\alert\alert.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import {
    AbstractPureComponent,
    Classes,
    DISPLAYNAME_PREFIX,
    type Intent,
    type MaybeElement,
    type Props,
} from "../../common";
import {
    ALERT_WARN_CANCEL_ESCAPE_KEY,
    ALERT_WARN_CANCEL_OUTSIDE_CLICK,
    ALERT_WARN_CANCEL_PROPS,
} from "../../common/errors";
import { Button } from "../button/buttons";
import { Dialog } from "../dialog/dialog";
import { Icon, type IconName } from "../icon/icon";
import type { OverlayLifecycleProps } from "../overlay/overlayProps";

export interface AlertProps extends OverlayLifecycleProps, Props {
    /**
     * Whether pressing <kbd>escape</kbd> when focused on the Alert should cancel the alert.
     * If this prop is enabled, then either `onCancel` or `onClose` must also be defined.
     *
     * @default false
     */
    canEscapeKeyCancel?: boolean;

    /**
     * Whether clicking outside the Alert should cancel the alert.
     * If this prop is enabled, then either `onCancel` or `onClose` must also be defined.
     *
     * @default false
     */
    canOutsideClickCancel?: boolean;

    /**
     * The text for the cancel button.
     * If this prop is defined, then either `onCancel` or `onClose` must also be defined.
     */
    cancelButtonText?: string;

    /** Dialog contents. */
    children?: React.ReactNode;

    /**
     * The text for the confirm (right-most) button.
     * This button will always appear, and uses the value of the `intent` prop below.
     *
     * @default "OK"
     */
    confirmButtonText?: string;

    /** Name of a Blueprint UI icon (or an icon element) to display on the left side. */
    icon?: IconName | MaybeElement;

    /**
     * The intent to be applied to the confirm (right-most) button and the icon (if provided).
     */
    intent?: Intent;

    /**
     * Toggles the visibility of the alert.
     * This prop is required because the component is controlled.
     */
    isOpen: boolean;

    /**
     * If set to `true`, the confirm button will be set to its loading state. The cancel button, if
     * visible, will be disabled.
     *
     * @default false
     */
    loading?: boolean;

    /**
     * CSS styles to apply to the alert.
     */
    style?: React.CSSProperties;

    /**
     * Indicates how long (in milliseconds) the overlay's enter/leave transition takes.
     * This is used by React `CSSTransition` to know when a transition completes and must match
     * the duration of the animation in CSS. Only set this prop if you override Blueprint's default
     * transitions with new transitions of a different length.
     *
     * @default 300
     */
    transitionDuration?: number;

    /**
     * The container element into which the overlay renders its contents, when `usePortal` is `true`.
     * This prop is ignored if `usePortal` is `false`.
     *
     * @default document.body
     */
    portalContainer?: HTMLElement;

    /**
     * Handler invoked when the alert is canceled. Alerts can be **canceled** in the following ways:
     * - clicking the cancel button (if `cancelButtonText` is defined)
     * - pressing the escape key (if `canEscapeKeyCancel` is enabled)
     * - clicking on the overlay backdrop (if `canOutsideClickCancel` is enabled)
     *
     * If any of the `cancel` props are defined, then either `onCancel` or `onClose` must be defined.
     */
    onCancel?(evt?: React.SyntheticEvent<HTMLElement>): void;

    /**
     * Handler invoked when the confirm button is clicked. Alerts can be **confirmed** in the following ways:
     * - clicking the confirm button
     * - focusing on the confirm button and pressing `enter` or `space`
     */
    onConfirm?(evt?: React.SyntheticEvent<HTMLElement>): void;

    /**
     * Handler invoked when the Alert is confirmed or canceled; see `onConfirm` and `onCancel` for more details.
     * First argument is `true` if confirmed, `false` otherwise.
     * This is an alternative to defining separate `onConfirm` and `onCancel` handlers.
     */
    onClose?(confirmed: boolean, evt?: React.SyntheticEvent<HTMLElement>): void;
}

/**
 * Alert component.
 *
 * @see https://blueprintjs.com/docs/#core/components/alert
 */
export class Alert extends AbstractPureComponent<AlertProps> {
    public static defaultProps: AlertProps = {
        canEscapeKeyCancel: false,
        canOutsideClickCancel: false,
        confirmButtonText: "OK",
        isOpen: false,
        loading: false,
    };

    public static displayName = `${DISPLAYNAME_PREFIX}.Alert`;

    public render() {
        const {
            canEscapeKeyCancel,
            canOutsideClickCancel,
            children,
            className,
            icon,
            intent,
            loading,
            cancelButtonText,
            confirmButtonText,
            onClose,
            ...overlayProps
        } = this.props;
        return (
            <Dialog
                {...overlayProps}
                role="alertdialog"
                className={classNames(Classes.ALERT, className)}
                canEscapeKeyClose={canEscapeKeyCancel}
                canOutsideClickClose={canOutsideClickCancel}
                onClose={this.handleCancel}
            >
                <div className={Classes.ALERT_BODY}>
                    <Icon icon={icon} size={40} intent={intent} />
                    <div className={Classes.ALERT_CONTENTS}>{children}</div>
                </div>
                <div className={Classes.ALERT_FOOTER}>
                    <Button loading={loading} intent={intent} text={confirmButtonText} onClick={this.handleConfirm} />
                    {cancelButtonText && (
                        <Button text={cancelButtonText} disabled={loading} onClick={this.handleCancel} />
                    )}
                </div>
            </Dialog>
        );
    }

    protected validateProps(props: AlertProps) {
        if (props.onClose == null && (props.cancelButtonText == null) !== (props.onCancel == null)) {
            console.warn(ALERT_WARN_CANCEL_PROPS);
        }

        const hasCancelHandler = props.onCancel != null || props.onClose != null;
        if (props.canEscapeKeyCancel && !hasCancelHandler) {
            console.warn(ALERT_WARN_CANCEL_ESCAPE_KEY);
        }
        if (props.canOutsideClickCancel && !hasCancelHandler) {
            console.warn(ALERT_WARN_CANCEL_OUTSIDE_CLICK);
        }
    }

    private handleCancel = (evt?: React.SyntheticEvent<HTMLElement>) => this.internalHandleCallbacks(false, evt);

    private handleConfirm = (evt: React.SyntheticEvent<HTMLElement>) => this.internalHandleCallbacks(true, evt);

    private internalHandleCallbacks(confirmed: boolean, evt?: React.SyntheticEvent<HTMLElement>) {
        const { onCancel, onClose, onConfirm } = this.props;
        (confirmed ? onConfirm : onCancel)?.(evt);
        onClose?.(confirmed, evt);
    }
}

================================================================================

File: src\components\alert\_alert.scss
--------------------------------------------------------------------------------
// Copyright 2016 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";

.#{$ns}-alert {
  max-width: $pt-grid-size * 40;
  padding: $pt-grid-size * 2;
}

.#{$ns}-alert-body {
  display: flex;

  .#{$ns}-icon {
    font-size: $pt-icon-size-large * 2;
    margin-right: $pt-grid-size * 2;
    margin-top: 0;
  }
}

.#{$ns}-alert-contents {
  word-break: break-word;
}

.#{$ns}-alert-footer {
  display: flex;
  flex-direction: row-reverse;
  margin-top: $pt-grid-size;

  .#{$ns}-button {
    margin-left: $pt-grid-size;
  }
}

================================================================================

File: src\components\breadcrumbs\breadcrumb.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { type ActionProps, Classes, type LinkProps } from "../../common";
import { Icon } from "../icon/icon";

export interface BreadcrumbProps extends ActionProps<HTMLAnchorElement>, LinkProps {
    children?: React.ReactNode;

    /** Whether this breadcrumb is the current breadcrumb. */
    current?: boolean;

    /**
     * Pass through value to icon's title attribute. Should be used for breadcrumbs without
     * text or children defined.
     */
    iconTitle?: string;
}

/**
 * Breadcrumb component.
 *
 * @see https://blueprintjs.com/docs/#core/components/breadcrumbs
 */
export const Breadcrumb: React.FC<BreadcrumbProps> = props => {
    const classes = classNames(
        Classes.BREADCRUMB,
        {
            [Classes.BREADCRUMB_CURRENT]: props.current,
            [Classes.DISABLED]: props.disabled,
        },
        props.className,
    );

    const icon = props.icon != null ? <Icon title={props.iconTitle} icon={props.icon} /> : undefined;

    if (props.href == null && props.onClick == null) {
        return (
            <span className={classes}>
                {icon}
                {props.text}
                {props.children}
            </span>
        );
    }
    return (
        <a
            className={classes}
            href={props.href}
            onClick={props.disabled ? undefined : props.onClick}
            onFocus={props.disabled ? undefined : props.onFocus}
            tabIndex={props.disabled ? undefined : 0}
            target={props.target}
        >
            {icon}
            {props.text}
            {props.children}
        </a>
    );
};

================================================================================

File: src\components\breadcrumbs\breadcrumbs.md
--------------------------------------------------------------------------------
@# Breadcrumbs

__Breadcrumbs__ identify the path to the current resource in an application.

@reactExample BreadcrumbsExample

@## Usage

The __Breadcrumbs__ component requires an `items` array of [breadcrumb props](#core/components/breadcrumbs.breadcrumb)
and renders them in an [__OverflowList__](#core/components/overflow-list) to automatically collapse breadcrumbs that
do not fit in the available space.

```tsx
import { Breadcrumbs, Breadcrumb, BreadcrumbProps, Icon } from "@blueprintjs/core";
import * as React from "react";

const BREADCRUMBS: BreadcrumbProps[] = [
    { href: "/users", icon: "folder-close", text: "Users" },
    { href: "/users/janet", icon: "folder-close", text: "Janet" },
    { icon: "document", text: "image.jpg" },
];

export class BreadcrumbsExample extends React.PureComponent {
    public render() {
        return (
            <Breadcrumbs
                currentBreadcrumbRenderer={this.renderCurrentBreadcrumb}
                items={BREADCRUMBS}
            />
        );
    }

    private renderCurrentBreadcrumb = ({ text, ...restProps }: BreadcrumbProps) => {
        // customize rendering of last breadcrumb
        return <Breadcrumb {...restProps}>{text} <Icon icon="star" /></Breadcrumb>;
    };
}
```

@## Props interface

@interface BreadcrumbsProps

@### Breadcrumb

The __Breadcrumb__ component renders an `a.@ns-breadcrumb` if given an `href` or `onClick` and a `span.@ns-breadcrumb`
otherwise. Typically you will supply an array of `BreadcrumbProps` to the `<Breadcrumbs items>` prop and only need to
render this component directly when defining a custom `breadcrumbRenderer`.

@interface BreadcrumbProps

================================================================================

File: src\components\breadcrumbs\breadcrumbs.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2022 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Boundary, Classes, type Props, removeNonHTMLProps } from "../../common";
import { Menu } from "../menu/menu";
import { MenuItem } from "../menu/menuItem";
import { OverflowList, type OverflowListProps } from "../overflow-list/overflowList";
import { Popover, type PopoverProps } from "../popover/popover";

import { Breadcrumb, type BreadcrumbProps } from "./breadcrumb";

export interface BreadcrumbsProps extends Props {
    /**
     * Callback invoked to render visible breadcrumbs. Best practice is to
     * render a `<Breadcrumb>` element. If `currentBreadcrumbRenderer` is also
     * supplied, that callback will be used for the current breadcrumb instead.
     *
     * @default Breadcrumb
     */
    breadcrumbRenderer?: (props: BreadcrumbProps) => React.JSX.Element;

    /**
     * Which direction the breadcrumbs should collapse from: start or end.
     *
     * @default Boundary.START
     */
    collapseFrom?: Boundary;

    /**
     * Callback invoked to render the current breadcrumb, which is the last
     * element in the `items` array.
     *
     * If this prop is omitted, `breadcrumbRenderer` will be invoked for the
     * current breadcrumb instead.
     */
    currentBreadcrumbRenderer?: (props: BreadcrumbProps) => React.JSX.Element;

    /**
     * All breadcrumbs to display. Breadcrumbs that do not fit in the container
     * will be rendered in an overflow menu instead.
     */
    items: readonly BreadcrumbProps[];

    /**
     * The minimum number of visible breadcrumbs that should never collapse into
     * the overflow menu, regardless of DOM dimensions.
     *
     * @default 0
     */
    minVisibleItems?: number;

    /**
     * Props to spread to `OverflowList`. Note that `items`,
     * `overflowRenderer`, and `visibleItemRenderer` cannot be changed.
     */
    overflowListProps?: Partial<
        Omit<OverflowListProps<BreadcrumbProps>, "items" | "overflowRenderer" | "visibleItemRenderer">
    >;

    /**
     * Props to spread to the popover showing the overflow menu.
     */
    popoverProps?: Partial<
        Omit<PopoverProps, "content" | "defaultIsOpen" | "disabled" | "fill" | "renderTarget" | "targetTagName">
    >;
}

/**
 * Breadcrumbs component.
 *
 * @see https://blueprintjs.com/docs/#core/components/breadcrumbs
 */
export class Breadcrumbs extends AbstractPureComponent<BreadcrumbsProps> {
    public static defaultProps: Partial<BreadcrumbsProps> = {
        collapseFrom: Boundary.START,
    };

    public render() {
        const { className, collapseFrom, items, minVisibleItems, overflowListProps = {} } = this.props;
        return (
            <OverflowList
                collapseFrom={collapseFrom}
                minVisibleItems={minVisibleItems}
                tagName="ul"
                {...overflowListProps}
                className={classNames(Classes.BREADCRUMBS, overflowListProps.className, className)}
                items={items}
                overflowRenderer={this.renderOverflow}
                visibleItemRenderer={this.renderBreadcrumbWrapper}
            />
        );
    }

    private renderOverflow = (items: readonly BreadcrumbProps[]) => {
        const { collapseFrom, popoverProps } = this.props;

        let orderedItems = items;
        if (collapseFrom === Boundary.START) {
            // If we're collapsing from the start, the menu should be read from the bottom to the
            // top, continuing with the breadcrumbs to the right. Since this means the first
            // breadcrumb in the props must be the last in the menu, we need to reverse the overlow
            // order.
            orderedItems = items.slice().reverse();
        }

        return (
            <li>
                <Popover
                    placement={collapseFrom === Boundary.END ? "bottom-end" : "bottom-start"}
                    disabled={orderedItems.length === 0}
                    content={<Menu>{orderedItems.map(this.renderOverflowBreadcrumb)}</Menu>}
                    {...popoverProps}
                >
                    <span className={Classes.BREADCRUMBS_COLLAPSED} />
                </Popover>
            </li>
        );
    };

    private renderOverflowBreadcrumb = (props: BreadcrumbProps, index: number) => {
        const isClickable = props.href != null || props.onClick != null;
        const htmlProps = removeNonHTMLProps(props);
        return <MenuItem disabled={!isClickable} {...htmlProps} text={props.text} key={index} />;
    };

    private renderBreadcrumbWrapper = (props: BreadcrumbProps, index: number) => {
        const isCurrent = this.props.items[this.props.items.length - 1] === props;
        return <li key={index}>{this.renderBreadcrumb(props, isCurrent)}</li>;
    };

    private renderBreadcrumb(props: BreadcrumbProps, isCurrent: boolean) {
        if (isCurrent && this.props.currentBreadcrumbRenderer != null) {
            return this.props.currentBreadcrumbRenderer(props);
        } else if (this.props.breadcrumbRenderer != null) {
            return this.props.breadcrumbRenderer(props);
        } else {
            // allow user to override 'current' prop
            return <Breadcrumb current={isCurrent} {...props} />;
        }
    }
}

================================================================================

File: src\components\breadcrumbs\_breadcrumbs.scss
--------------------------------------------------------------------------------
// Copyright 2016 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "@blueprintjs/icons/lib/scss/variables";
@import "../../common/variables";

/*
Breadcrumbs

Markup:
<ul class="#{$ns}-breadcrumbs">
  <li><a class="#{$ns}-breadcrumbs-collapsed" href="#"></a></li>
  <li><a class="#{$ns}-breadcrumb #{$ns}-disabled">Folder one</a></li>
  <li><a class="#{$ns}-breadcrumb" href="#">Folder two</a></li>
  <li><a class="#{$ns}-breadcrumb" href="#">Folder three</a></li>
  <li><span class="#{$ns}-breadcrumb #{$ns}-breadcrumb-current">File</span></li>
</ul>

Styleguide breadcrumbs
*/

.#{$ns}-breadcrumbs {
  align-items: center;
  cursor: default;
  display: flex;
  flex-wrap: wrap;
  height: $pt-input-height;
  list-style: none;
  // unstyled inline list reset
  margin: 0;
  padding: 0;

  // descendant selector because nothing should come between ul and li
  > li {
    align-items: center;
    display: flex;

    &::after {
      background: svg-icon("16px/chevron-right.svg", (path: (fill: $pt-icon-color)));
      content: "";
      display: block;
      height: $pt-icon-size-standard;
      margin: 0 ($pt-grid-size * 0.5);
      width: $pt-icon-size-standard;
    }

    &:last-of-type::after {
      display: none;
    }
  }
}

.#{$ns}-breadcrumb,
.#{$ns}-breadcrumb-current,
.#{$ns}-breadcrumbs-collapsed {
  align-items: center;
  display: inline-flex;
  font-size: $pt-font-size-large;
}

.#{$ns}-breadcrumb,
.#{$ns}-breadcrumbs-collapsed {
  color: $pt-text-color-muted;
}

.#{$ns}-breadcrumb {
  &:hover {
    text-decoration: none;
  }

  &.#{$ns}-disabled {
    color: $pt-text-color-disabled;
    cursor: not-allowed;
  }

  .#{$ns}-icon {
    margin-right: $pt-grid-size * 0.5;
  }
}

.#{$ns}-breadcrumb-current {
  color: inherit;
  font-weight: 600;

  .#{$ns}-input {
    font-size: inherit;
    font-weight: inherit;
    vertical-align: baseline;
  }
}

.#{$ns}-breadcrumbs-collapsed {
  background: rgba($gray3, 0.15);
  border: none;
  border-radius: $pt-border-radius;
  cursor: pointer;
  margin-right: 2px;
  padding: 1px ($pt-grid-size * 0.5);
  vertical-align: text-bottom;

  &::before {
    background: svg-icon("16px/more.svg", (circle: (fill: $pt-icon-color))) center no-repeat;
    content: "";
    display: block;
    height: $pt-icon-size-standard;
    width: $pt-icon-size-standard;
  }

  &:hover {
    background: rgba($gray3, 0.3);
    color: $pt-text-color;
    text-decoration: none;
  }
}

.#{$ns}-dark {
  .#{$ns}-breadcrumb,
  .#{$ns}-breadcrumbs-collapsed {
    color: $pt-dark-text-color-muted;
  }

  .#{$ns}-breadcrumbs > li::after {
    background: svg-icon("16px/chevron-right.svg", (path: (fill: $pt-dark-icon-color)));
    color: $pt-dark-icon-color;
  }

  .#{$ns}-breadcrumb.#{$ns}-disabled {
    color: $pt-dark-text-color-disabled;
  }

  .#{$ns}-breadcrumb-current {
    color: $pt-dark-text-color;
  }

  .#{$ns}-breadcrumbs-collapsed {
    background: rgba($gray3, 0.2);

    &::before {
      background: svg-icon("16px/more.svg", (circle: (fill: $pt-dark-icon-color))) center no-repeat;
    }

    &:hover {
      background: rgba($gray3, 0.3);
      color: $pt-dark-text-color;
    }
  }
}

================================================================================

File: src\components\button\button-group.md
--------------------------------------------------------------------------------
@# Button group

__ButtonGroup__ arranges multiple buttons in a horizontal or vertical group.

@reactExample ButtonGroupExample

@## Usage

Most of __ButtonGroup__'s props are also supported by __Button__ directly; setting these props on __ButtonGroup__ will
apply the same value to all buttons in the group. Note that most modifiers, once enabled on the group, cannot be
overridden on child buttons (due to the cascading nature of CSS).

The component also supports all HTML `<div>` props.

```tsx
<ButtonGroup minimal={true} onMouseEnter={...}>
    <Button icon="database">Queries</Button>
    <Button icon="function">Functions</Button>
    <AnchorButton rightIcon="caret-down">Options</AnchorButton>
</ButtonGroup>
```

@## Props interface

@interface ButtonGroupProps

@## Usage with popovers

__Button__ elements inside a __ButtonGroup__ can trivially be wrapped with a [__Popover__](#core/components/popover) to
create complex toolbars.

@reactExample ButtonGroupPopoverExample

@## Flex layout

__ButtonGroup__ renders a CSS inline flex row (or column if vertical) and provides some modifer props for common
flexbox patterns:

- Enable the `fill` prop on a button group to make all buttons expand equally to
  fill the available space.
    - Buttons will expand horizontally by default, or vertically if the `vertical` prop is enabled.
    - Add the class `Classes.FIXED` to individual buttons to revert them to their initial sizes.

- Alternatively, enable the `fill` prop on specific buttons (instead of on the
  group) to expand them equally to fill the available space while other
  buttons retain their original sizes.

You can adjust the specific size of a button with the `flex-basis` or `width` CSS properties.

@## Vertical layout

Buttons in a vertical group all have the same width as the widest button in the group.

Use the `alignText` prop to control icon and text alignment in the buttons. Set this prop on __ButtonGroup__ to affect
all buttons in the group, or set the prop on individual buttons directly.

@## CSS API

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use [`<ButtonGroup>`](#core/components/button-group)
</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

</div>

Arrange multiple buttons in a group by wrapping them in `.@ns-button-group`.
You can apply sizing directly on the button group container element.

You should implement interactive segmented controls as button groups.

@css button-group

================================================================================

File: src\components\button\buttonGroup.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { type Alignment, Classes } from "../../common";
import { DISPLAYNAME_PREFIX, type HTMLDivProps, type Props } from "../../common/props";

export interface ButtonGroupProps extends Props, HTMLDivProps, React.RefAttributes<HTMLDivElement> {
    /**
     * Text alignment within button. By default, icons and text will be centered
     * within the button. Passing `"left"` or `"right"` will align the button
     * text to that side and push `icon` and `rightIcon` to either edge. Passing
     * `"center"` will center the text and icons together.
     */
    alignText?: Alignment;

    /** Buttons in this group. */
    children: React.ReactNode;

    /**
     * Whether the button group should take up the full width of its container.
     *
     * @default false
     */
    fill?: boolean;

    /**
     * Whether the child buttons should appear with minimal styling.
     *
     * @default false
     */
    minimal?: boolean;

    /**
     * Whether the child buttons should use outlined styles.
     *
     * @default false
     */
    outlined?: boolean;

    /**
     * Whether the child buttons should appear with large styling.
     *
     * @default false
     */
    large?: boolean;

    /**
     * Whether the button group should appear with vertical styling.
     *
     * @default false
     */
    vertical?: boolean;
}

// this component is simple enough that tests would be purely tautological.
/* istanbul ignore next */
/**
 * Button group component.
 *
 * @see https://blueprintjs.com/docs/#core/components/button-group
 */
export const ButtonGroup: React.FC<ButtonGroupProps> = React.forwardRef<HTMLDivElement, ButtonGroupProps>(
    (props, ref) => {
        const { alignText, className, fill, minimal, outlined, large, vertical, ...htmlProps } = props;
        const buttonGroupClasses = classNames(
            Classes.BUTTON_GROUP,
            {
                [Classes.FILL]: fill,
                [Classes.LARGE]: large,
                [Classes.MINIMAL]: minimal,
                [Classes.OUTLINED]: outlined,
                [Classes.VERTICAL]: vertical,
            },
            Classes.alignmentClass(alignText),
            className,
        );
        return (
            <div {...htmlProps} ref={ref} className={buttonGroupClasses}>
                {props.children}
            </div>
        );
    },
);
ButtonGroup.displayName = `${DISPLAYNAME_PREFIX}.ButtonGroup`;

================================================================================

File: src\components\button\buttonProps.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type * as React from "react";

import type { ActionProps, Alignment, MaybeElement } from "../../common";
import type { IconName } from "../icon/icon";

export interface ButtonSharedProps extends ActionProps<HTMLElement> {
    /**
     * If set to `true`, the button will display in an active state.
     * This is equivalent to setting `className={Classes.ACTIVE}`.
     *
     * @default false
     */
    active?: boolean;

    /**
     * Text alignment within button. By default, icons and text will be centered
     * within the button. Passing `"left"` or `"right"` will align the button
     * text to that side and push `icon` and `rightIcon` to either edge. Passing
     * `"center"` will center the text and icons together.
     *
     * @default Alignment.CENTER
     */
    alignText?: Alignment;

    /** Button contents. */
    children?: React.ReactNode;

    /**
     * If set to `true`, the button text element will hide overflow text that does not fit into a
     * single line and show a trailing ellipsis, similar to the `Text` component.
     *
     * @default false
     */
    ellipsizeText?: boolean;

    /** Whether this button should expand to fill its container. */
    fill?: boolean;

    /** Whether this button should use large styles. */
    large?: boolean;

    /**
     * If set to `true`, the button will display a centered loading spinner instead of its contents
     * and the button will be disabled (_even if_ `disabled={false}`). The width of the button is
     * not affected by the value of this prop.
     *
     * @default false
     */
    loading?: boolean;

    /** Whether this button should use minimal styles. */
    minimal?: boolean;

    /** Whether this button should use outlined styles. */
    outlined?: boolean;

    /** Name of a Blueprint UI icon (or an icon element) to render after the text. */
    rightIcon?: IconName | MaybeElement;

    /** Whether this button should use small styles. */
    small?: boolean;

    /** Class name(s) to apply to the text span element. */
    textClassName?: string;

    /**
     * HTML `type` attribute of button. Accepted values are `"button"`, `"submit"`, and `"reset"`.
     * Note that this prop has no effect on `AnchorButton`; it only affects `Button`.
     *
     * @default "button"
     */
    type?: "submit" | "reset" | "button";
}

/**
 * Props interface assignable to both the Button and AnchorButton components.
 *
 * It is useful for the props for the two components to be assignable to each other because the components
 * are so similar and distinguishing between them in their event handlers is usually unnecessary.
 */
export type ButtonSharedPropsAndAttributes = ButtonSharedProps & React.HTMLAttributes<HTMLElement>;

export type ButtonProps = ButtonSharedProps &
    React.ButtonHTMLAttributes<HTMLButtonElement> &
    React.RefAttributes<HTMLButtonElement>;

export type AnchorButtonProps = ButtonSharedProps &
    React.AnchorHTMLAttributes<HTMLAnchorElement> &
    React.RefAttributes<HTMLAnchorElement>;

================================================================================

File: src\components\button\buttons.md
--------------------------------------------------------------------------------
@# Buttons

Buttons trigger actions when clicked. You may render a button as either a `<button>` or `<a>` HTML element
using the `<Button>` and `<AnchorButton>` components, respectively.

@reactExample ButtonsExample

@## AnchorButton vs Button

The two button components generate different HTML tags. They each look the same, but they have different semantic
behaviors according to the HTML spec.

```tsx
<AnchorButton text="Click" />
```

```html
<a class="@ns-button" role="button" tabindex={0}>Click</a>
```

---

```tsx
<Button icon="refresh" />
```

```html
<button class="@ns-button" type="button"><svg class="@ns-icon">...</svg></button>
```

<div class="@ns-callout @ns-intent-danger @ns-icon-error @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Disabled __Button__ elements prevent all interaction
</h5>

Use __AnchorButton__ if you need mouse interaction events (such as hovering) on a disabled button.

__Button__ uses the native `disabled` attribute on the `<button>` tag so the browser disables all interactions.
__AnchorButton__ uses the class `.@ns-disabled` because `<a>` tags do not support the `disabled` attribute. As a result,
the __AnchorButton__ component will prevent *only* the `onClick` handler when disabled but permit other events.

</div>

@## Adding icons

__Button__ and __AnchorButton__ support `icon` and `rightIcon` props to place an icon on either end of their text/children.
These icons can either be specified as string identifiers (e.g. `"arrow-right"`), dynamically-loaded
[`<Icon>` components](https://blueprintjs.com/docs/#core/components/icon),
[static icon components](#core/components/icon.static-components) (e.g. `<ArrowRight />`), or any custom JSX element.

@reactExample ButtonsIconsExample

@## Props interface

The two button components each support arbitrary HTML attributes for their underlying DOM element
(`<button>` and `<a>` respectively). These attributes may override the components' default values, such as
`role` on `<AnchorButton>`.

@interface ButtonSharedProps

@## CSS API

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use `<Button>` or `<AnchorButton>`

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

</div>

Use the `@ns-button` class to access button styles. You should implement buttons using the
`<button>` or `<a>` tags rather than `<div>` for accessibility.

* Make sure to include `type="button"` on `<button>` tags (use `type="submit"` to submit a
  `<form>`) and `role="button"` on `<a>` tags for accessibility.
* Add the attribute `tabindex="0"` to make `<a>` tags focusable. `<button>` elements are
  focusable by default.
* For buttons implemented with `<a>` tags, add `tabindex="-1"` to disabled buttons to prevent the
  user from focusing them by pressing <kbd>tab</kbd> on the keyboard. (This does not happen in the example below.)
* Note that `<a>` tags do not respond to the `:disabled` attribute; use `.@ns-disabled` instead.

@css button

================================================================================

File: src\components\button\buttons.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Classes, Utils } from "../../common";
import { DISPLAYNAME_PREFIX, removeNonHTMLProps } from "../../common/props";
import { mergeRefs } from "../../common/refs";
import { Icon } from "../icon/icon";
import { Spinner, SpinnerSize } from "../spinner/spinner";
import { Text } from "../text/text";

import type { AnchorButtonProps, ButtonProps } from "./buttonProps";

/**
 * Button component.
 *
 * @see https://blueprintjs.com/docs/#core/components/button
 */
export const Button: React.FC<ButtonProps> = React.forwardRef<HTMLButtonElement, ButtonProps>((props, ref) => {
    const commonAttributes = useSharedButtonAttributes(props, ref);

    return (
        <button type="button" {...removeNonHTMLProps(props)} {...commonAttributes}>
            {renderButtonContents(props)}
        </button>
    );
});
Button.displayName = `${DISPLAYNAME_PREFIX}.Button`;

/**
 * AnchorButton component.
 *
 * @see https://blueprintjs.com/docs/#core/components/button
 */
export const AnchorButton: React.FC<AnchorButtonProps> = React.forwardRef<HTMLAnchorElement, AnchorButtonProps>(
    (props, ref) => {
        const { href, tabIndex = 0 } = props;
        const commonProps = useSharedButtonAttributes(props, ref);

        return (
            <a
                role="button"
                {...removeNonHTMLProps(props)}
                {...commonProps}
                aria-disabled={commonProps.disabled}
                href={commonProps.disabled ? undefined : href}
                tabIndex={commonProps.disabled ? -1 : tabIndex}
            >
                {renderButtonContents(props)}
            </a>
        );
    },
);
AnchorButton.displayName = `${DISPLAYNAME_PREFIX}.AnchorButton`;

/**
 * Most of the button logic lives in this shared hook.
 */
function useSharedButtonAttributes<E extends HTMLAnchorElement | HTMLButtonElement>(
    props: E extends HTMLAnchorElement ? AnchorButtonProps : ButtonProps,
    ref: React.Ref<E>,
) {
    const {
        active = false,
        alignText,
        fill,
        large,
        loading = false,
        minimal,
        onBlur,
        onKeyDown,
        onKeyUp,
        outlined,
        small,
        tabIndex,
    } = props;
    const disabled = props.disabled || loading;

    // the current key being pressed
    const [currentKeyPressed, setCurrentKeyPressed] = React.useState<string | undefined>();
    // whether the button is in "active" state
    const [isActive, setIsActive] = React.useState(false);
    // our local ref for the button element, merged with the consumer's own ref (if supplied) in this hook's return value
    const buttonRef = React.useRef<E | null>(null);

    const handleBlur = React.useCallback(
        (e: React.FocusEvent<any>) => {
            if (isActive) {
                setIsActive(false);
            }
            onBlur?.(e);
        },
        [isActive, onBlur],
    );
    const handleKeyDown = React.useCallback(
        (e: React.KeyboardEvent<any>) => {
            if (Utils.isKeyboardClick(e)) {
                e.preventDefault();
                if (e.key !== currentKeyPressed) {
                    setIsActive(true);
                }
            }
            setCurrentKeyPressed(e.key);
            onKeyDown?.(e);
        },
        [currentKeyPressed, onKeyDown],
    );
    const handleKeyUp = React.useCallback(
        (e: React.KeyboardEvent<any>) => {
            if (Utils.isKeyboardClick(e)) {
                setIsActive(false);
                buttonRef.current?.click();
            }
            setCurrentKeyPressed(undefined);
            onKeyUp?.(e);
        },
        [onKeyUp],
    );

    const className = classNames(
        Classes.BUTTON,
        {
            [Classes.ACTIVE]: !disabled && (active || isActive),
            [Classes.DISABLED]: disabled,
            [Classes.FILL]: fill,
            [Classes.LARGE]: large,
            [Classes.LOADING]: loading,
            [Classes.MINIMAL]: minimal,
            [Classes.OUTLINED]: outlined,
            [Classes.SMALL]: small,
        },
        Classes.alignmentClass(alignText),
        Classes.intentClass(props.intent),
        props.className,
    );

    return {
        className,
        disabled,
        onBlur: handleBlur,
        onClick: disabled ? undefined : props.onClick,
        onFocus: disabled ? undefined : props.onFocus,
        onKeyDown: handleKeyDown,
        onKeyUp: handleKeyUp,
        ref: mergeRefs(buttonRef, ref),
        tabIndex: disabled ? -1 : tabIndex,
    };
}

/**
 * Shared rendering code for button contents.
 */
function renderButtonContents<E extends HTMLAnchorElement | HTMLButtonElement>(
    props: E extends HTMLAnchorElement ? AnchorButtonProps : ButtonProps,
) {
    const { children, ellipsizeText, icon, loading, rightIcon, text, textClassName } = props;
    const hasTextContent = !Utils.isReactNodeEmpty(text) || !Utils.isReactNodeEmpty(children);
    return (
        <>
            {loading && <Spinner key="loading" className={Classes.BUTTON_SPINNER} size={SpinnerSize.SMALL} />}
            <Icon key="leftIcon" icon={icon} />
            {hasTextContent && (
                <Text
                    key="text"
                    className={classNames(Classes.BUTTON_TEXT, textClassName)}
                    ellipsize={ellipsizeText}
                    tagName="span"
                >
                    {text}
                    {children}
                </Text>
                // <span key="text" className={classNames(Classes.BUTTON_TEXT, textClassName)}>
                //     {text}
                //     {children}
                // </span>
            )}
            <Icon key="rightIcon" icon={rightIcon} />
        </>
    );
}

================================================================================

File: src\components\button\_button-group.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "../forms/common";
@import "./common";

/*
Button groups

Markup:
<div class="#{$ns}-button-group {{.modifier}}">
  <button type="button" class="#{$ns}-button #{$ns}-intent-success">Save</button>
  <button type="button" class="#{$ns}-button #{$ns}-intent-success #{$ns}-icon-caret-down"></button>
</div>
<div class="#{$ns}-button-group {{.modifier}}">
  <a class="#{$ns}-button #{$ns}-icon-database" tabindex="0" role="button">Queries</a>
  <a class="#{$ns}-button #{$ns}-icon-function" tabindex="0" role="button">Functions</a>
  <a class="#{$ns}-button" tabindex="0" role="button">
    Options <span class="#{$ns}-icon-standard #{$ns}-icon-caret-down #{$ns}-align-right"></span>
  </a>
</div>
<div class="#{$ns}-button-group {{.modifier}}">
  <a class="#{$ns}-button #{$ns}-icon-chart" tabindex="0" role="button"></a>
  <a class="#{$ns}-button #{$ns}-icon-control" tabindex="0" role="button"></a>
  <a class="#{$ns}-button #{$ns}-icon-graph" tabindex="0" role="button"></a>
  <a class="#{$ns}-button #{$ns}-icon-camera" tabindex="0" role="button"></a>
  <a class="#{$ns}-button #{$ns}-icon-map" tabindex="0" role="button"></a>
  <a class="#{$ns}-button #{$ns}-icon-code" tabindex="0" role="button"></a>
  <a class="#{$ns}-button #{$ns}-icon-th" tabindex="0" role="button"></a>
  <a class="#{$ns}-button #{$ns}-icon-time" tabindex="0" role="button"></a>
  <a class="#{$ns}-button #{$ns}-icon-compressed" tabindex="0" role="button"></a>
</div>

.#{$ns}-fill - Buttons expand equally to fill container
.#{$ns}-large - Use large buttons
.#{$ns}-minimal - Use minimal buttons
.#{$ns}-outlined - Use outlined buttons
.#{$ns}-vertical - Vertical layout

Styleguide button-group
*/

.#{$ns}-button-group {
  display: inline-flex;

  .#{$ns}-button {
    // ensure button can never be smaller than its default size
    flex: 0 0 auto;
    position: relative;
    z-index: index($control-group-stack, "button-default");

    // the ordering of these z-index CSS rules is particular because of CSS
    // selector specificity. specifically, disabled styles should have
    // precedence over hover and active styles to prevent mouse interactions on
    // disabled buttons from reordering elements in the stack.

    &:focus {
      z-index: index($control-group-stack, "button-focus");
    }

    &:hover {
      z-index: index($control-group-stack, "button-hover");
    }

    &:active,
    &.#{$ns}-active {
      z-index: index($control-group-stack, "button-active");
    }

    &:disabled,
    &.#{$ns}-disabled {
      z-index: index($control-group-stack, "button-disabled");
    }

    &[class*="#{$ns}-intent-"] {
      z-index: index($control-group-stack, "intent-button-default");

      &:focus {
        z-index: index($control-group-stack, "intent-button-focus");
      }

      &:hover {
        z-index: index($control-group-stack, "intent-button-hover");
      }

      &:active,
      &.#{$ns}-active {
        z-index: index($control-group-stack, "intent-button-active");
      }

      &:disabled,
      &.#{$ns}-disabled {
        z-index: index($control-group-stack, "intent-button-disabled");
      }
    }
  }

  // support wrapping buttons in a tooltip, which adds a wrapper element
  &:not(.#{$ns}-minimal), &.#{$ns}-outlined {
    > .#{$ns}-popover-wrapper:not(:first-child) .#{$ns}-button,
    > .#{$ns}-button:not(:first-child) {
      border-bottom-left-radius: 0;
      border-top-left-radius: 0;
    }

    > .#{$ns}-popover-wrapper:not(:last-child) .#{$ns}-button,
    > .#{$ns}-button:not(:last-child) {
      border-bottom-right-radius: 0;
      border-top-right-radius: 0;
    }
  }

  &:not(.#{$ns}-minimal):not(.#{$ns}-outlined) {
    > .#{$ns}-popover-wrapper:not(:last-child) .#{$ns}-button,
    > .#{$ns}-button:not(:last-child) {
      margin-right: -$button-border-width;
    }
  }

  &.#{$ns}-minimal, &.#{$ns}-outlined {
    .#{$ns}-button {
      @include pt-button-minimal();
    }

    @media (forced-colors: active) and (prefers-color-scheme: dark) {
      // Because we give even minimal buttons a border in high contrast mode, we need to handle border styles
      // similar to how we handle non-minimal buttons

      &:not(:first-child) {
        border-bottom-left-radius: 0;
        border-left: none;
        border-top-left-radius: 0;
      }

      &:not(:last-child) {
        border-bottom-right-radius: 0;
        border-top-right-radius: 0;
        margin-right: -$button-border-width;
      }
    }
  }

  &.#{$ns}-outlined {
    > .#{$ns}-button {
      @include pt-button-outlined();
    }

    &:not(.#{$ns}-vertical) {
      > .#{$ns}-button:not(:last-child) {
        border-right: none;
      }
    }
  }

  .#{$ns}-popover-wrapper,
  .#{$ns}-popover-target {
    display: flex;
    flex: 1 1 auto;
  }

  /*
  Responsive

  Markup:
  <div class="#{$ns}-button-group #{$ns}-large #{$ns}-fill">
    <a class="#{$ns}-button #{$ns}-intent-primary #{$ns}-fixed" tabindex="0" role="button">Start</a>
    <a class="#{$ns}-button #{$ns}-intent-primary" tabindex="0" role="button">Left</a>
    <a class="#{$ns}-button #{$ns}-intent-primary #{$ns}-active" tabindex="0" role="button">Middle</a>
    <a class="#{$ns}-button #{$ns}-intent-primary" tabindex="0" role="button">Right</a>
    <a class="#{$ns}-button #{$ns}-intent-primary #{$ns}-fixed" tabindex="0" role="button">End</a>
  </div>
  <br />
  <div class="#{$ns}-button-group #{$ns}-fill">
    <button class="#{$ns}-button #{$ns}-icon-arrow-left"></button>
    <button class="#{$ns}-button #{$ns}-fill">Middle</button>
    <button class="#{$ns}-button #{$ns}-icon-arrow-right"></button>
  </div>

  Styleguide button-group}-fill
  */

  &.#{$ns}-fill {
    display: flex;
    width: 100%;
  }

  .#{$ns}-button.#{$ns}-fill,
  &.#{$ns}-fill .#{$ns}-button:not(.#{$ns}-fixed) {
    flex: 1 1 auto;
  }

  /*
  Vertical button groups

  Markup:
  <div class="#{$ns}-button-group #{$ns}-vertical">
    <a class="#{$ns}-button #{$ns}-icon-search-template" role="button" tabindex="0"></a>
    <a class="#{$ns}-button #{$ns}-icon-zoom-in" role="button" tabindex="0"></a>
    <a class="#{$ns}-button #{$ns}-icon-zoom-out" role="button" tabindex="0"></a>
    <a class="#{$ns}-button #{$ns}-icon-zoom-to-fit" role="button" tabindex="0"></a>
  </div>
  <div class="#{$ns}-button-group #{$ns}-vertical">
    <button type="button" class="#{$ns}-button #{$ns}-active">Home</button>
    <button type="button" class="#{$ns}-button">Pages</button>
    <button type="button" class="#{$ns}-button">Blog</button>
    <button type="button" class="#{$ns}-button">Calendar</button>
  </div>
  <div class="#{$ns}-button-group #{$ns}-vertical #{$ns}-align-left #{$ns}-large">
    <button type="button" class="#{$ns}-button #{$ns}-intent-primary #{$ns}-icon-document">Text</button>
    <button type="button" class="#{$ns}-button #{$ns}-intent-primary #{$ns}-icon-media #{$ns}-active">Media</button>
    <button type="button" class="#{$ns}-button #{$ns}-intent-primary #{$ns}-icon-link">Sources</button>
  </div>

  Styleguide button-group-vertical
  */

  &.#{$ns}-vertical {
    align-items: stretch;
    flex-direction: column;
    vertical-align: top;

    &.#{$ns}-fill {
      height: 100%;
      width: unset;
    }

    .#{$ns}-button {
      // we never want that margin-right when vertical
      margin-right: 0 !important; /* stylelint-disable-line declaration-no-important */
      // needed to ensure buttons take up the full width when wrapped in a Popover:
      width: 100%;
    }

    &:not(.#{$ns}-minimal), &.#{$ns}-outlined {
      > .#{$ns}-popover-wrapper:first-child .#{$ns}-button,
      > .#{$ns}-button:first-child {
        border-radius: $pt-border-radius $pt-border-radius 0 0;
      }

      > .#{$ns}-popover-wrapper:last-child .#{$ns}-button,
      > .#{$ns}-button:last-child {
        border-radius: 0 0 $pt-border-radius $pt-border-radius;
      }
    }

    &:not(.#{$ns}-minimal):not(.#{$ns}-outlined) {
      > .#{$ns}-popover-wrapper:not(:last-child) .#{$ns}-button,
      > .#{$ns}-button:not(:last-child) {
        margin-bottom: -$button-border-width;
      }
    }

    &.#{$ns}-outlined {
      > .#{$ns}-button:not(:last-child) {
        border-bottom: none;
      }
    }
  }

  &.#{$ns}-align-left .#{$ns}-button {
    text-align: left;
  }
}

================================================================================

File: src\components\button\_button.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "../../common/variables-extended";
@import "./common";

/*
Button

Markup:
<a role="button" class="#{$ns}-button {{.modifier}}" {{:modifier}} tabindex="0">Anchor</a>
<button type="button" class="#{$ns}-button #{$ns}-icon-add {{.modifier}}" {{:modifier}}>Button</button>

:disabled - Disabled state
.#{$ns}-active - Active appearance
.#{$ns}-disabled - Disabled appearance
.#{$ns}-intent-primary - Primary intent
.#{$ns}-intent-success - Success intent
.#{$ns}-intent-warning - Warning intent
.#{$ns}-intent-danger - Danger intent
.#{$ns}-minimal - More subtle appearance
.#{$ns}-outlined - Subtle yet structured appearance
.#{$ns}-large - Larger size
.#{$ns}-small - Smaller size
.#{$ns}-fill - Fill parent container

Styleguide button
*/
.#{$ns}-button {
  @include pt-button-layout();
  @include pt-button-height($pt-button-height);

  &:empty {
    // override padding from other modifiers (for CSS icon support)
    /* stylelint-disable-next-line declaration-no-important */
    padding: 0 !important;
  }

  &:disabled,
  &.#{$ns}-disabled {
    cursor: not-allowed;
  }

  &.#{$ns}-fill {
    display: flex;
    width: 100%;
  }

  &.#{$ns}-align-right,
  .#{$ns}-align-right & {
    text-align: right;
  }

  &.#{$ns}-align-left,
  .#{$ns}-align-left & {
    text-align: left;
  }

  // default styles
  &:not([class*="#{$ns}-intent-"]) {
    @include pt-button();
  }

  // intents
  @each $intent, $colors in $button-intents {
    &.#{$ns}-intent-#{$intent} {
      @include pt-button-intent($colors...);
    }
  }

  &[class*="#{$ns}-intent-"] .#{$ns}-button-spinner .#{$ns}-spinner-head {
    stroke: $white;
  }

  // size modifiers
  &.#{$ns}-large,
  .#{$ns}-large & {
    @include pt-button-height-large();
  }

  &.#{$ns}-small,
  .#{$ns}-small & {
    @include pt-button-height-small();
  }

  // loading state
  &.#{$ns}-loading {
    position: relative;

    &[class*="#{$ns}-icon-"]::before {
      visibility: hidden;
    }

    .#{$ns}-button-spinner {
      margin: 0;
      // spinner appears centered within button
      position: absolute;
    }

    > :not(.#{$ns}-button-spinner) {
      visibility: hidden;
    }
  }

  // icons
  &[class*="#{$ns}-icon-"] {
    &::before {
      @include pt-icon();
      color: $pt-icon-color;
    }
  }

  #{$icon-classes} {
    color: $pt-icon-color;

    &.#{$ns}-align-right {
      margin-left: $button-icon-spacing;
    }
  }

  // button with SVG icon only (no text or children)
  .#{$ns}-icon:first-child:last-child,
  // if loading, then it contains exactly [spinner, icon]
  .#{$ns}-spinner + .#{$ns}-icon:last-child {
    // center icon horizontally. this works for large buttons too.
    margin: 0 (-($pt-button-height - $pt-icon-size-standard) * 0.5);
  }

  // dark theme
  .#{$ns}-dark & {
    &:not([class*="#{$ns}-intent-"]) {
      @include pt-dark-button();

      &[class*="#{$ns}-icon-"]::before {
        color: $pt-dark-icon-color;
      }

      #{$icon-classes} {
        &:not([class*="#{$ns}-intent-"]) {
          color: $pt-dark-icon-color;
        }
      }
    }

    &[class*="#{$ns}-intent-"] {
      @include pt-dark-button-intent();

      .#{$ns}-button-spinner .#{$ns}-spinner-head {
        stroke: $dark-progress-head-color;
      }
    }
  }

  // disabled and intent button icon should use same color as text
  &:disabled,
  &.#{$ns}-disabled,
  &[class*="#{$ns}-intent-"] {
    &::before,
    #{$icon-classes} {
      /* stylelint-disable-next-line declaration-no-important */
      color: inherit !important;
    }
  }

  // minimal must come last to override all default styles
  &.#{$ns}-minimal {
    @include pt-button-minimal();
  }

  // outline is based on the styles of minimal
  &.#{$ns}-outlined {
    @include pt-button-minimal();
    @include pt-button-outlined();
  }

  // special case override: use dark text for warning intent
  &.#{$ns}-intent-warning {
    background: $orange5;
    color: $pt-text-color;

    &:not(.#{$ns}-disabled).#{$ns}-icon > svg {
      fill: rgba($dark-gray1, 0.7);
    }

    &:not(.#{$ns}-disabled):not(.#{$ns}-minimal):not(.#{$ns}-outlined) {
      &:hover {
        background: $orange4;
        color: $pt-text-color;
      }

      &:active,
      &.#{$ns}-active {
        background: $orange3;
        color: $pt-text-color;

        @media (forced-colors: active) and (prefers-color-scheme: dark) {
          // Windows High Contrast dark theme
          background: $pt-high-contrast-mode-active-background-color;
        }
      }
    }

    &:disabled,
    &.#{$ns}-disabled {
      background: rgba($orange3, 0.5);
      color: rgba($dark-gray1, 0.35);

      .#{$ns}-dark & {
        color: rgba($dark-gray1, 0.6);
      }
    }

    &.#{$ns}-minimal,
    &.#{$ns}-outlined {
      background: none;

      .#{$ns}-dark & {
        &:not(.#{$ns}-disabled).#{$ns}-icon > svg {
          fill: $orange5;
        }
      }
    }
  }
}

a.#{$ns}-button {
  text-align: center;
  text-decoration: none;
  transition: none;

  &,
  &:hover,
  &:active {
    // override global 'a' styles
    color: $pt-text-color;
  }

  &.#{$ns}-disabled {
    color: $button-color-disabled;
  }
}

.#{$ns}-button-text {
  // default: don't grow to fill but allow shrinking as necessary
  flex: 0 1 auto;
}

// when alignment is set, grow to fill and inherit `text-align` set on `.#{$ns}-button`
.#{$ns}-button,
.#{$ns}-button-group {
  &.#{$ns}-align-left,
  &.#{$ns}-align-right {
    .#{$ns}-button-text {
      flex: 1 1 auto;
    }
  }
}

================================================================================

File: src\components\button\_common.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/mixins";
@import "../../common/variables";
@import "../../common/variables-extended";
@import "../progress-bar/common";

$button-border-width: 1px !default;
$button-padding: ($pt-grid-size * 0.5) $pt-grid-size !default;
$button-padding-small: 0 ($pt-grid-size * 0.7) !default;
$button-padding-large: ($pt-grid-size * 0.5) ($pt-grid-size * 1.5) !default;
$button-icon-spacing: ($pt-button-height - $pt-icon-size-standard) * 0.5 !default;
$button-icon-spacing-large: ($pt-button-height-large - $pt-icon-size-large) * 0.5 !default;

/*
CSS `border` property issues:
- An element can only have one border.
- Borders can't stack with shadows.
- Borders modify the size of the element they're applied to.
- Border positioning requires the extra `box-sizing` property.

`box-shadow` doesn't have these issues, we're using it instead of `border`.
*/
$button-box-shadow:
  inset 0 0 0 $button-border-width rgba($black, 0.2),
  0 1px 2px rgba($black, 0.1) !default;
$button-box-shadow-active:
  inset 0 0 0 $button-border-width rgba($black, 0.2),
  0 1px 2px rgba($black, 0.2) !default;

$dark-button-box-shadow:
  inset 0 0 0 $button-border-width rgba($white, 0.1),
  0 1px 2px rgba($black, 0.2) !default;
$dark-button-box-shadow-active:
  inset 0 0 0 $button-border-width rgba($white, 0.1),
  0 1px 2px rgba($black, 0.4) !default;

$button-color-disabled: $pt-text-color-disabled !default;
$button-background-color: $light-gray5 !default;
$button-background-color-hover: $light-gray4 !default;
$button-background-color-active: $light-gray2 !default;
$button-background-color-disabled: rgba($light-gray1, 0.5) !default;
$button-background-color-active-disabled: rgba($light-gray1, 0.7) !default;
$button-intent-color-disabled: rgba($white, 0.6);
$dark-button-color-disabled: $pt-dark-text-color-disabled !default;
$dark-button-background-color: $dark-gray4 !default;
$dark-button-background-color-hover: $dark-gray3 !default;
$dark-button-background-color-active: $dark-gray1 !default;
$dark-button-background-color-disabled: rgba($dark-gray5, 0.5) !default;
$dark-button-background-color-active-disabled: rgba($dark-gray5, 0.7) !default;
$dark-button-intent-color-disabled: rgba($white, 0.3);

$minimal-button-divider-width: 1px !default;
$minimal-button-background-color: none !default;
$minimal-button-background-color-hover: rgba($gray3, 0.15) !default;
$minimal-button-background-color-active: rgba($gray3, 0.3) !default;
$dark-minimal-button-background-color: none !default;
$dark-minimal-button-background-color-hover: rgba($gray3, 0.15) !default;
$dark-minimal-button-background-color-active: rgba($gray3, 0.3) !default;

$button-outlined-width: 1px !default;
$button-outlined-border-intent-opacity: 0.6 !default;
$button-outlined-border-disabled-intent-opacity: 0.2 !default;

// "intent": (default, hover, active colors)
$button-intents: (
  "primary": ($blue3, $blue2, $blue1),
  "success": ($green3, $green2, $green1),
  "warning": ($orange3, $orange2, $orange1),
  "danger": ($red3, $red2, $red1)
) !default;

@mixin pt-button-layout() {
  @include pt-flex-container(row, $button-icon-spacing, $inline: inline);
  align-items: center;

  border: none;
  border-radius: $pt-border-radius;
  cursor: pointer;
  font-size: $pt-font-size;
  justify-content: center;
  padding: $button-padding;
  text-align: left;
  vertical-align: middle;
}

@mixin pt-button-height($height) {
  min-height: $height;
  min-width: $height;
}

@mixin pt-button-height-large() {
  @include pt-button-height($pt-button-height-large);
  @include pt-flex-margin(row, $button-icon-spacing-large);
  font-size: $pt-font-size-large;
  padding: $button-padding-large;
}

@mixin pt-button-height-default() {
  @include pt-button-height($pt-button-height);
  padding: $button-padding;
}

@mixin pt-button-height-small() {
  @include pt-button-height($pt-button-height-small);
  padding: $button-padding-small;
}

// N.B. this mixin cannot be used on pseudo element selectors because it will produce invalid CSS
@mixin pt-button() {
  @include pt-button-default-colors();

  &:hover {
    @include pt-button-hover();
  }

  &:active,
  &.#{$ns}-active {
    @include pt-button-active();
  }

  &:disabled,
  &.#{$ns}-disabled {
    @include pt-button-disabled();

    &.#{$ns}-active,
    &.#{$ns}-active:hover {
      background: $button-background-color-active-disabled;
    }
  }

  @media (forced-colors: active) and (prefers-color-scheme: dark) {
    // Windows High Contrast dark theme
    border: 1px solid $pt-high-contrast-mode-border-color;
  }
}

@mixin pt-button-default-colors() {
  background-color: $button-background-color;
  box-shadow: $button-box-shadow;
  color: $pt-text-color;
}

@mixin pt-button-hover() {
  background-clip: padding-box;
  background-color: $button-background-color-hover;
  box-shadow: $button-box-shadow-active;
}

@mixin pt-button-active() {
  background-color: $button-background-color-active;
  box-shadow: $button-box-shadow-active;

  @media (forced-colors: active) and (prefers-color-scheme: dark) {
    // Windows High Contrast dark theme
    background: $pt-high-contrast-mode-active-background-color;
  }
}

@mixin pt-button-disabled() {
  background-color: $button-background-color-disabled;
  box-shadow: none;
  color: $button-color-disabled;
  cursor: not-allowed;
  outline: none;
}

@mixin pt-button-intent($default-color, $hover-color, $active-color) {
  background-color: $default-color;
  box-shadow: $button-box-shadow;
  color: $white;

  &:hover,
  &:active,
  &.#{$ns}-active {
    color: $white;
  }

  &:hover {
    background-color: $hover-color;
    box-shadow: $button-box-shadow-active;
  }

  &:active,
  &.#{$ns}-active {
    background-color: $active-color;
    box-shadow: $button-box-shadow-active;
  }

  &:disabled,
  &.#{$ns}-disabled {
    @include pt-button-intent-disabled($default-color);
  }

  @media (forced-colors: active) and (prefers-color-scheme: dark) {
    // Windows High Contrast dark theme
    border: 1px solid $pt-high-contrast-mode-border-color;
    box-shadow: none;
  }
}

@mixin pt-button-intent-disabled($default-color) {
  background-color: rgba($default-color, 0.5);
  border-color: transparent;
  box-shadow: none;
  color: $button-intent-color-disabled;

  @media (forced-colors: active) and (prefers-color-scheme: dark) {
    // Windows High Contrast dark theme
    border-color: $pt-high-contrast-mode-disabled-border-color;
    color: $pt-high-contrast-mode-disabled-border-color;
  }
}

// N.B. this mixin cannot be used on pseudo element selectors because it will produce invalid CSS
@mixin pt-dark-button() {
  @include pt-dark-button-default-colors();

  &:hover,
  &:active,
  &.#{$ns}-active {
    color: $pt-dark-text-color;
  }

  &:hover {
    @include pt-dark-button-hover();
  }

  &:active,
  &.#{$ns}-active {
    @include pt-dark-button-active();
  }

  &:disabled,
  &.#{$ns}-disabled {
    @include pt-dark-button-disabled();

    &.#{$ns}-active {
      background: $dark-button-background-color-active-disabled;
    }
  }

  .#{$ns}-button-spinner .#{$ns}-spinner-head {
    background: $dark-progress-track-color;
    stroke: $dark-progress-head-color;
  }
}

@mixin pt-dark-button-default-colors() {
  background-color: $dark-button-background-color;
  box-shadow: $dark-button-box-shadow;
  color: $pt-dark-text-color;
}

@mixin pt-dark-button-hover() {
  background-color: $dark-button-background-color-hover;
  box-shadow: $dark-button-box-shadow-active;
}

@mixin pt-dark-button-active() {
  background-color: $dark-button-background-color-active;
  box-shadow: $dark-button-box-shadow-active;
}

@mixin pt-dark-button-disabled() {
  background-color: $dark-button-background-color-disabled;
  box-shadow: none;
  color: $dark-button-color-disabled;
}

@mixin pt-dark-button-intent() {
  box-shadow: $dark-button-box-shadow;

  &:hover {
    box-shadow: $dark-button-box-shadow;
  }

  &:active,
  &.#{$ns}-active {
    box-shadow: $dark-button-box-shadow-active;
  }

  &:disabled,
  &.#{$ns}-disabled {
    @include pt-dark-button-intent-disabled();
  }
}

@mixin pt-dark-button-intent-disabled() {
  box-shadow: none;
  color: $dark-button-intent-color-disabled;
}

@mixin pt-button-minimal() {
  background: $minimal-button-background-color;
  box-shadow: none;

  &:hover {
    background: $minimal-button-background-color-hover;
    box-shadow: none;
    color: $pt-text-color;
    text-decoration: none;
  }

  &:active,
  &.#{$ns}-active {
    background: $minimal-button-background-color-active;
    box-shadow: none;
    color: $pt-text-color;
  }

  &:disabled,
  &:disabled:hover,
  &.#{$ns}-disabled,
  &.#{$ns}-disabled:hover {
    background: none;
    color: $pt-text-color-disabled;
    cursor: not-allowed;

    &.#{$ns}-active {
      background: $minimal-button-background-color-active;
    }
  }

  .#{$ns}-dark & {
    @include pt-dark-button-minimal();
  }

  @each $intent, $colors in $button-intents {
    &.#{$ns}-intent-#{$intent} {
      @include pt-button-minimal-intent($intent);
    }
  }
}

@mixin pt-dark-button-minimal() {
  background: $dark-minimal-button-background-color;
  box-shadow: none;
  color: $white;

  &:hover,
  &:active,
  &.#{$ns}-active {
    background: none;
    box-shadow: none;
    color: $white;
  }

  &:hover {
    background: $dark-minimal-button-background-color-hover;
  }

  &:active,
  &.#{$ns}-active {
    background: $dark-minimal-button-background-color-active;
  }

  &:disabled,
  &:disabled:hover,
  &.#{$ns}-disabled,
  &.#{$ns}-disabled:hover {
    background: none;
    color: $pt-dark-text-color-disabled;
    cursor: not-allowed;

    &.#{$ns}-active {
      background: $dark-minimal-button-background-color-active;
    }
  }
}

$dark-minimal-hover-text-colors: (
  "primary": $blue5,
  "success": $green5,
  "warning": $orange5,
  "danger": $red5,
);

$dark-minimal-active-text-colors: (
  "primary": $blue6,
  "success": $green6,
  "warning": $orange6,
  "danger": $red6,
);

@mixin pt-button-minimal-intent($intent) {
  $intent-color: map-get($pt-intent-colors, $intent);
  $text-color: map-get($pt-intent-text-colors, $intent);
  $active-text-color: map-get($pt-intent-active-text-colors, $intent);
  $dark-text-color: map-get($pt-dark-intent-text-colors, $intent);
  $dark-active-text-color: map-get($dark-minimal-active-text-colors, $intent);
  $dark-hover-text-color: map-get($dark-minimal-hover-text-colors, $intent);

  color: $text-color;

  &:hover,
  &:active,
  &.#{$ns}-active {
    background: none;
    box-shadow: none;
    color: $text-color;
  }

  &:hover {
    background: rgba($intent-color, 0.15);
    color: $text-color;
  }

  &:active,
  &.#{$ns}-active {
    background: rgba($intent-color, 0.3);
    color: $active-text-color;
  }

  &:disabled,
  &.#{$ns}-disabled {
    background: none;
    color: rgba($text-color, 0.5);

    &.#{$ns}-active {
      background: rgba($intent-color, 0.3);
    }
  }

  .#{$ns}-button-spinner .#{$ns}-spinner-head {
    stroke: $text-color;
  }

  .#{$ns}-dark & {
    color: $dark-text-color;

    &:hover {
      background: rgba($intent-color, 0.2);
      color: $dark-hover-text-color;
    }

    &:active,
    &.#{$ns}-active {
      background: rgba($intent-color, 0.3);
      color: $dark-active-text-color;
    }

    &:disabled,
    &.#{$ns}-disabled {
      background: none;
      color: rgba($dark-text-color, 0.5);

      &.#{$ns}-active {
        background: rgba($intent-color, 0.3);
      }
    }
  }
}

@mixin pt-button-minimal-divider() {
  $divider-height: $pt-grid-size * 2;
  background: $pt-divider-black;

  margin: ($pt-button-height - $divider-height) * 0.5;
  width: $minimal-button-divider-width;

  .#{$ns}-dark & {
    background: $pt-dark-divider-white;
  }
}

@mixin pt-button-outlined() {
  border: $button-outlined-width solid rgba($pt-text-color, 0.2);
  box-sizing: border-box;

  &:disabled,
  &.#{$ns}-disabled,
  &:disabled:hover,
  &.#{$ns}-disabled:hover {
    border-color: rgba($pt-text-color-disabled, 0.1);
  }

  .#{$ns}-dark & {
    @include pt-dark-button-outlined();
  }

  @each $intent, $colors in $button-intents {
    &.#{$ns}-intent-#{$intent} {
      @include pt-button-outlined-intent(
        map-get($pt-intent-text-colors, $intent),
        map-get($pt-dark-intent-text-colors, $intent)
      );
    }
  }
}

@mixin pt-dark-button-outlined() {
  border-color: rgba($white, 0.4);

  &:disabled,
  &:disabled:hover,
  &.#{$ns}-disabled,
  &.#{$ns}-disabled:hover {
    border-color: rgba($white, 0.2);
  }
}

@mixin pt-button-outlined-intent($text-color, $dark-text-color) {
  border-color: rgba($text-color, $button-outlined-border-intent-opacity);

  &:disabled,
  &.#{$ns}-disabled {
    border-color: rgba($text-color, $button-outlined-border-disabled-intent-opacity);
  }

  .#{$ns}-dark & {
    border-color: rgba($dark-text-color, $button-outlined-border-intent-opacity);

    &:disabled,
    &.#{$ns}-disabled {
      border-color: rgba($dark-text-color, $button-outlined-border-disabled-intent-opacity);
    }
  }
}

================================================================================

File: src\components\callout\callout.md
--------------------------------------------------------------------------------
@# Callout

__Callouts__ visually highlight important content for the user. They may contain
a title, an icon and content. Each intent has a default icon associated with it.

@reactExample CalloutExample

@## Props interface

@interface CalloutProps

@## CSS API

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use [`<Callout>`](#core/components/callout)

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

</div>

Callouts use the same visual intent modifier classes as buttons. If you need a heading, use the `<h5>`
element with a `.@ns-heading` class.

@css callout

================================================================================

File: src\components\callout\callout.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Error, type IconName, InfoSign, type SVGIconProps, Tick, WarningSign } from "@blueprintjs/icons";

import {
    AbstractPureComponent,
    Classes,
    DISPLAYNAME_PREFIX,
    type HTMLDivProps,
    Intent,
    type IntentProps,
    type MaybeElement,
    type Props,
    Utils,
} from "../../common";
import { H5 } from "../html/html";
import { Icon } from "../icon/icon";

/** This component also supports the full range of HTML `<div>` attributes. */
export interface CalloutProps extends IntentProps, Props, HTMLDivProps {
    /** Callout contents. */
    children?: React.ReactNode;

    /**
     * Whether to use a compact appearance, which reduces the visual padding around callout content.
     */
    compact?: boolean;

    /**
     * Name of a Blueprint UI icon (or an icon element) to render on the left side.
     *
     * If this prop is omitted or `undefined`, the `intent` prop will determine a default icon.
     * If this prop is explicitly `null`, no icon will be displayed (regardless of `intent`).
     */
    icon?: IconName | MaybeElement;

    /**
     * Visual intent color to apply to background, title, and icon.
     *
     * Defining this prop also applies a default icon, if the `icon` prop is omitted.
     */
    intent?: Intent;

    /**
     * String content of optional title element.
     *
     * Due to a conflict with the HTML prop types, to provide JSX content simply
     * pass `<H4>JSX title content</H4>` as first `children` element instead of
     * using this prop (note uppercase tag name to use the Blueprint Heading
     * component).
     */
    title?: string;
}

/**
 * Callout component.
 *
 * @see https://blueprintjs.com/docs/#core/components/callout
 */
export class Callout extends AbstractPureComponent<CalloutProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.Callout`;

    public render() {
        const { className, children, icon, intent, title, compact, ...htmlProps } = this.props;
        const iconElement = this.renderIcon(icon, intent);
        const classes = classNames(Classes.CALLOUT, Classes.intentClass(intent), className, {
            [Classes.CALLOUT_HAS_BODY_CONTENT]: !Utils.isReactNodeEmpty(children),
            [Classes.CALLOUT_ICON]: iconElement != null,
            [Classes.COMPACT]: compact,
        });

        return (
            <div className={classes} {...htmlProps}>
                {iconElement}
                {title && <H5>{title}</H5>}
                {children}
            </div>
        );
    }

    private renderIcon(icon?: CalloutProps["icon"], intent?: Intent): IconName | MaybeElement {
        // 1. no icon
        if (icon === null || icon === false) {
            return undefined;
        }

        const iconProps = { "aria-hidden": true, tabIndex: -1 } satisfies SVGIconProps;

        // 2. icon specified by name or as a custom SVG element
        if (icon !== undefined) {
            return <Icon icon={icon} {...iconProps} />;
        }

        // 3. icon specified by intent prop
        switch (intent) {
            case Intent.DANGER:
                return <Error {...iconProps} />;
            case Intent.PRIMARY:
                return <InfoSign {...iconProps} />;
            case Intent.WARNING:
                return <WarningSign {...iconProps} />;
            case Intent.SUCCESS:
                return <Tick {...iconProps} />;
            default:
                return undefined;
        }
    }
}

================================================================================

File: src\components\callout\_callout.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables-extended";

/*
Callout

Markup:
<div class="#{$ns}-callout {{.modifier}}">
  <h5 class="#{$ns}-heading">Callout Heading</h5>
  It's dangerous to go alone! Take <a href="#">this</a>.
</div>

.#{$ns}-intent-primary - Primary intent
.#{$ns}-intent-success - Success intent
.#{$ns}-intent-warning - Warning intent
.#{$ns}-intent-danger  - Danger intent
.#{$ns}-icon-info-sign - With an icon

Styleguide callout
*/

$callout-padding: $pt-grid-size * 1.5;
$callout-header-margin-top: $pt-grid-size * 0.2;
$callout-padding-compact: $pt-grid-size;

.#{$ns}-callout {
  @include running-typography();
  background-color: rgba($gray3, 0.15);
  border-radius: $pt-border-radius;
  padding: $callout-padding;
  position: relative;
  width: 100%;

  // CSS API support
  &[class*="#{$ns}-icon-"] {
    padding-left: $callout-padding + $pt-icon-size-standard + ($pt-grid-size * 0.7);

    &::before {
      @include pt-icon($pt-icon-size-standard);
      color: $pt-icon-color;
      left: $callout-padding;
      position: absolute;
      top: $callout-padding + $callout-header-margin-top;
    }
  }

  // High contrast mode hides backgrounds, so we need to use a border instead
  @media (forced-colors: active) and (prefers-color-scheme: dark) {
    border: 1px solid $pt-high-contrast-mode-border-color;
  }

  &.#{$ns}-callout-icon {
    padding-left: $callout-padding + $pt-icon-size-standard + ($pt-grid-size * 0.7);

    > .#{$ns}-icon:first-child {
      color: $pt-icon-color;
      left: $callout-padding;
      position: absolute;
      top: $callout-padding + $callout-header-margin-top;
    }
  }

  .#{$ns}-heading {
    line-height: $pt-icon-size-standard;
    margin-bottom: 0;
    margin-top: $callout-header-margin-top;
  }

  &.#{$ns}-callout-has-body-content {
    .#{$ns}-heading {
      margin-bottom: $half-grid-size;
    }
  }

  &.#{$ns}-compact {
    padding: $callout-padding-compact;

    &.#{$ns}-callout-icon {
      padding-left: $callout-padding-compact + $pt-icon-size-standard + ($pt-grid-size * 0.7);

      > .#{$ns}-icon:first-child {
        left: $callout-padding-compact;
        top: $callout-padding-compact + $callout-header-margin-top;
      }
    }
  }

  .#{$ns}-dark & {
    background-color: rgba($gray3, 0.2);

    &[class*="#{$ns}-icon-"]::before,
    &.#{$ns}-callout-icon > .#{$ns}-icon:first-child {
      color: $pt-dark-icon-color;
    }
  }

  @each $intent, $color in $pt-intent-colors {
    &.#{$ns}-intent-#{$intent} {
      background-color: rgba($color, 0.1);
      color: map-get($pt-intent-text-colors, $intent);

      @media (forced-colors: active) and (prefers-color-scheme: dark) {
        border: 1px solid $pt-high-contrast-mode-border-color;
      }

      &[class*="#{$ns}-icon-"]::before,
      > .#{$ns}-icon:first-child,
      .#{$ns}-heading {
        color: map-get($pt-intent-text-colors, $intent);
      }

      .#{$ns}-dark & {
        background-color: rgba($color, 0.2);
        color: map-get($pt-dark-intent-text-colors, $intent);

        &[class*="#{$ns}-icon-"]::before,
        > .#{$ns}-icon:first-child,
        .#{$ns}-heading {
          color: map-get($pt-dark-intent-text-colors, $intent);
        }
      }
    }
  }

  &.#{$ns}-intent-primary {
    // special case for links inside primary intent callouts, which would otherwise not have any indication
    // that they are clickable links; see https://github.com/palantir/blueprint/issues/5853
    a {
      text-decoration: underline;

      &:hover {
        color: $blue1;
      }
    }

    .#{$ns}-dark & {
      a:hover {
        color: $blue6;
      }
    }
  }

  .#{$ns}-running-text & {
    margin: ($pt-grid-size * 2) 0;
  }
}

================================================================================

File: src\components\card\card.md
--------------------------------------------------------------------------------
@# Card

A **Card** is a bounded unit of UI content with a solid background color.

@reactExample CardExample

@## Usage

```tsx
import { Button, Card, Elevation } from "@blueprintjs/core";

<Card interactive={true} elevation={Elevation.TWO}>
    <h5>
        <a href="#">Card heading</a>
    </h5>
    <p>Card content</p>
    <Button>Submit</Button>
</Card>;
```

@## Elevation

Apply an `elevation` value to a card to apply a drop shadow that simulates height in the UI.
Five elevations are supported, from 0 to 4.

Note that the `Classes.ELEVATION_*` classes can be used on any element (not just a `Card`) to apply the drop shadow.

@## Props interface

@interface CardProps

@## CSS API

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use [`<Card>`](#core/components/card)

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

</div>

Start with `.@ns-card` and add an elevation class `.@ns-elevation-*` to apply a drop shadow that simulates height in
the UI.

Add the `.@ns-interactive` modifier class to make a `.@ns-card` respond to user interactions. When you hover over cards
with this class applied, the mouse changes to a pointer and increases the elevation shadow on the card.

@css card

================================================================================

File: src\components\card\card.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Classes, Elevation } from "../../common";
import { DISPLAYNAME_PREFIX, type HTMLDivProps, type Props } from "../../common/props";

export interface CardProps extends Props, HTMLDivProps, React.RefAttributes<HTMLDivElement> {
    /**
     * Controls the intensity of the drop shadow beneath the card: the higher
     * the elevation, the higher the drop shadow. At elevation `0`, no drop
     * shadow is applied.
     *
     * @default 0
     */
    elevation?: Elevation;

    /**
     * Whether the card should respond to user interactions. If set to `true`,
     * hovering over the card will increase the card's elevation
     * and change the mouse cursor to a pointer.
     *
     * Recommended when `onClick` is also defined.
     *
     * @default false
     */
    interactive?: boolean;

    /**
     * Whether this card should appear selected.
     *
     * @default undefined
     */
    selected?: boolean;

    /**
     * Whether this component should use compact styles with reduced visual padding.
     *
     * @default false
     */
    compact?: boolean;

    /**
     * Callback invoked when the card is clicked.
     * Recommended when `interactive` is `true`.
     */
    onClick?: (e: React.MouseEvent<HTMLDivElement>) => void;
}

/**
 * Card component.
 *
 * @see https://blueprintjs.com/docs/#core/components/card
 */
export const Card: React.FC<CardProps> = React.forwardRef((props, ref) => {
    const { className, elevation, interactive, selected, compact, ...htmlProps } = props;
    const classes = classNames(className, Classes.CARD, Classes.elevationClass(elevation!), {
        [Classes.INTERACTIVE]: interactive,
        [Classes.COMPACT]: compact,
        [Classes.SELECTED]: selected,
    });
    return <div className={classes} ref={ref} {...htmlProps} />;
});
Card.defaultProps = {
    elevation: Elevation.ZERO,
    interactive: false,
};
Card.displayName = `${DISPLAYNAME_PREFIX}.Card`;

================================================================================

File: src\components\card\_card-variables.scss
--------------------------------------------------------------------------------
// Copyright 2023 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables-extended";

$card-padding: $pt-grid-size * 2 !default;
$card-padding-compact: $pt-grid-size * 1.5 !default;

$card-background-color: $white !default;
$dark-card-background-color: $pt-dark-app-elevated-background-color !default;

$card-list-border-width: 1px !default;

// stylelint-disable max-line-length

// CardList Card item min-height is calculated as height of a button + vertical padding.
// We need to add an extra pixel to account for the bottom border.
$card-list-item-padding-vertical: $pt-grid-size !default;
$card-list-item-min-height: $pt-button-height + ($card-list-item-padding-vertical * 2) + $card-list-border-width !default;
$card-list-item-padding: $card-list-item-padding-vertical $card-padding !default;

$card-list-item-padding-vertical-compact: 7px !default;
$card-list-item-min-height-compact: $pt-button-height + ($card-list-item-padding-vertical-compact * 2) + $card-list-border-width !default;
$card-list-item-padding-compact: $card-list-item-padding-vertical-compact $card-padding-compact !default;

================================================================================

File: src\components\card\_card.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "./card-variables";

/*
Cards

Markup:
<div class="#{$ns}-card {{.modifier}}">
  We build products that make people better at their most important work.
</div>

.#{$ns}-elevation-0 - Ground floor. This level provides just a gentle border shadow.
.#{$ns}-elevation-1 - First. Subtle drop shadow intended for static containers.
.#{$ns}-elevation-2 - Second. An even stronger shadow, moving on up.
.#{$ns}-elevation-3 - Third. For containers overlaying content temporarily.
.#{$ns}-elevation-4 - Fourth. The strongest shadow, usually for overlay containers on top of backdrops.
.#{$ns}-interactive - On hover, increase elevation and use pointer cursor.

Styleguide card
*/

.#{$ns}-card {
  background-color: $card-background-color;
  border-radius: $pt-border-radius;
  box-shadow: $pt-elevation-shadow-0;
  padding: $card-padding;
  transition: transform ($pt-transition-duration * 2) $pt-transition-ease,
              box-shadow ($pt-transition-duration * 2) $pt-transition-ease;

  &.#{$ns}-dark,
  .#{$ns}-dark & {
    background-color: $dark-card-background-color;
    box-shadow: $pt-dark-elevation-shadow-0;
  }

  // High contrast mode hides box-shadows, so we need to use a border instead
  @media (forced-colors: active) and (prefers-color-scheme: dark) {
    border: 1px solid $pt-high-contrast-mode-border-color;
    box-shadow: none;
  }
}

@for $index from 1 through length($elevation-shadows) {
  .#{$ns}-elevation-#{$index - 1} {
    box-shadow: nth($elevation-shadows, $index);

    &.#{$ns}-dark,
    .#{$ns}-dark & {
      box-shadow: nth($dark-elevation-shadows, $index);
    }

    @media (forced-colors: active) and (prefers-color-scheme: dark) {
      border: 1px solid $pt-high-contrast-mode-border-color;
    }
  }
}

.#{$ns}-card.#{$ns}-compact {
  padding: $card-padding-compact;
}

.#{$ns}-card.#{$ns}-interactive {
  &:hover {
    box-shadow: $pt-elevation-shadow-3;
    cursor: pointer;

    &.#{$ns}-dark,
    .#{$ns}-dark & {
      box-shadow: $pt-dark-elevation-shadow-3;
    }
  }

  &.#{$ns}-selected {
    box-shadow: 0 0 0 3px rgba($blue4, 0.2), 0 0 0 1px $blue4;

    &.#{$ns}-dark,
    .#{$ns}-dark & {
      box-shadow: 0 0 0 3px rgba($blue5, 0.4), 0 0 0 1px $blue5;
    }
  }

  &:active {
    box-shadow: $pt-elevation-shadow-1;
    transition-duration: 0;

    &.#{$ns}-dark,
    .#{$ns}-dark & {
      box-shadow: $pt-dark-elevation-shadow-1;
    }
  }
}

================================================================================

File: src\components\card-list\card-list.md
--------------------------------------------------------------------------------
---
tag: new
---

@# Card List

__CardList__ is a lightweight wrapper around the [__Card__](#core/components/card) component. It can be used to
visually group together cards in a list without any excess visual weight around or between them. Long lists may
be styled with CSS to scroll vertically.

@reactExample CardListExample

@## Usage

```tsx
import { Card, CardList } from "@blueprintjs/core";

<CardList>
    <Card>Basil</Card>
    <Card>Olive oil</Card>
    <Card>Kosher Salt</Card>
    <Card>Garlic</Card>
    <Card>Pine nuts</Card>
    <Card>Parmigiano Reggiano</Card>
</CardList>
```

@## Combining with Section

__CardList__ may be used as content for the [__Section__](#core/components/section) component (inside a nested
__SectionCard__). This allows support for features like a title & description above the list.

Set the same value for `<SectionCard padded>` and `<CardList bordered>` (either `true` or `false` for both) to get two
different kinds of appearances.

```tsx
import { Card, CardList, Section, SectionCard } from "@blueprintjs/core";

<Section title="Traditional pesto">
    <SectionCard padded={false}>
        <CardList bordered={false}>
            <Card>Basil</Card>
            <Card>Olive oil</Card>
            {/* ... */}
        </CardList>
    </SectionCard>
</Section>
```

@## Props interface

@interface CardListProps

================================================================================

File: src\components\card-list\card-list.scss
--------------------------------------------------------------------------------
// Copyright 2023 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../card/card-variables";

.#{$ns}-card-list {
  overflow: auto;
  padding: 0;
  width: 100%;

  > .#{$ns}-card {
    align-items: center;
    border-radius: 0;
    box-shadow: none;
    display: flex;
    min-height: $card-list-item-min-height;
    padding: $card-list-item-padding;

    &.#{$ns}-interactive:hover,
    &.#{$ns}-interactive:active {
      background-color: $light-gray5;
      box-shadow: none;

      .#{$ns}-dark & {
        background-color: $dark-gray4;
      }
    }

    &.#{$ns}-selected {
      background-color: $light-gray4;
      box-shadow: none;

      .#{$ns}-dark & {
        background-color: $dark-gray5;
        box-shadow: none;
      }
    }

    &:not(:last-child) {
      border-bottom: $card-list-border-width solid $pt-divider-black-muted;

      .#{$ns}-dark & {
        border-color: $pt-dark-divider-white-muted;
      }
    }
  }

  &.#{$ns}-compact {
    padding: 0;

    > .#{$ns}-card {
      min-height: $card-list-item-min-height-compact;
      padding: $card-list-item-padding-compact;
    }
  }

  .#{$ns}-dark & {
    // card border is inset in dark theme, so we need to add padding to prevent items from going over it
    padding: 1px;
  }

  &:not(.#{$ns}-card-list-bordered) {
    border-radius: 0;
    box-shadow: none;

    .#{$ns}-dark & {
      margin: 1px;
      width: calc(100% - 2px);
    }
  }
}

================================================================================

File: src\components\card-list\cardList.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Classes, DISPLAYNAME_PREFIX, Elevation, type HTMLDivProps, type Props } from "../../common";
import { Card } from "../card/card";

export interface CardListProps extends Props, HTMLDivProps, React.RefAttributes<HTMLDivElement> {
    /**
     * Whether this container element should have a visual border.
     *
     * Set this to `false` to remove elevation and border radius styles, which allows this element to be a child of
     * another bordered container element without padding (like SectionCard). Note that this also sets a 1px margin
     * _in dark theme_ to account for inset box shadows in that theme used across the design system. Be sure to test
     * your UI in both light and dark theme if you modify this prop value.
     *
     * @default true
     */
    bordered?: boolean;

    /**
     * Whether this component should use compact styles with reduced visual padding.
     *
     * Note that this prop affects styling for all Cards within this CardList and you do not need to set the
     * `compact` prop individually on those child Cards.
     *
     * @default false
     */
    compact?: boolean;
}

export const CardList: React.FC<CardListProps> = React.forwardRef((props, ref) => {
    const { bordered, className, children, compact, ...htmlProps } = props;

    const classes = classNames(className, Classes.CARD_LIST, {
        [Classes.CARD_LIST_BORDERED]: bordered,
        [Classes.COMPACT]: compact,
    });

    return (
        <Card role="list" elevation={Elevation.ZERO} className={classes} {...htmlProps} ref={ref}>
            {children}
        </Card>
    );
});
CardList.defaultProps = {
    bordered: true,
    compact: false,
};
CardList.displayName = `${DISPLAYNAME_PREFIX}.CardList`;

================================================================================

File: src\components\collapse\collapse.md
--------------------------------------------------------------------------------
@# Collapse

The __Collapse__ element shows and hides content with a built-in slide in/out animation.
You might use this to create a panel of settings for your application, with sub-sections
that can be expanded and collapsed.

@reactExample CollapseExample

@## Usage

Any content should be a child of `<Collapse>`. Content must be in the document flow
(e.g. `position: absolute;` wouldn't work, as the parent element would inherit a height of 0).

Toggling the `isOpen` prop triggers the open and close animations.
Once the component is in the closed state, the children are no longer rendered, unless the
`keepChildrenMounted` prop is true.

```tsx
export interface CollapseExampleState {
    isOpen?: boolean;
};

export class CollapseExample extends React.Component<{}, CollapseExampleState> {
    public state = {
        isOpen: false,
    };

    public render() {
        return (
            <div>
                <Button onClick={this.handleClick}>
                    {this.state.isOpen ? "Hide" : "Show"} build logs
                </Button>
                <Collapse isOpen={this.state.isOpen}>
                    <Pre>
                        Dummy text.
                    </Pre>
                </Collapse>
            </div>
        );
    }

    private handleClick = () => {
        this.setState({ isOpen: !this.state.isOpen });
    }
}
```

@## Props interface

@interface CollapseProps

================================================================================

File: src\components\collapse\collapse.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes } from "../../common";
import { DISPLAYNAME_PREFIX, type Props } from "../../common/props";

export interface CollapseProps extends Props {
    /** Contents to collapse. */
    children?: React.ReactNode;

    /**
     * Component to render as the root element.
     * Useful when rendering a `Collapse` inside a `<table>`, for instance.
     *
     * @default "div"
     */
    component?: React.ElementType;

    /**
     * Whether the component is open or closed.
     *
     * @default false
     */
    isOpen?: boolean;

    /**
     * Whether the child components will remain mounted when the `Collapse` is closed.
     * Setting to true may improve performance by avoiding re-mounting children.
     *
     * @default false
     */
    keepChildrenMounted?: boolean;

    /**
     * The length of time the transition takes, in milliseconds. This must match
     * the duration of the animation in CSS. Only set this prop if you override
     * Blueprint's default transitions with new transitions of a different
     * length.
     *
     * @default 200
     */
    transitionDuration?: number;
}

export interface CollapseState {
    /** The state the element is currently in. */
    animationState: AnimationStates;

    /** The height that should be used for the content animations. This is a CSS value, not just a number. */
    height: string | undefined;

    /**
     * The most recent non-zero height (once a height has been measured upon first open; it is undefined until then)
     */
    heightWhenOpen: number | undefined;
}

/**
 * `Collapse` can be in one of six states, enumerated here.
 * When changing the `isOpen` prop, the following happens to the states:
 * isOpen={true}  : CLOSED -> OPEN_START -> OPENING -> OPEN
 * isOpen={false} : OPEN -> CLOSING_START -> CLOSING -> CLOSED
 */
export enum AnimationStates {
    /**
     * The body is re-rendered, height is set to the measured body height and
     * the body Y is set to 0.
     */
    OPEN_START,

    /**
     * Animation begins, height is set to auto. This is all animated, and on
     * complete, the state changes to OPEN.
     */
    OPENING,

    /**
     * The collapse height is set to auto, and the body Y is set to 0 (so the
     * element can be seen as normal).
     */
    OPEN,

    /**
     * Height has been changed from auto to the measured height of the body to
     * prepare for the closing animation in CLOSING.
     */
    CLOSING_START,

    /**
     * Height is set to 0 and the body Y is at -height. Both of these properties
     * are transformed, and then after the animation is complete, the state
     * changes to CLOSED.
     */
    CLOSING,

    /**
     * The contents of the collapse is not rendered, the collapse height is 0,
     * and the body Y is at -height (so that the bottom of the body is at Y=0).
     */
    CLOSED,
}

/**
 * Collapse component.
 *
 * @see https://blueprintjs.com/docs/#core/components/collapse
 */
export class Collapse extends AbstractPureComponent<CollapseProps, CollapseState> {
    public static displayName = `${DISPLAYNAME_PREFIX}.Collapse`;

    public static defaultProps: Partial<CollapseProps> = {
        component: "div",
        isOpen: false,
        keepChildrenMounted: false,
        transitionDuration: 200,
    };

    public static getDerivedStateFromProps(props: CollapseProps, state: CollapseState) {
        const { isOpen } = props;
        const { animationState } = state;

        if (isOpen) {
            switch (animationState) {
                case AnimationStates.OPEN:
                    // no-op
                    break;
                case AnimationStates.OPENING:
                    // allow Collapse#onDelayedStateChange() to handle the transition here
                    break;
                default:
                    return { animationState: AnimationStates.OPEN_START };
            }
        } else {
            switch (animationState) {
                case AnimationStates.CLOSED:
                    // no-op
                    break;
                case AnimationStates.CLOSING:
                    // allow Collapse#onDelayedStateChange() to handle the transition here
                    break;
                default:
                    // need to set an explicit height so that transition can work
                    return {
                        animationState: AnimationStates.CLOSING_START,
                        height: `${state.heightWhenOpen}px`,
                    };
            }
        }

        return null;
    }

    public state: CollapseState = {
        animationState: this.props.isOpen ? AnimationStates.OPEN : AnimationStates.CLOSED,
        height: undefined,
        heightWhenOpen: undefined,
    };

    // The element containing the contents of the collapse.
    private contents: HTMLElement | null = null;

    public render() {
        const isContentVisible = this.state.animationState !== AnimationStates.CLOSED;
        const shouldRenderChildren = isContentVisible || this.props.keepChildrenMounted;
        const displayWithTransform = isContentVisible && this.state.animationState !== AnimationStates.CLOSING;
        const isAutoHeight = this.state.height === "auto";

        const containerStyle = {
            height: isContentVisible ? this.state.height : undefined,
            overflowY: isAutoHeight ? "visible" : undefined,
            // transitions don't work with height: auto
            transition: isAutoHeight ? "none" : undefined,
        };

        const contentsStyle = {
            // only use heightWhenOpen while closing
            transform: displayWithTransform ? "translateY(0)" : `translateY(-${this.state.heightWhenOpen}px)`,
            // transitions don't work with height: auto
            transition: isAutoHeight ? "none" : undefined,
        };

        return React.createElement(
            this.props.component!,
            {
                className: classNames(Classes.COLLAPSE, this.props.className),
                style: containerStyle,
            },
            <div
                className={Classes.COLLAPSE_BODY}
                ref={this.contentsRefHandler}
                style={contentsStyle}
                aria-hidden={!isContentVisible}
            >
                {shouldRenderChildren ? this.props.children : null}
            </div>,
        );
    }

    public componentDidMount() {
        this.forceUpdate();
        // HACKHACK: this should probably be done in getSnapshotBeforeUpdate
        /* eslint-disable react/no-did-mount-set-state */
        if (this.props.isOpen) {
            this.setState({ animationState: AnimationStates.OPEN, height: "auto" });
        } else {
            this.setState({ animationState: AnimationStates.CLOSED, height: "0px" });
        }
        /* eslint-disable react/no-did-mount-set-state */
    }

    public componentDidUpdate() {
        if (this.contents == null) {
            return;
        }

        const { transitionDuration } = this.props;
        const { animationState } = this.state;

        if (animationState === AnimationStates.OPEN_START) {
            const { clientHeight } = this.contents;
            this.setState({
                animationState: AnimationStates.OPENING,
                height: `${clientHeight}px`,
                heightWhenOpen: clientHeight,
            });
            this.setTimeout(() => this.onDelayedStateChange(), transitionDuration);
        } else if (animationState === AnimationStates.CLOSING_START) {
            const { clientHeight } = this.contents;
            this.setTimeout(() =>
                this.setState({
                    animationState: AnimationStates.CLOSING,
                    height: "0px",
                    heightWhenOpen: clientHeight,
                }),
            );
            this.setTimeout(() => this.onDelayedStateChange(), transitionDuration);
        }
    }

    private contentsRefHandler = (el: HTMLElement | null) => {
        this.contents = el;
        if (this.contents != null) {
            const height = this.contents.clientHeight;
            this.setState({
                animationState: this.props.isOpen ? AnimationStates.OPEN : AnimationStates.CLOSED,
                height: height === 0 ? undefined : `${height}px`,
                heightWhenOpen: height === 0 ? undefined : height,
            });
        }
    };

    private onDelayedStateChange() {
        switch (this.state.animationState) {
            case AnimationStates.OPENING:
                this.setState({ animationState: AnimationStates.OPEN, height: "auto" });
                break;
            case AnimationStates.CLOSING:
                this.setState({ animationState: AnimationStates.CLOSED });
                break;
            default:
                break;
        }
    }
}

================================================================================

File: src\components\collapse\_collapse.scss
--------------------------------------------------------------------------------
// Copyright 2016 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";

$collapse-transition: ($pt-transition-duration * 2) $pt-transition-ease !default;

.#{$ns}-collapse {
  height: 0;
  overflow-y: hidden;
  transition: height $collapse-transition;

  .#{$ns}-collapse-body {
    transition: transform $collapse-transition;

    &[aria-hidden="true"] {
      display: none;
    }
  }
}

================================================================================

File: src\components\context-menu\context-menu-popover.md
--------------------------------------------------------------------------------
@# Context Menu Popover

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Consider [Context Menu](#core/components/context-menu) first

</h5>

The APIs described on this page are lower-level and have some limitations compared to
[Context Menu](#core/components/context-menu), so you should try that API _first_ to see if it addresses your use case.

</div>

**Context Menu Popover** is a lower-level API for [**Context Menu**](#core/components/context-menu) which does
not hook up any interaction handlers for you and simply renders an opinionated
[**Popover**](#core/components/popover) at a particular target offset on the page through a
[**Portal**](#core/components/portal).

@reactExample ContextMenuPopoverExample

@## Declarative API

Use the `<ContextMenuPopover>` component like any other React component in your tree. Note that this is a controlled
component which requires its `isOpen` and `targetOffset` props to be defined.

@interface ContextMenuPopoverProps

@## Imperative API

Two functions are provided as an imperative API for showing and hiding a singleton **Context Menu Popover** on
the page:

```ts
export function showContextMenu(
    props: ContextMenuPopoverProps,
    options?: DOMMountOptions<ContextMenuPopoverProps>,
): void;
export function hideContextMenu(options?: DOMMountOptions<ContextMenuPopoverProps>): void;
```

These are useful in some cases when working with imperative code that does not follow typical React paradigms.
Note that these functions come with come caveats, and thus they should be used with caution:

-   they rely on global state stored in Blueprint library code.
-   they create a new React DOM tree via `ReactDOM.render()` (or `ReactDOM.createRoot()` if you override the
    default renderer via `options`), which means they do not preserve any existing React context from the calling code.
-   they do _not_ automatically detect dark theme, so you must manualy set the `{ isDarkTheme: true }` property

================================================================================

File: src\components\context-menu\context-menu.md
--------------------------------------------------------------------------------
@# Context Menu

**Context menus** present the user with a list of actions when right-clicking on a target element.
They essentially generate an opinionated [**Popover**](#core/components/popover) instance configured
with the appropriate interaction handlers.

@reactExample ContextMenuExample

@## Usage

Create a context menu using the simple function component:

```tsx
import { ContextMenu, Menu, MenuItem } from "@blueprintjs/core";

export default function ContextMenuExample() {
    return (
        <ContextMenu
            content={
                <Menu>
                    <MenuItem text="Save" />
                    <MenuItem text="Save as..." />
                    <MenuItem text="Delete..." intent="danger" />
                </Menu>
            }
        >
            <div className="my-context-menu-target">Right click me!</div>
        </ContextMenu>
    );
}
```

`<ContextMenu>` will render a `<div>` wrapper element around its children. You can treat this
component as a `<div>`, since extra props will be forwarded down to the DOM element. For example,
you can add an `onClick` handler. You may also customize the tag name of the generated wrapper
element using the `tagName` prop. Note that the generated popover will be rendered as a _sibling_
of this wrapper element.

### Advanced usage

By default, `<ContextMenu>` will render a wrapper element around its children to attach an event handler
and get a DOM ref for theme detection. If this wrapper element breaks your HTML and/or CSS layout in
some way and you wish to omit it, you may do so by utilizing ContextMenu's advanced rendering API
which uses a `children` render function. If you use this approach, you must take care to properly use
all the render props supplied to the `children()` function:

```tsx
import classNames from "classnames";
import { ContextMenu, ContextMenuChildrenProps, Menu, MenuItem } from "@blueprintjs/core";

export default function AdvancedContextMenuExample() {
    return (
        <ContextMenu
            content={
                <Menu>
                    <MenuItem text="Save" />
                    <MenuItem text="Save as..." />
                    <MenuItem text="Delete..." intent="danger" />
                </Menu>
            }
        >
            {(ctxMenuProps: ContextMenuChildrenProps) => (
                <div
                    className={classNames("my-context-menu-target", ctxMenuProps.className)}
                    onContextMenu={ctxMenuProps.onContextMenu}
                    ref={ctxMenuProps.ref}
                >
                    {ctxMenuProps.popover}
                    Right click me!
                </div>
            )}
        </ContextMenu>
    );
}
```

Both `content` and `children` props support the [render prop](https://reactjs.org/docs/render-props.html)
pattern, so you may use information about the context menu's state (such as `isOpen: boolean`) in your
render code.

@## Props interface

To enable/disable the context menu popover, use the `disabled` prop. Note that it is inadvisable to change
the value of this prop inside the `onContextMenu` callback for this component; doing so can lead to unpredictable
behavior.

@interface ContextMenuProps

================================================================================

File: src\components\context-menu\contextMenu.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Classes, DISPLAYNAME_PREFIX, mergeRefs, type Props, Utils } from "../../common";
import { TooltipContext, TooltipProvider } from "../popover/tooltipContext";

import { ContextMenuPopover } from "./contextMenuPopover";
import type { ContextMenuPopoverOptions, Offset } from "./contextMenuShared";

/**
 * Render props relevant to the _content_ of a context menu (rendered as the underlying Popover's content).
 */
export interface ContextMenuContentProps {
    /** Whether the context menu is currently open. */
    isOpen: boolean;

    /**
     * The computed target offset (x, y) coordinates for the context menu click event.
     * On first render, before any context menu click event has occurred, this will be undefined.
     */
    targetOffset: Offset | undefined;

    /** The context menu click event. If isOpen is false, this will be undefined. */
    mouseEvent: React.MouseEvent<HTMLElement> | undefined;
}

/**
 * Render props for advanced usage of ContextMenu.
 */
export interface ContextMenuChildrenProps {
    /** Context menu container element class */
    className: string;

    /** Render props relevant to the content of this context menu */
    contentProps: ContextMenuContentProps;

    /** Context menu handler which implements the custom context menu interaction */
    onContextMenu: React.MouseEventHandler<HTMLElement>;

    /** Popover element rendered by ContextMenu, used to establish a click target to position the menu */
    popover: React.JSX.Element | undefined;

    /** DOM ref for the context menu target, used to detect dark theme */
    ref: React.Ref<any>;
}

export interface ContextMenuProps
    extends Omit<React.HTMLAttributes<HTMLElement>, "children" | "className" | "content" | "onContextMenu">,
        React.RefAttributes<any>,
        Props {
    /**
     * Menu content. This will usually be a Blueprint `<Menu>` component.
     * This optionally functions as a render prop so you can use component state to render content.
     */
    content: React.JSX.Element | ((props: ContextMenuContentProps) => React.JSX.Element | undefined) | undefined;

    /**
     * The context menu target. This may optionally be a render function so you can use
     * component state to render the target.
     */
    children: React.ReactNode | ((props: ContextMenuChildrenProps) => React.ReactElement);

    /**
     * Whether the context menu is disabled.
     *
     * @default false
     */
    disabled?: boolean;

    /**
     * Callback invoked when the popover overlay closes.
     */
    onClose?: () => void;

    /**
     * An optional context menu event handler. This can be useful if you want to do something with the
     * mouse event unrelated to rendering the context menu itself, especially if that involves setting
     * React state (which is an error to do in the render code path of this component).
     */
    onContextMenu?: React.MouseEventHandler<HTMLElement>;

    /**
     * A limited subset of props to forward along to the popover overlay generated by this component.
     */
    popoverProps?: ContextMenuPopoverOptions;

    /**
     * HTML tag to use for container element. Only used if this component's children are specified as
     * React node(s), not when it is a render function (in that case, you get to render whatever tag
     * you wish).
     *
     * @default "div"
     */
    tagName?: keyof React.JSX.IntrinsicElements;
}

/**
 * Context menu component.
 *
 * @see https://blueprintjs.com/docs/#core/components/context-menu
 */
export const ContextMenu: React.FC<ContextMenuProps> = React.forwardRef<any, ContextMenuProps>((props, userRef) => {
    const {
        className,
        children,
        content,
        disabled = false,
        onClose,
        onContextMenu,
        popoverProps,
        tagName = "div",
        ...restProps
    } = props;

    // ancestor TooltipContext state doesn't affect us since we don't care about parent ContextMenus, we only want to
    // force disable parent Tooltips in certain cases through dispatching actions
    // N.B. any calls to this dispatch function will be no-ops if there is no TooltipProvider ancestor of this component
    const [, tooltipCtxDispatch] = React.useContext(TooltipContext);
    // click target offset relative to the viewport (e.clientX/clientY), since the target will be rendered in a Portal
    const [targetOffset, setTargetOffset] = React.useState<Offset | undefined>(undefined);
    // hold a reference to the click mouse event to pass to content/child render functions
    const [mouseEvent, setMouseEvent] = React.useState<React.MouseEvent<HTMLElement>>();
    const [isOpen, setIsOpen] = React.useState<boolean>(false);
    // we need a ref on the child element (or the wrapper we generate) to check for dark theme
    const childRef = React.useRef<HTMLDivElement>(null);

    // If disabled prop is changed, we don't want our old context menu to stick around.
    // If it has just been enabled (disabled = false), then the menu ought to be opened by
    // a new mouse event. Users should not be updating this prop in the onContextMenu callback
    // for this component (that will lead to unpredictable behavior).
    React.useEffect(() => {
        setIsOpen(false);
        tooltipCtxDispatch({ type: "RESET_DISABLED_STATE" });
    }, [disabled, tooltipCtxDispatch]);

    const handlePopoverClose = React.useCallback(() => {
        setIsOpen(false);
        setMouseEvent(undefined);
        tooltipCtxDispatch({ type: "RESET_DISABLED_STATE" });
        onClose?.();
    }, [onClose, tooltipCtxDispatch]);

    // if the menu was just opened, we should check for dark theme (but don't do this on every render)
    // eslint-disable-next-line react-hooks/exhaustive-deps
    const isDarkTheme = React.useMemo(() => Utils.isDarkTheme(childRef.current), [childRef, isOpen]);

    const contentProps: ContextMenuContentProps = React.useMemo(
        () => ({
            isOpen,
            mouseEvent,
            targetOffset,
        }),
        [isOpen, mouseEvent, targetOffset],
    );
    // create a memoized function to render the menu so that we can call it if necessary in the "contextmenu" event
    // handler which runs before this render function has a chance to re-run and update the `menu` variable
    const renderMenu = React.useCallback(
        (menuContentProps: ContextMenuContentProps) =>
            disabled ? undefined : Utils.isFunction(content) ? content(menuContentProps) : content,
        [disabled, content],
    );
    const menuContent = React.useMemo(() => renderMenu(contentProps), [contentProps, renderMenu]);

    // only render the popover if there is content in the context menu;
    // this avoid doing unnecessary rendering & computation
    const maybePopover =
        menuContent === undefined ? undefined : (
            <ContextMenuPopover
                {...popoverProps}
                content={menuContent}
                isDarkTheme={isDarkTheme}
                isOpen={isOpen}
                targetOffset={targetOffset}
                onClose={handlePopoverClose}
            />
        );

    const handleContextMenu = React.useCallback(
        (e: React.MouseEvent<HTMLElement>) => {
            // support nested menus (inner menu target would have called preventDefault())
            if (e.defaultPrevented) {
                return;
            }

            // If disabled, we should avoid the extra work in this event handler.
            // Otherwise: if using the child or content function APIs, we need to make sure contentProps gets updated,
            // so we handle the event regardless of whether the consumer returned an undefined menu.
            const shouldHandleEvent =
                !disabled && (Utils.isFunction(children) || Utils.isFunction(content) || content !== undefined);

            if (shouldHandleEvent) {
                setIsOpen(true);
                e.persist();
                setMouseEvent(e);
                const newTargetOffset = { left: e.clientX, top: e.clientY };
                setTargetOffset(newTargetOffset);
                tooltipCtxDispatch({ type: "FORCE_DISABLED_STATE" });

                const newMenuContent = renderMenu({ isOpen: true, mouseEvent: e, targetOffset: newTargetOffset });

                if (newMenuContent === undefined) {
                    // If there is no menu content, we shouldn't automatically swallow the contextmenu event, since the
                    // user probably wants to fall back to default browser behavior. If they still want to disable the
                    // native context menu in that case, they can do so with their own `onContextMenu` handler.
                } else {
                    e.preventDefault();
                }
            }

            onContextMenu?.(e);
        },
        [disabled, children, content, onContextMenu, tooltipCtxDispatch, renderMenu],
    );

    const containerClassName = classNames(className, Classes.CONTEXT_MENU);

    const child = Utils.isFunction(children) ? (
        children({
            className: containerClassName,
            contentProps,
            onContextMenu: handleContextMenu,
            popover: maybePopover,
            ref: childRef,
        })
    ) : (
        <>
            {maybePopover}
            {React.createElement<React.HTMLAttributes<any>>(
                tagName,
                {
                    className: containerClassName,
                    onContextMenu: handleContextMenu,
                    ref: mergeRefs(childRef, userRef),
                    ...restProps,
                },
                children,
            )}
        </>
    );

    // force descendant Tooltips to be disabled when this context menu is open
    return <TooltipProvider forceDisable={isOpen}>{child}</TooltipProvider>;
});
ContextMenu.displayName = `${DISPLAYNAME_PREFIX}.ContextMenu`;

================================================================================

File: src\components\context-menu\contextMenuPopover.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Classes, DISPLAYNAME_PREFIX } from "../../common";
import { Popover } from "../popover/popover";
import type { PopoverTargetProps } from "../popover/popoverSharedProps";
import { Portal } from "../portal/portal";

import type { ContextMenuPopoverOptions, Offset } from "./contextMenuShared";

export interface ContextMenuPopoverProps extends ContextMenuPopoverOptions {
    isOpen: boolean;
    isDarkTheme?: boolean;
    content: React.JSX.Element;
    onClose?: () => void;
    targetOffset: Offset | undefined;
}

/**
 * A floating popover which is positioned at a given target offset inside its parent element container.
 * Used to display context menus. Note that this behaves differently from other popover components like
 * Popover and Tooltip, which wrap their children with interaction handlers -- if you're looking for the whole
 * interaction package, use ContextMenu instead.
 *
 * @see https://blueprintjs.com/docs/#core/components/context-menu-popover
 */
export const ContextMenuPopover = React.memo(function _ContextMenuPopover(props: ContextMenuPopoverProps) {
    const {
        content,
        popoverClassName,
        onClose,
        isDarkTheme = false,
        rootBoundary = "viewport",
        targetOffset,
        transitionDuration = 100,
        ...popoverProps
    } = props;
    const cancelContextMenu = React.useCallback((e: React.SyntheticEvent<HTMLDivElement>) => e.preventDefault(), []);

    // Popover should attach its ref to the virtual target we render inside a Portal, not the "inline" child target
    const renderTarget = React.useCallback(
        ({ ref }: PopoverTargetProps) => (
            <Portal>
                <div className={Classes.CONTEXT_MENU_VIRTUAL_TARGET} style={targetOffset} ref={ref} />
            </Portal>
        ),
        [targetOffset],
    );

    const handleInteraction = React.useCallback(
        (nextOpenState: boolean) => {
            if (!nextOpenState) {
                onClose?.();
            }
        },
        [onClose],
    );

    return (
        <Popover
            placement="right-start"
            rootBoundary={rootBoundary}
            transitionDuration={transitionDuration}
            {...popoverProps}
            content={
                // this prevents right-clicking inside our context menu
                <div onContextMenu={cancelContextMenu}>{content}</div>
            }
            enforceFocus={false}
            // Generate key based on offset so that a new Popover instance is created
            // when offset changes, to force recomputing position.
            key={getPopoverKey(targetOffset)}
            hasBackdrop={true}
            backdropProps={{ className: Classes.CONTEXT_MENU_BACKDROP }}
            minimal={true}
            onInteraction={handleInteraction}
            popoverClassName={classNames(Classes.CONTEXT_MENU_POPOVER, popoverClassName, {
                [Classes.DARK]: isDarkTheme,
            })}
            positioningStrategy="fixed"
            renderTarget={renderTarget}
        />
    );
});
ContextMenuPopover.displayName = `${DISPLAYNAME_PREFIX}.ContextMenuPopover`;

function getPopoverKey(targetOffset: Offset | undefined) {
    return targetOffset === undefined ? "default" : `${targetOffset.left}x${targetOffset.top}`;
}

================================================================================

File: src\components\context-menu\contextMenuShared.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { OverlayLifecycleProps } from "../overlay/overlayProps";
import type { PopoverProps } from "../popover/popover";

export type Offset = {
    left: number;
    top: number;
};

/**
 * A limited subset of props to forward along to the context menu popover overlay.
 *
 * Overriding `placement` is not recommended, as users expect context menus to open towards the bottom right
 * of their cursor, which is the default placement. However, this option is provided to help with rare cases where
 * the menu is triggered at the bottom and/or right edge of a window and the built-in popover flipping behavior does
 * not work effectively.
 */
export type ContextMenuPopoverOptions = OverlayLifecycleProps &
    Pick<PopoverProps, "placement" | "popoverClassName" | "transitionDuration" | "popoverRef" | "rootBoundary">;

================================================================================

File: src\components\context-menu\contextMenuSingleton.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";
import * as ReactDOM from "react-dom";

import { Classes } from "../../common";
import type { DOMMountOptions } from "../../common/utils/mountOptions";
import { OverlaysProvider } from "../../context/overlays/overlaysProvider";

import { ContextMenuPopover, type ContextMenuPopoverProps } from "./contextMenuPopover";

/** DOM element which contains the context menu singleton instance for the imperative ContextMenu APIs. */
let contextMenuElement: HTMLElement | undefined;

/**
 * Show a context menu at a particular offset from the top-left corner of the document.
 * The menu will appear below-right of this point and will flip to below-left if there is not enough
 * room onscreen. Additional props like `onClose`, `isDarkTheme`, etc. can be forwarded to the `<ContextMenuPopover>`.
 *
 * Context menus created with this API will automatically close when a user clicks outside the popover.
 * You may force them to close by using `hideContextMenu()`.
 *
 * Note that this API relies on global state in the @blueprintjs/core package, and should be used with caution,
 * especially if your build system allows multiple copies of Blueprint libraries to be bundled into an application at
 * once.
 *
 * Alternative APIs to consider which do not have the limitations of global state:
 *  - `<ContextMenu>`
 *  - `<ContextMenuPopover>`
 *
 * @see https://blueprintjs.com/docs/#core/components/context-menu-popover.imperative-api
 */
export function showContextMenu(
    props: Omit<ContextMenuPopoverProps, "isOpen">,
    options: DOMMountOptions<ContextMenuPopoverProps> = {},
) {
    const {
        container = document.body,
        domRenderer = ReactDOM.render,
        domUnmounter = ReactDOM.unmountComponentAtNode,
    } = options;

    if (contextMenuElement === undefined) {
        contextMenuElement = document.createElement("div");
        contextMenuElement.classList.add(Classes.CONTEXT_MENU);
        container.appendChild(contextMenuElement);
    } else {
        // N.B. It's important to unmount previous instances of the ContextMenuPopover rendered by this function.
        // Otherwise, React will detect no change in props sent to the already-mounted component, and therefore
        // do nothing after the first call to this function, leading to bugs like https://github.com/palantir/blueprint/issues/5949
        domUnmounter(contextMenuElement);
    }

    domRenderer(
        <OverlaysProvider>
            <UncontrolledContextMenuPopover {...props} />
        </OverlaysProvider>,
        contextMenuElement,
    );
}

/**
 * Hide a context menu that was created using `showContextMenu()`.
 *
 * Note that this API relies on global state in the @blueprintjs/core package, and should be used with caution.
 *
 * @see https://blueprintjs.com/docs/#core/components/context-menu-popover.imperative-api
 */
export function hideContextMenu(options: DOMMountOptions<ContextMenuPopoverProps> = {}) {
    const { domUnmounter = ReactDOM.unmountComponentAtNode } = options;

    if (contextMenuElement !== undefined) {
        domUnmounter(contextMenuElement);
        contextMenuElement = undefined;
    }
}

/**
 * A simple wrapper around `ContextMenuPopover` which is open by default and uncontrolled.
 * It closes when a user clicks outside the popover.
 */
function UncontrolledContextMenuPopover({ onClose, ...props }: Omit<ContextMenuPopoverProps, "isOpen">) {
    const [isOpen, setIsOpen] = React.useState(true);
    const handleClose = React.useCallback(() => {
        setIsOpen(false);
        onClose?.();
    }, [onClose]);

    return <ContextMenuPopover isOpen={isOpen} {...props} onClose={handleClose} />;
}

================================================================================

File: src\components\context-menu\_context-menu.scss
--------------------------------------------------------------------------------
// Copyright 2021 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";

.#{$ns}-context-menu-virtual-target {
  position: fixed;
}

================================================================================

File: src\components\control-card\checkboxCard.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Classes } from "../../common";
import { DISPLAYNAME_PREFIX } from "../../common/props";

import { ControlCard, type ControlCardProps } from "./controlCard";

export type CheckboxCardProps = Omit<ControlCardProps, "controlKind">;

/**
 * Checkbox Card component.
 *
 * @see https://blueprintjs.com/docs/#core/components/control-card.checkbox-card
 */
export const CheckboxCard: React.FC<CheckboxCardProps> = React.forwardRef((props, ref) => {
    const className = classNames(props.className, Classes.CHECKBOX_CONTROL_CARD);
    return <ControlCard {...props} className={className} controlKind="checkbox" ref={ref} />;
});
CheckboxCard.defaultProps = {
    alignIndicator: "left",
};
CheckboxCard.displayName = `${DISPLAYNAME_PREFIX}.CheckboxCard`;

================================================================================

File: src\components\control-card\control-card.md
--------------------------------------------------------------------------------
---
tag: new
---

@# Control card

A control card is an interactive [**Card**](#core/components/card) with an embedded form control.
There are a few supported form controls, each has a corresponding component API:

-   [**SwitchCard**](#core/components/control-card.switch-card)
-   [**CheckboxCard**](#core/components/control-card.checkbox-card)
-   [**RadioCard**](#core/components/control-card.radio-card)

The label may be specified as either `children` (`React.ReactNode`) or the `label` prop (`string`).

Users may click anywhere inside the card to toggle the control state.

By default, a "checked" control card will be displayed with the same appearance as a "selected" card.
This behavior may be toggled with the `showAsSelectedWhenChecked` prop.

@## Switch card

Card with an embedded [**Switch**](#core/components/switch) control (right-aligned by default).

Most of the properties in [**CardProps**](#core/components/card.props-interface) and
[**SwitchProps**](#core/components/switch.props-interface) are available on the root component.

@reactExample SwitchCardExample

@## Checkbox card

Card with an embedded [**Checkbox**](#core/components/checkbox) control (left-aligned by default).

Most of the properties in [**CardProps**](#core/components/card.props-interface) and
[**CheckboxProps**](#core/components/checkbox.props-interface) are available on the root component.

@reactExample CheckboxCardExample

@## Radio card

Card with an embedded [**Radio**](#core/components/radio) control (left-aligned by default).

Most of the properties in [**CardProps**](#core/components/card.props-interface) and
[**RadioProps**](#core/components/radio.props-interface) are available on the root component.

Just like the **Radio** component, a **RadioCard** is usually contained in a
[**RadioCardGroup**](#core/components/radio.radiogroup) which manages its selection state.

```tsx
import { RadioGroup, RadioCard } from "@blueprintjs/core";
import React from "react";

function RadioCardGroupExample() {
    const [selectedValue, setSelectedValue] = React.useState<string | undefined>();
    const handleChange = React.useCallback((event: React.FormEvent<HTMLInputElement>) => {
        setSelectedValue(event.currentTarget.value);
    }, []);

    return (
        <RadioGroup selectedValue={selectedValue} onChange={handleChange} label="Lunch Special">
            <RadioCard label="Soup" value="soup" />
            <RadioCard label="Salad" value="salad" />
            <RadioCard label="Sandwich" value="sandwich" />
        </RadioGroup>
    );
}
```

@reactExample RadioCardGroupExample

@## Props interface

@interface ControlCardProps

@## Combining with CardList

Control cards work just like regular cards inside a [**CardList**](#core/components/card-list).

@reactExample ControlCardListExample

================================================================================

File: src\components\control-card\controlCard.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Classes } from "../../common";
import { DISPLAYNAME_PREFIX, type HTMLInputProps } from "../../common/props";
import { Card, type CardProps } from "../card/card";
import type { CheckedControlProps, ControlProps } from "../forms/controlProps";
import { Checkbox, Radio, Switch } from "../forms/controls";

import { useCheckedControl } from "./useCheckedControl";

export type ControlKind = "switch" | "checkbox" | "radio";

/**
 * Subset of {@link CardProps} which can be used to adjust its behavior.
 */
type SupportedCardProps = Omit<CardProps, "interactive" | "onChange">;

/**
 * Subset of {@link ControlProps} which can be used to adjust its behavior.
 */
type SupportedControlProps = Pick<
    ControlProps,
    keyof CheckedControlProps | "alignIndicator" | "disabled" | "inputRef" | "label" | "value"
>;

/**
 * Shared props interface for all control card components, including `CheckboxCard`, `RadioCard`, and `SwitchCard`.
 * The label content may be specified as either `label` or `children`, but not both.
 */
export interface ControlCardProps extends SupportedCardProps, SupportedControlProps {
    /**
     * Which kind of form control to render inside the card.
     */
    controlKind: ControlKind;

    // N.B. this is split out of the root properties in the inerface because it would conflict with CardProps' HTMLDivProps
    /**
     * HTML input attributes to forward to the control `<input>` element.
     */
    inputProps?: HTMLInputProps;

    /**
     * Whether the component should use "selected" Card styling when checked.
     *
     * @default true
     */
    showAsSelectedWhenChecked?: boolean;
}

/**
 * ControlCard component, used to render a {@link Card} with a form control.
 *
 * @internal
 */
export const ControlCard: React.FC<ControlCardProps> = React.forwardRef((props, ref) => {
    const {
        alignIndicator,
        checked: _checked,
        children,
        className,
        controlKind,
        defaultChecked: _defaultChecked,
        disabled,
        inputProps,
        inputRef,
        label,
        onChange: _onChange,
        showAsSelectedWhenChecked,
        value,
        ...cardProps
    } = props;

    const { checked, onChange } = useCheckedControl(props);

    // use a container element to achieve a good flex layout
    const labelElement = <div className={Classes.CONTROL_CARD_LABEL}>{children ?? label}</div>;
    const controlProps: ControlProps = {
        alignIndicator,
        checked,
        disabled,
        inline: true,
        inputRef,
        labelElement,
        onChange,
        value,
        ...inputProps,
    };
    const classes = classNames(Classes.CONTROL_CARD, className, {
        [Classes.SELECTED]: showAsSelectedWhenChecked && checked,
    });

    return (
        <Card interactive={!disabled} className={classes} ref={ref} {...cardProps}>
            {controlKind === "switch" ? (
                <Switch {...controlProps} />
            ) : controlKind === "checkbox" ? (
                <Checkbox {...controlProps} />
            ) : controlKind === "radio" ? (
                <Radio {...controlProps} />
            ) : (
                labelElement
            )}
        </Card>
    );
});
ControlCard.defaultProps = {
    alignIndicator: "right",
    showAsSelectedWhenChecked: true,
};
ControlCard.displayName = `${DISPLAYNAME_PREFIX}.ControlCard`;

================================================================================

File: src\components\control-card\radioCard.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Classes } from "../../common";
import { DISPLAYNAME_PREFIX } from "../../common/props";

import { ControlCard, type ControlCardProps } from "./controlCard";

export type RadioCardProps = Omit<ControlCardProps, "controlKind">;

/**
 * Radio Card component.
 *
 * @see https://blueprintjs.com/docs/#core/components/control-card.radio-card
 */
export const RadioCard: React.FC<RadioCardProps> = React.forwardRef((props, ref) => {
    const className = classNames(props.className, Classes.RADIO_CONTROL_CARD);
    return <ControlCard {...props} className={className} controlKind="radio" ref={ref} />;
});
RadioCard.displayName = `${DISPLAYNAME_PREFIX}.RadioCard`;

================================================================================

File: src\components\control-card\switchCard.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Classes } from "../../common";
import { DISPLAYNAME_PREFIX } from "../../common/props";

import { ControlCard, type ControlCardProps } from "./controlCard";

export type SwitchCardProps = Omit<ControlCardProps, "controlKind">;

/**
 * Switch Card component.
 *
 * @see https://blueprintjs.com/docs/#core/components/control-card.switch-card
 */
export const SwitchCard: React.FC<SwitchCardProps> = React.forwardRef((props, ref) => {
    const className = classNames(props.className, Classes.SWITCH_CONTROL_CARD);
    return <ControlCard {...props} className={className} controlKind="switch" ref={ref} />;
});
SwitchCard.displayName = `${DISPLAYNAME_PREFIX}.SwitchCard`;

================================================================================

File: src\components\control-card\useCheckedControl.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

import type { CheckedControlProps } from "../forms/controlProps";

/**
 * Keep track of a control's checked state in both controlled and uncontrolled modes
 */
export function useCheckedControl(props: CheckedControlProps) {
    const [checkedStateForUncontrolledMode, setChecked] = React.useState(() => props.defaultChecked ?? false);

    // If the checked prop is passed, this input is in "controlled mode" and
    // should always reflect the value of the controlled prop. Any internal
    // state tracked for "uncontrolled mode" should be ignored.
    const checked = props.checked ?? checkedStateForUncontrolledMode;

    const onChange = React.useCallback<React.ChangeEventHandler<HTMLInputElement>>(
        e => {
            setChecked(c => !c);
            props.onChange?.(e);
        },
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [props.onChange],
    );
    return { checked, onChange };
}

================================================================================

File: src\components\control-card\_control-card.scss
--------------------------------------------------------------------------------
// Copyright 2023 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../card/card-variables";

// use an extra selector to increase specificity
.#{$ns}-card.#{$ns}-control-card {
  &,
  .#{$ns}-card-list > & {
    // min-height & padding will be set on the label element so that it can take up the full size of the card and
    // its entire visual element will be interactive  This is partially to work around https://github.com/palantir/blueprint/issues/6251
    min-height: auto;
    padding: 0;
  }
}

.#{$ns}-control-card {
  // need a lot of specificity here to override control styles for (switch, checkbox, etc.) and (align-left, align-right)
  // N.B. this is more space-efficient (in terms of generated CSS) than listing multiple compound selectors
  .#{$ns}-control.#{$ns}-control.#{$ns}-control {
    // control indicators should be top-aligned
    align-items: flex-start;
    display: flex;
    gap: $pt-grid-size;
    margin: 0;
    padding: $card-padding;
    width: calc(100%);

    &.#{$ns}-align-left {
      flex-direction: row;
      justify-content: flex-start;
    }

    &.#{$ns}-align-right {
      flex-direction: row-reverse;
      justify-content: space-between;
    }

    .#{$ns}-card-list & {
      padding: $card-padding;
    }

    .#{$ns}-card-list.#{$ns}-compact & {
      padding: $card-padding-compact;
    }

    .#{$ns}-control-indicator {
      margin: 0;
    }
  }

  &.#{$ns}-compact .#{$ns}-control.#{$ns}-control.#{$ns}-control {
    padding: $card-padding-compact;
  }
}

================================================================================

File: src\components\dialog\dialog.md
--------------------------------------------------------------------------------
@# Dialog

The **Dialog** component presents content overlaid over other parts of the UI via
[**Overlay2**](#core/components/overlay2).

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">Terminology note</h5>

The term "modal" is sometimes used to mean "dialog," but this is a misnomer.
_Modal_ is an adjective that describes parts of a UI. An element is considered to be "modal" if it
[blocks interaction with the rest of the application](https://en.wikipedia.org/wiki/Modal_window).
We use the term "dialog" in Blueprint to avoid confusion with the adjective.

</div>

Blueprint provides two types of dialogs:

1.  Standard dialog: show single view using the `<Dialog>` component
1.  Multi-step dialog: show multiple sequential views using the `<MultistepDialog>` component.

@## Dialog

@reactExample DialogExample

@## Usage

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

[OverlaysProvider](#core/context/overlays-provider) recommended

</h5>

This component renders an **Overlay2** which works best inside a React tree which includes an
**OverlaysProvider**. Blueprint v5.x includes a backwards-compatibile shim which allows this context
to be optional, but it will be required in a future major version. See the full
[migration guide](https://github.com/palantir/blueprint/wiki/Overlay2-migration) on the wiki.

</div>

A standard **Dialog** renders its contents in an [**Overlay2**](#core/components/overlay2) with a
`Classes.DIALOG` element. You can use some simple dialog markup sub-components or CSS classes
to structure its contents:

```tsx
<Dialog title="Informational dialog" icon="info-sign">
    <DialogBody>{/* body contents here */}</DialogBody>
    <DialogFooter actions={<Button intent="primary" text="Close" onClick={/* ... */} />} />
</Dialog>
```

@### Dialog props

`<Dialog>` is a stateless React component controlled by the `isOpen` prop.

The children you provide to this component are rendered as contents inside the
`Classes.DIALOG` element.

@interface DialogProps

@### Dialog body props

`<DialogBody>` renders a `Classes.DIALOG_BODY` element, optionally with a constrained container
height which allows vertical scrolling of its content.

@interface DialogBodyProps

@### Dialog footer props

`<DialogFooter>` renders a `Classes.DIALOG_FOOTER` element. Footer "actions" are rendered
towards the right side of the footer container element.

@interface DialogFooterProps

@### CSS API

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use `<Dialog>`

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

</div>

@css dialog

@## Multistep dialog

@reactExample MultistepDialogExample

@### Multistep dialog props

**MultistepDialog** is a wrapper around **Dialog** that displays a dialog with multiple steps. Each step has a
corresponding panel.

This component expects `<DialogStep>` child elements: each "step" is rendered in order and its panel is shown as the
dialog body content when the corresponding step is selected in the navigation panel.

@interface MultistepDialogProps

@### DialogStep

**DialogStep** is a minimal wrapper with no functionality of its own&mdash;it is managed entirely by its parent
**MultistepDialog** container. Typically, you should render a `<DialogBody>` element as the `panel` element. A step's
title text can be set via the `title` prop.

@interface DialogStepProps

================================================================================

File: src\components\dialog\dialog.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { type IconName, IconSize, SmallCross } from "@blueprintjs/icons";

import {
    AbstractPureComponent,
    Classes,
    DISPLAYNAME_PREFIX,
    type MaybeElement,
    mergeRefs,
    type Props,
} from "../../common";
import * as Errors from "../../common/errors";
import { uniqueId } from "../../common/utils";
import { Button } from "../button/buttons";
import { H6 } from "../html/html";
import { Icon } from "../icon/icon";
import type { BackdropProps, OverlayableProps } from "../overlay/overlayProps";
import { Overlay2 } from "../overlay2/overlay2";

export interface DialogProps extends OverlayableProps, BackdropProps, Props {
    /** Dialog contents. */
    children?: React.ReactNode;

    /**
     * Toggles the visibility of the overlay and its children.
     * This prop is required because the component is controlled.
     */
    isOpen: boolean;

    /**
     * Dialog always has a backdrop so this prop cannot be overriden.
     */
    hasBackdrop?: never;

    /**
     * Name of a Blueprint UI icon (or an icon element) to render in the
     * dialog's header. Note that the header will only be rendered if `title` is
     * provided.
     */
    icon?: IconName | MaybeElement;

    /**
     * Whether to show the close button in the dialog's header.
     * Note that the header will only be rendered if `title` is provided.
     *
     * @default true
     */
    isCloseButtonShown?: boolean;

    /**
     * @default "dialog"
     */
    role?: Extract<React.AriaRole, "dialog" | "alertdialog">;

    /**
     * CSS styles to apply to the dialog.
     *
     * @default {}
     */
    style?: React.CSSProperties;

    /**
     * Title of the dialog. If provided, an element with `Classes.DIALOG_HEADER`
     * will be rendered inside the dialog before any children elements.
     */
    title?: React.ReactNode;

    /**
     * Name of the transition for internal `CSSTransition`. Providing your own
     * name here will require defining new CSS transition properties.
     */
    transitionName?: string;

    /**
     * Ref attached to the `Classes.DIALOG_CONTAINER` element.
     */
    containerRef?: React.Ref<HTMLDivElement>;

    /**
     * ID of the element that contains title or label text for this dialog.
     *
     * By default, if the `title` prop is supplied, this component will generate
     * a unique ID for the `<H5>` title element and use that ID here.
     */
    "aria-labelledby"?: string;

    /**
     * ID of an element that contains description text inside this dialog.
     */
    "aria-describedby"?: string;
}

/**
 * Dialog component.
 *
 * @see https://blueprintjs.com/docs/#core/components/dialog
 */
export class Dialog extends AbstractPureComponent<DialogProps> {
    public static defaultProps: DialogProps = {
        canOutsideClickClose: true,
        isOpen: false,
    };

    private childRef = React.createRef<HTMLDivElement>();

    private titleId: string;

    public static displayName = `${DISPLAYNAME_PREFIX}.Dialog`;

    public constructor(props: DialogProps) {
        super(props);

        const id = uniqueId("bp-dialog");
        this.titleId = `title-${id}`;
    }

    public render() {
        const { className, children, containerRef, style, title, role = "dialog", ...overlayProps } = this.props;

        return (
            <Overlay2
                {...overlayProps}
                className={Classes.OVERLAY_SCROLL_CONTAINER}
                childRef={this.childRef}
                hasBackdrop={true}
            >
                <div
                    className={Classes.DIALOG_CONTAINER}
                    ref={containerRef === undefined ? this.childRef : mergeRefs(containerRef, this.childRef)}
                >
                    <div
                        className={classNames(Classes.DIALOG, className)}
                        role={role}
                        aria-modal={overlayProps.enforceFocus ?? Overlay2.defaultProps?.enforceFocus}
                        aria-labelledby={this.props["aria-labelledby"] || (title ? this.titleId : undefined)}
                        aria-describedby={this.props["aria-describedby"]}
                        style={style}
                    >
                        {this.maybeRenderHeader()}
                        {children}
                    </div>
                </div>
            </Overlay2>
        );
    }

    protected validateProps(props: DialogProps) {
        if (props.title == null) {
            if (props.icon != null) {
                console.warn(Errors.DIALOG_WARN_NO_HEADER_ICON);
            }
            if (props.isCloseButtonShown != null) {
                console.warn(Errors.DIALOG_WARN_NO_HEADER_CLOSE_BUTTON);
            }
        }
    }

    private maybeRenderCloseButton() {
        // show close button if prop is undefined or null
        // this gives us a behavior as if the default value were `true`
        if (this.props.isCloseButtonShown !== false) {
            return (
                <Button
                    aria-label="Close"
                    className={Classes.DIALOG_CLOSE_BUTTON}
                    icon={<SmallCross size={IconSize.STANDARD} />}
                    minimal={true}
                    onClick={this.props.onClose}
                />
            );
        } else {
            return undefined;
        }
    }

    private maybeRenderHeader() {
        const { icon, title } = this.props;
        if (title == null) {
            return undefined;
        }
        return (
            <div className={Classes.DIALOG_HEADER}>
                <Icon icon={icon} size={IconSize.STANDARD} aria-hidden={true} tabIndex={-1} />
                <H6 id={this.titleId}>{title}</H6>
                {this.maybeRenderCloseButton()}
            </div>
        );
    }
}

================================================================================

File: src\components\dialog\dialogBody.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes } from "../../common";
import type { Props } from "../../common/props";

export interface DialogBodyProps extends Props {
    /** Dialog body contents. */
    children?: React.ReactNode;

    /**
     * Enable scrolling for the container
     *
     * @default true
     */
    useOverflowScrollContainer?: boolean;
}

/**
 * Dialog body component.
 *
 * @see https://blueprintjs.com/docs/#core/components/dialog.dialog-body-props
 */
export class DialogBody extends AbstractPureComponent<DialogBodyProps> {
    public static defaultProps: DialogBodyProps = {
        useOverflowScrollContainer: true,
    };

    public render() {
        return (
            <div
                className={classNames(Classes.DIALOG_BODY, this.props.className, {
                    [Classes.DIALOG_BODY_SCROLL_CONTAINER]: this.props.useOverflowScrollContainer,
                })}
            >
                {this.props.children}
            </div>
        );
    }
}

================================================================================

File: src\components\dialog\dialogFooter.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes } from "../../common";
import type { Props } from "../../common/props";

export interface DialogFooterProps extends Props {
    /** Child contents are rendered on the left side of the footer. */
    children?: React.ReactNode;

    /** Dialog actions (typically buttons) are rendered on the right side of the footer. */
    actions?: React.ReactNode;

    /**
     * Use a "minimal" appearance for the footer, simply applying an HTML role and
     * some visual padding. This is useful for small dialogs, and should not be used
     * with `<DialogBody useOverflowScrollContainer>`.
     *
     * Note that this is the default behavior when using the CSS API, since that's
     * how the `-dialog-footer` class was first introduced, so these styles are
     * applied without a "modifier" class.
     *
     * When using the JS component API, `minimal` is false by default.
     *
     * Show the footer close from the content.
     * Do not use with scroll body
     * Use for small dialogs (confirm)
     *
     * @default false;
     */
    minimal?: boolean;
}

/**
 * Dialog footer component.
 *
 * @see https://blueprintjs.com/docs/#core/components/dialog.dialog-footer-props
 */
export class DialogFooter extends AbstractPureComponent<DialogFooterProps> {
    public static defaultProps: DialogFooterProps = {
        minimal: false,
    };

    public render() {
        return (
            <div
                className={classNames(Classes.DIALOG_FOOTER, this.props.className, {
                    [Classes.DIALOG_FOOTER_FIXED]: !this.props.minimal,
                })}
            >
                {this.renderMainSection()}
                {this.maybeRenderActionsSection()}
            </div>
        );
    }

    /** Render the main footer section (left aligned). */
    private renderMainSection() {
        return <div className={Classes.DIALOG_FOOTER_MAIN_SECTION}>{this.props.children}</div>;
    }

    /** Optionally render the footer actions (right aligned). */
    private maybeRenderActionsSection() {
        const { actions } = this.props;
        if (actions == null) {
            return undefined;
        }
        return <div className={Classes.DIALOG_FOOTER_ACTIONS}>{actions}</div>;
    }
}

================================================================================

File: src\components\dialog\dialogStep.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2020 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes } from "../../common";
import { DISPLAYNAME_PREFIX, type HTMLDivProps, type Props } from "../../common/props";

import type { DialogStepButtonProps } from "./dialogStepButton";

export type DialogStepId = string | number;

export interface DialogStepProps extends Props, Omit<HTMLDivProps, "id" | "title" | "onClick"> {
    /**
     * Unique identifier used to identify which step is selected.
     */
    id: DialogStepId;

    /**
     * Panel content, rendered by the parent `MultistepDialog` when this step is active.
     */
    panel: React.JSX.Element;

    /**
     * Space-delimited string of class names applied to multistep dialog panel container.
     */
    panelClassName?: string;

    /**
     * Content of step title element, rendered in a list left of the active panel.
     */
    title?: React.ReactNode;

    /**
     * Props for the back button.
     */
    backButtonProps?: DialogStepButtonProps;

    /**
     * Props for the next button.
     */
    nextButtonProps?: DialogStepButtonProps;
}

/**
 * Dialog step component.
 *
 * @see https://blueprintjs.com/docs/#core/components/dialog.dialogstep
 */
export class DialogStep extends AbstractPureComponent<DialogStepProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.DialogStep`;

    // this component is never rendered directly; see MultistepDialog#renderDialogStepPanel()
    /* istanbul ignore next */
    public render() {
        const { className } = this.props;
        return (
            <div className={Classes.DIALOG_STEP_CONTAINER} role="tab">
                <div className={classNames(Classes.DIALOG_STEP, className)} />
            </div>
        );
    }
}

================================================================================

File: src\components\dialog\dialogStepButton.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2020 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

import type { ButtonSharedPropsAndAttributes } from "../button/buttonProps";
import { AnchorButton } from "../button/buttons";
import { Tooltip, type TooltipProps } from "../tooltip/tooltip";

export type DialogStepButtonProps = Partial<ButtonSharedPropsAndAttributes> & {
    /** If defined, the button will be wrapped with a tooltip with the specified content. */
    tooltipContent?: TooltipProps["content"];
};

export function DialogStepButton({ tooltipContent, ...props }: DialogStepButtonProps) {
    const button = <AnchorButton {...props} />;

    if (tooltipContent !== undefined) {
        return <Tooltip content={tooltipContent}>{button}</Tooltip>;
    } else {
        return button;
    }
}

================================================================================

File: src\components\dialog\multistepDialog.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2020 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes, type Position, Utils } from "../../common";
import { DISPLAYNAME_PREFIX } from "../../common/props";
import { clickElementOnKeyPress } from "../../common/utils";

import { Dialog, type DialogProps } from "./dialog";
import { DialogFooter } from "./dialogFooter";
import { DialogStep, type DialogStepId, type DialogStepProps } from "./dialogStep";
import { DialogStepButton, type DialogStepButtonProps } from "./dialogStepButton";

type DialogStepElement = React.ReactElement<DialogStepProps & { children: React.ReactNode }>;

export type MultistepDialogNavPosition = typeof Position.TOP | typeof Position.LEFT | typeof Position.RIGHT;

export interface MultistepDialogProps extends DialogProps {
    /**
     * Props for the back button.
     */
    backButtonProps?: DialogStepButtonProps;

    /** Dialog steps. */
    children?: React.ReactNode;

    /**
     * Props for the close button that appears in the footer.
     */
    closeButtonProps?: DialogStepButtonProps;

    /**
     * Props for the button to display on the final step.
     */
    finalButtonProps?: DialogStepButtonProps;

    /**
     * Position of the step navigation within the dialog.
     *
     * @default "left"
     */
    navigationPosition?: MultistepDialogNavPosition;

    /**
     * Props for the next button.
     */
    nextButtonProps?: DialogStepButtonProps;

    /**
     * A callback that is invoked when the user selects a different step by clicking on back, next, or a step itself.
     */
    onChange?(
        newDialogStepId: DialogStepId,
        prevDialogStepId: DialogStepId | undefined,
        event: React.MouseEvent<HTMLElement>,
    ): void;

    /**
     * Whether to reset the dialog state to its initial state on close.
     * By default, closing the dialog will reset its state.
     *
     * @default true
     */
    resetOnClose?: boolean;

    /**
     * Whether the footer close button is shown. When this value is true, the button will appear
     * regardless of the value of `isCloseButtonShown`.
     *
     * @default false
     */
    showCloseButtonInFooter?: boolean;

    /**
     * A 0 indexed initial step to start off on, to start in the middle of the dialog, for example.
     * If the provided index exceeds the number of steps, it defaults to the last step.
     * If a negative index is provided, it defaults to the first step.
     */
    initialStepIndex?: number;
}

interface MultistepDialogState {
    lastViewedIndex: number;
    selectedIndex: number;
}

const PADDING_BOTTOM = 0;

const MIN_WIDTH = 800;

/**
 * Multi-step dialog component.
 *
 * @see https://blueprintjs.com/docs/#core/components/dialog.multistep-dialog
 */
export class MultistepDialog extends AbstractPureComponent<MultistepDialogProps, MultistepDialogState> {
    public static displayName = `${DISPLAYNAME_PREFIX}.MultistepDialog`;

    public static defaultProps: Partial<MultistepDialogProps> = {
        canOutsideClickClose: true,
        isOpen: false,
        navigationPosition: "left",
        resetOnClose: true,
        showCloseButtonInFooter: false,
    };

    public state: MultistepDialogState = this.getInitialIndexFromProps(this.props);

    public render() {
        const { className, navigationPosition, showCloseButtonInFooter, isCloseButtonShown, ...otherProps } =
            this.props;

        return (
            <Dialog
                isCloseButtonShown={isCloseButtonShown}
                {...otherProps}
                className={classNames(
                    {
                        [Classes.MULTISTEP_DIALOG_NAV_RIGHT]: navigationPosition === "right",
                        [Classes.MULTISTEP_DIALOG_NAV_TOP]: navigationPosition === "top",
                    },
                    className,
                )}
                style={this.getDialogStyle()}
            >
                <div className={Classes.MULTISTEP_DIALOG_PANELS}>
                    {this.renderLeftPanel()}
                    {this.maybeRenderRightPanel()}
                </div>
            </Dialog>
        );
    }

    public componentDidUpdate(prevProps: MultistepDialogProps) {
        if (
            (prevProps.resetOnClose || prevProps.initialStepIndex !== this.props.initialStepIndex) &&
            !prevProps.isOpen &&
            this.props.isOpen
        ) {
            this.setState(this.getInitialIndexFromProps(this.props));
        }
    }

    private getDialogStyle() {
        return { minWidth: MIN_WIDTH, paddingBottom: PADDING_BOTTOM, ...this.props.style };
    }

    private renderLeftPanel() {
        return (
            <div className={Classes.MULTISTEP_DIALOG_LEFT_PANEL} role="tablist" aria-label="steps">
                {this.getDialogStepChildren().filter(isDialogStepElement).map(this.renderDialogStep)}
            </div>
        );
    }

    private renderDialogStep = (step: DialogStepElement, index: number) => {
        const stepNumber = index + 1;
        const hasBeenViewed = this.state.lastViewedIndex >= index;
        const currentlySelected = this.state.selectedIndex === index;
        const handleClickDialogStep =
            index > this.state.lastViewedIndex ? undefined : this.getDialogStepChangeHandler(index);
        return (
            <div
                className={classNames(Classes.DIALOG_STEP_CONTAINER, {
                    [Classes.ACTIVE]: currentlySelected,
                    [Classes.DIALOG_STEP_VIEWED]: hasBeenViewed,
                })}
                key={index}
                aria-disabled={!currentlySelected && !hasBeenViewed}
                aria-selected={currentlySelected}
                role="tab"
            >
                <div
                    className={Classes.DIALOG_STEP}
                    onClick={handleClickDialogStep}
                    tabIndex={handleClickDialogStep ? 0 : -1}
                    // enable enter key to take effect on the div as if it were a button
                    onKeyDown={clickElementOnKeyPress(["Enter", " "])}
                >
                    <div className={Classes.DIALOG_STEP_ICON}>{stepNumber}</div>
                    <div className={Classes.DIALOG_STEP_TITLE}>{step.props.title}</div>
                </div>
            </div>
        );
    };

    private maybeRenderRightPanel() {
        const steps = this.getDialogStepChildren();
        if (steps.length <= this.state.selectedIndex) {
            return null;
        }

        const { className, panel, panelClassName } = steps[this.state.selectedIndex].props;
        return (
            <div className={classNames(Classes.MULTISTEP_DIALOG_RIGHT_PANEL, className, panelClassName)}>
                {panel}
                {this.renderFooter()}
            </div>
        );
    }

    private renderFooter() {
        const { closeButtonProps, showCloseButtonInFooter, onClose } = this.props;
        const maybeCloseButton = !showCloseButtonInFooter ? undefined : (
            <DialogStepButton text="Close" onClick={onClose} {...closeButtonProps} />
        );
        return <DialogFooter actions={this.renderButtons()}>{maybeCloseButton}</DialogFooter>;
    }

    private renderButtons() {
        const { selectedIndex } = this.state;
        const steps = this.getDialogStepChildren();
        const buttons = [];

        if (this.state.selectedIndex > 0) {
            const backButtonProps = steps[selectedIndex].props.backButtonProps ?? this.props.backButtonProps;
            buttons.push(
                <DialogStepButton
                    key="back"
                    onClick={this.getDialogStepChangeHandler(selectedIndex - 1)}
                    text="Back"
                    {...backButtonProps}
                />,
            );
        }

        if (selectedIndex === this.getDialogStepChildren().length - 1) {
            buttons.push(
                <DialogStepButton intent="primary" key="final" text="Submit" {...this.props.finalButtonProps} />,
            );
        } else {
            const nextButtonProps = steps[selectedIndex].props.nextButtonProps ?? this.props.nextButtonProps;
            buttons.push(
                <DialogStepButton
                    intent="primary"
                    key="next"
                    onClick={this.getDialogStepChangeHandler(selectedIndex + 1)}
                    text="Next"
                    {...nextButtonProps}
                />,
            );
        }

        return buttons;
    }

    private getDialogStepChangeHandler(index: number) {
        return (event: React.MouseEvent<HTMLElement>) => {
            if (this.props.onChange !== undefined) {
                const steps = this.getDialogStepChildren();
                const prevStepId = steps[this.state.selectedIndex].props.id;
                const newStepId = steps[index].props.id;
                this.props.onChange(newStepId, prevStepId, event);
            }
            this.setState({
                lastViewedIndex: Math.max(this.state.lastViewedIndex, index),
                selectedIndex: index,
            });
        };
    }

    /** Filters children to only `<DialogStep>`s */
    private getDialogStepChildren(props: MultistepDialogProps & { children?: React.ReactNode } = this.props) {
        return React.Children.toArray(props.children).filter(isDialogStepElement);
    }

    private getInitialIndexFromProps(props: MultistepDialogProps) {
        if (props.initialStepIndex !== undefined) {
            const boundedInitialIndex = Math.max(
                0,
                Math.min(props.initialStepIndex, this.getDialogStepChildren(props).length - 1),
            );
            return {
                lastViewedIndex: boundedInitialIndex,
                selectedIndex: boundedInitialIndex,
            };
        } else {
            return {
                lastViewedIndex: 0,
                selectedIndex: 0,
            };
        }
    }
}

function isDialogStepElement(child: any): child is DialogStepElement {
    return Utils.isElementOfType(child, DialogStep);
}

================================================================================

File: src\components\dialog\_dialog-body.scss
--------------------------------------------------------------------------------
// Copyright 2023 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

.#{$ns}-dialog-body {
  flex: 1 1 auto;
  // We'd like to use padding instead of margin here to be consistent with the -dialog-body-scroll-container class,
  // but we need to keep this margin style for backwards-compatibility. This may change in a future major version.
  // TODO(adahiya): migrate from margin to padding style (CSS breaking change)
  margin: $dialog-padding;
}

// modifier for -dialog-body class, works similarly to -overlay-scroll-container
.#{$ns}-dialog-body-scroll-container {
  margin: 0;
  max-height: 70vh;
  overflow: auto;
  padding: $dialog-padding;
}

================================================================================

File: src\components\dialog\_dialog-footer.scss
--------------------------------------------------------------------------------
// Copyright 2023 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

.#{$ns}-dialog-footer {
  flex: 0 0 auto;
  // We'd like to use padding instead of margin here to be consistent with the -dialog-footer-fixed class,
  // but we need to keep this margin style for backwards-compatibility. This may change in a future major version.
  // TODO(adahiya): migrate from margin to padding style (CSS breaking change)
  margin: $dialog-padding;
}

.#{$ns}-dialog-footer-fixed {
  align-items: center;
  background-color: $white;
  border-radius: 0  0 $dialog-border-radius $dialog-border-radius;
  border-top: 1px solid $pt-divider-black;
  display: flex;
  gap: $dialog-padding;
  justify-content: space-between;
  margin: 0;
  padding: $pt-grid-size $pt-grid-size $pt-grid-size $dialog-padding;

  .#{$ns}-dark & {
    background: $dark-gray4;
    border-top: 1px solid $pt-dark-divider-white;
  }
}

.#{$ns}-dialog-footer-main-section {
  flex: 1 1 auto;
}

.#{$ns}-dialog-footer-actions {
  display: flex;
  justify-content: flex-end;

  .#{$ns}-button {
    margin-left: $pt-grid-size;
  }
}

================================================================================

File: src\components\dialog\_dialog.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@use "sass:math";
@import "@blueprintjs/icons/lib/scss/variables";
@import "../../common/mixins";
@import "../../common/react-transition";
@import "../../common/variables";

/*
Dialog

Markup:
<!-- this container element fills its parent and centers the .#{$ns}-dialog within it -->
<div class="#{$ns}-dialog-container">
  <div class="#{$ns}-dialog">
    <div class="#{$ns}-dialog-header">
      <span class="#{$ns}-icon-large #{$ns}-icon-inbox"></span>
      <h5 class="#{$ns}-heading">Dialog header</h5>
      <button aria-label="Close" class="#{$ns}-dialog-close-button #{$ns}-button #{$ns}-minimal #{$ns}-icon-cross"></button>
    </div>
    <div class="#{$ns}-dialog-body">
      This dialog hasn't been wired up with any open or close interactions.
      It's just an example of markup and styles.
    </div>
    <div class="#{$ns}-dialog-footer">
      <div class="#{$ns}-dialog-footer-actions">
        <button type="button" class="#{$ns}-button">Secondary button</button>
        <button type="submit" class="#{$ns}-button #{$ns}-intent-primary">Primary button</button>
      </div>
    </div>
  </div>
</div>

Styleguide dialog
*/

$dialog-background-color: $light-gray5 !default;
$dialog-border-radius: $pt-border-radius * 2 !default;
$dialog-margin: ($pt-grid-size * 3) 0 !default;
$dialog-padding: $pt-grid-size * 1.5 !default;

.#{$ns}-dialog-container {
  $dialog-transition-props: (
    opacity: (0, 1),
    transform: (scale(0.5), scale(1))
  );

  @include react-transition(
    "#{$ns}-overlay",
    $dialog-transition-props,
    $duration: $pt-transition-duration * 3,
    $easing: $pt-transition-ease-bounce,
    $before: "&",
    $after: "> .#{$ns}-dialog"
  );
  align-items: center;
  display: flex;
  justify-content: center;
  min-height: 100%;
  pointer-events: none;
  user-select: none;
  width: 100%;
}

.#{$ns}-dialog {
  background: $dialog-background-color;
  border-radius: $dialog-border-radius;
  box-shadow: $pt-dialog-box-shadow;
  display: flex;
  flex-direction: column;
  margin: $dialog-margin;
  pointer-events: all;
  user-select: text;
  width: $pt-grid-size * 50;

  &:focus {
    outline: 0;
  }

  &.#{$ns}-dark,
  .#{$ns}-dark & {
    background: $pt-dark-app-background-color;
    box-shadow: $pt-dark-dialog-box-shadow;
    color: $pt-dark-text-color;
  }

  @media (forced-colors: active) and (prefers-color-scheme: dark) {
    border: 1px solid $pt-high-contrast-mode-border-color;
  }
}

$dialog-header-padding: math.div($pt-grid-size, 2);

.#{$ns}-dialog-header {
  align-items: center;
  background: $white;
  border-radius: $dialog-border-radius $dialog-border-radius 0 0;
  box-shadow: 0 1px 0 $pt-divider-black;
  display: flex;
  flex: 0 0 auto;
  min-height: $pt-button-height + $dialog-header-padding * 2;
  padding: $dialog-header-padding;
  padding-left: $dialog-padding;
  z-index: 0;

  .#{$ns}-icon-large,
  .#{$ns}-icon {
    color: $pt-icon-color;
    flex: 0 0 auto;
    margin-left: -3px;
    margin-right: $dialog-padding * 0.5;
  }

  .#{$ns}-heading {
    @include overflow-ellipsis();
    flex: 1 1 auto;
    line-height: inherit;
    margin: 0;

    &:last-child {
      margin-right: $dialog-padding;
    }
  }

  .#{$ns}-dark & {
    background: $dark-gray3;
    box-shadow: inset 0 0 0 1px $pt-dark-divider-white;

    .#{$ns}-icon-large,
    .#{$ns}-icon {
      color: $pt-dark-icon-color;
    }
  }

  @media (forced-colors: active) and (prefers-color-scheme: dark) {
    border-bottom: 1px solid $pt-high-contrast-mode-border-color;
  }
}

================================================================================

File: src\components\dialog\_multistep-dialog.scss
--------------------------------------------------------------------------------
// Copyright 2020 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "@blueprintjs/icons/lib/scss/variables";
@import "../../common/mixins";
@import "../../common/react-transition";
@import "../../common/variables";

$dialog-border-radius: $pt-border-radius * 2 !default;
$step-radius: $pt-border-radius * 2 !default;

.#{$ns}-multistep-dialog-panels {
  display: flex;

  // If title doesn't exist, this element will be the first child and top
  // borders needs to be rounded.
  &:first-child {
    .#{$ns}-dialog-step-container:first-child {
      border-radius: $dialog-border-radius 0 0 0;
    }

    .#{$ns}-multistep-dialog-right-panel {
      border-top-right-radius: $dialog-border-radius;
    }
  }

  .#{$ns}-multistep-dialog-nav-top & {
    flex-direction: column;

    // Handle case where title it not rendered.
    &:first-child {
      .#{$ns}-dialog-step-container:first-child {
        border-radius: $dialog-border-radius 0 0 0;
      }

      .#{$ns}-dialog-step-container:last-child {
        border-radius: 0 $dialog-border-radius 0 0;
      }
    }

    .#{$ns}-multistep-dialog-left-panel {
      flex-direction: row;
    }

    .#{$ns}-dialog-step-container {
      flex-grow: 1;

      &:not(:first-child) {
        border-left: 1px solid $pt-divider-black;
      }

      .#{$ns}-dark & {
        border-color: $pt-dark-divider-black;
      }
    }

    .#{$ns}-multistep-dialog-right-panel {
      border-left: none;
    }

    .#{$ns}-multistep-dialog-right-panel,
    .#{$ns}-multistep-dialog-footer {
      border-radius: 0 0 $dialog-border-radius $dialog-border-radius;
    }
  }

  .#{$ns}-multistep-dialog-nav-right & {
    flex-direction: row-reverse;

    // Handle case where title it not rendered.
    &:first-child {
      .#{$ns}-multistep-dialog-right-panel {
        border-radius: $dialog-border-radius 0 0 $dialog-border-radius;
      }

      .#{$ns}-dialog-step-container:first-child {
        border-radius: 0 $dialog-border-radius 0 0;
      }
    }

    .#{$ns}-multistep-dialog-left-panel {
      border-radius: 0 0 $dialog-border-radius 0;
    }

    .#{$ns}-multistep-dialog-right-panel {
      border-left: none;
      border-radius: $dialog-border-radius 0 0 $dialog-border-radius;
      border-right: 1px solid $pt-divider-black;

      .#{$ns}-dark & {
        border-color: $pt-dark-divider-black;
      }
    }

    .#{$ns}-dialog-footer {
      border-bottom-left-radius: 0;
    }
  }
}

.#{$ns}-multistep-dialog-left-panel {
  display: flex;
  flex: 1;
  flex-direction: column;

  .#{$ns}-dark & {
    background: $dark-gray2;
    border-bottom: 1px solid $pt-dark-divider-white;
    border-bottom-left-radius: $dialog-border-radius;
    border-left: 1px solid $pt-dark-divider-white;
  }
}

.#{$ns}-multistep-dialog-right-panel {
  background-color: $light-gray5;
  border-left: 1px solid $pt-divider-black;
  border-radius: 0 0 $dialog-border-radius 0;
  flex: 3;
  min-width: 0;

  .#{$ns}-dark & {
    background-color: $dark-gray3;
    border-bottom: 1px solid $pt-dark-divider-white;
    border-bottom-right-radius: $dialog-border-radius;
    border-left: 1px solid $pt-dark-divider-white;
    border-right: 1px solid $pt-dark-divider-white;
  }
}

.#{$ns}-multistep-dialog-footer {
  // Deprecating
}

.#{$ns}-dialog-step-container {
  background-color: $light-gray5;
  border-bottom: 1px solid $pt-divider-black;

  .#{$ns}-dark & {
    background: $dark-gray3;
    border-bottom: 1px solid $pt-dark-divider-white;
  }

  &.#{$ns}-dialog-step-viewed {
    background-color: $white;
    .#{$ns}-dark & {
      background: $dark-gray4;
    }
  }
}

.#{$ns}-dialog-step {
  align-items: center;
  border-radius: $step-radius;
  cursor: not-allowed;
  display: flex;
  margin: 4px;
  padding: 6px 14px;

  .#{$ns}-dark & {
    background: $dark-gray3;
  }

  // by default, steps are inactive until they are visited
  .#{$ns}-dialog-step-viewed & {
    background-color: $white;
    cursor: pointer;

    .#{$ns}-dark & {
      background: $dark-gray4;
    }
  }

  &:hover {
    background-color: $light-gray5;

    .#{$ns}-dark & {
      background: $dark-gray3;
    }
  }
}

.#{$ns}-dialog-step-icon {
  align-items: center;
  background-color: $pt-text-color-disabled;
  border-radius: 50%;
  color: $white;
  display: flex;
  height: 25px;
  justify-content: center;
  width: 25px;

  .#{$ns}-dark & {
    background-color: $pt-dark-icon-color-disabled;
  }

  .#{$ns}-active.#{$ns}-dialog-step-viewed & {
    background-color: $blue4;
  }

  .#{$ns}-dialog-step-viewed & {
    background-color: $gray3;
  }
}

.#{$ns}-dialog-step-title {
  color: $pt-text-color-disabled;
  flex: 1;
  padding-left: 10px;

  .#{$ns}-dark & {
    color: $pt-dark-text-color-disabled;
  }

  // step title is active only when the step is selected
  .#{$ns}-active.#{$ns}-dialog-step-viewed & {
    color: $blue4;
  }

  .#{$ns}-dialog-step-viewed:not(.#{$ns}-active) & {
    color: $pt-text-color;

    .#{$ns}-dark & {
      color: $pt-dark-text-color;
    }
  }
}

================================================================================

File: src\components\divider\divider.md
--------------------------------------------------------------------------------
@# Divider

__Divider__ visually separate contents with a thin line and margin on all sides.

Dividers work best in flex layouts where they will adapt to orientation without additional styles. Otherwise, a
divider will appear as a full-width 1px-high block element.

@reactExample DividerExample

@## Props interface

@interface DividerProps

================================================================================

File: src\components\divider\divider.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent } from "../../common";
import { DIVIDER } from "../../common/classes";
import { DISPLAYNAME_PREFIX, type Props } from "../../common/props";

export interface DividerProps extends Props, React.HTMLAttributes<HTMLElement> {
    /**
     * HTML tag to use for element.
     *
     * @default "div"
     */
    tagName?: keyof React.JSX.IntrinsicElements;
}

// this component is simple enough that tests would be purely tautological.
/* istanbul ignore next */

/**
 * Divider component.
 *
 * @see https://blueprintjs.com/docs/#core/components/divider
 */
export class Divider extends AbstractPureComponent<DividerProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.Divider`;

    public render(): React.JSX.Element {
        const { className, tagName = "div", ...htmlProps } = this.props;
        const classes = classNames(DIVIDER, className);
        return React.createElement(tagName, {
            ...htmlProps,
            className: classes,
        });
    }
}

================================================================================

File: src\components\divider\_divider.scss
--------------------------------------------------------------------------------
// Copyright 2018 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";

$divider-margin: $pt-grid-size * 0.5 !default;

.#{$ns}-divider {
  border-bottom: 1px solid $pt-divider-black;
  // since the element is empty, it will occupy minimal space and only show
  // the appropriate border based on direction of container.
  border-right: 1px solid $pt-divider-black;
  margin: $divider-margin;

  .#{$ns}-dark & {
    border-color: $pt-dark-divider-white;
  }
}

================================================================================

File: src\components\drawer\drawer.md
--------------------------------------------------------------------------------
@# Drawer

**Drawers** overlay content over existing parts of the UI and are anchored to the edge of the screen.
It is built using the lower-level [**Overlay2**](#core/components/overlay2) component.

@reactExample DrawerExample

@## Usage

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

[OverlaysProvider](#core/context/overlays-provider) recommended

</h5>

This component renders an **Overlay2** which works best inside a React tree which includes an
**OverlaysProvider**. Blueprint v5.x includes a backwards-compatibile shim which allows this context
to be optional, but it will be required in a future major version. See the full
[migration guide](https://github.com/palantir/blueprint/wiki/Overlay2-migration) on the wiki.

</div>

`<Drawer>` is a stateless React component controlled by its `isOpen` prop.

Use the `size` prop to set the size of a **Drawer**. This prop sets CSS `width` if `vertical={false}` (default)
and `height` otherwise. Constants are available for common sizes:

-   `DrawerSize.SMALL = 360px`
-   `DrawerSize.STANDARD = 50%` (default)
-   `DrawerSize.LARGE = 90%`

@## Props interface

@interface DrawerProps

================================================================================

File: src\components\drawer\drawer.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { type IconName, IconSize, SmallCross } from "@blueprintjs/icons";

import { AbstractPureComponent, Classes, type Props } from "../../common";
import * as Errors from "../../common/errors";
import { getPositionIgnoreAngles, isPositionHorizontal, type Position } from "../../common/position";
import { DISPLAYNAME_PREFIX, type MaybeElement } from "../../common/props";
import { Button } from "../button/buttons";
import { H4 } from "../html/html";
import { Icon } from "../icon/icon";
import type { BackdropProps, OverlayableProps } from "../overlay/overlayProps";
import { Overlay2 } from "../overlay2/overlay2";

export enum DrawerSize {
    SMALL = "360px",
    STANDARD = "50%",
    LARGE = "90%",
}

export interface DrawerProps extends OverlayableProps, BackdropProps, Props {
    /** Drawer contents. */
    children?: React.ReactNode;

    /**
     * Name of a Blueprint UI icon (or an icon element) to render in the
     * drawer's header. Note that the header will only be rendered if `title` is
     * provided.
     */
    icon?: IconName | MaybeElement;

    /**
     * Whether to show the close button in the dialog's header.
     * Note that the header will only be rendered if `title` is provided.
     *
     * @default true
     */
    isCloseButtonShown?: boolean;

    /**
     * Toggles the visibility of the overlay and its children.
     * This prop is required because the component is controlled.
     */
    isOpen: boolean;

    /**
     * Position of a drawer. All angled positions will be casted into pure positions
     * (top, bottom, left, or right).
     *
     * @default "right"
     */
    position?: Position;

    /**
     * CSS size of the drawer. This sets `width` if horizontal position (default)
     * and `height` otherwise.
     *
     * Constants are available for common sizes:
     * - `DrawerSize.SMALL = 360px`
     * - `DrawerSize.STANDARD = 50%`
     * - `DrawerSize.LARGE = 90%`
     *
     * @default DrawerSize.STANDARD = "50%"
     */
    size?: number | string;

    /**
     * CSS styles to apply to the dialog.
     *
     * @default {}
     */
    style?: React.CSSProperties;

    /**
     * Title of the dialog. If provided, an element with `Classes.DIALOG_HEADER`
     * will be rendered inside the dialog before any children elements.
     */
    title?: React.ReactNode;

    /**
     * Name of the transition for internal `CSSTransition`. Providing your own
     * name here will require defining new CSS transition properties.
     */
    transitionName?: string;
}

export class Drawer extends AbstractPureComponent<DrawerProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.Drawer`;

    public static defaultProps: DrawerProps = {
        canOutsideClickClose: true,
        isOpen: false,
        position: "right",
        style: {},
    };

    public render() {
        const { hasBackdrop, size, style, position } = this.props;
        const { className, children, ...overlayProps } = this.props;
        const realPosition = getPositionIgnoreAngles(position!);

        const classes = classNames(
            Classes.DRAWER,
            {
                [Classes.positionClass(realPosition) ?? ""]: true,
            },
            className,
        );

        const styleProp =
            size == null
                ? style
                : {
                      ...style,
                      [isPositionHorizontal(realPosition) ? "height" : "width"]: size,
                  };

        return (
            // N.B. the `OVERLAY_CONTAINER` class is a bit of a misnomer since it is only being used by the Drawer
            // component, but we keep it for backwards compatibility.
            <Overlay2 {...overlayProps} className={classNames({ [Classes.OVERLAY_CONTAINER]: hasBackdrop })}>
                <div className={classes} style={styleProp}>
                    {this.maybeRenderHeader()}
                    {children}
                </div>
            </Overlay2>
        );
    }

    protected validateProps(props: DrawerProps) {
        if (props.title == null) {
            if (props.icon != null) {
                console.warn(Errors.DIALOG_WARN_NO_HEADER_ICON);
            }
            if (props.isCloseButtonShown != null) {
                console.warn(Errors.DIALOG_WARN_NO_HEADER_CLOSE_BUTTON);
            }
        }
        if (props.position != null) {
            if (props.position !== getPositionIgnoreAngles(props.position)) {
                console.warn(Errors.DRAWER_ANGLE_POSITIONS_ARE_CASTED);
            }
        }
    }

    private maybeRenderCloseButton() {
        // `isCloseButtonShown` can't be defaulted through default props because of props validation
        // so this check actually defaults it to true (fails only if directly set to false)
        if (this.props.isCloseButtonShown !== false) {
            return (
                <Button
                    aria-label="Close"
                    className={Classes.DIALOG_CLOSE_BUTTON}
                    icon={<SmallCross size={IconSize.LARGE} />}
                    minimal={true}
                    onClick={this.props.onClose}
                />
            );
        } else {
            return null;
        }
    }

    private maybeRenderHeader() {
        const { icon, title } = this.props;
        if (title == null) {
            return null;
        }
        return (
            <div className={Classes.DRAWER_HEADER}>
                <Icon icon={icon} size={IconSize.LARGE} />
                <H4>{title}</H4>
                {this.maybeRenderCloseButton()}
            </div>
        );
    }
}

================================================================================

File: src\components\drawer\_drawer.scss
--------------------------------------------------------------------------------
// Copyright 2018 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "@blueprintjs/icons/lib/scss/variables";
@import "../../common/mixins";
@import "../../common/react-transition";
@import "../../common/variables";

$drawer-margin: ($pt-grid-size * 3) 0 !default;
$drawer-padding: $pt-grid-size * 2 !default;

$drawer-default-size: 50%;

$drawer-background-color: $white !default;
$dark-drawer-background-color: $dark-gray4 !default;

.#{$ns}-drawer {
  background: $drawer-background-color;
  box-shadow: $pt-elevation-shadow-4;
  display: flex;
  flex-direction: column;
  margin: 0;
  padding: 0;

  &:focus {
    outline: 0;
  }

  &.#{$ns}-position-top {
    @include react-transition-phase(
      "#{$ns}-overlay",
      "enter",
      (transform: (translateY(-100%), translateY(0))),
      $pt-transition-duration * 2,
      $pt-transition-ease,
      $before: "&"
    );
    @include react-transition-phase(
      "#{$ns}-overlay",
      "exit",
      (transform: (translateY(-100%), translateY(0))),
      $pt-transition-duration,
      $before: "&"
    );
    height: $drawer-default-size;
    left: 0;
    right: 0;

    top: 0;

    @media (forced-colors: active) and (prefers-color-scheme: dark) {
      border-bottom: 1px solid $pt-high-contrast-mode-border-color;
    }
  }

  &.#{$ns}-position-bottom {
    @include react-transition-phase(
      "#{$ns}-overlay",
      "enter",
      (transform: (translateY(100%), translateY(0))),
      $pt-transition-duration * 2,
      $pt-transition-ease,
      $before: "&"
    );
    @include react-transition-phase(
      "#{$ns}-overlay",
      "exit",
      (transform: (translateY(100%), translateY(0))),
      $pt-transition-duration,
      $before: "&"
    );
    bottom: 0;
    height: $drawer-default-size;
    left: 0;

    right: 0;

    @media (forced-colors: active) and (prefers-color-scheme: dark) {
      border-top: 1px solid $pt-high-contrast-mode-border-color;
    }
  }

  &.#{$ns}-position-left {
    @include react-transition-phase(
      "#{$ns}-overlay",
      "enter",
      (transform: (translateX(-100%), translateX(0))),
      $pt-transition-duration * 2,
      $pt-transition-ease,
      $before: "&"
    );
    @include react-transition-phase(
      "#{$ns}-overlay",
      "exit",
      (transform: (translateX(-100%), translateX(0))),
      $pt-transition-duration,
      $before: "&"
    );
    bottom: 0;
    left: 0;

    top: 0;
    width: $drawer-default-size;

    @media (forced-colors: active) and (prefers-color-scheme: dark) {
      border-right: 1px solid $pt-high-contrast-mode-border-color;
    }
  }

  &.#{$ns}-position-right {
    @include react-transition-phase(
      "#{$ns}-overlay",
      "enter",
      (transform: (translateX(100%), translateX(0))),
      $pt-transition-duration * 2,
      $pt-transition-ease,
      $before: "&"
    );
    @include react-transition-phase(
      "#{$ns}-overlay",
      "exit",
      (transform: (translateX(100%), translateX(0))),
      $pt-transition-duration,
      $before: "&"
    );
    bottom: 0;
    right: 0;

    top: 0;
    width: $drawer-default-size;

    @media (forced-colors: active) and (prefers-color-scheme: dark) {
      border-left: 1px solid $pt-high-contrast-mode-border-color;
    }
  }

  &.#{$ns}-dark,
  .#{$ns}-dark & {
    background: $dark-drawer-background-color;
    box-shadow: $pt-dark-dialog-box-shadow;
    color: $pt-dark-text-color;
  }
}

.#{$ns}-drawer-header {
  align-items: center;
  border-radius: 0;
  box-shadow: 0 1px 0 $pt-divider-black;
  display: flex;
  flex: 0 0 auto;
  min-height: $pt-icon-size-large + $drawer-padding;
  padding: $drawer-padding * 0.25;
  padding-left: $drawer-padding;
  position: relative;

  @media (forced-colors: active) and (prefers-color-scheme: dark) {
    border-bottom: 1px solid $pt-high-contrast-mode-border-color;
  }

  .#{$ns}-icon-large,
  .#{$ns}-icon {
    color: $pt-icon-color;
    flex: 0 0 auto;
    margin-right: $drawer-padding * 0.5;
  }

  .#{$ns}-heading {
    @include overflow-ellipsis();
    flex: 1 1 auto;
    line-height: inherit;
    margin: 0;

    &:last-child {
      margin-right: $drawer-padding;
    }
  }

  .#{$ns}-dark & {
    box-shadow: 0 1px 0 $pt-dark-divider-black;

    .#{$ns}-icon-large,
    .#{$ns}-icon {
      color: $pt-dark-icon-color;
    }
  }
}

.#{$ns}-drawer-body {
  flex: 1 1 auto;
  line-height: $pt-grid-size * 1.8;
  overflow: auto;
}

.#{$ns}-drawer-footer {
  box-shadow: inset 0 1px 0 $pt-divider-black;
  flex: 0 0 auto;
  padding: $drawer-padding*0.5 $drawer-padding;
  position: relative;

  .#{$ns}-dark & {
    box-shadow: inset 0 1px 0 $pt-dark-divider-black;
  }
}

================================================================================

File: src\components\editable-text\editable-text.md
--------------------------------------------------------------------------------
@# Editable text

__EditableText__ is an interactive component which appears as normal UI text. It transforms into an interactive
text input field when a user hovers and/or focuses on it.

The text input inherits all font styling from its ancestors, making for a seamless transition between reading and
editing text.

You might use this component for inline renaming, or for an
[editable multiline description](#core/components/editable-text.multiline-mode).
You should not use __EditableText__ when a more static, always-editable
[__InputGroup__](#core/components/input-group) or [__TextArea__](#core/components/text-area)
component would suffice.

@reactExample EditableTextExample

<div class="@ns-callout @ns-intent-danger @ns-icon-error @ns-callout-has-body-content">
    <h5 class="@ns-heading">Centering EditableText</h5>

**Do not center this component** using `text-align: center`, as it will cause an infinite loop
in the browser ([more details](https://github.com/JedWatson/react-select/issues/540)). Instead,
you should center the component via flexbox or with `position` and `transform: translateX(-50%)`.

</div>


@## Multiline mode

By default, __EditableText__ supports _exactly one line of text_ and will grow or shrink horizontally based on the
length of text.

You may enable the `multiline` prop to use a `<textarea>` which spans multiple lines instead of a single-line
`<input type="text">`. Multiline mode always appears at 100% width and adjusts _vertically_ based on length of text.
Use the `minLines` and `maxLines` props to constrain the height of the component.

```tsx
<EditableText multiline={true} minLines={3} maxLines={12} {...props} />
```

Users may confirm text in multiline mode by pressing <kbd>Ctrl + Enter</kbd> or <kbd>Command + Enter</kbd> rather than
<kbd>Enter</kbd>. (Pressing the <kbd>Enter</kbd> key by itself moves the cursor to the next line.) This behavior
can be inverted with the `confirmOnEnterKey` prop.

@## Usage

__EditableText__ is used like an [`<input>` element](https://facebook.github.io/react/docs/forms.html) and supports
controlled or uncontrolled usage through the `value` or `defaultValue` props, respectively. Use `onChange` to listen to
ongoing updates and use `onConfirm` and `onCancel` to listen only to completed or canceled edits.

The `onConfirm` and `onCancel` callbacks are invoked based on user interaction. The user presses <kbd>Enter</kbd>
(or <kbd>Command + Enter</kbd> when multiline) or blurs the input to confirm the current value, or presses
<kbd>Escape</kbd> to cancel. Canceling resets the field to the last confirmed value. Neither callback is invoked if the
value is unchanged.

@## Props interface

@interface EditableTextProps

================================================================================

File: src\components\editable-text\editableText.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes } from "../../common";
import { DISPLAYNAME_PREFIX, type IntentProps, type Props } from "../../common/props";
import { clamp } from "../../common/utils";

export interface EditableTextProps extends IntentProps, Props {
    /**
     * EXPERIMENTAL FEATURE.
     *
     * When true, this forces the component to _always_ render an editable input (or textarea)
     * both when the component is focussed and unfocussed, instead of the component's default
     * behavior of switching between a text span and a text input upon interaction.
     *
     * This behavior can help in certain applications where, for example, a custom right-click
     * context menu is used to supply clipboard copy and paste functionality.
     *
     * @default false
     */
    alwaysRenderInput?: boolean;

    /**
     * If `true` and in multiline mode, the `enter` key will trigger onConfirm and `mod+enter`
     * will insert a newline. If `false`, the key bindings are inverted such that `enter`
     * adds a newline.
     *
     * @default false
     */
    confirmOnEnterKey?: boolean;

    /** Default text value of uncontrolled input. */
    defaultValue?: string;

    /**
     * Whether the text can be edited.
     *
     * @default false
     */
    disabled?: boolean;

    /**
     * Ref to attach to the root element rendered by this component.
     *
     * N.B. this may be renamed to simply `ref` in a future major version of Blueprint, when this class component is
     * refactored into a function.
     */
    elementRef?: React.Ref<HTMLDivElement>;

    /** Whether the component is currently being edited. */
    isEditing?: boolean;

    /** Maximum number of characters allowed. Unlimited by default. */
    maxLength?: number;

    /** Minimum width in pixels of the input, when not `multiline`. */
    minWidth?: number;

    /**
     * Whether the component supports multiple lines of text.
     * This prop should not be changed during the component's lifetime.
     *
     * @default false
     */
    multiline?: boolean;

    /**
     * Maximum number of lines before scrolling begins, when `multiline`.
     */
    maxLines?: number;

    /**
     * Minimum number of lines (essentially minimum height), when `multiline`.
     *
     * @default 1
     */
    minLines?: number;

    /**
     * Placeholder text when there is no value.
     *
     * @default "Click to Edit"
     */
    placeholder?: string;

    /**
     * Whether the entire text field should be selected on focus.
     * If `false`, the cursor is placed at the end of the text.
     * This prop is ignored on inputs with type other then text, search, url, tel and password. See https://html.spec.whatwg.org/multipage/input.html#do-not-apply for details.
     *
     * @default false
     */
    selectAllOnFocus?: boolean;

    /**
     * The type of input that should be shown, when not `multiline`.
     */
    type?: string;

    /** Text value of controlled input. */
    value?: string;

    /** ID attribute to pass to the underlying element that contains the text contents. This allows for referencing via aria attributes */
    contentId?: string;

    /** Callback invoked when user cancels input with the `esc` key. Receives last confirmed value. */
    onCancel?(value: string): void;

    /** Callback invoked when user changes input in any way. */
    onChange?(value: string): void;

    /** Callback invoked when user confirms value with `enter` key or by blurring input. */
    onConfirm?(value: string): void;

    /** Callback invoked after the user enters edit mode. */
    onEdit?(value: string | undefined): void;
}

export interface EditableTextState {
    /** Pixel height of the input, measured from span size */
    inputHeight?: number;
    /** Pixel width of the input, measured from span size */
    inputWidth?: number;
    /** Whether the value is currently being edited */
    isEditing?: boolean;
    /** The last confirmed value */
    lastValue?: string;
    /** The controlled input value, may be different from prop during editing */
    value?: string;
}

const BUFFER_WIDTH_DEFAULT = 5;

/**
 * EditableText component.
 *
 * @see https://blueprintjs.com/docs/#core/components/editable-text
 */
export class EditableText extends AbstractPureComponent<EditableTextProps, EditableTextState> {
    public static displayName = `${DISPLAYNAME_PREFIX}.EditableText`;

    public static defaultProps: EditableTextProps = {
        alwaysRenderInput: false,
        confirmOnEnterKey: false,
        defaultValue: "",
        disabled: false,
        maxLines: Infinity,
        minLines: 1,
        minWidth: 80,
        multiline: false,
        placeholder: "Click to Edit",
        type: "text",
    };

    private inputElement: HTMLInputElement | HTMLTextAreaElement | null = null;

    private valueElement: HTMLSpanElement | null = null;

    private refHandlers = {
        content: (spanElement: HTMLSpanElement | null) => {
            this.valueElement = spanElement;
        },
        input: (input: HTMLInputElement | HTMLTextAreaElement | null) => {
            if (input != null) {
                this.inputElement = input;

                // temporary fix for #3882
                if (!this.props.alwaysRenderInput) {
                    this.inputElement.focus();
                }

                if (this.state != null && this.state.isEditing) {
                    const supportsSelection = inputSupportsSelection(input);
                    if (supportsSelection) {
                        const { length } = input.value;
                        input.setSelectionRange(this.props.selectAllOnFocus ? 0 : length, length);
                    }
                    if (!supportsSelection || !this.props.selectAllOnFocus) {
                        input.scrollLeft = input.scrollWidth;
                    }
                }
            }
        },
    };

    public constructor(props: EditableTextProps) {
        super(props);

        const value = props.value == null ? props.defaultValue : props.value;
        this.state = {
            inputHeight: 0,
            inputWidth: 0,
            isEditing: props.isEditing === true && props.disabled === false,
            lastValue: value,
            value,
        };
    }

    public render() {
        const { alwaysRenderInput, disabled, elementRef, multiline, contentId } = this.props;
        const value = this.props.value ?? this.state.value;
        const hasValue = value != null && value !== "";

        const classes = classNames(
            Classes.EDITABLE_TEXT,
            Classes.intentClass(this.props.intent),
            {
                [Classes.DISABLED]: disabled,
                [Classes.EDITABLE_TEXT_EDITING]: this.state.isEditing,
                [Classes.EDITABLE_TEXT_PLACEHOLDER]: !hasValue,
                [Classes.MULTILINE]: multiline,
            },
            this.props.className,
        );

        let contentStyle: React.CSSProperties;
        if (multiline) {
            // set height only in multiline mode when not editing
            // otherwise we're measuring this element to determine appropriate height of text
            contentStyle = { height: !this.state.isEditing ? this.state.inputHeight : undefined };
        } else {
            // minWidth only applies in single line mode (multiline == width 100%)
            contentStyle = {
                height: this.state.inputHeight,
                lineHeight: this.state.inputHeight != null ? `${this.state.inputHeight}px` : undefined,
                minWidth: this.props.minWidth,
            };
        }

        // If we are always rendering an input, then NEVER make the container div focusable.
        // Otherwise, make container div focusable when not editing, so it can still be tabbed
        // to focus (when the input is rendered, it is itself focusable so container div doesn't need to be)
        const tabIndex = alwaysRenderInput || this.state.isEditing || disabled ? undefined : 0;

        // we need the contents to be rendered while editing so that we can measure their height
        // and size the container element responsively
        const shouldHideContents = alwaysRenderInput && !this.state.isEditing;

        const spanProps: React.HTMLProps<HTMLSpanElement> = contentId != null ? { id: contentId } : {};

        return (
            <div className={classes} onFocus={this.handleFocus} tabIndex={tabIndex} ref={elementRef}>
                {alwaysRenderInput || this.state.isEditing ? this.renderInput(value) : undefined}
                {shouldHideContents ? undefined : (
                    <span
                        {...spanProps}
                        className={Classes.EDITABLE_TEXT_CONTENT}
                        ref={this.refHandlers.content}
                        style={contentStyle}
                    >
                        {hasValue ? value : this.props.placeholder}
                    </span>
                )}
            </div>
        );
    }

    public componentDidMount() {
        this.updateInputDimensions();
    }

    public componentDidUpdate(prevProps: EditableTextProps, prevState: EditableTextState) {
        const newState: EditableTextState = {};
        // allow setting the value to undefined/null in controlled mode
        if (this.props.value !== prevProps.value && (prevProps.value != null || this.props.value != null)) {
            newState.value = this.props.value;
        }
        if (this.props.isEditing != null && this.props.isEditing !== prevProps.isEditing) {
            newState.isEditing = this.props.isEditing;
        }
        if (this.props.disabled || (this.props.disabled == null && prevProps.disabled)) {
            newState.isEditing = false;
        }

        this.setState(newState);

        if (this.state.isEditing && !prevState.isEditing) {
            this.props.onEdit?.(this.state.value);
        }
        // updateInputDimensions is an expensive method. Call it only when the props
        // it depends on change
        if (
            this.state.value !== prevState.value ||
            this.props.alwaysRenderInput !== prevProps.alwaysRenderInput ||
            this.props.maxLines !== prevProps.maxLines ||
            this.props.minLines !== prevProps.minLines ||
            this.props.minWidth !== prevProps.minWidth ||
            this.props.multiline !== prevProps.multiline ||
            this.props.placeholder !== prevProps.placeholder
        ) {
            this.updateInputDimensions();
        }
    }

    public cancelEditing = () => {
        const { lastValue, value } = this.state;
        this.setState({ isEditing: false, value: lastValue });
        if (value !== lastValue) {
            this.props.onChange?.(lastValue!);
        }
        this.props.onCancel?.(lastValue!);
    };

    public toggleEditing = () => {
        if (this.state.isEditing) {
            const { value } = this.state;
            this.setState({ isEditing: false, lastValue: value });
            this.props.onConfirm?.(value!);
        } else if (!this.props.disabled) {
            this.setState({ isEditing: true });
        }
    };

    private handleFocus = () => {
        const { alwaysRenderInput, disabled, selectAllOnFocus } = this.props;

        if (!disabled) {
            this.setState({ isEditing: true });
        }

        if (alwaysRenderInput && selectAllOnFocus && this.inputElement != null) {
            const { length } = this.inputElement.value;
            this.inputElement.setSelectionRange(0, length);
        }
    };

    private handleTextChange = (event: React.FormEvent<HTMLElement>) => {
        const value = (event.target as HTMLInputElement).value;
        // state value should be updated only when uncontrolled
        if (this.props.value == null) {
            this.setState({ value });
        }
        this.props.onChange?.(value);
    };

    private handleKeyEvent = (event: React.KeyboardEvent<HTMLElement>) => {
        const { altKey, ctrlKey, metaKey, shiftKey } = event;
        if (event.key === "Escape") {
            this.cancelEditing();
            return;
        }

        const hasModifierKey = altKey || ctrlKey || metaKey || shiftKey;
        if (event.key === "Enter") {
            // prevent browsers (Edge?) from full screening with alt + enter
            // shift + enter adds a newline by default
            if (altKey || shiftKey) {
                event.preventDefault();
            }

            if (this.props.confirmOnEnterKey && this.props.multiline) {
                if (event.target != null && hasModifierKey) {
                    insertAtCaret(event.target as HTMLTextAreaElement, "\n");
                    this.handleTextChange(event);
                } else {
                    this.toggleEditing();
                }
            } else if (!this.props.multiline || hasModifierKey) {
                this.toggleEditing();
            }
        }
    };

    private renderInput(value: string | undefined) {
        const { disabled, maxLength, multiline, type, placeholder } = this.props;
        const props: React.InputHTMLAttributes<HTMLInputElement | HTMLTextAreaElement> = {
            className: Classes.EDITABLE_TEXT_INPUT,
            disabled,
            maxLength,
            onBlur: this.toggleEditing,
            onChange: this.handleTextChange,
            onKeyDown: this.handleKeyEvent,
            placeholder,
            value,
        };

        const { inputHeight, inputWidth } = this.state;
        if (inputHeight !== 0 && inputWidth !== 0) {
            props.style = {
                height: inputHeight,
                lineHeight: !multiline && inputHeight != null ? `${inputHeight}px` : undefined,
                width: multiline ? "100%" : inputWidth,
            };
        }

        return multiline ? (
            <textarea ref={this.refHandlers.input} {...props} />
        ) : (
            <input ref={this.refHandlers.input} type={type} {...props} />
        );
    }

    private updateInputDimensions() {
        if (this.valueElement != null) {
            const { maxLines, minLines, minWidth, multiline } = this.props;
            const { parentElement, textContent } = this.valueElement;
            let { scrollHeight, scrollWidth } = this.valueElement;
            const lineHeight = getLineHeight(this.valueElement);
            // add one line to computed <span> height if text ends in newline
            // because <span> collapses that trailing whitespace but <textarea> shows it
            if (multiline && this.state.isEditing && /\n$/.test(textContent ?? "")) {
                scrollHeight += lineHeight;
            }
            if (lineHeight > 0) {
                // line height could be 0 if the isNaN block from getLineHeight kicks in
                scrollHeight = clamp(scrollHeight, minLines! * lineHeight, maxLines! * lineHeight);
            }
            // Chrome's input caret height misaligns text so the line-height must be larger than font-size.
            // The computed scrollHeight must also account for a larger inherited line-height from the parent.
            scrollHeight = Math.max(scrollHeight, getFontSize(this.valueElement) + 1, getLineHeight(parentElement!));
            // Need to add a small buffer so text does not shift prior to resizing, causing an infinite loop.
            scrollWidth += BUFFER_WIDTH_DEFAULT;

            this.setState({
                inputHeight: scrollHeight,
                inputWidth: Math.max(scrollWidth, minWidth!),
            });
            // synchronizes the ::before pseudo-element's height while editing for Chrome 53
            if (multiline && this.state.isEditing) {
                this.setTimeout(() => (parentElement!.style.height = `${scrollHeight}px`));
            }
        }
    }
}

function getFontSize(element: HTMLElement) {
    const fontSize = getComputedStyle(element).fontSize;
    return fontSize === "" ? 0 : parseInt(fontSize.slice(0, -2), 10);
}

function getLineHeight(element: HTMLElement) {
    // getComputedStyle() => 18.0001px => 18
    let lineHeight = parseInt(getComputedStyle(element).lineHeight.slice(0, -2), 10);
    // this check will be true if line-height is a keyword like "normal"
    if (isNaN(lineHeight)) {
        // @see http://stackoverflow.com/a/18430767/6342931
        const line = document.createElement("span");
        line.innerHTML = "<br>";
        element.appendChild(line);
        const singleLineHeight = element.offsetHeight;
        line.innerHTML = "<br><br>";
        const doubleLineHeight = element.offsetHeight;
        element.removeChild(line);
        // this can return 0 in edge cases
        lineHeight = doubleLineHeight - singleLineHeight;
    }
    return lineHeight;
}

function insertAtCaret(el: HTMLTextAreaElement, text: string) {
    const { selectionEnd, selectionStart, value } = el;
    if (selectionStart >= 0) {
        const before = value.substring(0, selectionStart);
        const after = value.substring(selectionEnd, value.length);
        const len = text.length;
        el.value = `${before}${text}${after}`;
        el.selectionStart = selectionStart + len;
        el.selectionEnd = selectionStart + len;
    }
}

function inputSupportsSelection(input: HTMLInputElement | HTMLTextAreaElement) {
    switch (input.type) {
        // HTMLTextAreaElement
        case "textarea":
            return true;
        // HTMLInputElement
        // see https://html.spec.whatwg.org/multipage/input.html#do-not-apply
        case "text":
        case "search":
        case "tel":
        case "url":
        case "password":
            return true;
        default:
            return false;
    }
}

================================================================================

File: src\components\editable-text\_editable-text.scss
--------------------------------------------------------------------------------
// Copyright 2016 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "../forms/common";

.#{$ns}-editable-text {
  cursor: text;
  display: inline-block;
  max-width: 100%;
  position: relative;
  vertical-align: top;
  white-space: nowrap;

  // input styles on the ::before
  &::before {
    @include position-all(absolute, -$pt-border-radius);
    border-radius: $pt-border-radius;
    content: "";
    transition: background-color $pt-transition-duration $pt-transition-ease,
                box-shadow $pt-transition-duration $pt-transition-ease;
  }

  &:hover::before {
    box-shadow: input-transition-shadow($input-shadow-color-focus),
                inset 0 0 0 1px $pt-divider-black;
  }

  &.#{$ns}-editable-text-editing::before {
    background-color: $input-background-color;
    box-shadow: input-transition-shadow($input-shadow-color-focus, true), $input-box-shadow-focus;
  }

  @media (forced-colors: active) and (prefers-color-scheme: dark) {
    &:not(.#{$ns}-disabled)::before {
      border: 1px solid $pt-high-contrast-mode-border-color;
    }
  }

  @each $intent, $color in $pt-intent-colors {
    &.#{$ns}-intent-#{$intent} {
      .#{$ns}-editable-text-content,
      .#{$ns}-editable-text-input,
      .#{$ns}-editable-text-input::placeholder {
        color: $color;
      }

      &:hover::before {
        box-shadow: input-transition-shadow($color), inset border-shadow(0.4, $color, 1px);
      }

      &.#{$ns}-editable-text-editing::before {
        box-shadow: input-transition-shadow($color, true), $input-box-shadow-focus;
      }
    }
  }

  .#{$ns}-dark & {
    &:hover::before {
      box-shadow: input-transition-shadow($dark-input-shadow-color-focus),
                  inset 0 0 0 1px $pt-dark-divider-white;
    }

    &.#{$ns}-editable-text-editing::before {
      background-color: $dark-input-background-color;
      box-shadow: input-transition-shadow($dark-input-shadow-color-focus, true),
                  $pt-dark-input-box-shadow;
    }

    &.#{$ns}-disabled::before {
      box-shadow: none;
    }

    @each $intent, $color in $pt-dark-intent-text-colors {
      &.#{$ns}-intent-#{$intent} {
        .#{$ns}-editable-text-content,
        .#{$ns}-editable-text-input,
        .#{$ns}-editable-text-input::placeholder {
          color: $color;
        }

        &:hover::before {
          box-shadow: input-transition-shadow($color), inset border-shadow(0.4, $color, 1px);
        }

        &.#{$ns}-editable-text-editing::before {
          box-shadow: input-transition-shadow($color, true), $pt-dark-input-box-shadow;
        }
      }
    }
  }

  &.#{$ns}-disabled::before {
    // override intent + dark theme selectors
    /* stylelint-disable-next-line declaration-no-important */
    box-shadow: none !important;
  }
}

.#{$ns}-editable-text-input,
.#{$ns}-editable-text-content {
  color: inherit;
  display: inherit;
  font: inherit;
  letter-spacing: inherit;
  max-width: inherit;
  // inherit and respect parent bounds and text styles
  min-width: inherit;
  position: relative;
  // prevent user resizing of textarea
  resize: none;
  text-transform: inherit;
  vertical-align: top;
}

.#{$ns}-editable-text-input {
  @include pt-input-placeholder();
  background: none;
  // reset browser input styles (we're using an input solely because you can type in it)
  border: none;
  box-shadow: none;
  padding: 0;
  // IE11's textarea will otherwise inherit the white-space property from its direct parent
  white-space: pre-wrap;
  width: 100%;

  &:focus {
    outline: none;
  }

  &::-ms-clear {
    display: none;
  }
}

.#{$ns}-editable-text-content {
  overflow: hidden;
  // magical number to account for slight increase in input width for cursor bar
  padding-right: 2px;
  text-overflow: ellipsis;
  // preserve so trailing whitespace is included in scrollWidth
  white-space: pre;

  .#{$ns}-editable-text-editing > & {
    left: 0;
    position: absolute;
    visibility: hidden;
  }

  .#{$ns}-editable-text-placeholder > & {
    color: $input-placeholder-color;

    .#{$ns}-dark & {
      color: $dark-input-placeholder-color;
    }
  }
}

.#{$ns}-editable-text.#{$ns}-multiline {
  display: block;

  .#{$ns}-editable-text-content {
    overflow: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
  }
}

================================================================================

File: src\components\entity-title\entity-title.md
--------------------------------------------------------------------------------
---
tag: new
---

@# Entity Title

**EntityTitle** is a component that handles rendering a common UI pattern consisting of title, icon, subtitle and tag.

@reactExample EntityTitleExample

@## Props interface

@interface EntityTitleProps

================================================================================

File: src\components\entity-title\entityTitle.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { type IconName, IconNames } from "@blueprintjs/icons";

import { Classes, DISPLAYNAME_PREFIX, type MaybeElement, type Props } from "../../common";
import { H1, H2, H3, H4, H5, H6 } from "../html/html";
import { Icon } from "../icon/icon";
import { Text } from "../text/text";

export interface EntityTitleProps extends Props {
    /**
     * Whether the overflowing text content should be ellipsized.
     *
     * @default false
     */
    ellipsize?: boolean;

    /**
     * React component to render the main title heading. This defaults to
     * Blueprint's `<Text>` component, * which inherits font size from its
     * containing element(s).
     *
     * To render larger, more prominent titles, Use Blueprint's heading
     * components instead (e.g. `{ H1 } from "@blueprintjs/core"`).
     *
     * @default Text
     */
    heading?: React.FC<any>;

    /**
     * Name of a Blueprint UI icon (or an icon element) to render in the section's header.
     * Note that the header will only be rendered if `title` is provided.
     */
    icon?: IconName | MaybeElement;

    /**
     * Whether to render as loading state.
     *
     * @default false
     */
    loading?: boolean;

    /** The content to render below the title. Defaults to render muted text. */
    subtitle?: React.JSX.Element | string;

    /** The primary title to render. */
    title: React.JSX.Element | string;

    /** If specified, the title will be wrapped in an anchor with this URL. */
    titleURL?: string;

    /**
     * <Tag> components work best - if multiple, wrap in <React.Fragment>
     */
    tags?: React.ReactNode;
}

/**
 * EntityTitle component.
 *
 * @see https://blueprintjs.com/docs/#core/components/entity-title
 */
export const EntityTitle: React.FC<EntityTitleProps> = React.forwardRef<HTMLDivElement, EntityTitleProps>(
    (props, ref) => {
        const {
            className,
            ellipsize = false,
            heading = Text,
            icon,
            loading = false,
            subtitle,
            tags,
            title,
            titleURL,
        } = props;

        const titleElement = React.useMemo(() => {
            const maybeTitleWithURL =
                titleURL != null ? (
                    <a target="_blank" href={titleURL} rel="noreferrer">
                        {title}
                    </a>
                ) : (
                    title
                );

            return React.createElement(
                heading,
                {
                    className: classNames(Classes.ENTITY_TITLE_TITLE, {
                        [Classes.SKELETON]: loading,
                        [Classes.TEXT_OVERFLOW_ELLIPSIS]: heading !== Text && ellipsize,
                    }),
                    ellipsize: heading === Text ? ellipsize : undefined,
                },
                maybeTitleWithURL,
            );
        }, [titleURL, title, heading, loading, ellipsize]);

        const maybeSubtitle = React.useMemo(() => {
            if (subtitle == null) {
                return null;
            }

            return (
                <Text
                    className={classNames(Classes.TEXT_MUTED, Classes.ENTITY_TITLE_SUBTITLE, {
                        [Classes.SKELETON]: loading,
                    })}
                    ellipsize={ellipsize}
                >
                    {subtitle}
                </Text>
            );
        }, [ellipsize, loading, subtitle]);

        return (
            <div
                className={classNames(className, Classes.ENTITY_TITLE, getClassNameFromHeading(heading), {
                    [Classes.ENTITY_TITLE_ELLIPSIZE]: ellipsize,
                })}
                ref={ref}
            >
                {icon != null && (
                    <div
                        className={classNames(Classes.ENTITY_TITLE_ICON_CONTAINER, {
                            [Classes.ENTITY_TITLE_HAS_SUBTITLE]: maybeSubtitle != null,
                        })}
                    >
                        <Icon
                            aria-hidden={true}
                            className={classNames(Classes.TEXT_MUTED, { [Classes.SKELETON]: loading })}
                            icon={loading ? IconNames.SQUARE : icon}
                            tabIndex={-1}
                        />
                    </div>
                )}
                <div className={Classes.ENTITY_TITLE_TEXT}>
                    <div
                        className={classNames(Classes.ENTITY_TITLE_TITLE_AND_TAGS, {
                            [Classes.SKELETON]: loading,
                        })}
                    >
                        {titleElement}
                        {tags != null && <div className={Classes.ENTITY_TITLE_TAGS_CONTAINER}>{tags}</div>}
                    </div>
                    {maybeSubtitle}
                </div>
            </div>
        );
    },
);
EntityTitle.displayName = `${DISPLAYNAME_PREFIX}.EntityTitle`;

/**
 * Construct header class name from H{*}. Returns `undefined` if `heading` is not a Blueprint heading.
 */
function getClassNameFromHeading(heading: React.FC<unknown>) {
    const headerIndex = [H1, H2, H3, H4, H5, H6].findIndex(header => header === heading);
    if (headerIndex < 0) {
        return undefined;
    }
    return [Classes.getClassNamespace(), "entity-title-heading", `h${headerIndex + 1}`].join("-");
}

================================================================================

File: src\components\entity-title\_entity-title.scss
--------------------------------------------------------------------------------
// Copyright 2024 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "../../common/variables-extended";

.#{$ns}-entity-title {
  align-items: center;
  display: flex;
  gap: 0.7 * $pt-grid-size;
  min-width: 0;

  &-icon-container {
    &.#{$ns}-entity-title-has-subtitle {
      align-self: flex-start;
    }

    &:not(.#{$ns}-entity-title-has-subtitle) {
      align-items: center;
      display: flex;
    }
  }

  &-text {
    display: flex;
    flex-direction: column;
  }

  &-title-and-tags {
    align-items: center;
    display: flex;
    flex-direction: row;
    gap: 0.5 * $pt-grid-size;
  }

  &-tags-container {
    display: flex;
    gap: 0.2 * $pt-grid-size;
    margin-left: 0.5 * $pt-grid-size;
  }

  &-title {
    margin-bottom: 0;
    min-width: 0;
    overflow-wrap: break-word;
  }

  &-subtitle {
    font-size: $pt-font-size-small;
    margin-top: 0.2 * $pt-grid-size;
  }

  &-ellipsize,
  &-ellipsize &-text {
    overflow: hidden;
  }

  @each $tag, $props in $headings {
    &-heading-#{$tag} .#{$ns}-icon-container {
      align-items: center;
      display: flex;
      // Aligning icon which has unknown dimensions on the title size
      height: nth($props, 2);
    }
  }

  &-heading-h1,
  &-heading-h2,
  &-heading-h3 {
    gap: 1.5 * $pt-grid-size;

    .#{$ns}-entity-title-status-tag {
      margin-left: $pt-grid-size;
    }

    .#{$ns}-entity-title-subtitle {
      font-size: $pt-font-size;
    }
  }

  &-heading-h4,
  &-heading-h5,
  &-heading-h6 {
    gap: $pt-grid-size;

    .#{$ns}-entity-title-subtitle {
      font-size: $pt-font-size-small;
    }
  }
}

================================================================================

File: src\components\forms\asyncControllableInput.tsx
--------------------------------------------------------------------------------
/* !
 * Copyright 2020 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

import { AbstractPureComponent, DISPLAYNAME_PREFIX } from "../../common";

export type AsyncControllableInputProps = React.InputHTMLAttributes<HTMLInputElement> & {
    inputRef?: React.Ref<HTMLInputElement>;
};

type InputValue = AsyncControllableInputProps["value"];

export interface AsyncControllableInputState {
    /**
     * Whether we are in the middle of a composition event.
     *
     * @default false
     */
    isComposing: boolean;

    /**
     * The source of truth for the input value. This is not updated during IME composition.
     * It may be updated by a parent component.
     *
     * @default ""
     */
    value: InputValue;

    /**
     * The latest input value, which updates during IME composition. Defaults to props.value.
     */
    nextValue: InputValue;

    /**
     * Whether there is a pending update we are expecting from a parent component.
     *
     * @default false
     */
    hasPendingUpdate: boolean;
}

/**
 * A stateful wrapper around the low-level <input> component which works around a
 * [React bug](https://github.com/facebook/react/issues/3926). This bug is reproduced when an input
 * receives CompositionEvents (for example, through IME composition) and has its value prop updated
 * asychronously. This might happen if a component chooses to do async validation of a value
 * returned by the input's `onChange` callback.
 *
 * Note: this component does not apply any Blueprint-specific styling.
 */
export class AsyncControllableInput extends AbstractPureComponent<
    AsyncControllableInputProps,
    AsyncControllableInputState
> {
    public static displayName = `${DISPLAYNAME_PREFIX}.AsyncControllableInput`;

    /**
     * The amount of time (in milliseconds) which the input will wait after a compositionEnd event before
     * unlocking its state value for external updates via props. See `handleCompositionEnd` for more details.
     */
    public static COMPOSITION_END_DELAY = 10;

    public state: AsyncControllableInputState = {
        hasPendingUpdate: false,
        isComposing: false,
        nextValue: this.props.value,
        value: this.props.value,
    };

    private cancelPendingCompositionEnd: (() => void) | null = null;

    public static getDerivedStateFromProps(
        nextProps: AsyncControllableInputProps,
        nextState: AsyncControllableInputState,
    ): Partial<AsyncControllableInputState> | null {
        if (nextState.isComposing || nextProps.value === undefined) {
            // don't derive anything from props if:
            // - in uncontrolled mode, OR
            // - currently composing, since we'll do that after composition ends
            return null;
        }

        const userTriggeredUpdate = nextState.nextValue !== nextState.value;

        if (userTriggeredUpdate) {
            if (nextProps.value === nextState.nextValue) {
                // parent has processed and accepted our update
                if (nextState.hasPendingUpdate) {
                    return { value: nextProps.value, hasPendingUpdate: false };
                } else {
                    return { value: nextState.nextValue };
                }
            } else {
                if (nextProps.value === nextState.value) {
                    // we have sent the update to our parent, but it has not been processed yet. just wait.
                    // DO NOT set nextValue here, since that will temporarily render a potentially stale controlled value,
                    // causing the cursor to jump once the new value is accepted
                    return { hasPendingUpdate: true };
                }
                // accept controlled update overriding user action
                return { value: nextProps.value, nextValue: nextProps.value, hasPendingUpdate: false };
            }
        } else {
            // accept controlled update, could be confirming or denying user action
            return { value: nextProps.value, nextValue: nextProps.value, hasPendingUpdate: false };
        }
    }

    public render() {
        const { isComposing, hasPendingUpdate, value, nextValue } = this.state;
        const { inputRef, ...restProps } = this.props;
        return (
            <input
                {...restProps}
                ref={inputRef}
                // render the pending value even if it is not confirmed by a parent's async controlled update
                // so that the cursor does not jump to the end of input as reported in
                // https://github.com/palantir/blueprint/issues/4298
                value={isComposing || hasPendingUpdate ? nextValue : value}
                onCompositionStart={this.handleCompositionStart}
                onCompositionEnd={this.handleCompositionEnd}
                onChange={this.handleChange}
            />
        );
    }

    private handleCompositionStart = (e: React.CompositionEvent<HTMLInputElement>) => {
        this.cancelPendingCompositionEnd?.();
        this.setState({ isComposing: true });
        this.props.onCompositionStart?.(e);
    };

    private handleCompositionEnd = (e: React.CompositionEvent<HTMLInputElement>) => {
        // In some non-latin languages, a keystroke can end a composition event and immediately afterwards start another.
        // This can lead to unexpected characters showing up in the text input. In order to circumvent this problem, we
        // use a timeout which creates a delay which merges the two composition events, creating a more natural and predictable UX.
        // `this.state.nextValue` will become "locked" (it cannot be overwritten by the `value` prop) until a delay (10ms) has
        // passed without a new composition event starting.
        this.cancelPendingCompositionEnd = this.setTimeout(
            () => this.setState({ isComposing: false }),
            AsyncControllableInput.COMPOSITION_END_DELAY,
        );
        this.props.onCompositionEnd?.(e);
    };

    private handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const { value } = e.target;

        this.setState({ nextValue: value });
        this.props.onChange?.(e);
    };
}

================================================================================

File: src\components\forms\asyncControllableTextArea.tsx
--------------------------------------------------------------------------------
/* !
 * (c) Copyright 2023 Palantir Technologies Inc. All rights reserved.
 */

import * as React from "react";

import { DISPLAYNAME_PREFIX } from "../../common";
import { useAsyncControllableValue } from "../../hooks/useAsyncControllableValue";

export type AsyncControllableTextAreaProps = React.TextareaHTMLAttributes<HTMLTextAreaElement>;

/**
 * A wrapper around the low-level <textarea> component which works around a React bug
 * the same way <AsyncControllableInput> does.
 */
export const AsyncControllableTextArea = React.forwardRef<HTMLTextAreaElement, AsyncControllableTextAreaProps>(
    function _AsyncControllableTextArea(props, ref) {
        const {
            value: parentValue,
            onChange: parentOnChange,
            onCompositionStart: parentOnCompositionStart,
            onCompositionEnd: parentOnCompositionEnd,
            ...restProps
        } = props;

        const { value, onChange, onCompositionStart, onCompositionEnd } = useAsyncControllableValue({
            onChange: parentOnChange,
            onCompositionEnd: parentOnCompositionEnd,
            onCompositionStart: parentOnCompositionStart,
            value: parentValue,
        });

        return (
            <textarea
                {...restProps}
                value={value}
                onChange={onChange}
                onCompositionStart={onCompositionStart}
                onCompositionEnd={onCompositionEnd}
                ref={ref}
            />
        );
    },
);
AsyncControllableTextArea.displayName = `${DISPLAYNAME_PREFIX}.AsyncControllableTextArea`;

================================================================================

File: src\components\forms\checkbox.md
--------------------------------------------------------------------------------
@# Checkbox

A checkbox allows the user to toggle between checked, unchecked, and (sometimes) indeterminate states.

@reactExample CheckboxExample

@## Usage

Use the `checked` prop instead of `value` in controlled mode to avoid typings issues.
Enable the `indeterminate` prop for a third in-between state.

```tsx
// simple usage for string labels
<Checkbox checked={this.state.isEnabled} label="Enabled" onChange={this.handleEnabledChange} />

// advanced usage for JSX content
<Checkbox checked={this.state.isEnabled} onChange={this.handleEnabledChange}>
    <Icon icon="user" />
    John <strong>Doe</strong>
</Checkbox>
```

@## Props interface

This component supports the full range of HTML `<input>` props.

@interface CheckboxProps

@## CSS API

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use [`<Checkbox>`](#core/components/checkbox)

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

</div>

Blueprint's custom checkboxes use an extra `.@ns-control-indicator` element after the `<input>` to achieve
their custom styling. You should then wrap the whole thing in a `<label>` with the classes `.@ns-control.@ns-checkbox`.

Note that attribute modifiers (`:checked`, `:disabled`) are applied on the internal `<input>` element. Further note
that `:indeterminate` can only be set via JavaScript (the `Checkbox` React component supports it handily with a prop).

@css checkbox

================================================================================

File: src\components\forms\control-group.md
--------------------------------------------------------------------------------
@# Control group

A __ControlGroup__ renders multiple distinct form controls as one unit, with a small margin between elements. It
supports any number of buttons, text inputs, input groups, numeric inputs, and HTML selects as direct children.

<div class="@ns-callout @ns-intent-success @ns-icon-comparison @ns-callout-has-body-content">
    <h5 class="@ns-heading">Control group vs. input group</h5>

Both components group multiple elements into a single unit, but their usage patterns are quite different.

Think of __ControlGroup__ as a parent with multiple children, with each one a separate control.

Conversely, an [__InputGroup__](#core/components/input-group) is a single control, and should behave like
so. A button inside of an input group should only affect that input; if its reach is further, then it should be
promoted to live in a control group.

</div>

@reactExample ControlGroupExample

@## Flex layout

__ControlGroup__ is a CSS inline flex row (or column if vertical) and provides some modifer props for common flexbox
patterns:

- Enable the `fill` prop on a control group to make all controls expand equally to fill the available space.
    - Controls will expand horizontally by default, or vertically if the `vertical` prop is enabled.
    - Add the class `Classes.FIXED` to individual controls to revert them to their initial sizes.

- In addition, you may enable the `fill` prop on specific controls inside the group to expand them fill more space while
 other controls retain their original sizes.

You can adjust the specific size of a control with the `flex-basis` or `width` CSS properties.

@## Usage

This component is a lightweight wrapper around its children. It supports all HTML `<div>` attributes in addition to
those listed in the props interface below.

```tsx
<ControlGroup fill={true} vertical={false}>
    <Button icon="filter">Filter</Button>
    <InputGroup placeholder="Find filters..." />
</ControlGroup>
```

@## Props interface

@interface ControlGroupProps

@## CSS

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use [`<ControlGroup>`](#core/components/control-group)

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

</div>

Note that `.@ns-control-group` does not cascade any modifiers to its children. For example, each
child must be marked individually as `.@ns-large` for uniform large appearance.

@css control-group


================================================================================

File: src\components\forms\controlGroup.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Classes } from "../../common";
import { DISPLAYNAME_PREFIX, type HTMLDivProps, type Props } from "../../common/props";

export interface ControlGroupProps extends Props, HTMLDivProps, React.RefAttributes<HTMLDivElement> {
    /** Group contents. */
    children?: React.ReactNode;

    /**
     * Whether the control group should take up the full width of its container.
     *
     * @default false
     */
    fill?: boolean;

    /**
     * Whether the control group should appear with vertical styling.
     *
     * @default false
     */
    vertical?: boolean;
}

// this component is simple enough that tests would be purely tautological.
/* istanbul ignore next */
/**
 * Control group component.
 *
 * @see https://blueprintjs.com/docs/#core/components/control-group
 */
export const ControlGroup: React.FC<ControlGroupProps> = React.forwardRef<HTMLDivElement, ControlGroupProps>(
    (props, ref) => {
        const { children, className, fill, vertical, ...htmlProps } = props;

        const rootClasses = classNames(
            Classes.CONTROL_GROUP,
            {
                [Classes.FILL]: fill,
                [Classes.VERTICAL]: vertical,
            },
            className,
        );

        return (
            <div role="group" {...htmlProps} ref={ref} className={rootClasses}>
                {children}
            </div>
        );
    },
);
ControlGroup.displayName = `${DISPLAYNAME_PREFIX}.ControlGroup`;

================================================================================

File: src\components\forms\controlProps.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type * as React from "react";

import type { Alignment } from "../../common";
import type { HTMLInputProps, Props } from "../../common/props";

export interface CheckedControlProps {
    /** Whether the control is checked. */
    checked?: boolean;

    /** Whether the control is initially checked (uncontrolled mode). */
    defaultChecked?: boolean;

    /** Event handler invoked when input value is changed. */
    onChange?: React.ChangeEventHandler<HTMLInputElement>;
}

/**
 * Shared props for form control components like Switch, Checkbox, and Radio.
 */
export interface ControlProps
    extends CheckedControlProps,
        Props,
        HTMLInputProps,
        React.RefAttributes<HTMLLabelElement> {
    // NOTE: Some HTML props are duplicated here to provide control-specific documentation

    /**
     * Alignment of the indicator within container.
     *
     * @default Alignment.LEFT
     */
    alignIndicator?: Alignment;

    /** JSX label for the control. */
    children?: React.ReactNode;

    /** Whether the control is non-interactive. */
    disabled?: boolean;

    /** Whether the control should appear as an inline element. */
    inline?: boolean;

    /** Ref attached to the HTML `<input>` element backing this component. */
    inputRef?: React.Ref<HTMLInputElement>;

    /**
     * Text label for the control.
     *
     * Use `children` or `labelElement` to supply JSX content. This prop actually supports JSX elements,
     * but TypeScript will throw an error because `HTMLAttributes` only allows strings.
     */
    label?: string;

    /**
     * JSX element label for the control.
     *
     * This prop is a workaround for TypeScript consumers as the type definition for `label` only
     * accepts strings. JavaScript consumers can provide a JSX element directly to `label`.
     */
    labelElement?: React.ReactNode;

    /** Whether this control should use large styles. */
    large?: boolean;

    /**
     * Name of the HTML tag that wraps the checkbox.
     *
     * By default a `<label>` is used, which effectively enlarges the click
     * target to include all of its children. Supply a different tag name if
     * this behavior is undesirable or you're listening to click events from a
     * parent element (as the label can register duplicate clicks).
     *
     * @default "label"
     */
    tagName?: keyof React.JSX.IntrinsicElements;
}

================================================================================

File: src\components\forms\controls.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Classes, mergeRefs } from "../../common";
import { DISPLAYNAME_PREFIX } from "../../common/props";

import type { ControlProps } from "./controlProps";

/** Internal props for Checkbox/Radio/Switch to render correctly. */
interface ControlInternalProps extends ControlProps {
    type: "checkbox" | "radio";
    typeClassName: string;
    indicatorChildren?: React.ReactNode;
}

/**
 * Renders common control elements, with additional props to customize appearance.
 * This component is not exported and is only used within this module for `Checkbox`, `Radio`, and `Switch` below.
 */
const ControlInternal: React.FC<ControlInternalProps> = React.forwardRef<HTMLLabelElement, ControlInternalProps>(
    (props, ref) => {
        const {
            alignIndicator,
            children,
            className,
            indicatorChildren,
            inline,
            inputRef,
            label,
            labelElement,
            large,
            style,
            type,
            typeClassName,
            tagName = "label",
            ...htmlProps
        } = props;
        const classes = classNames(
            Classes.CONTROL,
            typeClassName,
            {
                [Classes.DISABLED]: htmlProps.disabled,
                [Classes.INLINE]: inline,
                [Classes.LARGE]: large,
            },
            Classes.alignmentClass(alignIndicator),
            className,
        );

        return React.createElement(
            tagName,
            { className: classes, style, ref },
            <input {...htmlProps} ref={inputRef} type={type} />,
            <span className={Classes.CONTROL_INDICATOR}>{indicatorChildren}</span>,
            label,
            labelElement,
            children,
        );
    },
);
ControlInternal.displayName = `${DISPLAYNAME_PREFIX}.Control`;

//
// Switch
//

/**
 * Switch component props.
 */
export interface SwitchProps extends ControlProps {
    /**
     * Text to display inside the switch indicator when checked.
     * If `innerLabel` is provided and this prop is omitted, then `innerLabel`
     * will be used for both states.
     *
     * @default innerLabel
     */
    innerLabelChecked?: string;

    /**
     * Text to display inside the switch indicator when unchecked.
     */
    innerLabel?: string;
}

/**
 * Switch component.
 *
 * @see https://blueprintjs.com/docs/#core/components/switch
 */
export const Switch: React.FC<SwitchProps> = React.forwardRef(
    ({ innerLabelChecked, innerLabel, ...controlProps }, ref) => {
        const switchLabels =
            innerLabel || innerLabelChecked
                ? [
                      <div key="checked" className={Classes.CONTROL_INDICATOR_CHILD}>
                          <div className={Classes.SWITCH_INNER_TEXT}>
                              {innerLabelChecked ? innerLabelChecked : innerLabel}
                          </div>
                      </div>,
                      <div key="unchecked" className={Classes.CONTROL_INDICATOR_CHILD}>
                          <div className={Classes.SWITCH_INNER_TEXT}>{innerLabel}</div>
                      </div>,
                  ]
                : null;
        return (
            <ControlInternal
                {...controlProps}
                indicatorChildren={switchLabels}
                ref={ref}
                type="checkbox"
                typeClassName={Classes.SWITCH}
            />
        );
    },
);
Switch.displayName = `${DISPLAYNAME_PREFIX}.Switch`;

//
// Radio
//

/**
 * Radio component props.
 */
export type RadioProps = ControlProps;

/**
 * Radio component.
 *
 * @see https://blueprintjs.com/docs/#core/components/radio
 */
export const Radio: React.FC<RadioProps> = React.forwardRef((props, ref) => (
    <ControlInternal {...props} ref={ref} type="radio" typeClassName={Classes.RADIO} />
));
Radio.displayName = `${DISPLAYNAME_PREFIX}.Radio`;

//
// Checkbox
//

/**
 * Checkbox component props.
 */
export interface CheckboxProps extends ControlProps {
    /** Whether this checkbox is initially indeterminate (uncontrolled mode). */
    defaultIndeterminate?: boolean;

    /**
     * Whether this checkbox is indeterminate, or "partially checked."
     * The checkbox will appear with a small dash instead of a tick to indicate that the value
     * is not exactly true or false.
     *
     * Note that this prop takes precendence over `checked`: if a checkbox is marked both
     * `checked` and `indeterminate` via props, it will appear as indeterminate in the DOM.
     */
    indeterminate?: boolean;
}

/**
 * Checkbox component.
 *
 * @see https://blueprintjs.com/docs/#core/components/checkbox
 */
export const Checkbox: React.FC<CheckboxProps> = React.forwardRef((props, ref) => {
    const { defaultIndeterminate, indeterminate, onChange, ...controlProps } = props;
    const [isIndeterminate, setIsIndeterminate] = React.useState<boolean>(
        indeterminate || defaultIndeterminate || false,
    );

    const localInputRef = React.useRef<HTMLInputElement>(null);
    const inputRef = props.inputRef === undefined ? localInputRef : mergeRefs(props.inputRef, localInputRef);

    const handleChange = React.useCallback(
        (evt: React.ChangeEvent<HTMLInputElement>) => {
            // update state immediately only if uncontrolled
            if (indeterminate === undefined) {
                setIsIndeterminate(evt.target.indeterminate);
            }
            // otherwise wait for props change. always invoke handler.
            onChange?.(evt);
        },
        [indeterminate, onChange],
    );

    React.useEffect(() => {
        if (indeterminate !== undefined) {
            setIsIndeterminate(indeterminate);
        }
    }, [indeterminate]);

    React.useEffect(() => {
        if (localInputRef.current != null) {
            localInputRef.current.indeterminate = isIndeterminate;
        }
    }, [localInputRef, isIndeterminate]);

    return (
        <ControlInternal
            {...controlProps}
            inputRef={inputRef}
            onChange={handleChange}
            ref={ref}
            type="checkbox"
            typeClassName={Classes.CHECKBOX}
        />
    );
});
Checkbox.displayName = `${DISPLAYNAME_PREFIX}.Checkbox`;

================================================================================

File: src\components\forms\file-input.md
--------------------------------------------------------------------------------
@# File input

__FileInput__ is a lightweight wrapper around a `<label>` container element which contains an `<input type="file">`.

@reactExample FileInputExample

@## Usage

```tsx
<FileInput disabled={true} text="Choose file..." onInputChange={...} />
```

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">Static file name</h5>

File name does not automatically update after a user selects a file.
To get this behavior, you must update the `text` prop.

</div>

@## Props interface

__FileInput__ supports the full range of HTML `<label>` DOM attributes.
Use `inputProps` to forward props to the `<input>` element.

@interface FileInputProps

@## CSS API

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use [`<FileInput>`](#core/components/forms/file-input)

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

</div>

Use the standard `input type="file"` along with a `span` with class `@ns-file-upload-input`.
Wrap that all in a `label` with class `@ns-file-input`.

@css file-input

================================================================================

File: src\components\forms\fileInput.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes } from "../../common";
import { DISPLAYNAME_PREFIX, type Props } from "../../common/props";

export interface FileInputProps extends React.LabelHTMLAttributes<HTMLLabelElement>, Props {
    /**
     * Whether the file input is non-interactive.
     * Setting this to `true` will automatically disable the child input too.
     */
    disabled?: boolean;

    /**
     * Whether the file input should take up the full width of its container.
     */
    fill?: boolean;

    /**
     * Whether the user has made a selection in the input. This will affect the component's
     * text styling. Make sure to set a non-empty value for the text prop as well.
     *
     * @default false
     */
    hasSelection?: boolean;

    /**
     * The props to pass to the child input.
     * `disabled` will be ignored in favor of the top-level prop.
     * `type` will be ignored, because the input _must_ be `type="file"`.
     * Pass `onChange` here to be notified when the user selects a file.
     */
    inputProps?: React.HTMLProps<HTMLInputElement>;

    /**
     * Whether the file input should appear with large styling.
     */
    large?: boolean;

    /**
     * Callback invoked on `<input>` `change` events.
     *
     * This callback is offered as a convenience; it is equivalent to `inputProps.onChange`.
     *
     * __Note:__ The top-level `onChange` prop is passed to the `<label>` element rather than the `<input>`,
     * which may not be what you expect.
     */
    onInputChange?: React.FormEventHandler<HTMLInputElement>;

    /**
     * Whether the file input should appear with small styling.
     */
    small?: boolean;

    /**
     * The text to display inside the input.
     *
     * @default "Choose file..."
     */
    text?: React.ReactNode;

    /**
     * The button text to display on the right side of the input.
     *
     * @default "Browse"
     */
    buttonText?: string;
}

const NS = Classes.getClassNamespace();

// this is a simple component, unit tests would be mostly tautological
/* istanbul ignore next */
/**
 * File input component.
 *
 * @see https://blueprintjs.com/docs/#core/components/file-input
 */
export class FileInput extends AbstractPureComponent<FileInputProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.FileInput`;

    public static defaultProps: FileInputProps = {
        hasSelection: false,
        inputProps: {},
        text: "Choose file...",
    };

    public render() {
        const {
            buttonText,
            className,
            disabled,
            fill,
            hasSelection,
            inputProps,
            large,
            onInputChange,
            small,
            text,
            ...htmlProps
        } = this.props;

        const rootClasses = classNames(className, Classes.FILE_INPUT, {
            [Classes.FILE_INPUT_HAS_SELECTION]: hasSelection,
            [Classes.DISABLED]: disabled,
            [Classes.FILL]: fill,
            [Classes.LARGE]: large,
            [Classes.SMALL]: small,
        });

        const uploadProps = {
            [`${NS}-button-text`]: buttonText,
            className: classNames(Classes.FILE_UPLOAD_INPUT, {
                [Classes.FILE_UPLOAD_INPUT_CUSTOM_TEXT]: !!buttonText,
            }),
        } satisfies React.HTMLProps<HTMLElement>;

        return (
            <label {...htmlProps} className={rootClasses}>
                <input {...inputProps} onChange={this.handleInputChange} type="file" disabled={disabled} />
                <span {...uploadProps}>{text}</span>
            </label>
        );
    }

    private handleInputChange = (e: React.FormEvent<HTMLInputElement>) => {
        this.props.onInputChange?.(e);
        this.props.inputProps?.onChange?.(e);
    };
}

================================================================================

File: src\components\forms\form-group.md
--------------------------------------------------------------------------------
@# Form group

Form groups support more complex form controls than [simple labels](#core/components/label),
such as [control groups](#core/components/control-group) or [`NumericInput`](#core/components/numeric-input).
They also support additional helper text to aid with user navigation.

@reactExample FormGroupExample

@## Props

This component is a lightweight wrapper around its children with props for the
label above and helper text below.

```tsx
<FormGroup
    helperText="Helper text with details..."
    label="Label A"
    labelFor="text-input"
    labelInfo="(required)"
>
    <InputGroup id="text-input" placeholder="Placeholder text" />
</FormGroup>
```

@interface FormGroupProps

@## CSS

- Link each label to its respective control element with a `for={#id}` attribute on the `<label>` and
`id={#id}` on the control.

- Add `.@ns-intent-*` or `.@ns-disabled` to `.@ns-form-group` to style the label and helper text.
Similar to labels, nested controls need to be styled separately.

- Add `.@ns-inline` to `.@ns-form-group` to place the label to the left of the control.

- Add `.@ns-large` to `.@ns-form-group` to align the label when used with large inline Blueprint controls.

@css form-group

================================================================================

File: src\components\forms\formGroup.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes, type Intent } from "../../common";
import { DISPLAYNAME_PREFIX, type IntentProps, type Props } from "../../common/props";

export interface FormGroupProps extends IntentProps, Props {
    /** Group contents. */
    children?: React.ReactNode;

    /**
     * A space-delimited list of class names to pass along to the
     * `Classes.FORM_CONTENT` element that contains `children`.
     */
    contentClassName?: string;

    /**
     * Whether form group should appear as non-interactive.
     * Remember that `input` elements must be disabled separately.
     */
    disabled?: boolean;

    /**
     * Whether the component should take up the full width of its container.
     */
    fill?: boolean;

    /**
     * Optional helper text. The given content will be wrapped in
     * `Classes.FORM_HELPER_TEXT` and displayed beneath `children`.
     * Helper text color is determined by the `intent`.
     */
    helperText?: React.ReactNode;

    /** Whether to render the label and children on a single line. */
    inline?: boolean;

    /**
     * Visual intent to apply to helper text and sub label.
     * Note that child form elements need to have their own intents applied independently.
     */
    intent?: Intent;

    /** Label of this form group. */
    label?: React.ReactNode;

    /**
     * `id` attribute of the labelable form element that this `FormGroup` controls,
     * used as `<label for>` attribute.
     */
    labelFor?: string;

    /**
     * Optional secondary text that appears after the label.
     */
    labelInfo?: React.ReactNode;

    /** CSS properties to apply to the root element. */
    style?: React.CSSProperties;

    /**
     * Optional text for `label`. The given content will be wrapped in
     * `Classes.FORM_GROUP_SUB_LABEL` and displayed beneath `label`.
     */
    subLabel?: React.ReactNode;
}

/**
 * Form group component.
 *
 * @see https://blueprintjs.com/docs/#core/components/form-group
 */
export class FormGroup extends AbstractPureComponent<FormGroupProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.FormGroup`;

    public render() {
        const { children, contentClassName, helperText, label, labelFor, labelInfo, style, subLabel } = this.props;
        return (
            <div className={this.getClassName()} style={style}>
                {label && (
                    <label className={Classes.LABEL} htmlFor={labelFor}>
                        {label} <span className={Classes.TEXT_MUTED}>{labelInfo}</span>
                    </label>
                )}
                {subLabel && <div className={Classes.FORM_GROUP_SUB_LABEL}>{subLabel}</div>}
                <div className={classNames(Classes.FORM_CONTENT, contentClassName)}>
                    {children}
                    {helperText && <div className={Classes.FORM_HELPER_TEXT}>{helperText}</div>}
                </div>
            </div>
        );
    }

    private getClassName() {
        const { className, disabled, fill, inline, intent } = this.props;
        return classNames(
            Classes.FORM_GROUP,
            Classes.intentClass(intent),
            {
                [Classes.DISABLED]: disabled,
                [Classes.FILL]: fill,
                [Classes.INLINE]: inline,
            },
            className,
        );
    }
}

================================================================================

File: src\components\forms\input-group.md
--------------------------------------------------------------------------------
@# Input group

**InputGroup** is basic building block used to render text inputs across many Blueprint components.
This component allows you to optionally add icons and buttons _within_ a text input to expand its appearance and
functionality. For example, you might use an input group to build a visibility toggle for a password field.

@reactExample InputGroupExample

@## Usage

**InputGroup** supports one non-interactive icon on the left side and one arbitrary element on the right side.
It measures the width of its child elements to create the appropriate right padding inside the input to accommodate
content of any length.

**InputGroup** should be used like a standard React `<input>` element, either in a controlled or uncontrolled fashion.
In addition to its own props, it supports all valid `<input>` HTML attributes and forwards them to the DOM
(the most common ones are detailed below).

If controlled with the `value` prop, **InputGroup** has support for _asynchronous updates_, which may occur with some
form handling libraries like `redux-form`. This is not broadly encouraged (a value returned from `onChange` should be
sent back to the component as a controlled `value` synchronously), but there is basic support for it using the
`asyncControl` prop. Note that the input cursor may jump to the end of the input if the speed of text entry
(time between change events) is faster than the speed of the async update.

For _multiline text_: use [**TextArea**](#core/components/text-area) instead.

@## Props interface

@interface InputGroupProps

@## Search input

Apply the attribute `type="search"` to style a text input as a search field. This styling is equivalent
to what is applied using the `Classes.ROUND` modifier class&mdash;it is automatically applied for `[type="search"]`
inputs.

Note that some browsers also implement a handler for the <kbd>esc</kbd> key to clear the text in a search field.

@reactExample SearchInputExample

@## CSS API

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use [`<InputGroup>`](#core/components/input-group)

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

Note that you cannot use buttons with text in the CSS API for input groups. The padding for text inputs
in CSS cannot accommodate buttons whose width varies due to text content.

</div>

#### `.@ns-input-group`

You can place a single `.@ns-icon` or `.@ns-button.@ns-icon-*` on either end of the input. The order is
dictated by the HTML markup: an element specified before the `input` appears on the left edge, and
vice versa. You do not need to apply sizing classes to the children&mdash;they inherit the size of
the parent input.

@css input-group

#### `.@ns-input`

Apply `Classes.INPUT` on an `input[type="text"]`. You should also specify `dir="auto"`
[to better support RTL languages](http://www.w3.org/International/questions/qa-html-dir#dirauto)
(in all browsers except Internet Explorer).

@css input

================================================================================

File: src\components\forms\inputGroup.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes } from "../../common";
import * as Errors from "../../common/errors";
import {
    type ControlledValueProps,
    DISPLAYNAME_PREFIX,
    type HTMLInputProps,
    removeNonHTMLProps,
} from "../../common/props";
import { Icon } from "../icon/icon";

import { AsyncControllableInput } from "./asyncControllableInput";
import type { InputSharedProps } from "./inputSharedProps";

type ControlledInputValueProps = ControlledValueProps<string, HTMLInputElement>;

export interface InputGroupProps
    extends Omit<HTMLInputProps, keyof ControlledInputValueProps>,
        ControlledInputValueProps,
        InputSharedProps {
    /**
     * Set this to `true` if you will be controlling the `value` of this input with asynchronous updates.
     * These may occur if you do not immediately call setState in a parent component with the value from
     * the `onChange` handler, or if working with certain libraries like __redux-form__.
     *
     * @default false
     */
    asyncControl?: boolean;

    /** Whether this input should use large styles. */
    large?: boolean;

    /** Whether this input should use small styles. */
    small?: boolean;

    /** Whether the input (and any buttons) should appear with rounded caps. */
    round?: boolean;

    /**
     * Name of the HTML tag that contains the input group.
     *
     * @default "div"
     */
    tagName?: keyof React.JSX.IntrinsicElements;

    /**
     * HTML `input` type attribute.
     *
     * @default "text"
     */
    type?: string;
}

export interface InputGroupState {
    leftElementWidth?: number;
    rightElementWidth?: number;
}

const NON_HTML_PROPS: Array<keyof InputGroupProps> = ["onValueChange"];

/**
 * Input group component.
 *
 * @see https://blueprintjs.com/docs/#core/components/input-group
 */
export class InputGroup extends AbstractPureComponent<InputGroupProps, InputGroupState> {
    public static displayName = `${DISPLAYNAME_PREFIX}.InputGroup`;

    public state: InputGroupState = {};

    private leftElement: HTMLElement | null = null;

    private rightElement: HTMLElement | null = null;

    private refHandlers = {
        leftElement: (ref: HTMLSpanElement | null) => (this.leftElement = ref),
        rightElement: (ref: HTMLSpanElement | null) => (this.rightElement = ref),
    };

    public render() {
        const {
            asyncControl = false,
            className,
            disabled,
            fill,
            inputClassName,
            inputRef,
            intent,
            large,
            readOnly,
            round,
            small,
            tagName = "div",
        } = this.props;
        const inputGroupClasses = classNames(
            Classes.INPUT_GROUP,
            Classes.intentClass(intent),
            {
                [Classes.DISABLED]: disabled,
                [Classes.READ_ONLY]: readOnly,
                [Classes.FILL]: fill,
                [Classes.LARGE]: large,
                [Classes.SMALL]: small,
                [Classes.ROUND]: round,
            },
            className,
        );
        const style: React.CSSProperties = {
            ...this.props.style,
            paddingLeft: this.state.leftElementWidth,
            paddingRight: this.state.rightElementWidth,
        };
        const inputProps = {
            type: "text",
            ...removeNonHTMLProps(this.props, NON_HTML_PROPS, true),
            "aria-disabled": disabled,
            className: classNames(Classes.INPUT, inputClassName),
            onChange: this.handleInputChange,
            style,
        } satisfies React.HTMLProps<HTMLInputElement>;
        const inputElement = asyncControl ? (
            <AsyncControllableInput {...inputProps} inputRef={inputRef} />
        ) : (
            <input {...inputProps} ref={inputRef} />
        );

        return React.createElement(
            tagName,
            { className: inputGroupClasses },
            this.maybeRenderLeftElement(),
            inputElement,
            this.maybeRenderRightElement(),
        );
    }

    public componentDidMount() {
        this.updateInputWidth();
    }

    public componentDidUpdate(prevProps: InputGroupProps) {
        const { leftElement, rightElement } = this.props;
        if (prevProps.leftElement !== leftElement || prevProps.rightElement !== rightElement) {
            this.updateInputWidth();
        }
    }

    protected validateProps(props: InputGroupProps) {
        if (props.leftElement != null && props.leftIcon != null) {
            console.warn(Errors.INPUT_WARN_LEFT_ELEMENT_LEFT_ICON_MUTEX);
        }
    }

    private handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const value = event.target.value;
        this.props.onChange?.(event);
        this.props.onValueChange?.(value, event.target);
    };

    private maybeRenderLeftElement() {
        const { leftElement, leftIcon } = this.props;

        if (leftElement != null) {
            return (
                <span className={Classes.INPUT_LEFT_CONTAINER} ref={this.refHandlers.leftElement}>
                    {leftElement}
                </span>
            );
        } else if (leftIcon != null) {
            return <Icon icon={leftIcon} aria-hidden={true} tabIndex={-1} />;
        }

        return undefined;
    }

    private maybeRenderRightElement() {
        const { rightElement } = this.props;
        if (rightElement == null) {
            return undefined;
        }
        return (
            <span className={Classes.INPUT_ACTION} ref={this.refHandlers.rightElement}>
                {rightElement}
            </span>
        );
    }

    private updateInputWidth() {
        const { leftElementWidth, rightElementWidth } = this.state;

        if (this.leftElement != null) {
            const { clientWidth } = this.leftElement;
            // small threshold to prevent infinite loops
            if (leftElementWidth === undefined || Math.abs(clientWidth - leftElementWidth) > 2) {
                this.setState({ leftElementWidth: clientWidth });
            }
        } else {
            this.setState({ leftElementWidth: undefined });
        }

        if (this.rightElement != null) {
            const { clientWidth } = this.rightElement;
            // small threshold to prevent infinite loops
            if (rightElementWidth === undefined || Math.abs(clientWidth - rightElementWidth) > 2) {
                this.setState({ rightElementWidth: clientWidth });
            }
        } else {
            this.setState({ rightElementWidth: undefined });
        }
    }
}

================================================================================

File: src\components\forms\inputSharedProps.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2022 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { IconName } from "@blueprintjs/icons";

import type { IntentProps, MaybeElement, Props } from "../../common/props";

/**
 * Shared props interface for text & numeric inputs.
 */
export interface InputSharedProps extends IntentProps, Props {
    /**
     * Whether the input is disabled.
     *
     * Note that `rightElement` must be disabled separately; this prop will not affect it.
     *
     * @default false
     */
    disabled?: boolean;

    /**
     * Whether the component should take up the full width of its container.
     */
    fill?: boolean;

    /**
     * Class name to apply to the `<input>` element (not the InputGroup container).
     */
    inputClassName?: string;

    /**
     * Ref attached to the HTML `<input>` element backing this component.
     */
    inputRef?: React.Ref<HTMLInputElement>;

    /**
     * Element to render on the left side of input.
     * This prop is mutually exclusive with `leftIcon`.
     */
    leftElement?: React.JSX.Element;

    /**
     * Name of a Blueprint UI icon to render on the left side of the input group,
     * before the user's cursor.
     *
     * This prop is mutually exclusive with `leftElement`.
     *
     * Note: setting a React.JSX.Element here is deprecated; use the `leftElement` prop instead.
     */
    leftIcon?: IconName | MaybeElement;

    /**
     * Placeholder text in the absence of any value.
     */
    placeholder?: string;

    /**
     * Whether the input is read-only.
     *
     * Note that `rightElement` must be disabled or made read-only separately;
     * this prop will not affect it.
     *
     * @default false
     */
    readOnly?: boolean;

    /**
     * Element to render on right side of input.
     * For best results, use a minimal button, tag, or small spinner.
     */
    rightElement?: React.JSX.Element;
}

================================================================================

File: src\components\forms\label.md
--------------------------------------------------------------------------------
@# Label

__Labels__ enhance the usability of your forms.

Wrapping a `<label>` element around a form input effectively increases the area where the user can click to activate
the control. Notice how in the examples below, clicking a label focuses its `<input>`.

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">Prefer form groups over labels</h5>

The [__FormGroup__ component](#core/components/form-group) provides additional functionality such as helper text and
modifier props as well as full label support. __FormGroup__ supports both simple and complex use cases, therefore we
recommend using it exclusively when constructing forms.

</div>

@## Usage

```tsx
<Label>
    Label A
    <input className={Classes.INPUT} placeholder="Placeholder text" />
</Label>

<Label htmlFor="input-b">Label B</Label>
<input className={Classes.INPUT} id="input-b" placeholder="Placeholder text" />
```

@## Props

This component supports the full range of `<label>` DOM attributes.

@interface LabelProps

@## CSS API

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use [`<Label>`](#core/components/forms/label)

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

</div>

Simple labels are useful for basic forms for a single `<input>`.

Apply disabled styles with the `@ns-disabled` class. This styles the label text, but does not disable any nested
children like inputs or selects. You must add the `:disabled` attribute directly to any nested elements to disable them.
Similarly the respective `@ns-*` form control will need a `.@ns-disabled` modifier. See the examples below.

@css label

================================================================================

File: src\components\forms\numeric-input.md
--------------------------------------------------------------------------------
@# Numeric input

**NumericInput** provides controls for inputting, incrementing, and decrementing numeric values.

@## Interactions

The value in a numeric input can be incremented or decremented using both keyboard and mouse interactions.

##### Keyboard interactions

-   `↑/↓` - change the value by one step (default: `±1`)
-   `Shift + ↑/↓` - change the value by one major step (default: `±10`)
-   `Alt + ↑/↓` - change the value by one minor step (default: `±0.1`)

##### Mouse interactions

-   `Click ⌃/⌄` - change the value by one step (default: `±1`)
-   `Shift + Click ⌃/⌄` - change the value by one major step (default: `±10`)
-   `Alt + Click ⌃/⌄` - change the value by one minor step (default: `±0.1`)

@## Basic example

This example shows how **NumericInput** works out of the box. It supports the basic keyboard and mouse interactions
listed above, as well as basic keyboard entry.

@reactExample NumericInputBasicExample

@## Extended example

This example shows how **NumericInput** can be extended beyond its core functionality. It supports the basic
interactions above as well as each of the following types of input:

-   **Number abbreviations** (e.g. `2.1k`, `-0.3m`)
-   **Scientific notation** (e.g. `2.1e3`, `-0.3e6`)
-   **Addition and subtraction expressions** (e.g. `3+2`, `0.1m - 5k + 1`)

These special-case inputs are evaluated when `Enter` is pressed (via a custom `onKeyDown` callback) and when the field
loses focus (via a custom `onBlur` callback). If the input is invalid when either of these callbacks is trigged, the
field will be cleared.

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign">

This example contains non-core functionality that is meant to demonstrate the extensibility of the **NumericInput**
component. The correctness of the custom evaluation code has not been tested robustly.

</div>

@reactExample NumericInputExtendedExample

@## Usage

@### Uncontrolled mode

By default, this component will function in uncontrolled mode, managing all of its own state. In uncontrolled mode,
you mus provide an `onValueChange` callback prop to access the value as the user manipulates it. The value will be
provided to the callback both as a number and as a string.

In general, uncontrolled mode is the recommended API for this component, as it allows users to type non-numeric digits
like `.` and `-` (for decimals and negative numbers, respectively) more easily.

```tsx
import { NumericInput } from "@blueprintjs/core";

export class NumericInputExample extends React.Component {
    public render() {
        return <NumericInput onValueChange={this.handleValueChange} />;
    }

    private handleValueChange = (valueAsNumber: number, valueAsString: string) => {
        console.log("Value as number:", valueAsNumber);
        console.log("Value as string:", valueAsString);
    };
}
```

@### Controlled mode

If you need to have more control over your numeric input's behavior, you can specify the `value` property to use the
component in **controlled mode**.

Note that NumericInput supports arbitrary text entry (not only numeric digits) so the `value`
**should always be provided as a string, not a number**. Accordingly, change event handlers should use the same data
type, namely the _second_ parameter of the `onValueChange` callback. This behavior allows users to type non-numeric
characters like decimal points (".") without the component eagerly coercing those strings to their parsed numeric
equivalents (`0.` becomes `0`, fractional data entry impossible).

Exceptions to this rule may occur if your input only supports _positive integers_, which will not
have any non-numeric characters. See the [precision section](#core/components/numeric-input.numeric-precision)
to learn how to enforce this kind of constraint.

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign">

When handling changes in controlled mode, always use the _second_ parameter of the `onValueChange` callback, which
provides the value as a string. This allows users to type non-numeric characters like decimal points (".") without the
component eagerly coercing those strings to their parsed numeric equivalents (`0.` becomes `0`, fractional data entry
impossible).

</div>

The combined support of arbitrary text entry, controlled mode, and custom callbacks makes it possible to extend the
numeric input's basic functionality in powerful ways. As shown in the example above, one could extend the numeric input
component with support for mathematical expressions as follows:

```tsx
import { NumericInput } from "@blueprintjs/core";
import * as SomeLibrary from "some-library";

interface NumericInputExampleState = {
    value?: number | string;
}

class NumericInputExample extends React.Component<{}, NumericInputExampleState> {
    public state = { value: NumericInput.VALUE_EMPTY };

    public render() {
        return (
            <NumericInput
                onValueChange={this.handleValueChange}
                value={this.state.value}
            />
        );
    }

    private handleValueChange = (_valueAsNumber: number, valueAsString: string) {
        // Important: use the string value to allow typing decimal places and negative numbers
        const result = SomeLibrary.evaluateMathExpression(valueAsString);
        this.setState({ value: result });
    }
}
```

@### Numeric precision

**NumericInput** determines its maximum precision by looking at both the `minorStepSize` and `stepSize` props.
If `minorStepSize` is non-null, the number of decimal places in that value will be the maximum precision.
Otherwise, the component will count the decimal places in `stepSize`.

Configuring these props allows you to expand or constrain the precision of the input. For example, to limit
the input to only integers, you can set `minorStepSize={null}` and allow the default `stepSize` of `1` to take
precedence.

@## Styling

**NumericInput** can be styled with the same set of visual modifier props & CSS classes as
[**ControlGroup**](#core/components/control-group). The most appropriate such modifier for **NumericInput** is `fill`,
which will make the component expand to fill all available width.

@## Props interface

@interface NumericInputProps

================================================================================

File: src\components\forms\numericInput.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { ChevronDown, ChevronUp } from "@blueprintjs/icons";

import {
    AbstractPureComponent,
    Classes,
    DISPLAYNAME_PREFIX,
    type HTMLInputProps,
    Intent,
    Position,
    refHandler,
    removeNonHTMLProps,
    setRef,
    Utils,
} from "../../common";
import * as Errors from "../../common/errors";
import { ButtonGroup } from "../button/buttonGroup";
import { Button } from "../button/buttons";

import { ControlGroup } from "./controlGroup";
import { InputGroup } from "./inputGroup";
import type { InputSharedProps } from "./inputSharedProps";
import {
    clampValue,
    getValueOrEmptyValue,
    isValidNumericKeyboardEvent,
    isValueNumeric,
    parseStringToStringNumber,
    sanitizeNumericInput,
    toLocaleString,
    toMaxPrecision,
} from "./numericInputUtils";

export interface NumericInputProps extends InputSharedProps {
    /**
     * Whether to allow only floating-point number characters in the field,
     * mimicking the native `input[type="number"]`.
     *
     * @default true
     */
    allowNumericCharactersOnly?: boolean;

    /**
     * Set this to `true` if you will be controlling the `value` of this input with asynchronous updates.
     * These may occur if you do not immediately call setState in a parent component with the value from
     * the `onChange` handler.
     */
    asyncControl?: boolean;

    /**
     * The position of the buttons with respect to the input field.
     *
     * @default Position.RIGHT
     */
    buttonPosition?: typeof Position.LEFT | typeof Position.RIGHT | "none";

    /**
     * Whether the value should be clamped to `[min, max]` on blur.
     * The value will be clamped to each bound only if the bound is defined.
     * Note that native `input[type="number"]` controls do *NOT* clamp on blur.
     *
     * @default false
     */
    clampValueOnBlur?: boolean;

    /**
     * In uncontrolled mode, this sets the default value of the input.
     * Note that this value is only used upon component instantiation and changes to this prop
     * during the component lifecycle will be ignored.
     *
     * @default ""
     */
    defaultValue?: number | string;
    /**
     * If set to `true`, the input will display with larger styling.
     * This is equivalent to setting `Classes.LARGE` via className on the
     * parent control group and on the child input group.
     *
     * @default false
     */
    large?: boolean;

    /**
     * The locale name, which is passed to the component to format the number and allowing to type the number in the specific locale.
     * [See MDN documentation for more info about browser locale identification](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation).
     *
     * @default ""
     */
    locale?: string;

    /**
     * The increment between successive values when <kbd>shift</kbd> is held.
     * Pass explicit `null` value to disable this interaction.
     *
     * @default 10
     */
    majorStepSize?: number | null;

    /** The maximum value of the input. */
    max?: number;

    /** The minimum value of the input. */
    min?: number;

    /**
     * The increment between successive values when <kbd>alt</kbd> is held.
     * Pass explicit `null` value to disable this interaction.
     *
     * @default 0.1
     */
    minorStepSize?: number | null;

    /**
     * Whether the entire text field should be selected on focus.
     *
     * @default false
     */
    selectAllOnFocus?: boolean;

    /**
     * Whether the entire text field should be selected on increment.
     *
     * @default false
     */
    selectAllOnIncrement?: boolean;

    /**
     * If set to `true`, the input will display with smaller styling.
     * This is equivalent to setting `Classes.SMALL` via className on the
     * parent control group and on the child input group.
     *
     * @default false
     */
    small?: boolean;

    /**
     * The increment between successive values when no modifier keys are held.
     *
     * @default 1
     */
    stepSize?: number;

    /**
     * The value to display in the input field.
     */
    value?: number | string;

    /** The callback invoked when the value changes due to a button click. */
    onButtonClick?(valueAsNumber: number, valueAsString: string): void;

    /** The callback invoked when the value changes due to typing, arrow keys, or button clicks. */
    onValueChange?(valueAsNumber: number, valueAsString: string, inputElement: HTMLInputElement | null): void;
}

export interface NumericInputState {
    currentImeInputInvalid: boolean;
    prevMinProp?: number;
    prevMaxProp?: number;
    shouldSelectAfterUpdate: boolean;
    stepMaxPrecision: number;
    value: string;
}

enum IncrementDirection {
    DOWN = -1,
    UP = +1,
}

const NON_HTML_PROPS: Array<keyof NumericInputProps> = [
    "allowNumericCharactersOnly",
    "buttonPosition",
    "clampValueOnBlur",
    "className",
    "defaultValue",
    "majorStepSize",
    "minorStepSize",
    "onButtonClick",
    "onValueChange",
    "selectAllOnFocus",
    "selectAllOnIncrement",
    "stepSize",
];

type ButtonEventHandlers = Required<Pick<React.HTMLAttributes<HTMLElement>, "onKeyDown" | "onMouseDown">>;

/**
 * Numeric input component.
 *
 * @see https://blueprintjs.com/docs/#core/components/numeric-input
 */
export class NumericInput extends AbstractPureComponent<HTMLInputProps & NumericInputProps, NumericInputState> {
    public static displayName = `${DISPLAYNAME_PREFIX}.NumericInput`;

    public static VALUE_EMPTY = "";

    public static VALUE_ZERO = "0";

    private numericInputId = Utils.uniqueId("numericInput");

    public static defaultProps: NumericInputProps = {
        allowNumericCharactersOnly: true,
        buttonPosition: Position.RIGHT,
        clampValueOnBlur: false,
        defaultValue: NumericInput.VALUE_EMPTY,
        large: false,
        majorStepSize: 10,
        minorStepSize: 0.1,
        selectAllOnFocus: false,
        selectAllOnIncrement: false,
        small: false,
        stepSize: 1,
    };

    public static getDerivedStateFromProps(props: NumericInputProps, state: NumericInputState) {
        const nextState = {
            prevMaxProp: props.max,
            prevMinProp: props.min,
        };

        const didMinChange = props.min !== state.prevMinProp;
        const didMaxChange = props.max !== state.prevMaxProp;
        const didBoundsChange = didMinChange || didMaxChange;

        // in controlled mode, use props.value
        // in uncontrolled mode, if state.value has not been assigned yet (upon initial mount), use props.defaultValue
        const value = props.value?.toString() ?? state.value;
        const stepMaxPrecision = NumericInput.getStepMaxPrecision(props);

        const sanitizedValue =
            value !== NumericInput.VALUE_EMPTY
                ? NumericInput.roundAndClampValue(value, stepMaxPrecision, props.min, props.max, 0, props.locale)
                : NumericInput.VALUE_EMPTY;

        // if a new min and max were provided that cause the existing value to fall
        // outside of the new bounds, then clamp the value to the new valid range.
        if (didBoundsChange && sanitizedValue !== state.value) {
            return { ...nextState, stepMaxPrecision, value: sanitizedValue };
        }
        return { ...nextState, stepMaxPrecision, value };
    }

    private static CONTINUOUS_CHANGE_DELAY = 300;

    private static CONTINUOUS_CHANGE_INTERVAL = 100;

    // Value Helpers
    // =============
    private static getStepMaxPrecision(props: HTMLInputProps & NumericInputProps) {
        if (props.minorStepSize != null) {
            return Utils.countDecimalPlaces(props.minorStepSize);
        } else {
            return Utils.countDecimalPlaces(props.stepSize!);
        }
    }

    private static roundAndClampValue(
        value: string,
        stepMaxPrecision: number,
        min: number | undefined,
        max: number | undefined,
        delta = 0,
        locale: string | undefined,
    ) {
        if (!isValueNumeric(value, locale)) {
            return NumericInput.VALUE_EMPTY;
        }
        const currentValue = parseStringToStringNumber(value, locale);
        const nextValue = toMaxPrecision(Number(currentValue) + delta, stepMaxPrecision);
        const clampedValue = clampValue(nextValue, min, max);
        return toLocaleString(clampedValue, locale);
    }

    public state: NumericInputState = {
        currentImeInputInvalid: false,
        shouldSelectAfterUpdate: false,
        stepMaxPrecision: NumericInput.getStepMaxPrecision(this.props),
        value: getValueOrEmptyValue(this.props.value ?? this.props.defaultValue),
    };

    // updating these flags need not trigger re-renders, so don't include them in this.state.
    private didPasteEventJustOccur = false;

    private delta = 0;

    public inputElement: HTMLInputElement | null = null;

    private inputRef: React.Ref<HTMLInputElement> = refHandler(this, "inputElement", this.props.inputRef);

    private intervalId?: number;

    private incrementButtonHandlers = this.getButtonEventHandlers(IncrementDirection.UP);

    private decrementButtonHandlers = this.getButtonEventHandlers(IncrementDirection.DOWN);

    private getCurrentValueAsNumber = () => Number(parseStringToStringNumber(this.state.value, this.props.locale));

    public render() {
        const { buttonPosition, className, fill, large, small } = this.props;
        const containerClasses = classNames(
            Classes.NUMERIC_INPUT,
            { [Classes.LARGE]: large, [Classes.SMALL]: small },
            className,
        );
        const buttons = this.renderButtons();
        return (
            <ControlGroup className={containerClasses} fill={fill}>
                {buttonPosition === Position.LEFT && buttons}
                {this.renderInput()}
                {buttonPosition === Position.RIGHT && buttons}
            </ControlGroup>
        );
    }

    public componentDidUpdate(prevProps: NumericInputProps, prevState: NumericInputState) {
        super.componentDidUpdate(prevProps, prevState);

        if (prevProps.inputRef !== this.props.inputRef) {
            setRef(prevProps.inputRef, null);
            this.inputRef = refHandler(this, "inputElement", this.props.inputRef);
            setRef(this.props.inputRef, this.inputElement);
        }

        if (this.state.shouldSelectAfterUpdate) {
            this.inputElement?.setSelectionRange(0, this.state.value.length);
        }

        const didMinChange = this.props.min !== prevProps.min;
        const didMaxChange = this.props.max !== prevProps.max;
        const didBoundsChange = didMinChange || didMaxChange;
        const didLocaleChange = this.props.locale !== prevProps.locale;
        const didValueChange = this.state.value !== prevState.value;

        if ((didBoundsChange && didValueChange) || (didLocaleChange && prevState.value !== NumericInput.VALUE_EMPTY)) {
            // we clamped the value due to a bounds change, so we should fire the change callback
            const valueToParse = didLocaleChange ? prevState.value : this.state.value;
            const valueAsString = parseStringToStringNumber(valueToParse, prevProps.locale);
            const localizedValue = toLocaleString(+valueAsString, this.props.locale);

            this.props.onValueChange?.(+valueAsString, localizedValue, this.inputElement);
        }
    }

    protected validateProps(nextProps: HTMLInputProps & NumericInputProps) {
        const { majorStepSize, max, min, minorStepSize, stepSize, value } = nextProps;
        if (min != null && max != null && min > max) {
            console.error(Errors.NUMERIC_INPUT_MIN_MAX);
        }
        if (stepSize! <= 0) {
            console.error(Errors.NUMERIC_INPUT_STEP_SIZE_NON_POSITIVE);
        }
        if (minorStepSize && minorStepSize <= 0) {
            console.error(Errors.NUMERIC_INPUT_MINOR_STEP_SIZE_NON_POSITIVE);
        }
        if (majorStepSize && majorStepSize <= 0) {
            console.error(Errors.NUMERIC_INPUT_MAJOR_STEP_SIZE_NON_POSITIVE);
        }
        if (minorStepSize && minorStepSize > stepSize!) {
            console.error(Errors.NUMERIC_INPUT_MINOR_STEP_SIZE_BOUND);
        }
        if (majorStepSize && majorStepSize < stepSize!) {
            console.error(Errors.NUMERIC_INPUT_MAJOR_STEP_SIZE_BOUND);
        }

        // controlled mode
        if (value != null) {
            const stepMaxPrecision = NumericInput.getStepMaxPrecision(nextProps);
            const sanitizedValue = NumericInput.roundAndClampValue(
                value.toString(),
                stepMaxPrecision,
                min,
                max,
                0,
                this.props.locale,
            );
            const valueDoesNotMatch = sanitizedValue !== value.toString();
            const localizedValue = toLocaleString(
                Number(parseStringToStringNumber(value, this.props.locale)),
                this.props.locale,
            );
            const isNotLocalized = sanitizedValue !== localizedValue;

            if (valueDoesNotMatch && isNotLocalized) {
                console.warn(Errors.NUMERIC_INPUT_CONTROLLED_VALUE_INVALID);
            }
        }
    }

    // Render Helpers
    // ==============

    private renderButtons() {
        const { intent, max, min, locale } = this.props;
        const value = parseStringToStringNumber(this.state.value, locale);
        const disabled = this.props.disabled || this.props.readOnly;
        const isIncrementDisabled = max !== undefined && value !== "" && +value >= max;
        const isDecrementDisabled = min !== undefined && value !== "" && +value <= min;

        return (
            <ButtonGroup className={Classes.FIXED} key="button-group" vertical={true}>
                <Button
                    aria-label="increment"
                    aria-controls={this.numericInputId}
                    disabled={disabled || isIncrementDisabled}
                    icon={<ChevronUp />}
                    intent={intent}
                    {...this.incrementButtonHandlers}
                />
                <Button
                    aria-label="decrement"
                    aria-controls={this.numericInputId}
                    disabled={disabled || isDecrementDisabled}
                    icon={<ChevronDown />}
                    intent={intent}
                    {...this.decrementButtonHandlers}
                />
            </ButtonGroup>
        );
    }

    private renderInput() {
        const inputGroupHtmlProps = removeNonHTMLProps(this.props, NON_HTML_PROPS, true);
        const valueAsNumber = this.getCurrentValueAsNumber();

        return (
            <InputGroup
                asyncControl={this.props.asyncControl}
                autoComplete="off"
                id={this.numericInputId}
                role={this.props.allowNumericCharactersOnly ? "spinbutton" : undefined}
                {...inputGroupHtmlProps}
                aria-valuemax={this.props.max}
                aria-valuemin={this.props.min}
                aria-valuenow={valueAsNumber}
                intent={this.state.currentImeInputInvalid ? Intent.DANGER : this.props.intent}
                inputClassName={this.props.inputClassName}
                inputRef={this.inputRef}
                large={this.props.large}
                leftElement={this.props.leftElement}
                leftIcon={this.props.leftIcon}
                onFocus={this.handleInputFocus}
                onBlur={this.handleInputBlur}
                onCompositionEnd={this.handleCompositionEnd}
                onCompositionUpdate={this.handleCompositionUpdate}
                onKeyDown={this.handleInputKeyDown}
                onKeyPress={this.handleInputKeyPress}
                onPaste={this.handleInputPaste}
                onValueChange={this.handleInputChange}
                rightElement={this.props.rightElement}
                small={this.props.small}
                value={this.state.value}
            />
        );
    }

    // Callbacks - Buttons
    // ===================

    private getButtonEventHandlers(direction: IncrementDirection): ButtonEventHandlers {
        return {
            // keydown is fired repeatedly when held so it's implicitly continuous
            onKeyDown: evt => {
                if (!this.props.disabled && Utils.isKeyboardClick(evt)) {
                    this.handleButtonClick(evt, direction);
                }
            },
            onMouseDown: evt => {
                if (!this.props.disabled) {
                    this.handleButtonClick(evt, direction);
                    this.startContinuousChange();
                }
            },
        };
    }

    private handleButtonClick = (e: React.MouseEvent | React.KeyboardEvent, direction: IncrementDirection) => {
        const delta = this.updateDelta(direction, e);
        const nextValue = this.incrementValue(delta);
        this.props.onButtonClick?.(Number(parseStringToStringNumber(nextValue, this.props.locale)), nextValue);
    };

    private startContinuousChange() {
        // The button's onMouseUp event handler doesn't fire if the user
        // releases outside of the button, so we need to watch all the way
        // from the top.
        document.addEventListener("mouseup", this.stopContinuousChange);

        // Initial delay is slightly longer to prevent the user from
        // accidentally triggering the continuous increment/decrement.
        this.setTimeout(() => {
            this.intervalId = window.setInterval(this.handleContinuousChange, NumericInput.CONTINUOUS_CHANGE_INTERVAL);
        }, NumericInput.CONTINUOUS_CHANGE_DELAY);
    }

    private stopContinuousChange = () => {
        this.delta = 0;
        this.clearTimeouts();
        clearInterval(this.intervalId);
        document.removeEventListener("mouseup", this.stopContinuousChange);
    };

    private handleContinuousChange = () => {
        // If either min or max prop is set, when reaching the limit
        // the button will be disabled and stopContinuousChange will be never fired,
        // hence the need to check on each iteration to properly clear the timeout
        if (this.props.min !== undefined || this.props.max !== undefined) {
            const min = this.props.min ?? -Infinity;
            const max = this.props.max ?? Infinity;
            const valueAsNumber = this.getCurrentValueAsNumber();
            if (valueAsNumber <= min || valueAsNumber >= max) {
                this.stopContinuousChange();
                return;
            }
        }
        const nextValue = this.incrementValue(this.delta);
        this.props.onButtonClick?.(Number(parseStringToStringNumber(nextValue, this.props.locale)), nextValue);
    };

    // Callbacks - Input
    // =================

    private handleInputFocus = (e: React.FocusEvent<HTMLInputElement>) => {
        // update this state flag to trigger update for input selection (see componentDidUpdate)
        this.setState({ shouldSelectAfterUpdate: this.props.selectAllOnFocus! });
        this.props.onFocus?.(e);
    };

    private handleInputBlur = (e: React.FocusEvent<HTMLInputElement>) => {
        // always disable this flag on blur so it's ready for next time.
        this.setState({ shouldSelectAfterUpdate: false });

        if (this.props.clampValueOnBlur) {
            const { value } = e.target as HTMLInputElement;
            this.handleNextValue(this.roundAndClampValue(value));
        }

        this.props.onBlur?.(e);
    };

    private handleInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
        if (this.props.disabled || this.props.readOnly) {
            return;
        }

        let direction: IncrementDirection | undefined;

        if (e.key === "ArrowUp") {
            direction = IncrementDirection.UP;
        } else if (e.key === "ArrowDown") {
            direction = IncrementDirection.DOWN;
        }

        if (direction !== undefined) {
            // when the input field has focus, some key combinations will modify
            // the field's selection range. we'll actually want to select all
            // text in the field after we modify the value on the following
            // lines. preventing the default selection behavior lets us do that
            // without interference.
            e.preventDefault();

            const delta = this.updateDelta(direction, e);
            this.incrementValue(delta);
        }

        this.props.onKeyDown?.(e);
    };

    private handleCompositionEnd = (e: React.CompositionEvent<HTMLInputElement>) => {
        if (this.props.allowNumericCharactersOnly) {
            this.handleNextValue(sanitizeNumericInput(e.data, this.props.locale));
            this.setState({ currentImeInputInvalid: false });
        }
    };

    private handleCompositionUpdate = (e: React.CompositionEvent<HTMLInputElement>) => {
        if (this.props.allowNumericCharactersOnly) {
            const { data } = e;
            const sanitizedValue = sanitizeNumericInput(data, this.props.locale);
            if (sanitizedValue.length === 0 && data.length > 0) {
                this.setState({ currentImeInputInvalid: true });
            } else {
                this.setState({ currentImeInputInvalid: false });
            }
        }
    };

    private handleInputKeyPress = (e: React.KeyboardEvent<HTMLInputElement>) => {
        // we prohibit keystrokes in onKeyPress instead of onKeyDown, because
        // e.key is not trustworthy in onKeyDown in all browsers.
        if (this.props.allowNumericCharactersOnly && !isValidNumericKeyboardEvent(e, this.props.locale)) {
            e.preventDefault();
        }

        // eslint-disable-next-line deprecation/deprecation
        this.props.onKeyPress?.(e);
    };

    private handleInputPaste = (e: React.ClipboardEvent<HTMLInputElement>) => {
        this.didPasteEventJustOccur = true;
        this.props.onPaste?.(e);
    };

    private handleInputChange = (value: string) => {
        let nextValue = value;
        if (this.props.allowNumericCharactersOnly && this.didPasteEventJustOccur) {
            this.didPasteEventJustOccur = false;
            nextValue = sanitizeNumericInput(value, this.props.locale);
        }

        this.handleNextValue(nextValue);
        this.setState({ shouldSelectAfterUpdate: false });
    };

    // Data logic
    // ==========

    private handleNextValue(valueAsString: string) {
        if (this.props.value == null) {
            this.setState({ value: valueAsString });
        }

        this.props.onValueChange?.(
            Number(parseStringToStringNumber(valueAsString, this.props.locale)),
            valueAsString,
            this.inputElement,
        );
    }

    private incrementValue(delta: number) {
        // pretend we're incrementing from 0 if currValue is empty
        const currValue = this.state.value === NumericInput.VALUE_EMPTY ? NumericInput.VALUE_ZERO : this.state.value;
        const nextValue = this.roundAndClampValue(currValue, delta);

        if (nextValue !== this.state.value) {
            this.handleNextValue(nextValue);
            this.setState({ shouldSelectAfterUpdate: this.props.selectAllOnIncrement! });
        }

        // return value used in continuous change updates
        return nextValue;
    }

    private getIncrementDelta(direction: IncrementDirection, isShiftKeyPressed: boolean, isAltKeyPressed: boolean) {
        const { majorStepSize, minorStepSize, stepSize } = this.props;

        if (isShiftKeyPressed && majorStepSize != null) {
            return direction * majorStepSize;
        } else if (isAltKeyPressed && minorStepSize != null) {
            return direction * minorStepSize;
        } else {
            return direction * stepSize!;
        }
    }

    private roundAndClampValue(value: string, delta = 0) {
        return NumericInput.roundAndClampValue(
            value,
            this.state.stepMaxPrecision,
            this.props.min,
            this.props.max,
            delta,
            this.props.locale,
        );
    }

    private updateDelta(direction: IncrementDirection, e: React.MouseEvent | React.KeyboardEvent) {
        this.delta = this.getIncrementDelta(direction, e.shiftKey, e.altKey);
        return this.delta;
    }
}

================================================================================

File: src\components\forms\numericInputUtils.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { clamp } from "../../common/utils";

/** Returns the `decimal` number separator based on locale */
function getDecimalSeparator(locale: string) {
    const testNumber = 1.9;
    const testText = testNumber.toLocaleString(locale);
    const one = (1).toLocaleString(locale);
    const nine = (9).toLocaleString(locale);
    const pattern = `${one}(.+)${nine}`;

    const result = new RegExp(pattern).exec(testText);

    return (result && result[1]) || ".";
}

export function toLocaleString(num: number, locale: string = "en-US") {
    // HACKHACK: roundingPriority is not supported yet in TypeScript https://github.com/microsoft/TypeScript/issues/43336
    return sanitizeNumericInput(num.toLocaleString(locale, { roundingPriority: "morePrecision" } as any), locale);
}

export function clampValue(value: number, min?: number, max?: number) {
    // defaultProps won't work if the user passes in null, so just default
    // to +/- infinity here instead, as a catch-all.
    const adjustedMin = min != null ? min : -Infinity;
    const adjustedMax = max != null ? max : Infinity;
    return clamp(value, adjustedMin, adjustedMax);
}

export function getValueOrEmptyValue(value: number | string = "") {
    return value.toString();
}

/** Transform the localized character (ex. "") to a javascript recognizable string number (ex. "10.99")  */
function transformLocalizedNumberToStringNumber(character: string, locale: string) {
    const charactersMap = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(value => value.toLocaleString(locale));
    const jsNumber = charactersMap.indexOf(character);

    if (jsNumber !== -1) {
        return jsNumber;
    } else {
        return character;
    }
}

/** Transforms the localized number (ex. "10,99") to a javascript recognizable string number (ex. "10.99")  */
export function parseStringToStringNumber(value: number | string, locale: string | undefined): string {
    const valueAsString = "" + value;
    if (parseFloat(valueAsString).toString() === value.toString()) {
        return value.toString();
    }

    if (locale !== undefined) {
        const decimalSeparator = getDecimalSeparator(locale);
        const sanitizedString = sanitizeNumericInput(valueAsString, locale);

        return sanitizedString
            .split("")
            .map(character => transformLocalizedNumberToStringNumber(character, locale))
            .join("")
            .replace(decimalSeparator, ".");
    }

    return value.toString();
}

/** Returns `true` if the string represents a valid numeric value, like "1e6". */
export function isValueNumeric(value: string, locale: string | undefined) {
    // checking if a string is numeric in Typescript is a big pain, because
    // we can't simply toss a string parameter to isFinite. below is the
    // essential approach that jQuery uses, which involves subtracting a
    // parsed numeric value from the string representation of the value. we
    // need to cast the value to the `any` type to allow this operation
    // between dissimilar types.
    const stringToStringNumber = parseStringToStringNumber(value, locale);
    return value != null && (stringToStringNumber as any) - parseFloat(stringToStringNumber) + 1 >= 0;
}

export function isValidNumericKeyboardEvent(e: React.KeyboardEvent, locale: string | undefined) {
    // unit tests may not include e.key. don't bother disabling those events.
    if (e.key == null) {
        return true;
    }

    // allow modified key strokes that may involve letters and other
    // non-numeric/invalid characters (Cmd + A, Cmd + C, Cmd + V, Cmd + X).
    if (e.ctrlKey || e.altKey || e.metaKey) {
        return true;
    }

    // keys that print a single character when pressed have a `key` name of
    // length 1. every other key has a longer `key` name (e.g. "Backspace",
    // "ArrowUp", "Shift"). since none of those keys can print a character
    // to the field--and since they may have important native behaviors
    // beyond printing a character--we don't want to disable their effects.
    const isSingleCharKey = e.key.length === 1;
    if (!isSingleCharKey) {
        return true;
    }

    // now we can simply check that the single character that wants to be printed
    // is a floating-point number character that we're allowed to print.
    return isFloatingPointNumericCharacter(e.key, locale);
}

/**
 * A regex that matches a string of length 1 (i.e. a standalone character)
 * if and only if it is a floating-point number character as defined by W3C:
 * https://www.w3.org/TR/2012/WD-html-markup-20120329/datatypes.html#common.data.float
 *
 * Floating-point number characters are the only characters that can be
 * printed within a default input[type="number"]. This component should
 * behave the same way when this.props.allowNumericCharactersOnly = true.
 * See here for the input[type="number"].value spec:
 * https://www.w3.org/TR/2012/WD-html-markup-20120329/input.number.html#input.number.attrs.value
 */
function isFloatingPointNumericCharacter(character: string, locale: string | undefined) {
    if (locale !== undefined) {
        const decimalSeparator = getDecimalSeparator(locale).replace(".", "\\.");
        const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(value => value.toLocaleString(locale)).join("");
        const localeFloatingPointNumericCharacterRegex = new RegExp(
            "^[Ee" + numbers + "\\+\\-" + decimalSeparator + "]$",
        );

        return localeFloatingPointNumericCharacterRegex.test(character);
    } else {
        const floatingPointNumericCharacterRegex = /^[Ee0-9\+\-\.]$/;

        return floatingPointNumericCharacterRegex.test(character);
    }
}

/**
 * Round the value to have _up to_ the specified maximum precision.
 *
 * This differs from `toFixed(5)` in that trailing zeroes are not added on
 * more precise values, resulting in shorter strings.
 */
export function toMaxPrecision(value: number, maxPrecision: number) {
    // round the value to have the specified maximum precision (toFixed is the wrong choice,
    // because it would show trailing zeros in the decimal part out to the specified precision)
    // source: http://stackoverflow.com/a/18358056/5199574
    const scaleFactor = Math.pow(10, maxPrecision);
    return Math.round(value * scaleFactor) / scaleFactor;
}

/**
 * Convert Japanese full-width numbers, e.g. '５', to ASCII, e.g. '5'
 * This should be called before performing any other numeric string input validation.
 */
function convertFullWidthNumbersToAscii(value: string) {
    return value.replace(/[\uFF10-\uFF19]/g, m => String.fromCharCode(m.charCodeAt(0) - 0xfee0));
}

/**
 * Convert full-width (Japanese) numbers to ASCII, and strip all characters that are not valid floating-point numeric characters
 */
export function sanitizeNumericInput(value: string, locale: string | undefined) {
    const valueChars = convertFullWidthNumbersToAscii(value).split("");
    const sanitizedValueChars = valueChars.filter(valueChar => isFloatingPointNumericCharacter(valueChar, locale));

    return sanitizedValueChars.join("");
}

================================================================================

File: src\components\forms\radio.md
--------------------------------------------------------------------------------
@# Radio

A radio button typically represents a single option in a mutually exclusive list (where only one item can be
selected at a time). Blueprint provides **Radio** and **RadioGroup** components for these two layers.

@reactExample RadioExample

@## Usage

Typically, radio buttons are used in a group to choose one option from several, similar to how a `<select>` element
contains several `<option>` elements. As such, you can use the **RadioGroup** component with a series of **Radio** children.
**RadioGroup** is responsible for managing state and interaction.

```tsx
<RadioGroup label="Lunch special" onChange={handleMealChange} selectedValue={mealType}>
    <Radio label="Soup" value="one" />
    <Radio label="Salad" value="two" />
    <Radio label="Sandwich" value="three" />
</RadioGroup>
```

@## Props interface

**Radio** supports the full range of HTML `<input>` attributes.

@interface RadioProps

@### RadioGroup

@interface RadioGroupProps

@interface OptionProps

@## CSS

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use [`<Checkbox>`](#core/components/checkbox)

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

</div>

Blueprint's custom radio buttons use an extra `.@ns-control-indicator` element after the `<input>` to achieve their
custom styling. You should then wrap the whole thing in a `<label>` with the classes `.@ns-control.@ns-radio`.

Note that attribute modifiers (`:checked`, `:disabled`) are applied on the internal `<input>` element.

@css radio

================================================================================

File: src\components\forms\radioGroup.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, type OptionProps, type Props } from "../../common";
import * as Errors from "../../common/errors";
import { isElementOfType } from "../../common/utils";
import { RadioCard } from "../control-card/radioCard";

import type { ControlProps } from "./controlProps";
import { Radio, type RadioProps } from "./controls";

export interface RadioGroupProps extends Props {
    /**
     * Radio elements. This prop is mutually exclusive with `options`.
     */
    children?: React.ReactNode;

    /**
     * Whether the group and _all_ its radios are disabled.
     * Individual radios can be disabled using their `disabled` prop.
     */
    disabled?: boolean;

    /**
     * Whether the radio buttons are to be displayed inline horizontally.
     */
    inline?: boolean;

    /** Optional label text to display above the radio buttons. */
    label?: React.ReactNode;

    /**
     * Name of the group, used to link radio buttons together in HTML.
     * If omitted, a unique name will be generated internally.
     */
    name?: string;

    /**
     * Callback invoked when the currently selected radio changes.
     * Use `event.currentTarget.value` to read the currently selected value.
     * This prop is required because this component only supports controlled usage.
     */
    onChange: (event: React.FormEvent<HTMLInputElement>) => void;

    /**
     * Array of options to render in the group. This prop is mutually exclusive
     * with `children`: either provide an array of `OptionProps` objects or
     * provide `<Radio>` children elements.
     */
    options?: readonly OptionProps[];

    /** Value of the selected radio. The child with this value will be `:checked`. */
    selectedValue?: string | number;
}

let counter = 0;
function nextName() {
    return `${RadioGroup.displayName}-${counter++}`;
}

/**
 * Radio group component.
 *
 * @see https://blueprintjs.com/docs/#core/components/radio.radiogroup
 */
export class RadioGroup extends AbstractPureComponent<RadioGroupProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.RadioGroup`;

    // a unique name for this group, which can be overridden by `name` prop.
    private autoGroupName = nextName();

    public render() {
        const { label } = this.props;
        return (
            <div className={classNames(Classes.RADIO_GROUP, this.props.className)}>
                {label == null ? null : <label className={Classes.LABEL}>{label}</label>}
                {Array.isArray(this.props.options) ? this.renderOptions() : this.renderChildren()}
            </div>
        );
    }

    protected validateProps() {
        if (this.props.children != null && this.props.options != null) {
            console.warn(Errors.RADIOGROUP_WARN_CHILDREN_OPTIONS_MUTEX);
        }
    }

    private renderChildren() {
        return React.Children.map(this.props.children, child => {
            if (isElementOfType(child, Radio) || isElementOfType(child, RadioCard)) {
                return React.cloneElement(
                    // Need this cast here to suppress a TS error caused by differing `ref` types for the Radio and
                    // RadioCard components. We aren't injecting a ref, so we don't need to be strict about that
                    // incompatibility.
                    child as React.ReactElement<ControlProps>,
                    this.getRadioProps(child.props as OptionProps),
                );
            } else {
                return child;
            }
        });
    }

    private renderOptions() {
        return this.props.options?.map(option => (
            <Radio {...this.getRadioProps(option)} key={option.value} labelElement={option.label || option.value} />
        ));
    }

    private getRadioProps(optionProps: OptionProps): Omit<RadioProps, "ref"> {
        const { name } = this.props;
        const { className, disabled, value } = optionProps;
        return {
            checked: value === this.props.selectedValue,
            className,
            disabled: disabled || this.props.disabled,
            inline: this.props.inline,
            name: name == null ? this.autoGroupName : name,
            onChange: this.props.onChange,
            value,
        };
    }
}

================================================================================

File: src\components\forms\switch.md
--------------------------------------------------------------------------------
@# Switch

__Switch__ is a form control for toggling between boolean states. It is similar to
[__Checkbox__](#core/components/checkbox), but presents a more skeuomorphic appearance that mimics a physical switch.

Its whole label is interactive and it supports a few visual modifiers for different UI layouts.

@reactExample SwitchExample

@## Props interface

@interface SwitchProps

@## CSS API

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use [`<Switch>`](#core/components/switch)

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

</div>

@css switch

================================================================================

File: src\components\forms\text-area.md
--------------------------------------------------------------------------------
@# Text area

**TextArea** is a multiline text input component which can be controlled similar to an
[**InputGroup**](#core/components/input-group) component or `<input>` element.

@reactExample TextAreaExample

@## Props interface

@interface TextAreaProps

@## CSS API

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use [`<TextArea>`](#core/components/text-area)

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

</div>

Apply `Classes.INPUT` to a `<textarea>` element.

@css textarea

================================================================================

File: src\components\forms\textArea.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes, refHandler, setRef } from "../../common";
import { DISPLAYNAME_PREFIX, type IntentProps, type Props } from "../../common/props";

import { AsyncControllableTextArea } from "./asyncControllableTextArea";

export interface TextAreaProps extends IntentProps, Props, React.TextareaHTMLAttributes<HTMLTextAreaElement> {
    /**
     * Set this to `true` if you will be controlling the `value` of this input with asynchronous updates.
     * These may occur if you do not immediately call setState in a parent component with the value from
     * the `onChange` handler, or if working with certain libraries like __redux-form__.
     *
     * @default false
     */
    asyncControl?: boolean;

    /**
     * Whether the component should automatically resize vertically as a user types in the text input.
     * This will disable manual resizing in the vertical dimension.
     *
     * @default false
     */
    autoResize?: boolean;

    /**
     * Whether the text area should take up the full width of its container.
     *
     * @default false
     */
    fill?: boolean;

    /**
     * Whether the text area should automatically grow vertically to accomodate content.
     *
     * @deprecated use the `autoResize` prop instead.
     */
    growVertically?: boolean;

    /**
     * Ref handler that receives HTML `<textarea>` element backing this component.
     */
    inputRef?: React.Ref<HTMLTextAreaElement>;

    /**
     * Whether the text area should appear with large styling.
     *
     * @default false
     */
    large?: boolean;

    /**
     * Whether the text area should appear with small styling.
     *
     * @default false
     */
    small?: boolean;
}

export interface TextAreaState {
    height?: number;
}

// this component is simple enough that tests would be purely tautological.
/* istanbul ignore next */
/**
 * Text area component.
 *
 * @see https://blueprintjs.com/docs/#core/components/text-area
 */
export class TextArea extends AbstractPureComponent<TextAreaProps, TextAreaState> {
    public static defaultProps: TextAreaProps = {
        autoResize: false,
        fill: false,
        large: false,
        small: false,
    };

    public static displayName = `${DISPLAYNAME_PREFIX}.TextArea`;

    public state: TextAreaState = {};

    // used to measure and set the height of the component on first mount
    public textareaElement: HTMLTextAreaElement | null = null;

    private handleRef: React.RefCallback<HTMLTextAreaElement> = refHandler(
        this,
        "textareaElement",
        this.props.inputRef,
    );

    private maybeSyncHeightToScrollHeight = () => {
        // eslint-disable-next-line deprecation/deprecation
        const { autoResize, growVertically } = this.props;

        if (this.textareaElement != null) {
            const { scrollHeight } = this.textareaElement;

            if (autoResize) {
                // set height to 0 to force scrollHeight to be the minimum height to fit
                // the content of the textarea
                this.textareaElement.style.height = "0px";
                this.textareaElement.style.height = scrollHeight.toString() + "px";
                this.setState({ height: scrollHeight });
            } else if (growVertically && scrollHeight > 0) {
                // N.B. this code path will be deleted in Blueprint v6.0 when `growVertically` is removed
                this.setState({ height: scrollHeight });
            }
        }

        if (this.props.autoResize && this.textareaElement != null) {
            // set height to 0 to force scrollHeight to be the minimum height to fit
            // the content of the textarea
            this.textareaElement.style.height = "0px";

            const { scrollHeight } = this.textareaElement;
            this.textareaElement.style.height = scrollHeight.toString() + "px";
            this.setState({ height: scrollHeight });
        }
    };

    public componentDidMount() {
        this.maybeSyncHeightToScrollHeight();
    }

    public componentDidUpdate(prevProps: TextAreaProps) {
        if (prevProps.inputRef !== this.props.inputRef) {
            setRef(prevProps.inputRef, null);
            this.handleRef = refHandler(this, "textareaElement", this.props.inputRef);
            setRef(this.props.inputRef, this.textareaElement);
        }

        if (prevProps.value !== this.props.value || prevProps.style !== this.props.style) {
            this.maybeSyncHeightToScrollHeight();
        }
    }

    public render() {
        const {
            asyncControl,
            autoResize,
            className,
            fill,
            // eslint-disable-next-line deprecation/deprecation
            growVertically,
            inputRef,
            intent,
            large,
            small,
            ...htmlProps
        } = this.props;

        const rootClasses = classNames(
            Classes.INPUT,
            Classes.TEXT_AREA,
            Classes.intentClass(intent),
            {
                [Classes.FILL]: fill,
                [Classes.LARGE]: large,
                [Classes.SMALL]: small,
                [Classes.TEXT_AREA_AUTO_RESIZE]: autoResize,
            },
            className,
        );

        // add explicit height style while preserving user-supplied styles if they exist
        let { style = {} } = htmlProps;
        if ((autoResize || growVertically) && this.state.height != null) {
            // this style object becomes non-extensible when mounted (at least in the enzyme renderer),
            // so we make a new one to add a property
            style = {
                ...style,
                height: `${this.state.height}px`,
            };
        }

        const TextAreaComponent = asyncControl ? AsyncControllableTextArea : "textarea";

        return (
            <TextAreaComponent
                {...htmlProps}
                className={rootClasses}
                onChange={this.handleChange}
                style={style}
                ref={this.handleRef}
            />
        );
    }

    private handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
        this.maybeSyncHeightToScrollHeight();
        this.props.onChange?.(e);
    };
}

================================================================================

File: src\components\forms\_common.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "@blueprintjs/icons/lib/scss/variables";
@import "../../common/variables";
@import "../button/common";

$input-padding-horizontal: $pt-grid-size !default;
$input-small-padding: $pt-input-height-small - $pt-icon-size-standard !default;
$input-font-weight: 400 !default;
$input-transition: box-shadow $pt-transition-duration $pt-transition-ease;

$input-color: $pt-text-color !default;
$input-color-disabled: $button-color-disabled !default;
$input-placeholder-color: $pt-text-color-muted !default;
$input-background-color: $white !default;
$input-background-color-disabled: rgba($light-gray1, 0.5) !default;
$input-shadow-color-focus: $pt-focus-indicator-color;

$dark-input-color: $pt-dark-text-color !default;
$dark-input-color-disabled: $dark-button-color-disabled !default;
$dark-input-placeholder-color: $pt-dark-text-color-muted !default;
$dark-input-background-color: rgba($black, 0.3) !default;
$dark-input-background-color-disabled: rgba($dark-gray5, 0.5) !default;
$dark-input-shadow-color-focus: $pt-dark-focus-indicator-color;

$control-indicator-size: $pt-icon-size-standard !default;
$control-indicator-size-large: $pt-icon-size-large !default;

// avoids edge blurriness for light theme focused default input
// second box-shadow of $pt-input-box-shadow
$input-box-shadow-focus: inset 0 1px 1px rgba($black, $pt-drop-shadow-opacity) !default;

// for best visual results, button group and control group elements should be
// stacked in the following order to ensure sharp edges in all cases and states:

$control-group-stack: (
  // lowest z-index
  "input-disabled",
  "input-default",
  "button-disabled",
  "button-default",
  "button-focus",
  "button-hover",
  "button-active",
  "intent-button-disabled",
  "intent-button-default",
  "intent-button-focus",
  "intent-button-hover",
  "intent-button-active",
  "intent-input-default",
  "input-focus",
  "intent-input-focus",
  "input-group-children",
  "select-caret"
);

// animating shadows requires the same number of shadows in different states
@function input-transition-shadow(
  $color: $input-shadow-color-focus,
  $focus: false,
  $outer-shadow-focus-width: 1px,
) {
  @if $focus {
    @return
      inset border-shadow(0.752, $color, 1px),
      border-shadow(0.752, $color, $outer-shadow-focus-width);
  } @else {
    @return
      border-shadow(0, $color, 0),
      border-shadow(0, $color, 0);
  }
}

@function dark-input-transition-shadow(
  $color: $dark-input-shadow-color-focus,
  $focus: false,
  $outer-shadow-focus-width: 1px,
) {
  @if $focus {
    @return
      inset border-shadow(0.752, $color, 1px),
      border-shadow(0.752, $color, $outer-shadow-focus-width);
  } @else {
    @return
      border-shadow(0, $color, 0),
      border-shadow(0, $color, 0);
  }
}

@mixin pt-input() {
  @include pt-input-placeholder();
  appearance: none;
  background: $input-background-color;
  border: none;
  border-radius: $pt-border-radius;
  box-shadow: input-transition-shadow($input-shadow-color-focus), $pt-input-box-shadow;
  color: $input-color;
  font-size: $pt-font-size;
  font-weight: $input-font-weight;
  height: $pt-input-height;
  line-height: $pt-input-height;

  outline: none;
  padding: 0 $input-padding-horizontal;
  transition: $input-transition;
  vertical-align: middle;

  &:focus,
  &.#{$ns}-active {
    box-shadow: input-transition-shadow($input-shadow-color-focus, true), $input-box-shadow-focus;
  }

  &[type="search"],
  &.#{$ns}-round {
    border-radius: $pt-input-height;
    // override normalize.css
    box-sizing: border-box;
    padding-left: $pt-grid-size;
  }

  &[readonly] {
    box-shadow: inset 0 0 0 1px $pt-divider-black;
  }

  &:disabled,
  &.#{$ns}-disabled {
    @include pt-input-disabled();
  }

  @media (forced-colors: active) and (prefers-color-scheme: dark) {
    border: 1px solid $pt-high-contrast-mode-border-color;
  }
}

@mixin pt-input-placeholder() {
  &::placeholder {
    color: $input-placeholder-color;
    // normalize.css sets an opacity less than 1, we don't want this
    opacity: 1;
  }
}

@mixin pt-input-disabled() {
  background: $input-background-color-disabled;
  box-shadow: none;
  color: $input-color-disabled;
  cursor: not-allowed;
  resize: none;

  &::placeholder {
    color: $input-color-disabled;
  }
}

@mixin pt-input-large() {
  font-size: $pt-font-size-large;
  height: $pt-input-height-large;
  line-height: $pt-input-height-large;

  &[type="search"],
  &.#{$ns}-round {
    padding: 0 ($input-padding-horizontal * 1.5);
  }
}

@mixin pt-input-small() {
  font-size: $pt-font-size-small;
  height: $pt-input-height-small;
  line-height: $pt-input-height-small;
  padding-left: $input-small-padding;
  padding-right: $input-small-padding;

  &[type="search"],
  &.#{$ns}-round {
    padding: 0 ($input-small-padding * 1.5);
  }
}

@mixin pt-dark-input-disabled() {
  background: $dark-input-background-color-disabled;
  box-shadow: none;
  color: $dark-input-color-disabled;
}

@mixin pt-dark-input-placeholder() {
  &::placeholder {
    color: $dark-input-placeholder-color;
  }
}

@mixin pt-dark-input() {
  @include pt-dark-input-placeholder();
  background: $dark-input-background-color;

  box-shadow: dark-input-transition-shadow($dark-input-shadow-color-focus),
              $pt-dark-input-box-shadow;
  color: $dark-input-color;

  &:focus {
    box-shadow: dark-input-transition-shadow($dark-input-shadow-color-focus, true);
  }

  &[readonly] {
    box-shadow: inset 0 0 0 1px $pt-dark-divider-black;
  }

  &:disabled,
  &.#{$ns}-disabled {
    @include pt-dark-input-disabled();
  }
}

@mixin pt-input-intent($color) {
  box-shadow: input-transition-shadow($color, false, 2px),
              inset border-shadow(1, $color),
              $pt-input-box-shadow;

  &:focus {
    box-shadow: input-transition-shadow($color, true, 2px),
                $input-box-shadow-focus;
  }

  &[readonly] {
    box-shadow: inset 0 0 0 1px $color;
  }

  &:disabled,
  &.#{$ns}-disabled {
    box-shadow: none;
  }
}

@mixin pt-dark-input-intent($color) {
  box-shadow: dark-input-transition-shadow($color, false, 2px),
              inset border-shadow(1, $color),
              $pt-dark-input-box-shadow;

  &:focus {
    box-shadow: dark-input-transition-shadow($color, true, 2px),
                $pt-dark-input-box-shadow;
  }

  &[readonly] {
    box-shadow: inset 0 0 0 1px $color;
  }

  &:disabled,
  &.#{$ns}-disabled {
    box-shadow: none;
  }
}

================================================================================

File: src\components\forms\_control-group.scss
--------------------------------------------------------------------------------
// Copyright 2016 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "../button/common";
@import "./common";
@import "../divider/divider";

/*
Control groups

Markup:
<div class="#{$ns}-control-group">
  <button class="#{$ns}-button #{$ns}-icon-filter">Filter</button>
  <input type="text" class="#{$ns}-input" placeholder="Find filters..." />
</div>
<div class="#{$ns}-control-group">
  <div class="#{$ns}-html-select">
    <select>
      <option selected>Filter...</option>
      <option value="1">Issues</option>
      <option value="2">Requests</option>
      <option value="3">Projects</option>
    </select>
    <span class="#{$ns}-icon #{$ns}-icon-double-caret-vertical"></span>
  </div>
  <div class="#{$ns}-input-group">
    <span class="#{$ns}-icon #{$ns}-icon-search"></span>
    <input type="text" class="#{$ns}-input" value="from:ggray to:allorca" />
  </div>
</div>
<div class="#{$ns}-control-group">
  <div class="#{$ns}-input-group">
    <span class="#{$ns}-icon #{$ns}-icon-people"></span>
    <input type="text" class="#{$ns}-input" placeholder="Find collaborators..." style="padding-right:94px" />
    <div class="#{$ns}-input-action">
      <button class="#{$ns}-button #{$ns}-minimal #{$ns}-intent-primary">
        can view<span class="#{$ns}-icon-standard #{$ns}-icon-caret-down #{$ns}-align-right"></span>
      </button>
    </div>
  </div>
  <button class="#{$ns}-button #{$ns}-intent-primary">Add</button>
</div>
<div class="#{$ns}-control-group">
  <div class="#{$ns}-html-select">
    <select>
      <option selected value="dollar">$</option>
      <option value="euro">€</option>
    </select>
    <span class="#{$ns}-icon #{$ns}-icon-double-caret-vertical"></span>
  </div>
  <div class="#{$ns}-control-group #{$ns}-numeric-input">
    <div class="#{$ns}-input-group">
      <input type="text" autocomplete="off" class="#{$ns}-input" style="padding-right: 10px;" value="1">
    </div>
    <div class="#{$ns}-button-group #{$ns}-vertical #{$ns}-fixed">
      <button type="button" class="#{$ns}-button">
        <span icon="chevron-up" class="#{$ns}-icon #{$ns}-icon-chevron-up">
          <svg data-icon="chevron-up" width="16" height="16" viewBox="0 0 16 16"><desc>chevron-up</desc><path d="M12.71 9.29l-4-4C8.53 5.11 8.28 5 8 5s-.53.11-.71.29l-4 4a1.003 1.003 0 001.42 1.42L8 7.41l3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71z" fill-rule="evenodd"></path></svg>
        </span>
      </button>
      <button type="button" class="#{$ns}-button">
        <span icon="chevron-down" class="#{$ns}-icon #{$ns}-icon-chevron-down">
          <svg data-icon="chevron-down" width="16" height="16" viewBox="0 0 16 16"><desc>chevron-down</desc><path d="M12 5c-.28 0-.53.11-.71.29L8 8.59l-3.29-3.3a1.003 1.003 0 00-1.42 1.42l4 4c.18.18.43.29.71.29s.53-.11.71-.29l4-4A1.003 1.003 0 0012 5z" fill-rule="evenodd"></path></svg>
        </span>
      </button>
    </div>
  </div>
</div>

Styleguide control-group
*/

.#{$ns}-control-group {
  // create a new stacking context to isolate all the z-indices
  @include new-render-layer();
  @include pt-flex-container(row);
  // each child is full height
  align-items: stretch;

  // similarly to button groups, elements in control groups are stacked in a
  // very particular order for best visual results. in each level of selector
  // specificity, we define disabled styles last so that they override all other
  // equally-specific styles (e.g. we don't want mouse interactions or focus
  // changes to change the z-index of a disabled element).

  .#{$ns}-button,
  .#{$ns}-html-select,
  .#{$ns}-input,
  .#{$ns}-select {
    // create a new stacking context
    position: relative;
  }

  .#{$ns}-input {
    z-index: index($control-group-stack, "input-default");

    &:focus {
      z-index: index($control-group-stack, "input-focus");
    }

    &[class*="#{$ns}-intent"] {
      z-index: index($control-group-stack, "intent-input-default");

      &:focus {
        z-index: index($control-group-stack, "intent-input-focus");
      }
    }

    &[readonly],
    &:disabled,
    &.#{$ns}-disabled {
      z-index: index($control-group-stack, "input-disabled");
    }
  }

  .#{$ns}-input-group[class*="#{$ns}-intent"] .#{$ns}-input {
    z-index: index($control-group-stack, "intent-input-default");

    &:focus {
      z-index: index($control-group-stack, "intent-input-focus");
    }
  }

  .#{$ns}-button,
  .#{$ns}-html-select select,
  .#{$ns}-select select {
    @include new-render-layer();
    z-index: index($control-group-stack, "button-default");

    &:focus {
      z-index: index($control-group-stack, "button-focus");
    }

    &:hover {
      z-index: index($control-group-stack, "button-hover");
    }

    &:active {
      z-index: index($control-group-stack, "button-active");
    }

    &[readonly],
    &:disabled,
    &.#{$ns}-disabled {
      z-index: index($control-group-stack, "button-disabled");
    }

    &[class*="#{$ns}-intent"] {
      z-index: index($control-group-stack, "intent-button-default");

      &:focus {
        z-index: index($control-group-stack, "intent-button-focus");
      }

      &:hover {
        z-index: index($control-group-stack, "intent-button-hover");
      }

      &:active {
        z-index: index($control-group-stack, "intent-button-active");
      }

      &[readonly],
      &:disabled,
      &.#{$ns}-disabled {
        z-index: index($control-group-stack, "intent-button-disabled");
      }
    }
  }

  // input group contents appear above input always
  .#{$ns}-input-group > .#{$ns}-icon,
  .#{$ns}-input-group > .#{$ns}-button,
  .#{$ns}-input-group > .#{$ns}-input-left-container,
  .#{$ns}-input-group > .#{$ns}-input-action {
    z-index: index($control-group-stack, "input-group-children");
  }

  // keep the select-menu carets on top of everything always (particularly when
  // .#{$ns}-selects are focused).
  .#{$ns}-select::after,
  .#{$ns}-html-select::after,
  .#{$ns}-select > .#{$ns}-icon,
  .#{$ns}-html-select > .#{$ns}-icon {
    z-index: index($control-group-stack, "select-caret");
  }

  // select container does not get focus directly (its <select> does), and it
  // sometimes needs to compete with adjacent container elements
  .#{$ns}-html-select:focus-within,
  .#{$ns}-select:focus-within {
    z-index: index($control-group-stack, "button-focus");
  }

  &:not(.#{$ns}-vertical) {
    > :not(:last-child) {
      margin-right: 2px;
    }
  }

  // special handling of numeric input, which is a nested control group itself
  .#{$ns}-numeric-input:not(:first-child) .#{$ns}-input-group {
    border-bottom-left-radius: 0;
    border-top-left-radius: 0;
  }

  /*
  Responsive control groups

  Markup:
  <div class="#{$ns}-control-group">
    <div class="#{$ns}-input-group #{$ns}-fill">
      <span class="#{$ns}-icon #{$ns}-icon-people"></span>
      <input type="text" class="#{$ns}-input" placeholder="Find collaborators..." />
    </div>
    <button class="#{$ns}-button #{$ns}-intent-primary">Add</button>
  </div>
  <div class="#{$ns}-control-group #{$ns}-fill">
    <button class="#{$ns}-button #{$ns}-icon-minus #{$ns}-fixed"></button>
    <input type="text" class="#{$ns}-input" placeholder="Enter a value..." />
    <button class="#{$ns}-button #{$ns}-icon-plus #{$ns}-fixed"></button>
  </div>

  Styleguide control-group-fill
  */
  &.#{$ns}-fill {
    width: 100%;
  }

  > .#{$ns}-fill {
    flex: 1 1 auto;
  }

  &.#{$ns}-fill > *:not(.#{$ns}-fixed) {
    flex: 1 1 auto;
  }

  /*
  Vertical control groups

  Markup:
  <div class="#{$ns}-control-group #{$ns}-vertical" style="width: 300px;">
    <div class="#{$ns}-input-group #{$ns}-large">
      <span class="#{$ns}-icon #{$ns}-icon-person"></span>
      <input type="text" class="#{$ns}-input" placeholder="Username" />
    </div>
    <div class="#{$ns}-input-group #{$ns}-large">
      <span class="#{$ns}-icon #{$ns}-icon-lock"></span>
      <input type="password" class="#{$ns}-input" placeholder="Password" />
    </div>
    <button class="#{$ns}-button #{$ns}-large #{$ns}-intent-primary">Login</button>
  </div>

  Styleguide control-group-vertical
  */

  &.#{$ns}-vertical {
    flex-direction: column;

    > :not(:last-child) {
      margin-bottom: 2px;
    }
  }
}

================================================================================

File: src\components\forms\_controls.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@use "sass:math";
@import "../../common/mixins";
@import "../../common/variables";
@import "../button/common";

$control-background-color: transparent !default;
$control-background-color-hover: $minimal-button-background-color-hover !default;
$control-background-color-active: $minimal-button-background-color-active !default;
$control-background-color-disabled: $minimal-button-background-color-hover !default;
$dark-control-background-color: transparent !default;
$dark-control-background-color-hover: $minimal-button-background-color-hover !default;
$dark-control-background-color-active: $minimal-button-background-color-active !default;
$dark-control-background-color-disabled: $minimal-button-background-color-hover !default;

$control-checked-background-color: nth(map-get($button-intents, "primary"), 1) !default;
$control-checked-background-color-hover: nth(map-get($button-intents, "primary"), 2) !default;
$control-checked-background-color-active: nth(map-get($button-intents, "primary"), 3) !default;
$control-checked-background-color-disabled: rgba($control-checked-background-color, 0.5) !default;

$control-box-shadow: inset 0 0 0 $button-border-width $gray2 !default;
$control-checked-box-shadow: inset 0 0 0 $button-border-width rgba($black, 0.2) !default;
$dark-control-box-shadow: inset 0 0 0 $button-border-width $gray3 !default;
$dark-control-checked-box-shadow: inset 0 0 0 $button-border-width rgba($white, 0.1) !default;

$control-indicator-size: $pt-icon-size-standard !default;
$control-indicator-size-large: $pt-icon-size-large !default;
$control-indicator-spacing: $pt-grid-size !default;

@mixin control-checked-colors($selector: ":checked") {
  input#{$selector} ~ .#{$ns}-control-indicator {
    background-color: $control-checked-background-color;
    box-shadow: $control-checked-box-shadow;
    color: $white;

    @media (forced-colors: active) and (prefers-color-scheme: dark) {
      background-color: $pt-high-contrast-mode-active-background-color;
      // Windows High Contrast dark theme
      border: 1px solid $pt-high-contrast-mode-active-background-color;
    }
  }

  &:hover input#{$selector} ~ .#{$ns}-control-indicator {
    background-color: $control-checked-background-color-hover;

    @media (forced-colors: active) and (prefers-color-scheme: dark) {
      // Windows High Contrast dark theme
      background-color: $pt-high-contrast-mode-active-background-color;
    }
  }

  input:not(:disabled):active#{$selector} ~ .#{$ns}-control-indicator {
    background: $control-checked-background-color-active;
  }

  input:disabled#{$selector} ~ .#{$ns}-control-indicator {
    background: $control-checked-background-color-disabled;
    box-shadow: none;
    color: rgba($white, 0.6);

    @media (forced-colors: active) and (prefers-color-scheme: dark) {
      background-color: $pt-high-contrast-mode-disabled-border-color;
      border-color: $pt-high-contrast-mode-disabled-border-color;
    }
  }

  .#{$ns}-dark & {
    input#{$selector} ~ .#{$ns}-control-indicator {
      box-shadow: $dark-control-checked-box-shadow;

      @media (forced-colors: active) and (prefers-color-scheme: dark) {
        // Windows High Contrast dark theme
        border: 1px solid $pt-high-contrast-mode-border-color;
      }
    }

    &:hover input#{$selector} ~ .#{$ns}-control-indicator {
      background-color: $control-checked-background-color-hover;
      box-shadow: $dark-control-checked-box-shadow;
    }

    input:not(:disabled):active#{$selector} ~ .#{$ns}-control-indicator {
      background-color: $control-checked-background-color-active;
      box-shadow: $dark-control-checked-box-shadow;
    }

    input:disabled#{$selector} ~ .#{$ns}-control-indicator {
      background: $control-checked-background-color-disabled;
      box-shadow: none;
      color: rgba($white, 0.6);
    }
  }
}

@mixin indicator-position($size) {
  $padding: $size + $control-indicator-spacing;

  &:not(.#{$ns}-align-right) {
    padding-left: $padding;

    .#{$ns}-control-indicator {
      margin-left: -$padding;
    }
  }

  &.#{$ns}-align-right {
    padding-right: $padding;

    .#{$ns}-control-indicator {
      margin-right: -$padding;
    }
  }
}

.#{$ns}-control {
  @include control-checked-colors();
  @include indicator-position($control-indicator-size);
  cursor: pointer;

  display: block;
  margin-bottom: $pt-grid-size;
  position: relative;
  text-transform: none;

  &.#{$ns}-disabled {
    color: $pt-text-color-disabled;
    cursor: not-allowed;
  }

  &.#{$ns}-inline {
    display: inline-block;
    margin-right: $pt-grid-size * 2;
  }

  input {
    left: 0;
    opacity: 0;
    position: absolute;
    top: 0;
    z-index: -1; // don't let it intercept clicks
  }

  .#{$ns}-control-indicator {
    background-clip: padding-box;
    background-color: $control-background-color;
    border: none;
    box-shadow: $control-box-shadow;
    cursor: pointer;
    display: inline-block;
    // font-size is used to size indicator for all control types,
    // to reduce property changes needed across types and sizes (large).
    font-size: $control-indicator-size;
    height: 1em;
    margin-right: $control-indicator-spacing;
    margin-top: -3px;
    position: relative;
    user-select: none;
    vertical-align: middle;
    width: 1em;

    &::before {
      content: "";
      display: block;
      height: 1em;
      width: 1em;
    }

    @media (forced-colors: active) and (prefers-color-scheme: dark) {
      // Windows High Contrast dark theme
      border: 1px solid $pt-high-contrast-mode-border-color;

      &::before {
        // Because we're using a border in high contrast mode, we need to adjust the margins
        // to compensate for the space the border takes up
        margin-left: -1px;
        margin-top: -1px;
      }
    }
  }

  &:hover .#{$ns}-control-indicator {
    background-color: $control-background-color-hover;
  }

  input:not(:disabled):active ~ .#{$ns}-control-indicator {
    background: $control-background-color-active;
    box-shadow: $control-box-shadow;
  }

  input:disabled ~ .#{$ns}-control-indicator {
    background: $control-background-color-disabled;
    box-shadow: none;
    cursor: not-allowed;
  }

  input:focus ~ .#{$ns}-control-indicator {
    @include focus-outline();
  }

  // right-aligned indicator is glued to the right side of the container
  &.#{$ns}-align-right .#{$ns}-control-indicator {
    float: right;
    margin-left: $control-indicator-spacing;
    margin-top: 1px;
  }

  &.#{$ns}-large {
    @include indicator-position($control-indicator-size-large);
    // larger text
    font-size: $pt-font-size-large;

    .#{$ns}-control-indicator {
      // em-based sizing
      font-size: $control-indicator-size-large;
    }

    &.#{$ns}-align-right .#{$ns}-control-indicator {
      margin-top: 0;
    }
  }

  /*
  Checkbox

  Markup:
  <label class="#{$ns}-control #{$ns}-checkbox {{.modifier}}">
    <input type="checkbox" {{:modifier}} />
    <span class="#{$ns}-control-indicator"></span>
    Checkbox
  </label>

  :checked  - Checked
  :disabled - Disabled. Also add <code>.#{$ns}-disabled</code> to <code>.#{$ns}-control</code> to change text color (not shown below).
  :indeterminate - Indeterminate. Note that this style can only be achieved via JavaScript
                   <code>input.indeterminate = true</code>.
  .#{$ns}-align-right - Right-aligned indicator
  .#{$ns}-large - Large

  Styleguide checkbox
  */

  &.#{$ns}-checkbox {
    @mixin indicator-inline-icon($icon, $fill-color: $white) {
      &::before {
        // embed SVG icon image as backgroud-image above gradient.
        // the SVG image content is inlined into the CSS, so use this sparingly.
        background-image: svg-icon("16px/#{$icon}.svg", (path: (fill: $fill-color)));
      }
    }

    // make :indeterminate look like :checked _for Checkbox only_
    @include control-checked-colors(":indeterminate");

    .#{$ns}-control-indicator {
      border-radius: $pt-border-radius;
    }

    input:checked ~ .#{$ns}-control-indicator {
      @include indicator-inline-icon("small-tick");
    }

    input:indeterminate ~ .#{$ns}-control-indicator {
      @include indicator-inline-icon("small-minus");
    }

    @media (forced-colors: active) and (prefers-color-scheme: dark) {
      input:checked:not(:disabled) ~ .#{$ns}-control-indicator {
        @include indicator-inline-icon("small-tick", $black);
      }

      input:indeterminate:not(:disabled) ~ .#{$ns}-control-indicator {
        @include indicator-inline-icon("small-minus", $black);
      }

      input:disabled ~ .#{$ns}-control-indicator {
        border-color: $pt-high-contrast-mode-disabled-border-color;
      }
    }
  }

  /*
  Radio

  Markup:
  <label class="#{$ns}-control #{$ns}-radio {{.modifier}}">
    <input type="radio" name="docs-radio-regular" {{:modifier}} />
    <span class="#{$ns}-control-indicator"></span>
    Radio
  </label>

  :checked  - Selected
  :disabled - Disabled. Also add <code>.#{$ns}-disabled</code> to <code>.#{$ns}-control</code> to change text color (not shown below).
  .#{$ns}-align-right - Right-aligned indicator
  .#{$ns}-large - Large

  Styleguide radio
  */

  &.#{$ns}-radio {
    .#{$ns}-control-indicator {
      border-radius: 50%;
    }

    input:checked ~ .#{$ns}-control-indicator::before {
      background-image: radial-gradient($white, $white 28%, transparent 32%);

      @media (forced-colors: active) and (prefers-color-scheme: dark) {
        // Windows High Contrast dark theme
        background: $pt-high-contrast-mode-active-background-color;
        // Subtract border on either end, and then an extra 2px for space between the border
        height: $control-indicator-size - 4px;
        margin-left: 1px;
        margin-top: 1px;
        width: $control-indicator-size - 4px;
      }
    }

    input:checked:disabled ~ .#{$ns}-control-indicator::before {
      opacity: 0.5;

      @media (forced-colors: active) and (prefers-color-scheme: dark) {
        background: $pt-high-contrast-mode-disabled-background-color;
      }
    }

    input:focus ~ .#{$ns}-control-indicator {
      -moz-outline-radius: $control-indicator-size;
    }

    @media (forced-colors: active) and (prefers-color-scheme: dark) {
      input:disabled ~ .#{$ns}-control-indicator {
        border-color: $pt-high-contrast-mode-disabled-border-color;
      }
    }
  }

  /*
  Switch

  Markup:
  <label class="#{$ns}-control #{$ns}-switch {{.modifier}}">
    <input type="checkbox" {{:modifier}} />
    <span class="#{$ns}-control-indicator"></span>
    Switch
  </label>

  :checked  - Selected
  :disabled - Disabled. Also add <code>.#{$ns}-disabled</code> to <code>.#{$ns}-control</code> to change text color (not shown below).
  .#{$ns}-align-right - Right-aligned indicator
  .#{$ns}-large - Large

  Styleguide switch
  */

  /* stylelint-disable-next-line order/order */
  $switch-width: 1.75em !default;
  $switch-indicator-margin: 2px !default;
  $switch-indicator-size: calc(1em - #{$switch-indicator-margin * 2});

  $switch-indicator-child-height: 1em;
  $switch-indicator-child-outside-margin: 0.5em;
  $switch-indicator-child-inside-margin: 1.2em;

  $switch-indicator-text-font-size: 0.7em;

  $switch-text-color: $pt-text-color !default;
  $switch-text-color-disabled: $pt-text-color-disabled !default;
  $switch-checked-text-color: $white !default;
  $switch-checked-text-color-disabled: rgba($white, 0.6) !default;
  $switch-background-color: rgba($gray3, 0.3) !default;
  $switch-background-color-hover: rgba($gray3, 0.4) !default;
  $switch-background-color-active: rgba($gray3, 0.5) !default;
  $switch-background-color-disabled: rgba($gray3, 0.15) !default;
  $switch-checked-background-color: $control-checked-background-color !default;
  $switch-checked-background-color-hover: $control-checked-background-color-hover !default;
  $switch-checked-background-color-active: $control-checked-background-color-active !default;
  $switch-checked-background-color-disabled: rgba($blue3, 0.5) !default;

  $dark-switch-text-color: $pt-dark-text-color !default;
  $dark-switch-text-color-disabled: $pt-dark-text-color-disabled !default;
  $dark-switch-checked-text-color: $white !default;
  $dark-switch-checked-text-color-disabled: $pt-dark-text-color-disabled !default;
  $dark-switch-background-color: rgba($black, 0.5) !default;
  $dark-switch-background-color-hover: rgba($black, 0.8) !default;
  $dark-switch-background-color-active: rgba($black, 0.9) !default;
  $dark-switch-background-color-disabled: rgba($gray3, 0.15) !default;
  $dark-switch-checked-background-color: $control-checked-background-color !default;
  $dark-switch-checked-background-color-hover: $control-checked-background-color-hover !default;
  $dark-switch-checked-background-color-active: $control-checked-background-color-active !default;
  $dark-switch-checked-background-color-disabled: rgba($blue3, 0.5) !default;

  $switch-indicator-background-color: rgba($gray3, 0.3) !default;
  $switch-indicator-box-shadow: 0 0 0 $button-border-width rgba($black, 0.5) !default;
  $switch-indicator-background-color-disabled: rgba($white, 0.8) !default;
  $switch-checked-indicator-background-color-disabled: rgba($white, 0.5) !default;
  $dark-switch-indicator-background-color: $gray4 !default;
  $dark-switch-indicator-background-color-disabled: rgba($gray4, 0.5) !default;
  $dark-switch-checked-indicator-background-color: $white !default;
  $dark-switch-checked-indicator-background-color-disabled: rgba($white, 0.3) !default;

  &.#{$ns}-switch {
    @mixin indicator-colors(
      $selector,
      $text-color,
      $background-color,
      $hover-color,
      $active-color,
      $disabled-text-color,
      $disabled-background-color,
      $disabled-indicator-color
    ) {
      input#{$selector} ~ .#{$ns}-control-indicator {
        background: $background-color;
        color: $text-color;
      }

      &:hover input#{$selector} ~ .#{$ns}-control-indicator {
        background: $hover-color;
      }

      input#{$selector}:not(:disabled):active ~ .#{$ns}-control-indicator {
        background: $active-color;
      }

      input#{$selector}:disabled ~ .#{$ns}-control-indicator {
        background: $disabled-background-color;
        color: $disabled-text-color;

        &::before {
          background: $disabled-indicator-color;
          box-shadow: none;
        }
      }
    }

    @include indicator-colors(
      "",
      $switch-text-color,
      $switch-background-color,
      $switch-background-color-hover,
      $switch-background-color-active,
      $switch-text-color-disabled,
      $switch-background-color-disabled,
      $switch-indicator-background-color-disabled
    );
    @include indicator-colors(
      ":checked",
      $switch-checked-text-color,
      $switch-checked-background-color,
      $switch-checked-background-color-hover,
      $switch-checked-background-color-active,
      $switch-checked-text-color-disabled,
      $switch-checked-background-color-disabled,
      $switch-checked-indicator-background-color-disabled
    );
    // convert em variable to px value
    @include indicator-position(math.div($switch-width, 1em) * $control-indicator-size);

    // Add Windows high contrast mode styles
    @media (forced-colors: active) and (prefers-color-scheme: dark) {
      input:checked ~ .#{$ns}-control-indicator {
        background: $pt-high-contrast-mode-active-background-color;
        border: 1px solid $pt-high-contrast-mode-border-color;
      }

      input:checked:disabled ~ .#{$ns}-control-indicator {
        background-color: $pt-high-contrast-mode-disabled-background-color;
      }

      input:not(:checked):disabled ~ .#{$ns}-control-indicator {
        border-color: $pt-high-contrast-mode-disabled-border-color;

        &::before {
          border-color: $pt-high-contrast-mode-disabled-border-color;
        }
      }

      &:hover input:checked ~ .#{$ns}-control-indicator {
        background: $pt-high-contrast-mode-active-background-color;
      }
    }

    .#{$ns}-control-indicator {
      border: none;
      border-radius: $switch-width;
      // override default button styles, never have a box-shadow here.
      /* stylelint-disable-next-line declaration-no-important */
      box-shadow: none !important;
      min-width: $switch-width;
      transition: background-color $pt-transition-duration $pt-transition-ease;
      width: auto;

      &::before {
        background: $white;
        border-radius: 50%;
        box-shadow: $switch-indicator-box-shadow;
        height: $switch-indicator-size;
        left: 0;
        margin: $switch-indicator-margin;
        position: absolute;
        transition: left $pt-transition-duration $pt-transition-ease;
        width: $switch-indicator-size;

        @media (forced-colors: active) and (prefers-color-scheme: dark) {
          // Windows High Contrast dark theme
          border: 1px solid $pt-high-contrast-mode-border-color;
          // Because we're using a border for the outline, we need to decrease the top margin
          margin-top: $switch-indicator-margin - 1px;
        }
      }

      @media (forced-colors: active) and (prefers-color-scheme: dark) {
        border: 1px solid $pt-high-contrast-mode-border-color;
      }
    }

    input:checked ~ .#{$ns}-control-indicator::before {
      // 1em is size of indicator
      left: calc(100% - 1em);
    }

    &.#{$ns}-large {
      @include indicator-position(math.div($switch-width, 1em) * $control-indicator-size-large);
    }

    .#{$ns}-dark & {
      @include indicator-colors(
        "",
        $dark-switch-text-color,
        $dark-switch-background-color,
        $dark-switch-background-color-hover,
        $dark-switch-background-color-active,
        $dark-switch-text-color-disabled,
        $dark-switch-background-color-disabled,
        $dark-switch-indicator-background-color-disabled
      );
      @include indicator-colors(
        ":checked",
        $dark-switch-checked-text-color,
        $dark-switch-checked-background-color,
        $dark-switch-checked-background-color-hover,
        $dark-switch-checked-background-color-active,
        $dark-switch-checked-text-color-disabled,
        $dark-switch-checked-background-color-disabled,
        $dark-switch-checked-indicator-background-color-disabled
      );

      .#{$ns}-control-indicator::before {
        background: $dark-switch-indicator-background-color;
      }

      input:checked ~ .#{$ns}-control-indicator::before {
        background: $dark-switch-checked-indicator-background-color;
      }

      // Add Windows high contrast mode styles
      @media (forced-colors: active) and (prefers-color-scheme: dark) {
        input:checked ~ .#{$ns}-control-indicator {
          background: $pt-high-contrast-mode-active-background-color;
          border: 1px solid $pt-high-contrast-mode-border-color;
        }

        input:checked:disabled ~ .#{$ns}-control-indicator {
          background-color: $pt-high-contrast-mode-disabled-background-color;
        }

        input:not(:checked):disabled ~ .#{$ns}-control-indicator {
          border-color: $pt-high-contrast-mode-disabled-border-color;

          // stylelint-disable-next-line max-nesting-depth
          &::before {
            border-color: $pt-high-contrast-mode-disabled-border-color;
          }
        }

        &:hover input:checked ~ .#{$ns}-control-indicator {
          background: $pt-high-contrast-mode-active-background-color;
        }
      }
    }

    .#{$ns}-switch-inner-text {
      font-size: $switch-indicator-text-font-size;
      text-align: center;
    }

    .#{$ns}-control-indicator-child {
      &:first-child {
        line-height: 0;
        margin-left: $switch-indicator-child-outside-margin;
        margin-right: $switch-indicator-child-inside-margin;
        visibility: hidden;
      }

      &:last-child {
        line-height: $switch-indicator-child-height;
        margin-left: $switch-indicator-child-inside-margin;
        margin-right: $switch-indicator-child-outside-margin;
        visibility: visible;
      }
    }

    input:checked ~ .#{$ns}-control-indicator .#{$ns}-control-indicator-child {
      &:first-child {
        line-height: $switch-indicator-child-height;
        visibility: visible;
      }

      &:last-child {
        line-height: 0;
        visibility: hidden;
      }
    }
  }

  .#{$ns}-dark & {
    color: $pt-dark-text-color;

    &.#{$ns}-disabled {
      color: $pt-dark-text-color-disabled;
    }

    .#{$ns}-control-indicator {
      background-color: $dark-control-background-color;
      box-shadow: $dark-control-box-shadow;
    }

    &:hover .#{$ns}-control-indicator {
      background-color: $dark-control-background-color-hover;
    }

    input:not(:disabled):active ~ .#{$ns}-control-indicator {
      background: $dark-control-background-color-active;
      box-shadow: $dark-control-box-shadow;
    }

    input:disabled ~ .#{$ns}-control-indicator {
      background: $dark-control-background-color-disabled;
      box-shadow: none;
      cursor: not-allowed;
    }

    &.#{$ns}-checkbox input:disabled {
      &:checked,
      &:indeterminate {
        ~ .#{$ns}-control-indicator {
          background: $control-checked-background-color-disabled;
        }
      }
    }
  }

  /*
  Inline labels

  Markup:
  <div>
    <label class="#{$ns}-label">A group of related options</label>
    <label class="#{$ns}-control #{$ns}-checkbox #{$ns}-inline">
      <input type="checkbox" />
      <span class="#{$ns}-control-indicator"></span>
      First
    </label>
    <label class="#{$ns}-control #{$ns}-checkbox #{$ns}-inline">
      <input type="checkbox" />
      <span class="#{$ns}-control-indicator"></span>
      Second
    </label>
    <label class="#{$ns}-control #{$ns}-checkbox #{$ns}-inline">
      <input type="checkbox" />
      <span class="#{$ns}-control-indicator"></span>
      Third
    </label>
  </div>

  Styleguide checkbox-inline
  */
}

================================================================================

File: src\components\forms\_file-input.scss
--------------------------------------------------------------------------------
// Copyright 2016 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "../button/common";
@import "../../common/mixins";

/*
File input

Markup:
<label class="#{$ns}-file-input {{.modifier}}">
  <input type="file" {{:modifier}}/>
  <span class="#{$ns}-file-upload-input">Choose file...</span>
</label>

:disabled - Disabled
.#{$ns}-large - Larger size
.#{$ns}-small - Smaller size
.#{$ns}-fill - Take up full width of parent element
.#{$ns}-file-input-has-selection - User has made a selection

Styleguide file-input
*/

$file-input-button-width: $pt-grid-size * 7 !default;
$file-input-button-width-large: $pt-grid-size * 8.5 !default;
$file-input-button-width-small: $pt-grid-size * 5.5 !default;
$file-input-button-padding: ($pt-input-height - $pt-button-height-small) * 0.5 !default;
$file-input-button-padding-large: ($pt-input-height-large - $pt-button-height) * 0.5 !default;
// stylelint-disable max-line-length
$file-input-button-padding-small: ($pt-input-height-small - $pt-button-height-smaller) * 0.5 !default;
// stylelint-enable max-line-length

.#{$ns}-file-input {
  cursor: pointer;
  display: inline-block;
  height: $pt-input-height;
  position: relative;

  input {
    margin: 0;
    min-width: $pt-grid-size * 20;
    opacity: 0;

    // unlike other form controls that directly style native elements,
    // pt-file-input wraps and hides the native element for better control over
    // visual styles. to disable, we need to disable the hidden child input, not
    // the surrounding wrapper. @see https://github.com/palantir/blueprint/issues/689
    // for gory details.
    &:disabled + .#{$ns}-file-upload-input,
    &.#{$ns}-disabled + .#{$ns}-file-upload-input {
      @include pt-input-disabled();

      &::after {
        @include pt-button-disabled();
      }

      .#{$ns}-dark & {
        @include pt-dark-input-disabled();

        &::after {
          @include pt-dark-button-disabled();
        }
      }
    }
  }

  &.#{$ns}-file-input-has-selection {
    .#{$ns}-file-upload-input {
      color: $pt-text-color;
    }

    .#{$ns}-dark & .#{$ns}-file-upload-input {
      color: $pt-dark-text-color;
    }
  }

  &.#{$ns}-fill {
    width: 100%;
  }

  &.#{$ns}-large,
  .#{$ns}-large & {
    height: $pt-input-height-large;
  }

  &.#{$ns}-small,
  .#{$ns}-small & {
    height: $pt-input-height-small;
  }

  .#{$ns}-file-upload-input-custom-text::after {
    content: attr(#{$ns}-button-text);
  }
}

.#{$ns}-file-upload-input {
  @include pt-input();
  @include overflow-ellipsis();
  color: $pt-text-color-disabled;
  left: 0;
  padding-right: $file-input-button-width + $input-padding-horizontal;
  position: absolute;
  right: 0;
  top: 0;
  user-select: none;

  &::after {
    @include pt-button-default-colors();
    @include pt-button-height($pt-button-height-small);
    @include overflow-ellipsis();
    border-radius: $pt-border-radius;
    content: "Browse";
    line-height: $pt-button-height-small;
    margin: $file-input-button-padding;
    position: absolute;
    right: 0;
    text-align: center;
    top: 0;
    width: $file-input-button-width;
  }

  &:hover::after {
    @include pt-button-hover();
  }

  &:active::after {
    @include pt-button-active();
  }

  // N.B. disabled state is handled above, inside .#{$ns}-file-input block

  .#{$ns}-large & {
    @include pt-input-large();
    padding-right: $file-input-button-width-large + $input-padding-horizontal;

    &::after {
      @include pt-button-height($pt-button-height);
      line-height: $pt-button-height;
      margin: $file-input-button-padding-large;
      width: $file-input-button-width-large;
    }
  }

  .#{$ns}-small & {
    @include pt-input-small();
    padding-right: $file-input-button-width-small + $input-padding-horizontal;

    &::after {
      @include pt-button-height($pt-button-height-smaller);
      line-height: $pt-button-height-smaller;
      margin: $file-input-button-padding-small;
      width: $file-input-button-width-small;
    }
  }

  .#{$ns}-dark & {
    @include pt-dark-input();
    color: $pt-dark-text-color-disabled;

    &::after {
      @include pt-dark-button-default-colors();
    }

    &:hover::after {
      @include pt-dark-button-hover();
    }

    &:active::after {
      @include pt-dark-button-active();
    }
  }
}

// hack to force the button shadow to display since
// it doesn't render correct via the `pt-button` mixin
/* stylelint-disable-next-line no-duplicate-selectors */
.#{$ns}-file-upload-input::after { box-shadow: $button-box-shadow; }

================================================================================

File: src\components\forms\_form-group.scss
--------------------------------------------------------------------------------
// Copyright 2017 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "../../common/mixins";
@import "common";

/*
Form groups

Markup:
<div class="#{$ns}-form-group {{.modifier}}">
  <label class="#{$ns}-label" for="form-group-input">
    Label
    <span class="#{$ns}-text-muted">(required)</span>
  </label>
  <div class="#{$ns}-form-content">
    <div class="#{$ns}-input-group {{.modifier}}">
      <span class="#{$ns}-icon #{$ns}-icon-calendar"></span>
      <input id="form-group-input" type="text" {{:modifier}} class="#{$ns}-input"
             style="width: 200px;" placeholder="Placeholder text" dir="auto" />
    </div>
    <div class="#{$ns}-form-helper-text">Please enter a value</div>
  </div>
</div>

:disabled - Disable the input.
.#{$ns}-disabled - Disabled styles. Input must be disabled separately via attribute.
.#{$ns}-inline - Label and content appear side by side.
.#{$ns}-intent-primary - Apply intent to form group and input separately.

Styleguide form-group
*/

.#{$ns}-form-group {
  display: flex;
  flex-direction: column;
  margin: 0 0 ($pt-grid-size * 1.5);

  label.#{$ns}-label {
    margin-bottom: $pt-grid-size * 0.5;
  }

  .#{$ns}-control {
    margin-top: ($pt-input-height - $control-indicator-size) * 0.5;
  }

  .#{$ns}-form-group-sub-label,
  .#{$ns}-form-helper-text {
    color: $pt-text-color-muted;
    font-size: $pt-font-size-small;
  }

  .#{$ns}-form-group-sub-label {
    margin-bottom: $pt-grid-size * 0.5;
  }

  .#{$ns}-form-helper-text {
    margin-top: $pt-grid-size * 0.5;
  }

  /* stylelint-disable-next-line order/declaration-block-order */
  @each $intent, $color in $pt-intent-text-colors {
    &.#{$ns}-intent-#{$intent} {
      .#{$ns}-form-helper-text {
        color: $color;
      }
    }
  }

  &.#{$ns}-fill {
    width: 100%;
  }

  &.#{$ns}-inline {
    align-items: flex-start;
    flex-direction: row;

    &.#{$ns}-large label.#{$ns}-label {
      line-height: $pt-input-height-large;
      margin: 0 $pt-grid-size 0 0;
    }

    label.#{$ns}-label {
      line-height: $pt-input-height;
      margin: 0 $pt-grid-size 0 0;
    }
  }

  &.#{$ns}-disabled {
    .#{$ns}-label,
    .#{$ns}-text-muted,
    .#{$ns}-form-group-sub-label,
    .#{$ns}-form-helper-text {
      // disabled state always overrides over styles
      /* stylelint-disable-next-line declaration-no-important */
      color: $pt-text-color-disabled !important;
    }
  }

  .#{$ns}-dark & {
    @each $intent, $color in $pt-dark-intent-text-colors {
      &.#{$ns}-intent-#{$intent} {
        .#{$ns}-form-helper-text {
          color: $color;
        }
      }
    }

    .#{$ns}-form-group-sub-label,
    .#{$ns}-form-helper-text {
      color: $pt-dark-text-color-muted;
    }

    &.#{$ns}-disabled {
      .#{$ns}-label,
      .#{$ns}-text-muted,
      .#{$ns}-form-group-sub-label,
      .#{$ns}-form-helper-text {
        // disabled state always overrides over styles
        /* stylelint-disable-next-line declaration-no-important */
        color: $pt-dark-text-color-disabled !important;
      }
    }
  }
}

================================================================================

File: src\components\forms\_index.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

// NOTE: this partial file is imported once here so form components can just use it.
// multiple @imports of shared/forms from different files causes placeholder @extends to
// output CSS multiple times which breaks textbox padding.
@import "./common";

@import "./control-group";
@import "./controls";
@import "./file-input";
@import "./form-group";
@import "./input-group";
@import "./input";
@import "./label";
@import "./numeric-input";

form {
  display: block;
}

================================================================================

File: src\components\forms\_input-group.scss
--------------------------------------------------------------------------------
// Copyright 2016 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "../../common/variables-extended";
@import "../button/common";

/*
Input groups

Markup:
<div class="#{$ns}-input-group {{.modifier}}">
  <span class="#{$ns}-icon #{$ns}-icon-filter"></span>
  <input type="text" class="#{$ns}-input" {{:modifier}} placeholder="Filter histogram..." />
</div>
<div class="#{$ns}-input-group {{.modifier}}">
  <input type="password" class="#{$ns}-input" {{:modifier}} placeholder="Enter your password..." />
  <button class="#{$ns}-button #{$ns}-minimal #{$ns}-intent-warning #{$ns}-icon-lock" {{:modifier}}></button>
</div>
<div class="#{$ns}-input-group {{.modifier}}">
  <span class="#{$ns}-icon #{$ns}-icon-search"></span>
  <input type="text" class="#{$ns}-input" {{:modifier}} placeholder="Search" />
  <button class="#{$ns}-button #{$ns}-minimal #{$ns}-intent-primary #{$ns}-icon-arrow-right" {{:modifier}}></button>
</div>

:disabled - Disabled input. Must be added separately to the <code>&#60;input&#62;</code> and <code>&#60;button&#62;</code>. Also add <code>.#{$ns}-disabled</code> to <code>.#{$ns}-input-group</code> for icon coloring (not shown below).
.#{$ns}-round - Rounded caps. Button will also be rounded.
.#{$ns}-large - Large group. Children will adjust size accordingly.
.#{$ns}-small - Small group. Children will adjust size accordingly.
.#{$ns}-intent-primary - Primary intent. (All 4 intents are supported.)
.#{$ns}-fill - Take up full width of parent element.

Styleguide input-group
*/

// 3px space between small button and regular input
$input-button-height: $pt-button-height-small !default;
// 5px space between regular button and large input
$input-button-height-large: $pt-button-height !default;
// 1px space between regular button and small input
$input-button-height-small: $pt-button-height-smaller !default;

.#{$ns}-input-group {
  display: block;
  position: relative;

  .#{$ns}-input {
    // explicit position prevents shadow clipping https://github.com/palantir/blueprint/pull/490#issuecomment-273342170
    position: relative;
    width: 100%;

    // add space if there's something before or after the input
    &:not(:first-child) {
      padding-left: $pt-input-height;
    }

    &:not(:last-child) {
      padding-right: $pt-input-height;
    }
  }

  .#{$ns}-input-action,
  > .#{$ns}-input-left-container,
  > .#{$ns}-button,
  > .#{$ns}-icon {
    position: absolute;
    top: 0;

    // glue it to the end it appears on
    &:first-child {
      left: 0;
    }

    &:last-child {
      right: 0;
    }
  }

  .#{$ns}-button {
    @include pt-button-height($input-button-height);
    margin: ($pt-input-height - $input-button-height) * 0.5;
    padding: $button-padding-small;

    // icons CSS API support
    &:empty { padding: 0; }
  }

  // bump icon or left content up so it sits above input
  > .#{$ns}-input-left-container,
  > .#{$ns}-icon {
    z-index: 1;
  }

  // direct descendant to exclude icons in buttons
  > .#{$ns}-input-left-container > .#{$ns}-icon,
  > .#{$ns}-icon {
    color: $pt-icon-color;

    &:empty {
      @include pt-icon($pt-icon-size-standard);
    }
  }

  // adjusting the margin of spinners in input groups
  // we have to avoid targetting buttons that contain a spinner
  > .#{$ns}-input-left-container > .#{$ns}-icon,
  > .#{$ns}-icon,
  .#{$ns}-input-action > .#{$ns}-spinner {
    margin: ($pt-input-height - $pt-icon-size-standard) * 0.5;
  }

  .#{$ns}-tag {
    margin: $pt-grid-size * 0.5;
  }

  // all buttons go gray in default state and assume their native colors only when hovered
  // or when input is focused. this prevents distracting colors in the UI.
  .#{$ns}-input:not(:focus) + .#{$ns}-button,
  .#{$ns}-input:not(:focus) + .#{$ns}-input-action .#{$ns}-button {
    &.#{$ns}-minimal:not(:hover):not(:focus) {
      color: $pt-text-color-muted;

      // same goes for dark
      /* stylelint-disable-next-line selector-max-compound-selectors */
      .#{$ns}-dark & {
        color: $pt-dark-text-color-muted;
      }

      #{$icon-classes} {
        color: $pt-icon-color;
      }
    }

    &.#{$ns}-minimal:disabled {
      // override more specific selector above
      /* stylelint-disable declaration-no-important */
      color: $pt-icon-color-disabled !important;

      #{$icon-classes} {
        color: $pt-icon-color-disabled !important;
      }
    }
  }

  // this class echoes `input:disabled` on the child input, but each action must individually be disabled
  &.#{$ns}-disabled {
    // note that enabled buttons inside this input group are still clickable
    cursor: not-allowed;

    .#{$ns}-icon {
      color: $pt-icon-color-disabled;
    }
  }

  &.#{$ns}-large {
    .#{$ns}-button {
      @include pt-button-height($input-button-height-large);
      margin: ($pt-input-height-large - $input-button-height-large) * 0.5;
    }

    > .#{$ns}-input-left-container > .#{$ns}-icon,
    > .#{$ns}-icon,
    .#{$ns}-input-action > .#{$ns}-spinner {
      margin: ($pt-input-height-large - $pt-icon-size-standard) * 0.5;
    }

    .#{$ns}-input {
      @include pt-input-large();

      &:not(:first-child) {
        padding-left: $pt-button-height-large;
      }

      &:not(:last-child) {
        padding-right: $pt-button-height-large;
      }
    }
  }

  &.#{$ns}-small {
    .#{$ns}-button {
      @include pt-button-height($pt-button-height-smaller);
      margin: ($pt-input-height-small - $pt-button-height-smaller) * 0.5;
    }

    .#{$ns}-tag {
      @include pt-button-height($pt-button-height-smaller);
      margin: ($pt-input-height-small - $pt-button-height-smaller) * 0.5;
    }

    > .#{$ns}-input-left-container > .#{$ns}-icon,
    > .#{$ns}-icon,
    .#{$ns}-input-action > .#{$ns}-spinner {
      margin: ($pt-input-height-small - $pt-icon-size-standard) * 0.5;
    }

    .#{$ns}-input {
      @include pt-input-small();

      &:not(:first-child) {
        padding-left: $pt-icon-size-standard + $input-small-padding;
      }

      &:not(:last-child) {
        padding-right: $pt-icon-size-standard + $input-small-padding;
      }
    }
  }

  &.#{$ns}-fill {
    flex: 1 1 auto;
    width: 100%;
  }

  &.#{$ns}-round {
    .#{$ns}-button,
    .#{$ns}-input,
    .#{$ns}-tag {
      border-radius: $pt-input-height;
    }
  }

  .#{$ns}-dark & {
    .#{$ns}-icon {
      color: $pt-dark-icon-color;
    }

    &.#{$ns}-disabled .#{$ns}-icon {
      color: $pt-dark-icon-color-disabled;
    }
  }

  @each $intent, $color in $pt-intent-colors {
    &.#{$ns}-intent-#{$intent} {
      .#{$ns}-input {
        @include pt-input-intent($color);

        .#{$ns}-dark & {
          @include pt-dark-input-intent(map-get($pt-dark-input-intent-box-shadow-colors, $intent));
        }
      }

      > .#{$ns}-icon {
        color: map-get($pt-intent-text-colors, $intent);

        .#{$ns}-dark & {
          color: map-get($pt-dark-intent-text-colors, $intent);
        }
      }
    }
  }
}

================================================================================

File: src\components\forms\_input.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";

/*
Text inputs

Markup:
<input class="#{$ns}-input {{.modifier}}" {{:modifier}} type="text" placeholder="Text input" dir="auto" />

:disabled - Disabled
:readonly - Readonly
.#{$ns}-round - Rounded ends
.#{$ns}-large - Larger size
.#{$ns}-small - Small size
.#{$ns}-intent-primary - Primary intent
.#{$ns}-intent-success - Success intent
.#{$ns}-intent-warning - Warning intent
.#{$ns}-intent-danger - Danger intent
.#{$ns}-fill - Take up full width of parent element

Styleguide input
*/

.#{$ns}-input {
  @include pt-input();

  &.#{$ns}-large {
    @include pt-input-large();
  }

  &.#{$ns}-small {
    @include pt-input-small();
  }

  &.#{$ns}-fill {
    flex: 1 1 auto;
    width: 100%;
  }

  .#{$ns}-dark & {
    @include pt-dark-input();
  }

  @each $intent, $color in $pt-intent-colors {
    &.#{$ns}-intent-#{$intent} {
      @include pt-input-intent($color);

      .#{$ns}-dark & {
        @include pt-dark-input-intent(map-get($pt-dark-input-intent-box-shadow-colors, $intent));
      }
    }
  }

  &::-ms-clear {
    display: none;
  }
}

// for iOS support
@supports (-webkit-touch-callout: none) {
  // only html input elements require a fix on iOS
  input.#{$ns}-input {
    &:disabled,
    &.#{$ns}-disabled {
      opacity: 1;
      -webkit-text-fill-color: $input-color-disabled;

      .#{$ns}-dark & {
        -webkit-text-fill-color: $dark-input-color-disabled;
      }
    }
  }
}


/*
Textareas

Markup:
<textarea class="#{$ns}-input {{.modifier}}" {{:modifier}} dir="auto"></textarea>

:disabled - Disabled
:readonly - Readonly
.#{$ns}-large - Larger font size
.#{$ns}-small - Small font size
.#{$ns}-intent-primary - Primary intent
.#{$ns}-intent-danger  - Danger intent
.#{$ns}-fill  - Take up full width of parent element

Styleguide textarea
*/

/* stylelint-disable-next-line selector-no-qualifying-type */
textarea.#{$ns}-input {
  max-width: 100%;
  padding: $input-padding-horizontal;

  &,
  &.#{$ns}-large,
  &.#{$ns}-small {
    // override input styles for these modifiers.
    // line-height is needed to center text on <input> but not on multiline <textarea>
    height: auto;
    line-height: inherit;
  }

  &.#{$ns}-small {
    padding: $input-small-padding;
  }
}

.#{$ns}-text-area {
  &.#{$ns}-text-area-auto-resize {
    // we are controlling vertical resizing automatically, so restrict user resizing to horizontal dimension only
    resize: horizontal;
  }
}

================================================================================

File: src\components\forms\_label.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables-extended";

/*
Labels

Markup:
<div>
  <label class="#{$ns}-label {{.modifier}}">
    Label A
    <span class="#{$ns}-text-muted">(optional)</span>
    <input {{:modifier}} class="#{$ns}-input" style="width: 200px;" type="text" placeholder="Text input" dir="auto" />
  </label>
  <label class="#{$ns}-label {{.modifier}}">
    Label B
    <div class="#{$ns}-input-group {{.modifier}}">
      <span class="#{$ns}-icon #{$ns}-icon-calendar"></span>
      <input {{:modifier}} class="#{$ns}-input" style="width: 200px;" type="text" placeholder="Input group" dir="auto" />
    </div>
  </label>
  <label class="#{$ns}-label {{.modifier}}">
    Label C
    <div class="#{$ns}-html-select {{.modifier}}">
      <select {{:modifier}}>
        <option selected>Choose an item...</option>
        <option value="1">One</option>
      </select>
      <span class="#{$ns}-icon #{$ns}-icon-double-caret-vertical"></span>
    </div>
  </label>
</div>

:disabled - Disable the input.
.#{$ns}-disabled - Disabled styles. Input must be disabled separately via attribute.
.#{$ns}-inline - Label and content appear side by side.

Styleguide label
*/

label.#{$ns}-label {
  display: block;
  margin-bottom: ($pt-grid-size * 1.5);
  margin-top: 0;

  .#{$ns}-html-select,
  .#{$ns}-input,
  .#{$ns}-select,
  .#{$ns}-slider,
  .#{$ns}-popover-wrapper {
    display: block;
    margin-top: $half-grid-size;
    text-transform: none;
  }

  .#{$ns}-button-group {
    margin-top: $half-grid-size;
  }

  .#{$ns}-select select,
  .#{$ns}-html-select select {
    font-weight: 400;
    vertical-align: top;
    width: 100%;
  }

  .#{$ns}-control-group {
    margin-top: $half-grid-size;

    > .#{$ns}-button-group,
    > .#{$ns}-html-select,
    > .#{$ns}-input,
    > .#{$ns}-select,
    > .#{$ns}-slider,
    > .#{$ns}-popover-wrapper {
      margin-top: 0;
    }
  }

  &.#{$ns}-disabled {
    &,
    .#{$ns}-text-muted {
      color: $pt-text-color-disabled;
    }
  }

  &.#{$ns}-inline {
    line-height: $pt-input-height;

    .#{$ns}-html-select,
    .#{$ns}-input,
    .#{$ns}-input-group,
    .#{$ns}-select,
    .#{$ns}-popover-wrapper {
      display: inline-block;
      margin: 0 0 0 $half-grid-size;
      vertical-align: top;
    }

    .#{$ns}-button-group {
      margin: 0 0 0 $half-grid-size;
    }

    .#{$ns}-input-group .#{$ns}-input {
      margin-left: 0;
    }

    &.#{$ns}-large {
      line-height: $pt-input-height-large;
    }

    .#{$ns}-control-group {
      margin: 0 0 0 $half-grid-size;

      > .#{$ns}-button-group,
      > .#{$ns}-html-select,
      > .#{$ns}-input,
      > .#{$ns}-select,
      > .#{$ns}-slider,
      > .#{$ns}-popover-wrapper {
        margin: 0;
      }
    }
  }

  &:not(.#{$ns}-inline) .#{$ns}-popover-target {
    display: block;
  }

  .#{$ns}-dark & {
    color: $pt-dark-heading-color;

    &.#{$ns}-disabled {
      &,
      .#{$ns}-text-muted {
        color: $pt-dark-text-color-disabled;
      }
    }
  }
}

================================================================================

File: src\components\forms\_numeric-input.scss
--------------------------------------------------------------------------------
@import "../../common/variables";
@import "./common";

.#{$ns}-numeric-input {
  // we need a very-specific selector here to override specificicty of selectors defined elsewhere.
  .#{$ns}-button-group.#{$ns}-vertical > .#{$ns}-button {
    // let the buttons shrink to equal heights
    flex: 1 1 ($pt-button-height-small * 0.5 - 1);
    min-height: 0;
    padding: 0;
    width: $pt-button-height-small;
  }

  &.#{$ns}-large .#{$ns}-button-group.#{$ns}-vertical > .#{$ns}-button {
    width: $pt-button-height-large;
  }

  &.#{$ns}-small .#{$ns}-button-group.#{$ns}-vertical > .#{$ns}-button {
    width: $pt-button-height-small;
  }
}

================================================================================

File: src\components\hotkeys\hotkey.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, type Props } from "../../common";
import type { HotkeyConfig } from "../../hooks";

import { KeyComboTag } from "./keyComboTag";

export type HotkeyProps = Props & HotkeyConfig;

/**
 * Hotkey component used to display a hotkey in the HotkeysDialog.
 * Should not be used by consumers directly.
 */
export class Hotkey extends AbstractPureComponent<HotkeyProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.Hotkey`;

    public static defaultProps = {
        allowInInput: false,
        disabled: false,
        global: false,
        preventDefault: false,
        stopPropagation: false,
    };

    public render() {
        const { label, className, ...spreadableProps } = this.props;

        const rootClasses = classNames(Classes.HOTKEY, className);
        return (
            <div className={rootClasses}>
                <div className={Classes.HOTKEY_LABEL}>{label}</div>
                <KeyComboTag {...spreadableProps} />
            </div>
        );
    }

    protected validateProps(props: HotkeyProps) {
        if (props.global !== true && props.group == null) {
            console.error("non-global Hotkeys must define a group");
        }
    }
}

================================================================================

File: src\components\hotkeys\hotkeyParser.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// alph sorting is unintuitive here
// tslint:disable object-literal-sort-keys

export interface KeyCodeTable {
    [code: number]: string;
}

export interface KeyCodeReverseTable {
    [key: string]: number;
}

export interface KeyMap {
    [key: string]: string;
}

/**
 * Named modifier keys
 *
 * @see https://www.w3.org/TR/uievents-key/#keys-modifier
 */
const MODIFIER_KEYS = new Set(["Shift", "Control", "Alt", "Meta"]);

export const MODIFIER_BIT_MASKS: KeyCodeReverseTable = {
    alt: 1,
    ctrl: 2,
    meta: 4,
    shift: 8,
};

export const CONFIG_ALIASES: KeyMap = {
    cmd: "meta",
    command: "meta",
    del: "delete",
    esc: "escape",
    escape: "escape",
    minus: "-",
    mod: isMac() ? "meta" : "ctrl",
    option: "alt",
    plus: "+",
    return: "enter",
    win: "meta",
    // need these aliases for backwards-compatibility (but they're also convenient)
    up: "ArrowUp",
    left: "ArrowLeft",
    down: "ArrowDown",
    right: "ArrowRight",
};

/**
 * Key mapping used in getKeyCombo() implementation for physical keys which are not alphabet characters or digits.
 *
 * N.B. at some point, we should stop using this mapping, since we can implement the desired functionality in a more
 * straightforward way by using the `event.code` property, which will always tell us the identifiers represented by the
 * _values_ in this object (the default physical keys, unaltered by modifier keys or keyboard layout).
 */
export const SHIFT_KEYS: KeyMap = {
    "~": "`",
    _: "-",
    "+": "=",
    "{": "[",
    "}": "]",
    "|": "\\",
    ":": ";",
    '"': "'",
    "<": ",",
    ">": ".",
    "?": "/",
};

export interface KeyCombo {
    key?: string;
    modifiers: number;
}

export function comboMatches(a: KeyCombo, b: KeyCombo) {
    return a.modifiers === b.modifiers && a.key === b.key;
}

/**
 * Converts a key combo string into a key combo object. Key combos include
 * zero or more modifier keys, such as `shift` or `alt`, and exactly one
 * action key, such as `A`, `enter`, or `left`.
 *
 * For action keys that require a shift, e.g. `@` or `|`, we inlude the
 * necessary `shift` modifier and automatically convert the action key to the
 * unshifted version. For example, `@` is equivalent to `shift+2`.
 */
export const parseKeyCombo = (combo: string): KeyCombo => {
    const pieces = combo.replace(/\s/g, "").toLowerCase().split("+");
    let modifiers = 0;
    let key: string | undefined;
    for (let piece of pieces) {
        if (piece === "") {
            throw new Error(`Failed to parse key combo "${combo}".
                Valid key combos look like "cmd + plus", "shift+p", or "!"`);
        }

        if (CONFIG_ALIASES[piece] !== undefined) {
            piece = CONFIG_ALIASES[piece];
        }

        if (MODIFIER_BIT_MASKS[piece] !== undefined) {
            modifiers += MODIFIER_BIT_MASKS[piece];
        } else if (SHIFT_KEYS[piece] !== undefined) {
            modifiers += MODIFIER_BIT_MASKS.shift;
            key = SHIFT_KEYS[piece];
        } else {
            key = piece.toLowerCase();
        }
    }
    return { modifiers, key };
};

/**
 * Interprets a keyboard event as a valid KeyComboTag `combo` prop string value.
 *
 * Note that this function is only used in the docs example and tests; it is not used by `useHotkeys()` or any
 * Blueprint consumers that we are currently aware of.
 */
export const getKeyComboString = (e: KeyboardEvent): string => {
    const comboParts = [] as string[];

    // modifiers first
    if (e.ctrlKey) {
        comboParts.push("ctrl");
    }
    if (e.altKey) {
        comboParts.push("alt");
    }
    if (e.shiftKey) {
        comboParts.push("shift");
    }
    if (e.metaKey) {
        comboParts.push("meta");
    }

    const key = maybeGetKeyFromEventCode(e);
    if (key !== undefined) {
        comboParts.push(key);
    } else {
        if (e.code === "Space") {
            comboParts.push("space");
        } else if (MODIFIER_KEYS.has(e.key)) {
            // do nothing
        } else if (e.shiftKey && SHIFT_KEYS[e.key] !== undefined) {
            comboParts.push(SHIFT_KEYS[e.key]);
        } else if (e.key !== undefined) {
            comboParts.push(e.key.toLowerCase());
        }
    }

    return comboParts.join(" + ");
};

const KEY_CODE_PREFIX = "Key";
const DIGIT_CODE_PREFIX = "Digit";

function maybeGetKeyFromEventCode(e: KeyboardEvent) {
    if (e.code == null) {
        return undefined;
    }

    if (e.code.startsWith(KEY_CODE_PREFIX)) {
        // Code looks like "KeyA", etc.
        return e.code.substring(KEY_CODE_PREFIX.length).toLowerCase();
    } else if (e.code.startsWith(DIGIT_CODE_PREFIX)) {
        // Code looks like "Digit1", etc.
        return e.code.substring(DIGIT_CODE_PREFIX.length).toLowerCase();
    } else if (e.code === "Space") {
        return "space";
    }

    return undefined;
}

/**
 * Determines the key combo object from the given keyboard event. A key combo includes zero or more modifiers
 * (represented by a bitmask) and one physical key. For most keys, we prefer dealing with the `code` property of the
 * event, since this is not altered by keyboard layout or the state of modifier keys. Fall back to using the `key`
 * property.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code
 */
export const getKeyCombo = (e: KeyboardEvent): KeyCombo => {
    let key: string | undefined;
    if (MODIFIER_KEYS.has(e.key)) {
        // Leave local variable `key` undefined
    } else {
        key = maybeGetKeyFromEventCode(e) ?? e.key?.toLowerCase();
    }

    let modifiers = 0;
    if (e.altKey) {
        modifiers += MODIFIER_BIT_MASKS.alt;
    }
    if (e.ctrlKey) {
        modifiers += MODIFIER_BIT_MASKS.ctrl;
    }
    if (e.metaKey) {
        modifiers += MODIFIER_BIT_MASKS.meta;
    }
    if (e.shiftKey) {
        modifiers += MODIFIER_BIT_MASKS.shift;
        if (SHIFT_KEYS[e.key] !== undefined) {
            key = SHIFT_KEYS[e.key];
        }
    }

    return { modifiers, key };
};

/**
 * Splits a key combo string into its constituent key values and looks up
 * aliases, such as `return` -> `enter`.
 *
 * Unlike the parseKeyCombo method, this method does NOT convert shifted
 * action keys. So `"@"` will NOT be converted to `["shift", "2"]`).
 */
export const normalizeKeyCombo = (combo: string, platformOverride?: string): string[] => {
    const keys = combo.replace(/\s/g, "").split("+");
    return keys.map(key => {
        const keyName = CONFIG_ALIASES[key] != null ? CONFIG_ALIASES[key] : key;
        return keyName === "meta" ? (isMac(platformOverride) ? "cmd" : "ctrl") : keyName;
    });
};

function isMac(platformOverride?: string) {
    // HACKHACK: see https://github.com/palantir/blueprint/issues/5174
    // eslint-disable-next-line deprecation/deprecation
    const platform = platformOverride ?? (typeof navigator !== "undefined" ? navigator.platform : undefined);
    return platform === undefined ? false : /Mac|iPod|iPhone|iPad/.test(platform);
}

================================================================================

File: src\components\hotkeys\hotkeys-target2.md
--------------------------------------------------------------------------------
@# HotkeysTarget2

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Migrating from [HotkeysTarget](#core/legacy/hotkeys-legacy)?

</h5>

__HotkeysTarget2__ is a replacement for HotkeysTarget. You are encouraged to use this new API, or
the `useHotkeys` hook directly in your function components, as they will become the standard
APIs in a future major version of Blueprint. See the full
[migration guide](https://github.com/palantir/blueprint/wiki/HotkeysTarget-&-useHotkeys-migration) on the wiki.

</div>


The __HotkeysTarget2__ component is a utility component which allows you to use the
[`useHotkeys` hook](#core/hooks/use-hotkeys) inside a React component class. It's useful if you want to switch to the
new hotkeys API without refactoring your class components into functional components.

Focus on the piano below to try its hotkeys. The global hotkeys dialog can be shown using the <kbd>?</kbd> key.

@reactExample HotkeysTarget2Example

@## Usage

First, make sure [__HotkeysProvider__](#core/context/hotkeys-provider) is configured correctly at the root of your
React application.

Then, to register hotkeys and generate the relevant event handlers, use the component like so:

```tsx
import * as React from "react";
import { HotkeysTarget2, InputGroup } from "@blueprintjs/core";

export default class extends React.PureComponent {
    private inputRef = React.createRef<HTMLInputElement>();

    private hotkeys = [
        {
            combo: "R",
            global: true,
            label: "Refresh data",
            onKeyDown: () => console.info("Refreshing data..."),
        },
        {
            combo: "F",
            group: "Input",
            label: "Focus text input",
            onKeyDown: this.inputRef.current?.focus(),
        },
    ];

    public render() {
        return (
            <HotkeysTarget2 hotkeys={this.hotkeys}>
                {({ handleKeyDown, handleKeyUp }) => (
                    <div tabIndex={0} onKeyDown={handleKeyDown} onKeyUp={handleKeyUp}>
                        Press "R" to refresh data, "F" to focus the input...
                        <InputGroup inputRef={this.inputRef} />
                    </div>
                )}
            </HotkeysTarget2>
        )
    }
}
```

Hotkeys must define a group, or be marked as global. The component will automatically bind global event handlers
and configure the <kbd>?</kbd> key to open the generated hotkeys dialog, but it is up to you to bind _local_
event handlers with the `handleKeyDown` and `handleKeyUp` functions in the child render function. Note that
you will likely have to set a non-negative `tabIndex` on the DOM node to which these local event handlers are
bound for them to work correctly.

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign">

See the [useHotkeys hook documentation](#core/hooks/use-hotkeys.key-combos) to understand the semantics of "key combos":
how they are configured and how they will appear in the global dialog.

</div>

@## Props interface

@interface HotkeysTarget2Props

@interface UseHotkeysOptions

@## Hotkey configuration

@interface HotkeyConfig

================================================================================

File: src\components\hotkeys\hotkeys.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, type Props } from "../../common";
import { HOTKEYS_HOTKEY_CHILDREN } from "../../common/errors";
import { isElementOfType, isReactChildrenElementOrElements } from "../../common/utils";
import { H4 } from "../html/html";

import { Hotkey, type HotkeyProps } from "./hotkey";

export interface HotkeysProps extends Props {
    /**
     * In order to make local hotkeys work on elements that are not normally
     * focusable, such as `<div>`s or `<span>`s, we add a `tabIndex` attribute
     * to the hotkey target, which makes it focusable. By default, we use `0`,
     * but you can override this value to change the tab navigation behavior
     * of the component. You may even set this value to `null`, which will omit
     * the `tabIndex` from the component decorated by `HotkeysTarget`.
     */
    tabIndex?: number;
}

/**
 * Hotkeys component used to display a list of hotkeys in the HotkeysDialog.
 * Should not be used by consumers directly.
 */
export class Hotkeys extends AbstractPureComponent<HotkeysProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.Hotkeys`;

    public static defaultProps = {
        tabIndex: 0,
    };

    public render() {
        if (!isReactChildrenElementOrElements(this.props.children)) {
            return null;
        }

        const hotkeys = React.Children.map(
            this.props.children,
            (child: React.ReactElement<HotkeyProps>) => child.props,
        );

        // sort by group label alphabetically, prioritize globals
        hotkeys.sort((a, b) => {
            if (a.global === b.global && a.group && b.group) {
                return a.group.localeCompare(b.group);
            }
            return a.global ? -1 : 1;
        });

        let lastGroup: string | undefined;
        const elems = [] as React.JSX.Element[];
        for (const hotkey of hotkeys) {
            const groupLabel = hotkey.group;
            if (groupLabel !== lastGroup) {
                elems.push(<H4 key={`group-${elems.length}`}>{groupLabel}</H4>);
                lastGroup = groupLabel;
            }
            elems.push(<Hotkey key={elems.length} {...hotkey} />);
        }
        const rootClasses = classNames(Classes.HOTKEY_COLUMN, this.props.className);
        return <div className={rootClasses}>{elems}</div>;
    }

    protected validateProps(props: HotkeysProps & { children: React.ReactNode }) {
        if (!isReactChildrenElementOrElements(props.children)) {
            return;
        }

        React.Children.forEach(props.children, (child: React.JSX.Element) => {
            if (!isElementOfType(child, Hotkey)) {
                throw new Error(HOTKEYS_HOTKEY_CHILDREN);
            }
        });
    }
}

================================================================================

File: src\components\hotkeys\hotkeysDialog2.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Classes } from "../../common";
import type { HotkeyConfig } from "../../hooks";
import { Dialog, type DialogProps } from "../dialog/dialog";
import { DialogBody } from "../dialog/dialogBody";

import { Hotkey } from "./hotkey";
import { Hotkeys } from "./hotkeys";

export interface HotkeysDialogProps extends DialogProps {
    /**
     * This string displayed as the group name in the hotkeys dialog for all
     * global hotkeys.
     */
    globalGroupName?: string;

    hotkeys: readonly HotkeyConfig[];
}

export const HotkeysDialog2: React.FC<HotkeysDialogProps> = ({ globalGroupName = "Global", hotkeys, ...props }) => {
    return (
        <Dialog {...props} className={classNames(Classes.HOTKEY_DIALOG, props.className)}>
            <DialogBody>
                <Hotkeys>
                    {hotkeys.map((hotkey, index) => (
                        <Hotkey
                            key={index}
                            {...hotkey}
                            group={hotkey.global === true && hotkey.group == null ? globalGroupName : hotkey.group}
                        />
                    ))}
                </Hotkeys>
            </DialogBody>
        </Dialog>
    );
};

================================================================================

File: src\components\hotkeys\hotkeysTarget2.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

import * as Errors from "../../common/errors";
import { isFunction, isNodeEnv } from "../../common/utils";
import { type HotkeyConfig, useHotkeys, type UseHotkeysOptions } from "../../hooks";

/** Identical to the return type of `useHotkeys` hook. */
export interface HotkeysTarget2RenderProps {
    handleKeyDown: React.KeyboardEventHandler<HTMLElement>;
    handleKeyUp: React.KeyboardEventHandler<HTMLElement>;
}

export interface HotkeysTarget2Props {
    /**
     * Render prop which receives the same callback handlers generated by the `useHotkeys` hook.
     * If your hotkey definitions are all global, you may supply an element instead.
     */
    children: React.JSX.Element | ((props: HotkeysTarget2RenderProps) => React.JSX.Element);

    /** Hotkey definitions. */
    hotkeys: readonly HotkeyConfig[];

    /** Hook customization options. */
    options?: UseHotkeysOptions;
}

/**
 * Utility component which allows consumers to use the new `useHotkeys` hook inside
 * React component classes. The implementation simply passes through to the hook.
 */
export const HotkeysTarget2 = ({ children, hotkeys, options }: HotkeysTarget2Props): React.JSX.Element => {
    const { handleKeyDown, handleKeyUp } = useHotkeys(hotkeys, options);

    // run props validation
    React.useEffect(() => {
        if (!isNodeEnv("production")) {
            if (typeof children !== "function" && hotkeys.some(h => !h.global)) {
                console.error(Errors.HOTKEYS_TARGET_CHILDREN_LOCAL_HOTKEYS);
            }
        }
    }, [hotkeys, children]);

    if (isFunction(children)) {
        return children({ handleKeyDown, handleKeyUp });
    } else {
        return children;
    }
};

================================================================================

File: src\components\hotkeys\index.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2020 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { Hotkey, type HotkeyProps } from "./hotkey";
export { Hotkeys, type HotkeysProps } from "./hotkeys";
export { KeyComboTag, type KeyComboTagProps } from "./keyComboTag";
export { type KeyCombo, comboMatches, getKeyCombo, getKeyComboString, parseKeyCombo } from "./hotkeyParser";

// N.B. "V1" variants of these APIs are exported from src/legacy/
export { HotkeysDialog2 } from "./hotkeysDialog2";
export { HotkeysTarget2, type HotkeysTarget2Props, type HotkeysTarget2RenderProps } from "./hotkeysTarget2";

================================================================================

File: src\components\hotkeys\keyComboTag.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import {
    ArrowDown,
    ArrowLeft,
    ArrowRight,
    ArrowUp,
    KeyCommand,
    KeyControl,
    KeyDelete,
    KeyEnter,
    KeyOption,
    KeyShift,
} from "@blueprintjs/icons";

import { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, type Props } from "../../common";
import { Icon } from "../icon/icon";

import { normalizeKeyCombo } from "./hotkeyParser";

const KEY_ICONS: Record<string, { icon: React.JSX.Element; iconTitle: string }> = {
    ArrowDown: { icon: <ArrowDown />, iconTitle: "Down key" },
    ArrowLeft: { icon: <ArrowLeft />, iconTitle: "Left key" },
    ArrowRight: { icon: <ArrowRight />, iconTitle: "Right key" },
    ArrowUp: { icon: <ArrowUp />, iconTitle: "Up key" },
    alt: { icon: <KeyOption />, iconTitle: "Alt/Option key" },
    cmd: { icon: <KeyCommand />, iconTitle: "Command key" },
    ctrl: { icon: <KeyControl />, iconTitle: "Control key" },
    delete: { icon: <KeyDelete />, iconTitle: "Delete key" },
    enter: { icon: <KeyEnter />, iconTitle: "Enter key" },
    meta: { icon: <KeyCommand />, iconTitle: "Command key" },
    shift: { icon: <KeyShift />, iconTitle: "Shift key" },
};

/** Reverse table of some CONFIG_ALIASES fields, for display by KeyComboTag */
export const DISPLAY_ALIASES: Record<string, string> = {
    ArrowDown: "down",
    ArrowLeft: "left",
    ArrowRight: "right",
    ArrowUp: "up",
};

export interface KeyComboTagProps extends Props {
    /** The key combo to display, such as `"cmd + s"`. */
    combo: string;

    /**
     * Whether to render in a minimal style.
     * If `false`, each key in the combo will be rendered inside a `<kbd>` tag.
     * If `true`, only the icon or short name of a key will be rendered with no wrapper styles.
     *
     * @default false
     */
    minimal?: boolean;
}

export class KeyComboTag extends AbstractPureComponent<KeyComboTagProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.KeyComboTag`;

    public render() {
        const { className, combo, minimal } = this.props;
        const keys = normalizeKeyCombo(combo)
            .map(key => (key.length === 1 ? key.toUpperCase() : key))
            .map(minimal ? this.renderMinimalKey : this.renderKey);
        return <span className={classNames(Classes.KEY_COMBO, className)}>{keys}</span>;
    }

    private renderKey = (key: string, index: number) => {
        const keyString = DISPLAY_ALIASES[key] ?? key;
        const icon = KEY_ICONS[key];
        const reactKey = `key-${index}`;
        return (
            <kbd className={classNames(Classes.KEY, { [Classes.MODIFIER_KEY]: icon != null })} key={reactKey}>
                {icon != null && <Icon icon={icon.icon} title={icon.iconTitle} />}
                {keyString}
            </kbd>
        );
    };

    private renderMinimalKey = (key: string, index: number) => {
        const icon = KEY_ICONS[key];
        return icon == null ? key : <Icon icon={icon.icon} title={icon.iconTitle} key={`key-${index}`} />;
    };
}

================================================================================

File: src\components\hotkeys\_hotkeys.scss
--------------------------------------------------------------------------------
// Copyright 2016 Palantir Technologies, Inc. All rights reserved.

@import "../../common/variables";
@import "../../common/mixins";

.#{$ns}-key-combo {
  @include pt-flex-container(row, $pt-grid-size * 0.5);
  align-items: center;
}

.#{$ns}-hotkey-dialog {
  padding-bottom: 0;
  top: $pt-grid-size * 4;

  .#{$ns}-dialog-body {
    margin: 0;
    padding: 0;
  }

  .#{$ns}-hotkey-label {
    flex-grow: 1;
  }
}

.#{$ns}-hotkey-column {
  margin: auto;
  padding: $pt-grid-size * 3;

  .#{$ns}-heading {
    margin-bottom: $pt-grid-size * 2;

    &:not(:first-child) {
      margin-top: $pt-grid-size * 4;
    }
  }
}

.#{$ns}-hotkey {
  align-items: center;
  display: flex;
  justify-content: space-between;
  margin-left: 0;
  margin-right: 0;

  &:not(:last-child) {
    margin-bottom: $pt-grid-size;
  }
}

================================================================================

File: src\components\html\html.md
--------------------------------------------------------------------------------
---
reference: html
---

@# HTML elements

In order to avoid conflicts with other stylesheets, Blueprint does not style
most HTML elements directly. Instead, we provide several ways to style basic elements:

1. Use Blueprint React components: `<H1>`.
1. Apply the Blueprint `Classes` constant to an HTML tag: `<h1 className={Classes.HEADING}>`.
1. Nest HTML tags inside a container with `Classes.RUNNING_TEXT` (see below).

The following elements should be used in this manner:

| Component    | HTML tag     | `Classes` constant                                           |
| ------------ | ------------ | ------------------------------------------------------------ |
| `H1` - `H6`  | `h1` - `h6`  | `HEADING`                                                    |
| `Blockquote` | `blockquote` | `BLOCKQUOTE`                                                 |
| `Code`       | `code`       | `CODE`                                                       |
| `Label`      | `label`      | `LABEL` - see [Labels](#core/components/label)               |
| `Pre`        | `pre`        | `CODE_BLOCK`                                                 |
| `OL`         | `ol`         | `LIST`                                                       |
| `UL`         | `ul`         | `LIST`                                                       |
| `HTMLTable`  | `table`      | `HTML_TABLE` - see [HTML Table](#core/components/html-table) |

The React components listed above each support the full set of relevant HTML attributes **and an
optional `ref` prop** (via `React.forwardRef`) to access the instance of the HTML element itself
(not the React component).

@## Nested usage

Applying `Classes.RUNNING_TEXT` to a container element allows the above HTML
elements to be used directly without additional CSS classes.
This is very useful for rendering generated markup where you cannot control the
exact HTML elements, such as a Markdown document.

See the [Running text](#core/typography.running-text) documentation for more information.

@## Linting

The [**@blueprintjs/eslint-config**](https://www.npmjs.com/package/@blueprintjs/eslint-config)
NPM package provides advanced configuration for [ESLint](https://eslint.org/). Blueprint is
currently transitioning from [TSLint](https://palantir.github.io/tslint/) to ESLint, and as
such, rules are being migrated from TSLint to ESLint. In the meantime, some TSLint rules are
being run using ESLint.

The [**@blueprintjs/eslint-plugin**](https://www.npmjs.com/package/@blueprintjs/eslint-plugin)
package includes a custom `blueprint-html-components` rule that will warn on usages of
JSX intrinsic elements (`<h1>`) that have a Blueprint alternative (`<H1>`). See
the package's [README](https://www.npmjs.com/package/@blueprintjs/eslint-plugin)
for usage instructions.

================================================================================

File: src\components\html\html.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { BLOCKQUOTE, CODE, CODE_BLOCK, HEADING, LABEL, LIST } from "../../common/classes";

function htmlElement<E extends HTMLElement>(
    tagName: keyof React.JSX.IntrinsicElements,
    tagClassName: string,
): React.FC<React.AllHTMLAttributes<E> & React.RefAttributes<E>> {
    /* eslint-disable-next-line react/display-name */
    return React.forwardRef<E, React.AllHTMLAttributes<E>>((props, ref) => {
        const { className, children, ...htmlProps } = props;
        return React.createElement(
            tagName,
            {
                ...htmlProps,
                className: classNames(tagClassName, className),
                ref,
            },
            children,
        );
    });
}

// the following components are linted by blueprint-html-components because
// they should rarely be used without the Blueprint classes/styles:

export const H1 = htmlElement<HTMLHeadingElement>("h1", HEADING);
export const H2 = htmlElement<HTMLHeadingElement>("h2", HEADING);
export const H3 = htmlElement<HTMLHeadingElement>("h3", HEADING);
export const H4 = htmlElement<HTMLHeadingElement>("h4", HEADING);
export const H5 = htmlElement<HTMLHeadingElement>("h5", HEADING);
export const H6 = htmlElement<HTMLHeadingElement>("h6", HEADING);

export const Blockquote = htmlElement<HTMLElement>("blockquote", BLOCKQUOTE);
export const Code = htmlElement<HTMLElement>("code", CODE);
export const Pre = htmlElement<HTMLElement>("pre", CODE_BLOCK);
export const Label = htmlElement<HTMLLabelElement>("label", LABEL);

// these two are not linted by blueprint-html-components because there are valid
// uses of these elements without Blueprint styles:
export const OL = htmlElement<HTMLOListElement>("ol", LIST);
export const UL = htmlElement<HTMLUListElement>("ul", LIST);

================================================================================

File: src\components\html-select\html-select.md
--------------------------------------------------------------------------------
@# HTML select

Styling HTML `<select>` tags requires a wrapper element to customize the dropdown caret, so Blueprint provides
a __HTMLSelect__ component to streamline this process.

<div class="@ns-callout @ns-intent-success @ns-icon-info-sign @ns-callout-has-body-content">

The [__Select__](#select/select-component) component in the [**@blueprintjs/select**](#select)
package provides a more full-features alternative to the native HTML `<select>` tag. Notably, it
supports custom filtering logic and item rendering.

</div>

@## Usage

Use __HTMLSelect__ exactly like you would use a native `<select>` with `value` (or `defaultValue`) and `onChange`.
Options can be passed as `<option>` children for full flexibility or via the `options` prop for simple shorthand.

@reactExample HTMLSelectExample

@## Props interface

@interface HTMLSelectProps

@## CSS API

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use [`<HTMLSelect>`](#core/components/html-select)

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

</div>

Put class modifiers on the wrapper and attribute modifiers and event handlers directly on the `<select>`.

@css select

================================================================================

File: src\components\html-select\htmlSelect.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { CaretDown, DoubleCaretVertical, type IconName, type SVGIconProps } from "@blueprintjs/icons";

import { DISABLED, FILL, HTML_SELECT, LARGE, MINIMAL } from "../../common/classes";
import { DISPLAYNAME_PREFIX, type OptionProps } from "../../common/props";
import type { Extends } from "../../common/utils";

export type HTMLSelectIconName = Extends<IconName, "double-caret-vertical" | "caret-down">;

export interface HTMLSelectProps
    extends React.RefAttributes<HTMLSelectElement>,
        React.SelectHTMLAttributes<HTMLSelectElement> {
    children?: React.ReactNode;

    /** Whether this element is non-interactive. */
    disabled?: boolean;

    /** Whether this element should fill its container. */
    fill?: boolean;

    /**
     * Name of one of the supported icons for this component to display on the right side of the element.
     *
     * @default "double-caret-vertical"
     */
    iconName?: HTMLSelectIconName;

    /**
     * Props to spread to the icon element displayed on the right side of the element.
     */
    iconProps?: Partial<SVGIconProps>;

    /** Whether to use large styles. */
    large?: boolean;

    /** Whether to use minimal styles. */
    minimal?: boolean;

    /** Multiple select is not supported. */
    multiple?: never;

    /** Change event handler. Use `event.currentTarget.value` to access the new value. */
    onChange?: React.ChangeEventHandler<HTMLSelectElement>;

    /**
     * Shorthand for supplying options: an array of basic types or
     * `{ label?, value }` objects. If no `label` is supplied, `value`
     * will be used as the label.
     */
    options?: ReadonlyArray<string | number | OptionProps>;

    /** Controlled value of this component. */
    value?: string | number;
}

// this component is simple enough that tests would be purely tautological.
/* istanbul ignore next */
/**
 * HTML select component
 *
 * @see https://blueprintjs.com/docs/#core/components/html-select
 */
export const HTMLSelect: React.FC<HTMLSelectProps> = React.forwardRef((props, ref) => {
    const {
        className,
        children,
        disabled,
        fill,
        iconName = "double-caret-vertical",
        iconProps,
        large,
        minimal,
        options = [],
        value,
        ...htmlProps
    } = props;
    const classes = classNames(
        HTML_SELECT,
        {
            [DISABLED]: disabled,
            [FILL]: fill,
            [LARGE]: large,
            [MINIMAL]: minimal,
        },
        className,
    );

    const iconTitle = "Open dropdown";
    const rightIcon =
        iconName === "double-caret-vertical" ? (
            <DoubleCaretVertical title={iconTitle} {...iconProps} />
        ) : (
            <CaretDown title={iconTitle} {...iconProps} />
        );

    const optionChildren = options.map(option => {
        const optionProps: OptionProps = typeof option === "object" ? option : { value: option };
        return <option {...optionProps} key={optionProps.value} children={optionProps.label || optionProps.value} />;
    });

    return (
        <div className={classes}>
            <select disabled={disabled} ref={ref} value={value} {...htmlProps} multiple={false}>
                {optionChildren}
                {children}
            </select>
            {rightIcon}
        </div>
    );
});
HTMLSelect.displayName = `${DISPLAYNAME_PREFIX}.HTMLSelect`;

================================================================================

File: src\components\html-select\_common.scss
--------------------------------------------------------------------------------
// Copyright 2018 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../forms/common";

%pt-select {
  @include pt-button-layout();
  @include pt-button();

  /* stylelint-disable property-no-vendor-prefix */
  -moz-appearance: none;
  -webkit-appearance: none;
  border-radius: $pt-border-radius;
  height: $pt-button-height;
  padding: 0 ($input-padding-horizontal * 3) 0 $input-padding-horizontal;
  // fill parent container
  width: 100%;
  /* stylelint-enable property-no-vendor-prefix */
}

%pt-select-minimal {
  @include pt-button-minimal();
}

%pt-select-large {
  font-size: $pt-font-size-large;
  height: $pt-button-height-large;
  padding-right: $input-padding-horizontal * 3.5;
}

%pt-dark-select {
  @include pt-dark-button();
}

%pt-select-disabled {
  background-color: $button-background-color-disabled;
  box-shadow: none;
  color: $button-color-disabled;
  cursor: not-allowed;
}

%pt-select-icon {
  color: $pt-icon-color;
  pointer-events: none;
  position: absolute;
  // N.B. it's more important for the icon to vertically align with button right icons rather than
  // input right padding, see https://github.com/palantir/blueprint/issues/6184
  right: $pt-grid-size;
  top: ($pt-button-height - $pt-icon-size-standard) * 0.5;

  &.#{$ns}-disabled {
    color: $pt-icon-color-disabled;
  }
}

================================================================================

File: src\components\html-select\_html-select.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "../popover/common";
@import "./common";

/*
HTML select

Markup:
<div class="#{$ns}-html-select {{.modifier}}">
  <select {{:modifier}}>
    <option selected>Choose an item...</option>
    <option value="1">One</option>
    <option value="2">Two</option>
    <option value="3">Three</option>
    <option value="4">Four</option>
  </select>
  <span class="#{$ns}-icon #{$ns}-icon-double-caret-vertical"></span>
</div>

:disabled - Disabled. Also add <code>.#{$ns}-disabled</code> to <code>.#{$ns}-select</code> for icon coloring (not shown below).
.#{$ns}-fill - Expand to fill parent container
.#{$ns}-large - Large size
.#{$ns}-minimal - Minimal appearance

Styleguide select
*/

.#{$ns}-html-select,
.#{$ns}-select {
  display: inline-block;
  letter-spacing: normal;
  position: relative;
  vertical-align: middle;

  select {
    @extend %pt-select;

    &:disabled {
      @extend %pt-select-disabled;
    }
  }

  .#{$ns}-icon {
    @extend %pt-select-icon;
    @include pt-icon-colors();
  }

  &.#{$ns}-minimal select {
    @extend %pt-select-minimal;
  }

  &.#{$ns}-large {
    select {
      @extend %pt-select-large;
    }

    &::after, // CSS support
    .#{$ns}-icon {
      right: $pt-grid-size * 1.2;
      top: ($pt-button-height-large - $pt-icon-size-standard) * 0.5;
    }
  }

  &.#{$ns}-fill {
    &,
    select {
      width: 100%;
    }
  }

  .#{$ns}-dark & {
    select {
      @extend %pt-dark-select;
    }

    option {
      background-color: $pt-dark-popover-background-color;
      color: $pt-dark-text-color;
    }

    option:disabled {
      color: $pt-dark-text-color-disabled;
    }

    &::after {
      color: $pt-dark-icon-color;
    }
  }
}

.#{$ns}-html-select {
  .#{$ns}-icon {
    @extend %pt-select-icon;
  }
}

// N.B. this icon implementation is deprecated and will be removed in Blueprint 6.0
.#{$ns}-select {
  &::after {
    @extend %pt-select-icon;
    @include pt-icon();
    content: map-get($blueprint-icon-codepoints, "double-caret-vertical");
  }
}

================================================================================

File: src\components\html-table\html-table.md
--------------------------------------------------------------------------------
@# HTML table

__HTMLTable__ provides Blueprint styling to native HTML tables.

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">This is not @blueprintjs/table</h5>

This component is a simple CSS-only skin for HTML `<table>` elements.
It is ideal for basic static tables. If you're looking for more complex
spreadsheet-like features, check out [**@blueprintjs/table**](#table).

</div>

@## Props interface

The `<HTMLTable>` component provides modifier props to apply styles to an HTML `<table>` element. Note that you are
responsible for rendering `<thead>` and `<tbody>` elements as children.

@interface HTMLTableProps

@## CSS API

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use [`<HTMLTable>`](#core/components/html-table)

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

</div>

Apply the `@ns-html-table` class to a `<table>` element. You can apply modifiers as additional classes.

@css html-table

================================================================================

File: src\components\html-table\htmlTable.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Classes, DISPLAYNAME_PREFIX } from "../../common";

export interface HTMLTableProps
    extends React.TableHTMLAttributes<HTMLTableElement>,
        React.RefAttributes<HTMLTableElement> {
    /** Enable borders between rows and cells. */
    bordered?: boolean;

    /** Use compact appearance with less padding. */
    compact?: boolean;

    /** Enable hover styles on rows. */
    interactive?: boolean;

    /** Use an alternate background color on odd-numbered rows. */
    striped?: boolean;
}

// this component is simple enough that tests would be purely tautological.
/* istanbul ignore next */
/**
 * HTML table component.
 *
 * @see https://blueprintjs.com/docs/#core/components/html-table
 */
export const HTMLTable: React.FC<HTMLTableProps> = React.forwardRef((props, ref) => {
    const { bordered, className, compact, interactive, striped, ...htmlProps } = props;
    const classes = classNames(
        Classes.HTML_TABLE,
        {
            [Classes.COMPACT]: compact,
            [Classes.HTML_TABLE_BORDERED]: bordered,
            [Classes.HTML_TABLE_STRIPED]: striped,
            [Classes.INTERACTIVE]: interactive,
        },
        className,
    );
    // eslint-disable-next-line @blueprintjs/html-components
    return <table {...htmlProps} ref={ref} className={classes} />;
});
HTMLTable.displayName = `${DISPLAYNAME_PREFIX}.HTMLTable`;

================================================================================

File: src\components\html-table\_html-table.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";

/*
Tables

Markup:
<table class="#{$ns}-html-table {{.modifier}}">
  <thead>
    <tr>
      <th>Project</th>
      <th>Description</th>
      <th>Technologies</th>
      <th>Contributors</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Blueprint</td>
      <td>CSS framework and UI toolkit</td>
      <td>Sass, TypeScript, React</td>
      <td>268</td>
    </tr>
    <tr>
      <td>TSLint</td>
      <td>Static analysis linter for TypeScript</td>
      <td>TypeScript</td>
      <td>403</td>
    </tr>
    <tr>
      <td>Plottable</td>
      <td>Composable charting library built on top of D3</td>
      <td>SVG, TypeScript, D3</td>
      <td>737</td>
    </tr>
  </tbody>
  <tfoot>
    <tr>
      <td colspan=3>Total</td>
      <td>1408</td>
    </tr>
  </tfoot>
</table>

.#{$ns}-compact - Compact appearance
.#{$ns}-html-table-bordered - Bordered appearance
.#{$ns}-html-table-striped - Striped appearance
.#{$ns}-interactive - Enables hover styles on rows

Styleguide html-table
*/

$table-row-height: $pt-grid-size * 4 !default;
$table-row-height-small: $pt-grid-size * 3 !default;
$table-border-width: 1px !default;
$table-border-color: $pt-divider-black !default;
$dark-table-border-color: $pt-dark-divider-white !default;

// placeholder for extending inside running-text (see typography)
%html-table {
  border-spacing: 0;
  font-size: $pt-font-size;

  th,
  td {
    padding: centered-text($table-row-height);
    text-align: left;
    vertical-align: top;
  }

  th {
    color: $pt-heading-color;
    font-weight: 600;
  }

  td {
    color: $pt-text-color;
  }

  tbody tr:first-child,
  tfoot tr:first-child {
    th,
    td {
      box-shadow: inset 0 $table-border-width 0 0 $table-border-color;
    }
  }

  // a bunch of deep compound selectors ahead, but there's not really a better way to do this right now
  /* stylelint-disable selector-max-compound-selectors */
  .#{$ns}-dark & {
    th {
      color: $pt-dark-heading-color;
    }

    td {
      color: $pt-dark-text-color;
    }

    tbody tr:first-child,
    tfoot tr:first-child {
      th,
      td {
        box-shadow: inset 0 $table-border-width 0 0 $dark-table-border-color;
      }
    }
  }
  /* stylelint-enable selector-max-compound-selectors */
}

table.#{$ns}-html-table {
  @extend %html-table;

  &.#{$ns}-compact {
    $small-vertical-padding: centered-text($table-row-height-small);

    th,
    td {
      padding-bottom: $small-vertical-padding;
      padding-top: $small-vertical-padding;
    }
  }

  &.#{$ns}-html-table-striped {
    tbody tr:nth-child(odd) td {
      background: rgba($gray3, 0.15);
    }
  }

  // Borders are applied as box-shadows (at the top and left borders of a cell) for better color control.
  &.#{$ns}-html-table-bordered {
    th:not(:first-child) {
      box-shadow: inset $table-border-width 0 0 0 $table-border-color;

      @media (forced-colors: active) and (prefers-color-scheme: dark) {
        border-left: 1px solid $pt-high-contrast-mode-border-color;
      }
    }

    tbody tr td,
    tfoot tr td {
      box-shadow: inset 0 $table-border-width 0 0 $table-border-color;

      &:not(:first-child) {
        box-shadow: inset $table-border-width $table-border-width 0 0 $table-border-color;

        @media (forced-colors: active) and (prefers-color-scheme: dark) {
          border-left: 1px solid $pt-high-contrast-mode-border-color;
          border-top: 1px solid $pt-high-contrast-mode-border-color;
        }
      }

      @media (forced-colors: active) and (prefers-color-scheme: dark) {
        border-top: 1px solid $pt-high-contrast-mode-border-color;
      }
    }

    &.#{$ns}-html-table-striped {
      tbody tr:not(:first-child) td {
        box-shadow: none;

        &:not(:first-child) {
          box-shadow: inset $table-border-width 0 0 0 $table-border-color;
        }
      }
    }
  }

  &.#{$ns}-interactive {
    tbody tr {
      &:hover td {
        background-color: rgba($gray3, 0.3);
        cursor: pointer;

        @media (forced-colors: active) and (prefers-color-scheme: dark) {
          background-color: $pt-high-contrast-mode-active-background-color;
        }
      }

      &:active td {
        background-color: rgba($gray3, 0.35);

        @media (forced-colors: active) and (prefers-color-scheme: dark) {
          background-color: $pt-high-contrast-mode-active-background-color;
        }
      }
    }
  }

  .#{$ns}-dark & {
    /* stylelint-disable selector-max-compound-selectors */
    &.#{$ns}-html-table-striped {
      tbody tr:nth-child(odd) td {
        background: rgba($gray1, 0.15);
      }
    }

    // Borders are applied as box-shadows (at the top and left borders of a cell) for better color control.
    &.#{$ns}-html-table-bordered {
      th:not(:first-child) {
        box-shadow: inset $table-border-width 0 0 0 $dark-table-border-color;
      }

      tbody tr td,
      tfoot tr td {
        box-shadow: inset 0 $table-border-width 0 0 $dark-table-border-color;

        &:not(:first-child) {
          box-shadow: inset $table-border-width $table-border-width 0 0 $dark-table-border-color;
        }
      }

      &.#{$ns}-html-table-striped {
        tbody tr:not(:first-child) td {
          box-shadow: inset $table-border-width 0 0 0 $dark-table-border-color;

          // easier than the alternative...
          /* stylelint-disable max-nesting-depth */
          &:first-child {
            box-shadow: none;
          }
        }
      }
    }

    &.#{$ns}-interactive {
      tbody tr {
        &:hover td {
          background-color: rgba($gray1, 0.3);
          cursor: pointer;
        }

        &:active td {
          background-color: rgba($gray1, 0.4);
        }
      }
    }
    /* stylelint-enable selector-max-compound-selectors */
  }
}

================================================================================

File: src\components\icon\icon.md
--------------------------------------------------------------------------------
@# Icon

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign">

See the [**Icons package**](#icons) for a searchable list of all available UI icons.

</div>

Blueprint provides icons in two formats (SVG and fonts). It's easy to change their color
or apply effects like text shadows via standard SVG or CSS properties.

This section describes two ways of using Blueprint's UI icons:
via the `Icon` component to render SVG images or via CSS classes to use the icon font.

Many Blueprint components provide an `icon` prop which accepts an icon name
(such as `"history"`) or a JSX element to use as the icon. When you specify
the name as a string, these components render `<Icon icon="..." />` under the hood.

@reactExample IconExample

@## Usage

Use the `<Icon>` component to easily render __SVG icons__ in React. The `icon`
prop is typed such that editors can offer autocomplete for known icon names. The
optional `size` prop determines the exact width and height of the icon
image; the icon element itself can be also be sized using CSS.

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign">

Icons may be configured to load in various ways, see ["Loading icons"](#icons/loading-icons).

</div>

The HTML element rendered by `<Icon>` can be customized with the `tagName` prop
(defaults to `span`), and additional props are passed to this element.

Data files in the __@blueprintjs/icons__ package provide SVG path information
for Blueprint's 500+ icons for 16px and 20px grids. The `icon` prop specifies
which SVG is rendered and the `size` prop determines which pixel grid is used:
`size >= 20` will use the 20px grid and smaller icons will use the 16px grid.

If `title` is _not_ provided to an `<Icon>`, `aria-hidden` will be set to true as
it will be assumed that the icon is decorative since it is unlabeled.

```tsx
import { Icon, IconSize } from "@blueprintjs/core";

// icon name string literals are type checked
<Icon icon="cross" />
<Icon icon="globe" size={20} />

// constants are provided for standard sizes
<Icon icon="graph" size={IconSize.LARGE} intent="primary" />

// you can also pass all valid HTML props
<Icon icon="add" onClick={this.handleAdd} onKeyDown={this.handleAddKeys} />
```

Custom sizes are supported. The following React element:

```tsx
<Icon icon="globe" size={30} />
```

...renders this HTML markup:

```xml
<span class="@ns-icon @ns-icon-globe" aria-hidden="true">
    <svg data-icon="globe" width="30" height="30" viewBox="0 0 20 20" role="img">
        <path d="..."></path>
    </svg>
</span>
```

@## Props interface

@interface DefaultIconProps

@## DOM attributes

The `<Icon>` component forwards extra HTML attributes to its root DOM element. By default,
the root element is a `<span>` wrapper around the icon `<svg>`. The tag name of this element
may be customized via the `tagName` prop as either:

- a custom HTML tag name (for example `<div>` instead of the default `<span>` wrapper), or
- `null`, which makes the component omit the wrapper element and only render the `<svg>` as its root element

By default, `<Icon>` supports a limited set of DOM attributes which are assignable to _all_ HTML and SVG
elements. In some cases, you may want to use more specific attributes which are only available on HTML elements
or SVG elements. The `<Icon>` component has a generic type which allows for this more advanced usage. You can
specify a type parameter on the component opening tag to (for example) set an HTML-only attribute:

```tsx
import { Icon } from "@blueprintjs/core";
import * as React from "react";

function Example() {
    const [isDraggable, setIsDraggable] = React.useState();
    // explicitly declare type of the root element so that we can set the "draggable" DOM attribute
    return <Icon<HTMLSpanElement> icon="drag-handle-horizontal" draggable={isDraggable} />;
}
```

Another use case for this type parameter API may be to get the correct type definition for an event handler
on the root element when _omitting_ the icon wrapper element:

```tsx
import { Icon } from "@blueprintjs/core";
import * as React from "react";

function Example() {
    const handleClick: React.MouseEventHandler<SVGSVGElement> = () => { /* ... */ };
    // explicitly declare type of the root element so that we can narrow the type of the event handler
    return <Icon<SVGSVGElement> icon="add" onClick={handleClick} tagName={null} />;
}
```

@## Static components

The `<Icon>` component loads icon paths via dynamic module imports by default. An alternative API
is available in the __@blueprintjs/icons__ package which provides static imports of each icon as
a React component. The example below uses the `<Calendar>` component.

Note that some `<Icon>` props are not yet supported for these components, such as `intent`.

@reactExample IconGeneratedComponentExample

@interface DefaultSVGIconProps

@## CSS API

The CSS-only icons API uses the __icon fonts__ from the __@blueprintjs/icons__ package.
Note that _none of Blueprint's React components use the icon font_; it is only provided
for convenience to Blueprint consumers for rare situations where an icon font may be
preferred over icon SVGs.

To use Blueprint UI icons via CSS, you must apply two classes to a `<span>` element:
- a __sizing class__, either `@ns-icon-standard` (16px) or `@ns-icon-large` (20px)
- an __icon name class__, such as `@ns-icon-projects`

Icon classes also support the four `.@ns-intent-*` modifiers to color the image.

```html
<span class="@ns-icon-{{size}} @ns-icon-{{name}}"></span>

<span class="@ns-icon-standard @ns-icon-projects"></span>
<span class="@ns-icon-large @ns-icon-geosearch @ns-intent-success"></span>
```

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">Non-standard sizes</h5>

Generally, font icons should only be used at either 16px or 20px. However, if a non-standard size is
necessary, set a `font-size` that is whole multiple of 16 or 20 with the relevant size class.
You can instead use the class `@ns-icon` to make the icon inherit its size from surrounding text.

</div>

================================================================================

File: src\components\icon\icon.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import {
    type DefaultSVGIconProps,
    type IconName,
    type IconPaths,
    Icons,
    IconSize,
    SVGIconContainer,
    type SVGIconProps,
} from "@blueprintjs/icons";

import {
    Classes,
    DISPLAYNAME_PREFIX,
    type IntentProps,
    type MaybeElement,
    type Props,
    removeNonHTMLProps,
} from "../../common";

// re-export for convenience, since some users won't be importing from or have a direct dependency on the icons package
export { type IconName, IconSize };

export interface IconOwnProps {
    /**
     * Whether the component should automatically load icon contents using an async import.
     *
     * @default true
     */
    autoLoad?: boolean;

    /**
     * Name of a Blueprint UI icon, or an icon element, to render. This prop is
     * required because it determines the content of the component, but it can
     * be explicitly set to falsy values to render nothing.
     *
     * - If `null` or `undefined` or `false`, this component will render nothing.
     * - If given an `IconName` (a string literal union of all icon names), that
     *   icon will be rendered as an `<svg>` with `<path>` tags. Unknown strings
     *   will render a blank icon to occupy space.
     * - If given a `React.JSX.Element`, that element will be rendered and _all other
     *   props on this component are ignored._ This type is supported to
     *   simplify icon support in other Blueprint components. As a consumer, you
     *   should avoid using `<Icon icon={<Element />}` directly; simply render
     *   `<Element />` instead.
     */
    icon: IconName | MaybeElement;

    /**
     * Alias for `size` prop. Kept around for backwards-compatibility with Blueprint v4.x,
     * will be removed in v6.0.
     *
     * @deprecated use `size` prop instead
     */
    iconSize?: number;

    /** Props to apply to the `SVG` element */
    svgProps?: React.HTMLAttributes<SVGElement>;
}

// N.B. the following inteface is defined as a type alias instead of an interface due to a TypeScript limitation
// where interfaces cannot extend conditionally-defined union types.
/**
 * Generic interface for the `<Icon>` component which may be parameterized by its root element type.
 *
 * @see https://blueprintjs.com/docs/#core/components/icon.dom-attributes
 */
export type IconProps<T extends Element = Element> = IntentProps & Props & SVGIconProps<T> & IconOwnProps;

/**
 * The default `<Icon>` props interface, equivalent to `IconProps` with its default type parameter.
 * This is primarly exported for documentation purposes; users should reference `IconProps<T>` instead.
 */
export interface DefaultIconProps extends IntentProps, Props, DefaultSVGIconProps, IconOwnProps {
    // empty interface for documentation purposes (documentalist handles this better than the IconProps<T> type alias)
}

/**
 * Generic icon component type. This is essentially a type hack required to make forwardRef work with generic
 * components. Note that this slows down TypeScript compilation, but it better than the alternative of globally
 * augmenting "@types/react".
 *
 * @see https://stackoverflow.com/a/73795494/7406866
 */
export interface IconComponent extends React.FC<IconProps<Element>> {
    <T extends Element = Element>(props: IconProps<T>): React.ReactElement | null;
}

/**
 * Icon component.
 *
 * @see https://blueprintjs.com/docs/#core/components/icon
 */
// eslint-disable-next-line prefer-arrow-callback
export const Icon: IconComponent = React.forwardRef(function <T extends Element>(
    props: IconProps<T>,
    ref: React.Ref<T>,
) {
    const { autoLoad, className, color, icon, intent, tagName, svgProps, title, htmlTitle, ...htmlProps } = props;

    // Preserve Blueprint v4.x behavior: iconSize prop takes predecence, then size prop, then fall back to default value
    // eslint-disable-next-line deprecation/deprecation
    const size = props.iconSize ?? props.size ?? IconSize.STANDARD;

    const [iconPaths, setIconPaths] = React.useState<IconPaths | undefined>(() =>
        typeof icon === "string" ? Icons.getPaths(icon, size) : undefined,
    );

    React.useEffect(() => {
        let shouldCancelIconLoading = false;
        if (typeof icon === "string") {
            // The icon may have been loaded already, in which case we can simply grab it.
            // N.B. when `autoLoad={true}`, we can't rely on simply calling Icons.load() here to re-load an icon module
            // which has already been loaded & cached, since it may have been loaded with special loading options which
            // this component knows nothing about.
            const loadedIconPaths = Icons.getPaths(icon, size);

            if (loadedIconPaths !== undefined) {
                setIconPaths(loadedIconPaths);
            } else if (autoLoad) {
                Icons.load(icon, size)
                    .then(() => {
                        // if this effect expired by the time icon loaded, then don't set state
                        if (!shouldCancelIconLoading) {
                            setIconPaths(Icons.getPaths(icon, size));
                        }
                    })
                    .catch(reason => {
                        console.error(`[Blueprint] Icon '${icon}' (${size}px) could not be loaded.`, reason);
                    });
            } else {
                console.error(
                    `[Blueprint] Icon '${icon}' (${size}px) is not loaded yet and autoLoad={false}, did you call Icons.load('${icon}', ${size})?`,
                );
            }
        }
        return () => {
            shouldCancelIconLoading = true;
        };
    }, [autoLoad, icon, size]);

    if (icon == null || typeof icon === "boolean") {
        return null;
    } else if (typeof icon !== "string") {
        return icon;
    }

    if (iconPaths == null) {
        // fall back to icon font if unloaded or unable to load SVG implementation
        const sizeClass =
            size === IconSize.STANDARD
                ? Classes.ICON_STANDARD
                : size === IconSize.LARGE
                  ? Classes.ICON_LARGE
                  : undefined;
        return React.createElement(tagName!, {
            "aria-hidden": title ? undefined : true,
            ...removeNonHTMLProps(htmlProps),
            className: classNames(
                Classes.ICON,
                sizeClass,
                Classes.iconClass(icon),
                Classes.intentClass(intent),
                className,
            ),
            "data-icon": icon,
            ref,
            title: htmlTitle,
        });
    } else {
        const pathElements = iconPaths.map((d, i) => <path d={d} key={i} fillRule="evenodd" />);
        // HACKHACK: there is no good way to narrow the type of SVGIconContainerProps here because of the use
        // of a conditional type within the type union that defines that interface. So we cast to <any>.
        // see https://github.com/microsoft/TypeScript/issues/24929, https://github.com/microsoft/TypeScript/issues/33014
        return (
            <SVGIconContainer<any>
                children={pathElements}
                // don't forward `Classes.ICON` or `Classes.iconClass(icon)` here, since the container will render those classes
                className={classNames(Classes.intentClass(intent), className)}
                color={color}
                htmlTitle={htmlTitle}
                iconName={icon}
                ref={ref}
                size={size}
                svgProps={svgProps}
                tagName={tagName}
                title={title}
                {...removeNonHTMLProps(htmlProps)}
            />
        );
    }
});
Icon.defaultProps = {
    autoLoad: true,
    tagName: "span",
};
Icon.displayName = `${DISPLAYNAME_PREFIX}.Icon`;

================================================================================

File: src\components\icon\_icon-mixins.scss
--------------------------------------------------------------------------------
// Copyright 2021 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "@blueprintjs/colors/lib/scss/colors";

@mixin pt-icon-font-smoothing() {
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
}

@mixin pt-icon-sized(
  $font-size: $pt-icon-size-standard,
  $font-family-size: strip-unit($font-size)
) {
  font-family: "blueprint-icons-#{$font-family-size}", sans-serif;
  font-size: $font-size;
  font-style: normal;
  font-variant: normal;
  font-weight: 400;
  height: $font-size;
  line-height: 1;
  // We explicitly add dimensions here so that icon elements have proper sizing before their icon paths are loaded;
  // this is useful (for example) to ensure that OverflowList takes proper measurements when partitioning on mount.
  width: $font-size;
}

@mixin pt-icon-colors() {
  color: $pt-icon-color;

  &:hover {
    color: $pt-icon-color-hover;
  }

  .#{$ns}-dark & {
    color: $pt-dark-icon-color;

    &:hover {
      color: $pt-dark-icon-color-hover;
    }
  }
}

@mixin pt-icon(
  $font-size: $pt-icon-size-standard,
  $font-family-size: strip-unit($font-size)
) {
  @include pt-icon-sized($font-size, $font-family-size);
  @include pt-icon-font-smoothing();
}

================================================================================

File: src\components\icon\_icon.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "@blueprintjs/icons/lib/scss/variables";
@import "../../common/variables";
@import "../../common/variables-extended";
@import "icon-mixins";

// the icon class which will contain an SVG icon
.#{$ns}-icon {
  // ensure icons sit inline with text & isolate svg from surrounding elements
  // (vertical alignment in flow is usually off due to svg - not an issue with flex.)
  display: inline-block;
  // respect dimensions exactly
  flex: 0 0 auto;
  // sit nicely with inline text
  vertical-align: text-bottom;

  &:not(:empty)::before {
    // clear font icon when there's an <svg> image
    /* stylelint-disable */
    content: "" !important; // fallback for IE11
    content: unset !important;
    /* stylelint-enable */
  }

  // TOOD: move to SVGIconContainer styles in @blueprintjs/icons in v6.0
  > svg {
    // prevent extra vertical whitespace
    display: block;

    // inherit text color unless explicit fill is set
    &:not([fill]) {
      fill: currentcolor;
    }
  }

  // muted icon style used by NonIdealState
  &.#{$ns}-icon-muted svg {
    fill-opacity: 15%;
    // need to show overflow for some strokes on paths that reach the edge of the icon bounding box
    overflow: visible;

    path {
      stroke: $gray3;
      stroke-opacity: 50%;
      stroke-width: 0.5px;
    }
  }

  .#{$ns}-dark & {
    .#{$ns}-icon-muted svg {
      fill-opacity: 20%;
    }
  }
}

// intent colors for both SVG and font icons are set in _typography-colors.scss

//
// Icon font styles
//
// TOOD: move to @blueprintjs/icons in v6.0
//

span.#{$ns}-icon-standard {
  @include pt-icon($pt-icon-size-standard);
  display: inline-block;
}

span.#{$ns}-icon-large {
  @include pt-icon($pt-icon-size-large);
  display: inline-block;
}

// only apply icon font styles when <svg> image is not present
span.#{$ns}-icon:empty {
  font-family: $blueprint-icons-20-font;
  font-size: inherit;
  font-style: normal;
  font-weight: 400;
  line-height: 1;

  &::before {
    @include pt-icon-font-smoothing();
  }

  &.#{$ns}-icon-standard {
    font-size: $pt-icon-size-standard;
  }

  &.#{$ns}-icon-large {
    font-size: $pt-icon-size-large;
  }
}

@each $name, $codepoint in $blueprint-icon-codepoints {
  .#{$ns}-icon-#{$name}::before {
    content: $codepoint;
  }
}

================================================================================

File: src\components\menu\menu.md
--------------------------------------------------------------------------------
@# Menu

__Menu__ displays a list of interactive menu items.

@reactExample MenuExample

@## Usage

Blueprint's __Menu__ API includes three React components:

* [__Menu__](#core/components/menu)
* [__MenuItem__](#core/components/menu.menu-item)
* [__MenuDivider__](#core/components/menu.menu-divider)

```tsx
<Menu>
    <MenuItem icon="new-text-box" onClick={handleClick} text="New text box" />
    <MenuItem icon="new-object" onClick={handleClick} text="New object" />
    <MenuItem icon="new-link" onClick={handleClick} text="New link" />
    <MenuDivider />
    <MenuItem text="Settings..." icon="cog" intent="primary">
        <MenuItem icon="tick" text="Save on edit" />
        <MenuItem icon="blank" text="Compile on edit" />
    </MenuItem>
</Menu>
```

@## Props interface

`<Menu>` renders a `<ul>` container element for menu items and dividers.

@interface MenuProps

@## Menu item

__MenuItem__ is a single interactive item in a [__Menu__](#core/components/menu).

This component renders an `<li>` containing an `<a>`. You can make the __MenuItem__ interactive by defining the
`href`, `target`, and `onClick` props as necessary.

Create submenus by nesting __MenuItem__ elements inside each other as `children`. Remember to use the required `text`
prop to define __MenuItem__ content.

@reactExample MenuItemExample

@interface MenuItemProps

@## Menu divider

__MenuDivider__ is a decorative component used to group sets of items into sections which may optionally have a title.

@interface MenuDividerProps

@## Dropdowns

__Menu__ only renders a static list container element. To make an interactive dropdown menu, you may leverage
[__Popover__](#core/components/popover) and specify a __Menu__ as the `content` property:

```tsx
<Popover content={<Menu>...</Menu>} placement="bottom">
    <Button alignText="left" icon="applications" rightIcon="caret-down" text="Open with..." />
</Popover>
```

Some tips for designing dropdown menus:

* __Appearance__: it's often useful to style the target Button with `fill={true}`, `alignText="left"`, and
  `rightIcon="caret-down"`. This makes it appear more like an [HTML `<select>`](#core/components/html-select) dropdown.

* __Interactions__: by default, the popover is automatically dismissed when the user clicks a menu
  item ([Popover docs](#core/components/popover.closing-on-click) have more details). If you want to opt out of this
  behavior, set `shouldDismissPopover={false}` on a __MenuItem__. For example, clicking the "Table" item in this
  dropdown menu will not dismiss the `Popover`:

@reactExample DropdownMenuExample

@## Submenus

To add a submenu to a __Menu__, you may nest one or more __MenuItem__ elements within another __MenuItem__.
The submenu opens to the right of its parent by default, but will adjust and flip to the left if there is not enough
room to the right.

```tsx
<Menu>
    <MenuItem text="Submenu">
        <MenuItem text="Child one" />
        <MenuItem text="Child two" />
        <MenuItem text="Child three" />
    </MenuItem>
</Menu>
```

@## CSS API

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use [`<Menu>` and `<MenuItem>`](#core/components/menu)

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

</div>

Menus can be constructed manually using the following HTML markup and `@ns-menu-*` classes
(available in JS/TS as `Classes.MENU_*`):

* Begin with a `ul.@ns-menu`. Each `li` child denotes a single entry in the menu.

* Put a `.@ns-menu-item` element inside an `li` to create a clickable entry. Use either `<button>` or `<a>` tags for
  menu items to denote interactivity.

* Add icons to menu items the same way you would to buttons: add the appropriate `@ns-icon-<name>` class\*.

* Make menu items active with the class `@ns-active` (along with `@ns-intent-*` if suitable).

* Make menu items non-interactive with the class `@ns-disabled`.

* Wrap menu item text in a `<span>` element for proper alignment. (Note that React automatically does this.)

* Add a right-aligned label to a menu item by adding a `span.@ns-menu-item-label` inside the
  `.@ns-menu-item`, after the content. Add an icon to the label by adding icon classes to the label
  element (`@ns-icon-standard` size is recommended).

* Add a divider between items with `li.@ns-menu-divider`.

* If you want the popover to close when the user clicks a menu item, add the class `@ns-popover-dismiss` to any
  relevant menu items.

<small>\* You do not need to add a `@ns-icon-<sizing>` class to menu items—icon sizing is
defined as part of `.@ns-menu-item`.</small>

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">

Note that the following examples are `display: inline-block`; you may need to adjust
menu width in your own usage.

</div>

@css menu

@### Section headers

Add an `li.@ns-menu-header`. Wrap the text in an `<h6>` tag for proper typography and borders.

@css menu-header

================================================================================

File: src\components\menu\menu.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes } from "../../common";
import { DISPLAYNAME_PREFIX, type Props } from "../../common/props";

export interface MenuProps extends Props, React.HTMLAttributes<HTMLUListElement> {
    /** Menu items. */
    children?: React.ReactNode;

    /** Whether the menu items in this menu should use a large appearance. */
    large?: boolean;

    /** Whether the menu items in this menu should use a small appearance. */
    small?: boolean;

    /** Ref handler that receives the HTML `<ul>` element backing this component. */
    ulRef?: React.Ref<HTMLUListElement>;
}

/**
 * Menu component.
 *
 * @see https://blueprintjs.com/docs/#core/components/menu
 */
export class Menu extends AbstractPureComponent<MenuProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.Menu`;

    public render() {
        const { className, children, large, small, ulRef, ...htmlProps } = this.props;
        const classes = classNames(className, Classes.MENU, {
            [Classes.LARGE]: large,
            [Classes.SMALL]: small,
        });
        return (
            <ul role="menu" {...htmlProps} className={classes} ref={ulRef}>
                {children}
            </ul>
        );
    }
}

================================================================================

File: src\components\menu\menuDivider.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Classes, DISPLAYNAME_PREFIX, type Props } from "../../common";
import { H6 } from "../html/html";

export interface MenuDividerProps extends Props {
    /** This component does not support children. */
    children?: never;

    /** Optional header title. */
    title?: React.ReactNode;

    /** Optional `id` prop for the header title. */
    titleId?: string;
}

/**
 * Menu divider component.
 *
 * @see https://blueprintjs.com/docs/#core/components/menu.menu-divider
 */
export class MenuDivider extends React.Component<MenuDividerProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.MenuDivider`;

    public render() {
        const { className, title, titleId } = this.props;
        if (title == null) {
            // simple divider
            return <li className={classNames(Classes.MENU_DIVIDER, className)} role="separator" />;
        } else {
            // section header with title
            return (
                <li className={classNames(Classes.MENU_HEADER, className)} role="separator">
                    <H6 id={titleId}>{title}</H6>
                </li>
            );
        }
    }
}

================================================================================

File: src\components\menu\menuItem.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2022 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { CaretRight, SmallTick } from "@blueprintjs/icons";

import { Classes } from "../../common";
import { type ActionProps, DISPLAYNAME_PREFIX, removeNonHTMLProps } from "../../common/props";
import { clickElementOnKeyPress } from "../../common/utils";
import { Icon } from "../icon/icon";
import { Popover, type PopoverProps } from "../popover/popover";
import { Text } from "../text/text";

import { Menu, type MenuProps } from "./menu";

/**
 * Note that the HTML attributes supported by this component are spread to the nested `<a>` element, while the
 * `ref` is attached to the root `<li>` element. This is an unfortunate quirk in the API which we keep around
 * for backwards-compatibility.
 */
export interface MenuItemProps
    extends ActionProps<HTMLAnchorElement>,
        React.AnchorHTMLAttributes<HTMLAnchorElement>,
        React.RefAttributes<HTMLLIElement> {
    /** Item text, required for usability. */
    text: React.ReactNode;

    /**
     * Whether this item should appear _active_, often useful to
     * indicate keyboard focus. Note that this is distinct from _selected_
     * appearance, which has its own prop.
     */
    active?: boolean;

    /**
     * Children of this component will be rendered in a _submenu_
     * that appears in a popover when hovering or clicking on this item.
     *
     * Use `text` prop for the content of the menu item itself.
     */
    children?: React.ReactNode;

    /**
     * Whether this menu item is non-interactive. Enabling this prop will ignore `href`, `tabIndex`,
     * and mouse event handlers (in particular click, down, enter, leave).
     */
    disabled?: boolean;

    /**
     * Right-aligned label text content, useful for displaying hotkeys.
     *
     * This prop actually supports JSX elements, but TypeScript will throw an error because
     * `HTMLAttributes` only allows strings. Use `labelElement` to supply a JSX element in TypeScript.
     */
    label?: string;

    /**
     * A space-delimited list of class names to pass along to the right-aligned label wrapper element.
     */
    labelClassName?: string;

    /**
     * Right-aligned label content, useful for displaying hotkeys.
     */
    labelElement?: React.ReactNode;

    /**
     * Changes the ARIA `role` property structure of this MenuItem to accomodate for various
     * different `role`s of the parent Menu `ul` element.
     *
     * If `menuitem`, role structure becomes:
     *
     * `<li role="none"><a role="menuitem" /></li>`
     *
     * which is proper role structure for a `<ul role="menu"` parent (this is the default `role` of a `Menu`).
     *
     * If `listoption`, role structure becomes:
     *
     * `<li role="option"><a role={undefined} /></li>`
     *
     * which is proper role structure for a `<ul role="listbox"` parent, or a `<select>` parent.
     *
     * If `listitem`, role structure becomes:
     *
     * `<li role={undefined}><a role={undefined} /></li>`
     *
     * which can be used if this item is within a basic `<ul/>` (or `role="list"`) parent.
     *
     * If `none`, role structure becomes:
     *
     * `<li role="none"><a role={undefined} /></li>`
     *
     * which can be used if wrapping this item in a custom `<li>` parent.
     *
     * @default "menuitem"
     */
    roleStructure?: "menuitem" | "listoption" | "listitem" | "none";

    /**
     * Whether the text should be allowed to wrap to multiple lines.
     * If `false`, text will be truncated with an ellipsis when it reaches `max-width`.
     *
     * @default false
     */
    multiline?: boolean;

    /**
     * Props to spread to the submenu popover. Note that `content` and `minimal` cannot be
     * changed and `usePortal` defaults to `false` so all submenus will live in
     * the same container.
     */
    popoverProps?: Partial<Omit<PopoverProps, "content" | "minimal">>;

    /**
     * Whether this item should appear selected - `roleStructure` must be `"listoption"` for this to be
     * applied. Defining this will set the `aria-selected` attribute and apply a small tick icon if `true`,
     * and empty space for a small tick icon if `false` or `undefined`.
     *
     * @default undefined
     */
    selected?: boolean;

    /**
     * Whether an enabled item without a submenu should automatically close its parent popover when clicked.
     *
     * @default true
     */
    shouldDismissPopover?: boolean;

    /**
     * Props to spread to the child `Menu` component if this item has a submenu.
     */
    submenuProps?: Partial<MenuProps>;

    /**
     * Name of the HTML tag that wraps the MenuItem.
     *
     * @default "a"
     */
    tagName?: keyof React.JSX.IntrinsicElements;

    /**
     * A space-delimited list of class names to pass along to the text wrapper element.
     */
    textClassName?: string;

    /**
     * HTML title to be passed to the <Text> component
     */
    htmlTitle?: string;
}

/**
 * Menu item component.
 *
 * @see https://blueprintjs.com/docs/#core/components/menu.menu-item
 */
export const MenuItem: React.FC<MenuItemProps> = React.forwardRef<HTMLLIElement, MenuItemProps>((props, ref) => {
    const {
        active,
        className,
        children,
        disabled,
        icon,
        intent,
        labelClassName,
        labelElement,
        multiline,
        popoverProps,
        roleStructure = "menuitem",
        selected,
        shouldDismissPopover,
        submenuProps,
        text,
        textClassName,
        tagName = "a",
        htmlTitle,
        ...htmlProps
    } = props;

    const [liRole, targetRole, ariaSelected] =
        roleStructure === "listoption" // "listoption": parent has listbox role, or is a <select>
            ? [
                  "option",
                  undefined, // target should have no role
                  Boolean(selected), // aria-selected prop
              ]
            : roleStructure === "menuitem" // "menuitem": parent has menu role
              ? [
                    "none",
                    "menuitem",
                    undefined, // don't set aria-selected prop
                ]
              : roleStructure === "none" // "none": allows wrapping MenuItem in custom <li>
                ? [
                      "none",
                      undefined, // target should have no role
                      undefined, // don't set aria-selected prop
                  ]
                : // roleStructure === "listitem"
                  [
                      undefined, // needs no role prop, li is listitem by default
                      undefined,
                      undefined, // don't set aria-selected prop
                  ];

    const isSelectable = roleStructure === "listoption";
    const isSelected = isSelectable && selected;
    const hasIcon = icon != null;
    const hasSubmenu = children != null;

    const intentClass = Classes.intentClass(intent);
    const anchorClasses = classNames(
        Classes.MENU_ITEM,
        intentClass,
        {
            [Classes.ACTIVE]: active,
            [Classes.DISABLED]: disabled,
            // prevent popover from closing when clicking on submenu trigger or disabled item
            [Classes.POPOVER_DISMISS]: shouldDismissPopover && !disabled && !hasSubmenu,
            [Classes.MENU_ITEM_IS_SELECTABLE]: isSelectable,
            [Classes.SELECTED]: isSelected,
        },
        className,
    );

    const maybeLabel =
        props.label == null && labelElement == null ? null : (
            <span className={classNames(Classes.MENU_ITEM_LABEL, labelClassName)}>
                {props.label}
                {labelElement}
            </span>
        );

    const target = React.createElement(
        tagName,
        {
            // for menuitems, onClick when enter key pressed doesn't take effect like it does for a button-- fix this
            onKeyDown: clickElementOnKeyPress(["Enter", " "]),
            // if hasSubmenu, must apply correct role and tabIndex to the outer popover target <span> instead of this target element
            role: hasSubmenu ? "none" : targetRole,
            tabIndex: hasSubmenu ? -1 : 0,
            ...removeNonHTMLProps(htmlProps),
            ...(disabled ? DISABLED_PROPS : {}),
            className: anchorClasses,
        },
        isSelected ? <SmallTick className={Classes.MENU_ITEM_SELECTED_ICON} /> : undefined,
        hasIcon ? (
            // wrap icon in a <span> in case `icon` is a custom element rather than a built-in icon identifier,
            // so that we always render this class
            <span className={Classes.MENU_ITEM_ICON}>
                <Icon icon={icon} aria-hidden={true} tabIndex={-1} />
            </span>
        ) : undefined,
        <Text className={classNames(Classes.FILL, textClassName)} ellipsize={!multiline} title={htmlTitle}>
            {text}
        </Text>,
        maybeLabel,
        hasSubmenu ? <CaretRight className={Classes.MENU_SUBMENU_ICON} title="Open sub menu" /> : undefined,
    );

    const liClasses = classNames({ [Classes.MENU_SUBMENU]: hasSubmenu });
    return (
        <li className={liClasses} ref={ref} role={liRole} aria-selected={ariaSelected}>
            {children == null ? (
                target
            ) : (
                <Popover
                    autoFocus={false}
                    captureDismiss={false}
                    disabled={disabled}
                    enforceFocus={false}
                    hoverCloseDelay={0}
                    interactionKind="hover"
                    modifiers={SUBMENU_POPOVER_MODIFIERS}
                    targetProps={{ role: targetRole, tabIndex: 0 }}
                    placement="right-start"
                    usePortal={false}
                    {...popoverProps}
                    content={<Menu {...submenuProps}>{children}</Menu>}
                    minimal={true}
                    popoverClassName={classNames(Classes.MENU_SUBMENU, popoverProps?.popoverClassName)}
                >
                    {target}
                </Popover>
            )}
        </li>
    );
});
MenuItem.defaultProps = {
    active: false,
    disabled: false,
    multiline: false,
    popoverProps: {},
    selected: undefined,
    shouldDismissPopover: true,
    text: "",
};
MenuItem.displayName = `${DISPLAYNAME_PREFIX}.MenuItem`;

const SUBMENU_POPOVER_MODIFIERS: PopoverProps["modifiers"] = {
    // 20px padding - scrollbar width + a bit
    flip: { options: { rootBoundary: "viewport", padding: 20 }, enabled: true },
    // shift popover up 5px so MenuItems align
    offset: { options: { offset: [-5, 0] }, enabled: true },
    preventOverflow: { options: { rootBoundary: "viewport", padding: 20 }, enabled: true },
};

// props to ignore when disabled
const DISABLED_PROPS: React.AnchorHTMLAttributes<HTMLAnchorElement> = {
    "aria-disabled": true,
    href: undefined,
    onClick: undefined,
    onMouseDown: undefined,
    onMouseEnter: undefined,
    onMouseLeave: undefined,
    tabIndex: -1,
};

================================================================================

File: src\components\menu\_common.scss
--------------------------------------------------------------------------------
// Copyright 2016 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/mixins";
@import "../../common/variables";
@import "../../common/variables-extended";

$menu-item-border-radius: $pt-border-radius !default;

// Set line-height of menu items to be a multiple of the font size. This is
// needed because if the line-height does not extend far enough past the font's
// baseline, clipping will occur when the .#{$ns}-text-overflow-ellipsis class is
// applied to it (#2177). Also, line-height should be an even value, or content
// will be misaligned by one pixel (Chrome quirk).
$menu-item-line-height-factor: 1.4;
$menu-item-line-height: round($pt-font-size * $menu-item-line-height-factor);
$menu-item-line-height-large: round($pt-font-size-large * $menu-item-line-height-factor);

$menu-min-width: $pt-grid-size * 18 !default;
$menu-item-padding: ($pt-button-height - $pt-icon-size-standard) * 0.5 !default;
$menu-item-padding-large: ($pt-button-height-large - $pt-icon-size-large) * 0.5 !default;
$menu-item-padding-vertical: ($pt-button-height - $menu-item-line-height) * 0.5 !default;
$menu-item-padding-vertical-large:
  ($pt-button-height-large - $menu-item-line-height-large) * 0.5 !default;
$menu-item-padding-small: ($pt-button-height-small - $pt-icon-size-standard) * 0.5 !default;
$menu-item-padding-vertical-small:
  ($pt-button-height-small - $menu-item-line-height) * 0.5 !default;
$menu-item-selected-icon-spacing: 2px;
$menu-item-indent: $pt-icon-size-standard + $menu-item-selected-icon-spacing * 2;

$menu-background-color: $white !default;
$dark-menu-background-color: $dark-gray3 !default;

$menu-item-color-hover: rgba($gray3, 0.15) !default;
$menu-item-color-active: rgba($gray3, 0.3) !default;

$menu-item-intent-colors: (
  "primary": (/* bg */ $blue3, /* fg */ $blue2, /* fg active */ $blue1),
  "success": (/* bg */ $green3, /* fg */ $green2, /* fg active */ $green1),
  "warning": (/* bg */ $orange3, /* fg */ $orange2, /* fg active */ $orange1),
  "danger": (/* bg */ $red3, /* fg */ $red2, /* fg active */ $red1),
) !default;

$dark-menu-item-intent-colors: (
  "primary": (/* bg */ $blue3, /* fg */ $blue5, /* fg active */ $blue6),
  "success": (/* bg */ $green3, /* fg */ $green5, /* fg active */ $green6),
  "warning": (/* bg */ $orange3, /* fg */ $orange5, /* fg active */ $orange6),
  "danger": (/* bg */ $red3, /* fg */ $red5, /* fg active */ $red6),
) !default;

@mixin menu-item() {
  @include pt-flex-container(row, $menu-item-padding);
  align-items: flex-start;
  border-radius: $menu-item-border-radius;
  color: inherit;
  line-height: $menu-item-line-height;
  padding: $menu-item-padding-vertical $menu-item-padding;
  text-decoration: none;
  user-select: none;

  > .#{$ns}-fill {
    word-break: break-word;
  }

  .#{$ns}-menu-item-icon {
    display: flex;
    flex-direction: column;
    height: $menu-item-line-height;
    justify-content: center;
  }

  .#{$ns}-menu-item-label {
    color: $pt-text-color-muted;
  }

  &::before,
  .#{$ns}-menu-item-icon,
  .#{$ns}-menu-item-selected-icon,
  .#{$ns}-submenu-icon {
    color: $pt-icon-color;
  }

  &::before,
  .#{$ns}-submenu-icon {
    margin-top: ($menu-item-line-height - $pt-icon-size-standard) * 0.5;
  }

  &:hover {
    @include menu-item-hover();
  }

  // N.B. mouse interaction :active appearance is different from the .#{$ns}-active modifier class.
  // The latter is often used to indicate keyboard navigation, and it's helpful to distinguish between keyboard
  // and mouse interactions.
  &:active {
    background-color: $menu-item-color-active;

    .#{$ns}-menu-item-label {
      color: $pt-text-color;
    }
  }

  &.#{$ns}-active {
    @include menu-item-active(false);
  }

  &.#{$ns}-menu-item-is-selectable {
    padding-left: $menu-item-indent;

    &.#{$ns}-selected {
      padding-left: 0;
    }

    .#{$ns}-menu-item-selected-icon {
      align-self: center;
      margin: 0 $menu-item-selected-icon-spacing;
    }
  }

  // disabled class needs to always overrides other styles
  /* stylelint-disable declaration-no-important */
  &.#{$ns}-disabled {
    background-color: inherit !important;
    color: $pt-text-color-disabled !important;
    cursor: not-allowed !important;
    // override global a:focus styles
    outline: none !important;

    &::before,
    .#{$ns}-menu-item-icon,
    .#{$ns}-submenu-icon {
      color: $pt-icon-color-disabled !important;
    }

    .#{$ns}-menu-item-label {
      color: $pt-text-color-disabled !important;
    }
  }
  /* stylelint-enable declaration-no-important */
}

@mixin dark-menu-item() {
  color: inherit;

  .#{$ns}-menu-item-label {
    color: $pt-dark-text-color-muted;
  }

  &::before,
  .#{$ns}-menu-item-icon,
  .#{$ns}-menu-item-selected-icon,
  .#{$ns}-submenu-icon {
    color: $pt-dark-icon-color;
  }

  &:hover {
    @include dark-menu-item-hover();
  }

  // N.B. mouse interaction :active appearance is different from the .#{$ns}-active modifier class.
  &:active {
    // we can use the same color as light theme due to transparency
    background-color: $menu-item-color-active;

    .#{$ns}-menu-item-label {
      color: $pt-dark-text-color;
    }
  }

  &.#{$ns}-active {
    @include menu-item-active(true);
  }

  // pt-disable always overrides over styles
  /* stylelint-disable declaration-no-important */
  &.#{$ns}-disabled {
    color: $pt-dark-text-color-disabled !important;

    &::before,
    .#{$ns}-menu-item-icon,
    .#{$ns}-submenu-icon {
      color: $pt-dark-icon-color-disabled !important;
    }

    .#{$ns}-menu-item-label {
      color: $pt-dark-text-color-disabled !important;
    }
  }
  /* stylelint-enable declaration-no-important */
}

@mixin menu-item-hover() {
  background-color: $menu-item-color-hover;
  color: inherit;
  cursor: pointer;
  text-decoration: none;
}

@mixin dark-menu-item-hover() {
  color: inherit;

  // need to override typography styles here
  .#{$ns}-menu-item-icon,
  .#{$ns}-submenu-icon {
    color: $pt-dark-icon-color;
  }
}

@mixin menu-item-active($is-dark) {
  $intent-colors: $menu-item-intent-colors;
  $background-alpha: 0.1;

  @if $is-dark {
    $intent-colors: $dark-menu-item-intent-colors;
    $background-alpha: 0.2;
  } @else {
    .#{$ns}-menu-item-label {
      color: inherit;
    }
  }

  background-color: rgba(nth(map-get($intent-colors, "primary"), 1), $background-alpha);
  color: nth(map-get($intent-colors, "primary"), 2);

  &::before,
  .#{$ns}-menu-item-icon,
  .#{$ns}-menu-item-selected-icon,
  .#{$ns}-submenu-icon {
    color: nth(map-get($intent-colors, "primary"), 2);
  }

  @each $intent in ("success", "warning", "danger") {
    &.#{$ns}-intent-#{$intent} {
      background-color: rgba(nth(map-get($intent-colors, $intent), 1), $background-alpha);
      color: nth(map-get($intent-colors, $intent), 2);

      &::before,
      .#{$ns}-menu-item-icon,
      .#{$ns}-submenu-icon {
        color: inherit;
      }
    }
  }

  @media (forced-colors: active) and (prefers-color-scheme: dark) {
    // Windows High Contrast dark theme
    background-color: $pt-high-contrast-mode-active-background-color;
  }
}

@mixin menu-item-intent($intent, $is-dark, $bg-color, $fg-color, $fg-color-active) {
  &.#{$ns}-intent-#{$intent} {
    color: $fg-color;

    &::before,
    .#{$ns}-menu-item-icon,
    .#{$ns}-menu-item-selected-icon,
    .#{$ns}-submenu-icon,
    .#{$ns}-menu-item-label {
      color: inherit;
    }

    &:hover {
      @if $is-dark {
        background-color: rgba($bg-color, 0.2);
      } @else {
        background-color: rgba($bg-color, 0.1);
      }
    }

    &:active,
    &.#{$ns}-active {
      @if $is-dark {
        background-color: rgba($bg-color, 0.3);
      } @else {
        background-color: rgba($bg-color, 0.2);
      }
      color: $fg-color-active;
    }
  }
}

@mixin menu-item-large() {
  font-size: $pt-font-size-large;
  line-height: $menu-item-line-height-large;
  padding-bottom: $menu-item-padding-vertical-large;
  padding-top: $menu-item-padding-vertical-large;

  .#{$ns}-menu-item-icon {
    height: $menu-item-line-height-large;
  }

  &::before,
  .#{$ns}-submenu-icon {
    // SVG icons remain standard size when menu is large
    margin-top: ($menu-item-line-height-large - $pt-icon-size-standard) * 0.5;
  }
}

@mixin menu-item-small() {
  padding-bottom: $menu-item-padding-vertical-small;
  padding-top: $menu-item-padding-vertical-small;
}

@mixin menu-divider() {
  border-top: 1px solid $pt-divider-black;
  display: block;
  // use negative margin to make dividers take up full menu width
  margin: $half-grid-size (-$half-grid-size);

  .#{$ns}-dark & {
    border-top-color: $pt-dark-divider-white;
  }
}

@mixin menu-header($heading-selector: null) {
  @include menu-divider();
  cursor: default;
  padding-left: $menu-item-padding - $half-grid-size;

  @if $heading-selector != null {
    &:first-of-type {
      border-top: none;
    }

    #{$heading-selector} {
      @include menu-heading();
    }

    &:first-of-type #{$heading-selector} {
      padding-top: 0;
    }
  }
}

@mixin menu-heading() {
  @include heading-typography();
  @include overflow-ellipsis();
  // a little extra space to avoid clipping descenders (because overflow hidden)
  line-height: $pt-icon-size-standard + 1px;
  margin: 0;
  padding: $pt-grid-size $menu-item-padding 0 (1px + $half-grid-size);
}

@mixin menu-header-large($heading-selector) {
  #{$heading-selector} {
    font-size: $pt-grid-size * 1.8;
    padding-bottom: $pt-grid-size * 0.5;
    padding-top: $pt-grid-size * 1.5;
  }

  &:first-of-type #{$heading-selector} {
    padding-top: 0;
  }
}

================================================================================

File: src\components\menu\_menu.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "@blueprintjs/icons/lib/scss/variables";
@import "../../common/mixins";

@import "./common";
@import "./submenu";

/*
Menus

Markup:
<ul class="#{$ns}-menu {{.modifier}} #{$ns}-elevation-1">
  <li>
    <a class="#{$ns}-menu-item #{$ns}-icon-people" tabindex="0">Share...</a>
  </li>
  <li>
    <a class="#{$ns}-menu-item #{$ns}-icon-circle-arrow-right" tabindex="0">Move...</a>
  </li>
  <li>
    <a class="#{$ns}-menu-item #{$ns}-icon-edit" tabindex="0">Rename</a>
  </li>
  <li class="#{$ns}-menu-divider"></li>
  <li>
    <a class="#{$ns}-menu-item #{$ns}-icon-trash #{$ns}-intent-danger" tabindex="0">Delete</a>
  </li>
</ul>

.#{$ns}-large - Large size
.#{$ns}-small - Small size

Styleguide menu
*/

.#{$ns}-menu {
  background: $menu-background-color;
  border-radius: $pt-border-radius;
  color: $pt-text-color;
  list-style: none;
  margin: 0;
  min-width: $menu-min-width;
  padding: $half-grid-size;
  text-align: left;
}

.#{$ns}-menu-divider {
  @include menu-divider();
}

.#{$ns}-menu-item {
  @include menu-item();

  @each $intent, $colors in $menu-item-intent-colors {
    @include menu-item-intent($intent, false, $colors...);
  }

  &::before {
    // support pt-icon-* classes directly on this element
    @include pt-icon();
    margin-right: $menu-item-padding;
  }

  .#{$ns}-large & {
    @include menu-item-large();

    &::before {
      @include pt-icon($pt-icon-size-large);
      margin-right: $menu-item-padding-large;
    }
  }

  .#{$ns}-small & {
    @include menu-item-small();
  }
}

button.#{$ns}-menu-item {
  background: none;
  border: none;
  text-align: left;
  width: 100%;
}

/*
Menu headers

Markup:
<ul class="#{$ns}-menu #{$ns}-elevation-1">
  <li class="#{$ns}-menu-header"><h6 class="#{$ns}-heading">Layouts</h6></li>
  <li><button type="button" class="#{$ns}-menu-item #{$ns}-icon-layout-auto">Auto</button></li>
  <li><button type="button" class="#{$ns}-menu-item #{$ns}-icon-layout-circle">Circle</button></li>
  <li><button type="button" class="#{$ns}-menu-item #{$ns}-icon-layout-grid">Grid</button></li>
  <li class="#{$ns}-menu-header"><h6 class="#{$ns}-heading">Views</h6></li>
  <li><button type="button" class="#{$ns}-menu-item #{$ns}-icon-history">History</button></li>
  <li><button type="button" class="#{$ns}-menu-item #{$ns}-icon-star">Favorites</button></li>
  <li><button type="button" class="#{$ns}-menu-item #{$ns}-icon-envelope">Messages</button></li>
</ul>

Styleguide menu-header
*/

.#{$ns}-menu-header {
  @include menu-header($heading-selector: "> h6");

  .#{$ns}-large & {
    @include menu-header-large($heading-selector: "> h6");
  }
}

// dark theme
.#{$ns}-dark {
  .#{$ns}-menu {
    background: $dark-menu-background-color;
    color: $pt-dark-text-color;
  }

  .#{$ns}-menu-item {
    @include dark-menu-item();

    @each $intent, $colors in $dark-menu-item-intent-colors {
      @include menu-item-intent($intent, true, $colors...);
    }
  }

  .#{$ns}-menu-divider,
  .#{$ns}-menu-header {
    border-color: $pt-dark-divider-white;
  }

  .#{$ns}-menu-header > h6 {
    color: $pt-dark-heading-color;
  }
}

// #402 support menu inside label
.#{$ns}-label .#{$ns}-menu {
  margin-top: $pt-grid-size * 0.5;
}

================================================================================

File: src\components\menu\_submenu.scss
--------------------------------------------------------------------------------
// Copyright 2016 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "@blueprintjs/icons/lib/scss/variables";
@import "./common";

.#{$ns}-submenu {
  > .#{$ns}-popover-wrapper {
    display: block;
  }

  .#{$ns}-popover-target {
    display: block;

    &.#{$ns}-popover-open > .#{$ns}-menu-item {
      // keep a trail of hovered items as submenus are opened
      /* stylelint-disable scss/at-extend-no-missing-placeholder */
      &:not([class*="#{$ns}-intent-"]) {
        @include menu-item-hover();
        .#{$ns}-dark & {
          @include dark-menu-item-hover();
        }
      }

      &[class*="#{$ns}-intent-"] {
        &,
        &:hover,
        &:active {
          @include menu-item-active(false);

          .#{$ns}-dark & {
            @include menu-item-active(true);
          }
        }
      }
      /* stylelint-enable scss/at-extend-no-missing-placeholder */
    }
  }

  &.#{$ns}-popover {
    box-shadow: none;
    // horizontal padding leaves some space from parent menu item, and extends mouse zone
    padding: 0 $half-grid-size;

    > .#{$ns}-popover-content {
      box-shadow: $pt-popover-box-shadow;
    }

    .#{$ns}-dark &,
    &.#{$ns}-dark {
      box-shadow: none;

      > .#{$ns}-popover-content {
        box-shadow: $pt-dark-popover-box-shadow;
      }
    }
  }
}

================================================================================

File: src\components\navbar\navbar.md
--------------------------------------------------------------------------------
@# Navbar

__Navbar__ presents useful navigation controls at the top of an application.

@reactExample NavbarExample

@## Usage

The __Navbar__ API includes four stateless React components:

*   __Navbar__
*   __NavbarGroup__ (aliased as `Navbar.Group`)
*   __NavbarHeading__ (aliased as `Navbar.Heading`)
*   __NavbarDivider__ (aliased as `Navbar.Divider`)

These components are simple containers for their children. Each of them supports the full range of HTML `<div>`
DOM attributes.

```tsx
<Navbar>
    <Navbar.Group align={Alignment.LEFT}>
        <Navbar.Heading>Blueprint</Navbar.Heading>
        <Navbar.Divider />
        <Button className="@ns-minimal" icon="home" text="Home" />
        <Button className="@ns-minimal" icon="document" text="Files" />
    </Navbar.Group>
</Navbar>
```

@### Fixed to viewport top

Enable the `fixedToTop` prop to attach a navbar to the top of the viewport using `position: fixed; top: 0;`. This is
so-called "sticky" behavior: the navbar stays at the top of the screen as the user scrolls through the document.

This modifier is not illustrated here because it breaks the document flow.

<div class="@ns-callout @ns-intent-danger @ns-icon-error @ns-callout-has-body-content">
    <h5 class="@ns-heading">Body padding required</h5>

The fixed navbar will lie on top of your other content unless you add padding to the top of the `<body>` element equal
to the height of the navbar. Use the `$pt-navbar-height` Sass variable.

</div>

@### Fixed width

If your application is inside a fixed-width container (instead of spanning the entire viewport), you can align the
navbar to match by wrap your navbar groups in an element with your desired `width` and `margin: 0 auto;` to horizontally
center it.

@css navbar-container

@## Props interface

@interface NavbarProps

@interface NavbarGroupProps

@interface NavbarHeadingProps

@interface NavbarDividerProps

@## CSS API

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use `<Navbar>`

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

</div>

Use the following classes to construct a navbar:

*   `nav.@ns-navbar` &ndash; The parent element. Use a `<nav>` element for accessibility.
*   `.@ns-navbar-group.@ns-align-(left|right)` &ndash; Left- or right-aligned group.
*   `.@ns-navbar-heading` &ndash; Larger text for your application title.
*   `.@ns-navbar-divider` &ndash; Thin vertical line that can be placed between groups of elements.

@css navbar

================================================================================

File: src\components\navbar\navbar.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes } from "../../common";
import { DISPLAYNAME_PREFIX, type HTMLDivProps, type Props } from "../../common/props";

import { NavbarDivider } from "./navbarDivider";
import { NavbarGroup } from "./navbarGroup";
import { NavbarHeading } from "./navbarHeading";

export interface NavbarProps extends Props, HTMLDivProps {
    children?: React.ReactNode;

    /**
     * Whether this navbar should be fixed to the top of the viewport (using CSS `position: fixed`).
     */
    fixedToTop?: boolean;
}

// this component is simple enough that tests would be purely tautological.
/* istanbul ignore next */
/**
 * Navbar component.
 *
 * @see https://blueprintjs.com/docs/#core/components/navbar
 */
export class Navbar extends AbstractPureComponent<NavbarProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.Navbar`;

    public static Divider = NavbarDivider;

    public static Group = NavbarGroup;

    public static Heading = NavbarHeading;

    public render() {
        const { children, className, fixedToTop, ...htmlProps } = this.props;
        const classes = classNames(Classes.NAVBAR, { [Classes.FIXED_TOP]: fixedToTop }, className);
        return (
            <div className={classes} {...htmlProps}>
                {children}
            </div>
        );
    }
}

================================================================================

File: src\components\navbar\navbarDivider.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes } from "../../common";
import { DISPLAYNAME_PREFIX, type HTMLDivProps, type Props } from "../../common/props";

// allow the empty interface so we can label it clearly in the docs
export interface NavbarDividerProps extends Props, HTMLDivProps {
    // Empty
}

// this component is simple enough that tests would be purely tautological.
/* istanbul ignore next */
export class NavbarDivider extends AbstractPureComponent<NavbarDividerProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.NavbarDivider`;

    public render() {
        const { className, ...htmlProps } = this.props;
        return <div className={classNames(Classes.NAVBAR_DIVIDER, className)} {...htmlProps} />;
    }
}

================================================================================

File: src\components\navbar\navbarGroup.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Alignment, Classes } from "../../common";
import { DISPLAYNAME_PREFIX, type HTMLDivProps, type Props } from "../../common/props";

export interface NavbarGroupProps extends Props, HTMLDivProps {
    /**
     * The side of the navbar on which the group should appear.
     * The `Alignment` enum provides constants for these values.
     *
     * @default Alignment.LEFT
     */
    align?: Alignment;

    children?: React.ReactNode;
}

// this component is simple enough that tests would be purely tautological.
/* istanbul ignore next */

export class NavbarGroup extends AbstractPureComponent<NavbarGroupProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.NavbarGroup`;

    public static defaultProps: NavbarGroupProps = {
        align: Alignment.LEFT,
    };

    public render() {
        const { align, children, className, ...htmlProps } = this.props;
        const classes = classNames(Classes.NAVBAR_GROUP, Classes.alignmentClass(align), className);
        return (
            <div className={classes} {...htmlProps}>
                {children}
            </div>
        );
    }
}

================================================================================

File: src\components\navbar\navbarHeading.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes } from "../../common";
import { DISPLAYNAME_PREFIX, type HTMLDivProps, type Props } from "../../common/props";

export interface NavbarHeadingProps extends Props, HTMLDivProps {
    children?: React.ReactNode;
}

// this component is simple enough that tests would be purely tautological.
/* istanbul ignore next */
export class NavbarHeading extends AbstractPureComponent<NavbarHeadingProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.NavbarHeading`;

    public render() {
        const { children, className, ...htmlProps } = this.props;
        return (
            <div className={classNames(Classes.NAVBAR_HEADING, className)} {...htmlProps}>
                {children}
            </div>
        );
    }
}

================================================================================

File: src\components\navbar\_navbar.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "../card/card-variables";

/*
Navbars

Markup:
<nav class="#{$ns}-navbar {{.modifier}}">
  <div class="#{$ns}-navbar-group #{$ns}-align-left">
    <div class="#{$ns}-navbar-heading">Blueprint</div>
    <input class="#{$ns}-input" placeholder="Search files..." type="text" />
  </div>
  <div class="#{$ns}-navbar-group #{$ns}-align-right">
    <button class="#{$ns}-button #{$ns}-minimal #{$ns}-icon-home">Home</button>
    <button class="#{$ns}-button #{$ns}-minimal #{$ns}-icon-document">Files</button>
    <span class="#{$ns}-navbar-divider"></span>
    <button class="#{$ns}-button #{$ns}-minimal #{$ns}-icon-user"></button>
    <button class="#{$ns}-button #{$ns}-minimal #{$ns}-icon-notifications"></button>
    <button class="#{$ns}-button #{$ns}-minimal #{$ns}-icon-cog"></button>
  </div>
</nav>

.#{$ns}-dark - Dark theme

Styleguide navbar
*/

$navbar-padding: $pt-grid-size * 1.5 !default;

$navbar-background-color: $card-background-color !default;
$dark-navbar-background-color: $dark-card-background-color !default;

.#{$ns}-navbar {
  background-color: $navbar-background-color;
  box-shadow: $pt-elevation-shadow-1;
  height: $pt-navbar-height;
  padding: 0 $navbar-padding;
  position: relative;
  width: 100%;
  z-index: $pt-z-index-content;

  &.#{$ns}-dark,
  .#{$ns}-dark & {
    background-color: $dark-navbar-background-color;
  }

  // shadow for dark navbar in light theme apps
  &.#{$ns}-dark {
    box-shadow: inset $pt-dark-elevation-shadow-1;
  }

  // shadow for dark navbar in dark theme apps
  .#{$ns}-dark & {
    box-shadow: $pt-dark-elevation-shadow-1;
  }

  &.#{$ns}-fixed-top {
    left: 0;
    position: fixed;
    right: 0;
    top: 0;
  }

  @media (forced-colors: active) and (prefers-color-scheme: dark) {
    border: 1px solid $pt-high-contrast-mode-border-color;
  }
}

.#{$ns}-navbar-heading {
  font-size: $pt-font-size-large;
  margin-right: $navbar-padding;
}

.#{$ns}-navbar-group {
  align-items: center;
  display: flex;
  height: $pt-navbar-height;

  &.#{$ns}-align-left {
    float: left;
  }

  &.#{$ns}-align-right {
    float: right;
  }
}

.#{$ns}-navbar-divider {
  border-left: 1px solid $pt-divider-black;
  height: $pt-navbar-height - $pt-grid-size * 3;
  margin: 0 $pt-grid-size;

  .#{$ns}-dark & {
    border-left-color: $pt-dark-divider-white;
  }
}

/*
Fixed width

Markup:
<nav class="#{$ns}-navbar #{$ns}-dark">
  <div style="margin: 0 auto; width: 480px;"> <!-- ADD ME -->
    <div class="#{$ns}-navbar-group #{$ns}-align-left">
      <div class="#{$ns}-navbar-heading">Blueprint</div>
    </div>
    <div class="#{$ns}-navbar-group #{$ns}-align-right">
      <button class="#{$ns}-button #{$ns}-minimal #{$ns}-icon-home">Home</button>
      <button class="#{$ns}-button #{$ns}-minimal #{$ns}-icon-document">Files</button>
      <span class="#{$ns}-navbar-divider"></span>
      <button class="#{$ns}-button #{$ns}-minimal #{$ns}-icon-user"></button>
      <button class="#{$ns}-button #{$ns}-minimal #{$ns}-icon-notifications"></button>
      <button class="#{$ns}-button #{$ns}-minimal #{$ns}-icon-cog"></button>
    </div>
  </div>
</nav>

Styleguide navbar-container
*/

================================================================================

File: src\components\non-ideal-state\non-ideal-state.md
--------------------------------------------------------------------------------
---
parent: components
---

@# Non-ideal state

Non-ideal UI states inform the user that some content is unavailable. There are several types of non-ideal states,
including:

*   **Empty state:** a container has just been created and has no data in it yet, or a container's contents have been
    intentionally removed.
*   **Loading state:** a container is awaiting data. A good practice is to show a spinner for this state with optional
    explanatory text below the spinner.
*   **Error state:** something went wrong (for instance, 404 and 500 HTTP errors). In this case, a good practice is to
    add a call to action directing the user what to do next.

@reactExample NonIdealStateExample

@## Usage

__NonIdealState__ component props are rendered in this order in the DOM, with comfortable spacing between each child:

1. `icon`
1. text (`title` + optional `description`)
1. `action`
1. `children`

By default, a vertical layout is used, but you can make it horizontal with `layout="horizontal"`.

Icons will also take on a muted appearance inside this component, with their shape contrast preserved by adding a small stroke to the SVG paths. This behavior can be disabled by setting `iconMuted={false}`.

@## Props interface

@interface NonIdealStateProps

@## CSS API

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use [`<NonIdealState>`](#core/components/non-ideal-state)

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

Note that you are required to set the `font-size` and `line-height` styles for the icon element to render it properly.

Also, since the CSS API uses the icon font, Blueprint styles cannot adjust the icon visual design to have a muted
appearance like it does with the React component API. This means __NonIdealState__ elements rendered with this API will
stand out visually (in a bad way) within the design system.

</div>

Apply the `.@ns-non-ideal-state` class to the root container element and wrap the icon element with a
`.@ns-non-ideal-state-visual` container.

The root container should only have direct element children, no grandchildren (except for text, which is enclosed in a
`.@ns-non-ideal-state-text` wrapper element). This constraint ensures proper spacing between each child.

@css non-ideal-state

================================================================================

File: src\components\non-ideal-state\nonIdealState.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { type IconName, IconSize } from "@blueprintjs/icons";

import { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, type MaybeElement, type Props } from "../../common";
import { ensureElement } from "../../common/utils";
import { H4 } from "../html/html";
import { Icon } from "../icon/icon";

export enum NonIdealStateIconSize {
    STANDARD = IconSize.STANDARD * 3,
    SMALL = IconSize.STANDARD * 2,
    EXTRA_SMALL = IconSize.LARGE,
}

export interface NonIdealStateProps extends Props {
    /** An action to resolve the non-ideal state which appears after `description`. */
    action?: React.JSX.Element;

    /**
     * Advanced usage: React `children` will appear last (after `action`).
     * Avoid passing raw strings as they will not receive margins and disrupt the layout flow.
     */
    children?: React.ReactNode;

    /**
     * A longer description of the non-ideal state.
     * A string or number value will be wrapped in a `<div>` to preserve margins.
     */
    description?: React.ReactChild;

    /** The name of a Blueprint icon or a JSX element (such as `<Spinner/>`) to render above the title. */
    icon?: IconName | MaybeElement;

    /**
     * How large the icon visual should be.
     *
     * @default NonIdealStateIconSize.STANDARD
     */
    iconSize?: NonIdealStateIconSize;

    /**
     * Whether the icon should use a muted style.
     *
     * @default true
     */
    iconMuted?: boolean;

    /**
     * Component layout, either vertical or horizontal.
     *
     * @default "vertical"
     */
    layout?: "vertical" | "horizontal";

    /** The title of the non-ideal state. */
    title?: React.ReactNode;
}

/**
 * Non-ideal state component.
 *
 * @see https://blueprintjs.com/docs/#core/components/non-ideal-state
 */
export class NonIdealState extends AbstractPureComponent<NonIdealStateProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.NonIdealState`;

    public static defaultProps: Partial<NonIdealStateProps> = {
        iconMuted: true,
        iconSize: NonIdealStateIconSize.STANDARD,
        layout: "vertical",
    };

    public render() {
        const { action, children, className, layout } = this.props;

        return (
            <div className={classNames(Classes.NON_IDEAL_STATE, `${Classes.NON_IDEAL_STATE}-${layout}`, className)}>
                {this.maybeRenderVisual()}
                {this.maybeRenderText()}
                {action}
                {children}
            </div>
        );
    }

    private maybeRenderVisual() {
        const { icon, iconMuted, iconSize } = this.props;
        if (icon == null) {
            return undefined;
        } else {
            return (
                <div
                    className={Classes.NON_IDEAL_STATE_VISUAL}
                    style={{ fontSize: `${iconSize}px`, lineHeight: `${iconSize}px` }}
                >
                    <Icon
                        className={classNames({ [Classes.ICON_MUTED]: iconMuted })}
                        icon={icon}
                        size={iconSize}
                        aria-hidden={true}
                        tabIndex={-1}
                    />
                </div>
            );
        }
    }

    private maybeRenderText() {
        const { description, title } = this.props;
        if (title == null && description == null) {
            return undefined;
        } else {
            return (
                <div className={Classes.NON_IDEAL_STATE_TEXT}>
                    {title && <H4>{title}</H4>}
                    {description && ensureElement(description, "div")}
                </div>
            );
        }
    }
}

================================================================================

File: src\components\non-ideal-state\_non-ideal-state.scss
--------------------------------------------------------------------------------
// Copyright 2016 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "../../common/mixins";

/*
Non-ideal state

Markup:
<div class="#{$ns}-non-ideal-state">
  <div class="#{$ns}-non-ideal-state-visual" style="font-size: 48px; line-height: 48px;">
    <span class="#{$ns}-icon #{$ns}-icon-muted #{$ns}-icon-folder-open"></span>
  </div>
  <div class="#{$ns}-non-ideal-state-text">
    <h4 class="#{$ns}-heading">This folder is empty</h4>
    <div>Create a new file to populate the folder.</div>
  </div>
  <button class="#{$ns}-button #{$ns}-intent-primary">Create</button>
</div>

Styleguide non-ideal-state
*/

.#{$ns}-non-ideal-state {
  @include pt-flex-container(column, $pt-grid-size * 2);
  align-items: center;
  color: $pt-text-color-muted;
  height: 100%;
  justify-content: center;
  text-align: center;
  width: 100%;

  > * {
    max-width: $pt-grid-size * 40;
  }

  .#{$ns}-heading {
    color: $pt-text-color-muted;
    line-height: $pt-grid-size * 2;
    margin-bottom: $pt-grid-size;

    &:only-child {
      margin-bottom: 0;
    }
  }

  &.#{$ns}-non-ideal-state-horizontal {
    @include pt-flex-container(row, $pt-grid-size * 2);
    text-align: left;

    // We need to override the pt-flex-container() styles on the default vertical layout of this
    // component with this universal selector. A better approach would be to only apply pt-flex-container(column, ...)
    // on the .#{$ns}-non-ideal-state-vertical class, but we cannot do that without a CSS breaking change.
    > * {
      margin-bottom: 0;
    }
  }

  .#{$ns}-dark & {
    color: $pt-dark-text-color-muted;

    .#{$ns}-heading {
      color: $pt-dark-text-color-muted;
    }
  }
}

.#{$ns}-non-ideal-state-visual {
  color: $gray3;
}

================================================================================

File: src\components\overflow-list\overflow-list.md
--------------------------------------------------------------------------------
@# Overflow list

__OverflowList__ takes a generic list of items and renders as many items as can fit inside its container. Overflowed
items that do not fit are collapsed into a single element. The visible items will be recomputed when a resize is
detected.

The `items` prop accepts an array of generic objects. The required `visibleItemRenderer` callback prop determines the
appearance of a visible item. The required `overflowRenderer` callback prop receives all overflowed items and renders
the overflow indicator.

This component uses [the `ResizeObserver` API][resizeobserver] to efficiently detect when its dimensions change. Use
the `observeParents` prop to watch for resizing further up in the DOM tree.

[resizeobserver]: https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver

@reactExample OverflowListExample

@## Props interface

@interface OverflowListProps

================================================================================

File: src\components\overflow-list\overflowList.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Boundary, Classes, DISPLAYNAME_PREFIX, type Props } from "../../common";
import { OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED } from "../../common/errors";
import { shallowCompareKeys } from "../../common/utils";
import { ResizeSensor } from "../resize-sensor/resizeSensor";

export interface OverflowListProps<T> extends Props {
    /**
     * Whether to force the overflowRenderer to always be called, even if there are zero items
     * overflowing. This may be useful, for example, if your overflow renderer contains a Popover
     * which you do not want to close as the list is resized.
     *
     * @default false
     */
    alwaysRenderOverflow?: boolean;

    /**
     * Which direction the items should collapse from: start or end of the
     * children. This also determines whether `overflowRenderer` appears before
     * (`START`) or after (`END`) the visible items.
     *
     * @default Boundary.START
     */
    collapseFrom?: Boundary;

    /**
     * All items to display in the list. Items that do not fit in the container
     * will be rendered in the overflow instead.
     */
    items: readonly T[];

    /**
     * The minimum number of visible items that should never collapse into the
     * overflow menu, regardless of DOM dimensions.
     *
     * @default 0
     */
    minVisibleItems?: number;

    /**
     * If `true`, all parent DOM elements of the container will also be
     * observed. If changes to a parent's size is detected, the overflow will be
     * recalculated.
     *
     * Only enable this prop if the overflow should be recalculated when a
     * parent element resizes in a way that does not also cause the
     * `OverflowList` to resize.
     *
     * @default false
     */
    observeParents?: boolean;

    /**
     * Callback invoked when the overflowed items change. This is called once
     * after the DOM has settled, rather that on every intermediate change. It
     * is not invoked if resizing produces an unchanged overflow state.
     */
    onOverflow?: (overflowItems: T[]) => void;

    /**
     * Callback invoked to render the overflowed items. Unlike
     * `visibleItemRenderer`, this prop is invoked once with all items that do
     * not fit in the container.
     *
     * Typical use cases for this prop will put overflowed items in a dropdown
     * menu or display a "+X items" label.
     */
    overflowRenderer: (overflowItems: T[]) => React.ReactNode;

    /** CSS properties to apply to the root element. */
    style?: React.CSSProperties;

    /**
     * HTML tag name for the container element.
     *
     * @default "div"
     */
    tagName?: keyof React.JSX.IntrinsicElements;

    /**
     * Callback invoked to render each visible item.
     * Remember to set a `key` on the rendered element!
     */
    visibleItemRenderer: (item: T, index: number) => React.ReactChild;
}

export interface OverflowListState<T> {
    /** Whether repartitioning is still active. An overflow can take several frames to settle. */
    repartitioning: boolean;
    /** Length of last overflow to dedupe `onOverflow` calls during smooth resizing. */
    lastOverflowCount: number;
    overflow: readonly T[];
    visible: readonly T[];
    /** Pointer for the binary search algorithm used to find the finished non-overflowing state */
    chopSize: number;
    lastChopSize: number | null;
}

/**
 * Overflow list component.
 *
 * @see https://blueprintjs.com/docs/#core/components/overflow-list
 */
export class OverflowList<T> extends React.Component<OverflowListProps<T>, OverflowListState<T>> {
    public static displayName = `${DISPLAYNAME_PREFIX}.OverflowList`;

    public static defaultProps: Partial<OverflowListProps<any>> = {
        alwaysRenderOverflow: false,
        collapseFrom: Boundary.START,
        minVisibleItems: 0,
    };

    public static ofType<U>() {
        return OverflowList as new (props: OverflowListProps<U>) => OverflowList<U>;
    }

    public state: OverflowListState<T> = {
        chopSize: this.defaultChopSize(),
        lastChopSize: null,
        lastOverflowCount: 0,
        overflow: [],
        repartitioning: false,
        visible: this.props.items,
    };

    private spacer: HTMLElement | null = null;

    public componentDidMount() {
        this.repartition();
    }

    public shouldComponentUpdate(nextProps: OverflowListProps<T>, nextState: OverflowListState<T>) {
        // We want this component to always re-render, even when props haven't changed, so that
        // changes in the renderers' behavior can be reflected.
        // The following statement prevents re-rendering only in the case where the state changes
        // identity (i.e. setState was called), but the state is still the same when
        // shallow-compared to the previous state. Original context: https://github.com/palantir/blueprint/pull/3278.
        // We also ensure that we re-render if the props DO change (which isn't necessarily accounted for by other logic).
        return this.props !== nextProps || !(this.state !== nextState && shallowCompareKeys(this.state, nextState));
    }

    public componentDidUpdate(prevProps: OverflowListProps<T>, prevState: OverflowListState<T>) {
        if (prevProps.observeParents !== this.props.observeParents) {
            console.warn(OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED);
        }

        if (
            prevProps.collapseFrom !== this.props.collapseFrom ||
            prevProps.items !== this.props.items ||
            prevProps.minVisibleItems !== this.props.minVisibleItems ||
            prevProps.overflowRenderer !== this.props.overflowRenderer ||
            prevProps.alwaysRenderOverflow !== this.props.alwaysRenderOverflow ||
            prevProps.visibleItemRenderer !== this.props.visibleItemRenderer
        ) {
            // reset visible state if the above props change.
            this.setState({
                chopSize: this.defaultChopSize(),
                lastChopSize: null,
                lastOverflowCount: 0,
                overflow: [],
                repartitioning: true,
                visible: this.props.items,
            });
        }

        const { repartitioning, overflow, lastOverflowCount } = this.state;

        if (
            // if a resize operation has just completed
            repartitioning === false &&
            prevState.repartitioning === true
        ) {
            // only invoke the callback if the UI has actually changed
            if (overflow.length !== lastOverflowCount) {
                this.props.onOverflow?.(overflow.slice());
            }
        } else if (!shallowCompareKeys(prevState, this.state)) {
            this.repartition();
        }
    }

    public render() {
        const { className, collapseFrom, observeParents, style, tagName = "div", visibleItemRenderer } = this.props;
        const overflow = this.maybeRenderOverflow();
        const list = React.createElement(
            tagName,
            {
                className: classNames(Classes.OVERFLOW_LIST, className),
                style,
            },
            collapseFrom === Boundary.START ? overflow : null,
            this.state.visible.map(visibleItemRenderer),
            collapseFrom === Boundary.END ? overflow : null,
            <div className={Classes.OVERFLOW_LIST_SPACER} ref={ref => (this.spacer = ref)} />,
        );

        return (
            <ResizeSensor onResize={this.resize} observeParents={observeParents}>
                {list}
            </ResizeSensor>
        );
    }

    private maybeRenderOverflow() {
        const { overflow } = this.state;
        if (overflow.length === 0 && !this.props.alwaysRenderOverflow) {
            return null;
        }
        return this.props.overflowRenderer(overflow.slice());
    }

    private resize = () => {
        this.repartition();
    };

    private repartition() {
        if (this.spacer == null) {
            return;
        }

        // if lastChopSize was 1, then our binary search has exhausted.
        const partitionExhausted = this.state.lastChopSize === 1;
        const minVisible = this.props.minVisibleItems ?? 0;

        // spacer has flex-shrink and width 1px so if it's much smaller then we know to shrink
        const shouldShrink = this.spacer.offsetWidth < 0.9 && this.state.visible.length > minVisible;

        // we only check partitionExhausted for shouldGrow to ensure shrinking is the final operation.
        const shouldGrow =
            (this.spacer.offsetWidth >= 1 || this.state.visible.length < minVisible) &&
            this.state.overflow.length > 0 &&
            !partitionExhausted;

        if (shouldShrink || shouldGrow) {
            this.setState(state => {
                let visible;
                let overflow;
                if (this.props.collapseFrom === Boundary.END) {
                    const result = shiftElements(
                        state.visible,
                        state.overflow,
                        this.state.chopSize * (shouldShrink ? 1 : -1),
                    );
                    visible = result[0];
                    overflow = result[1];
                } else {
                    const result = shiftElements(
                        state.overflow,
                        state.visible,
                        this.state.chopSize * (shouldShrink ? -1 : 1),
                    );
                    overflow = result[0];
                    visible = result[1];
                }

                return {
                    chopSize: halve(state.chopSize),
                    lastChopSize: state.chopSize,
                    // if we're starting a new partition cycle, record the last overflow count so we can track whether the UI changes after the new overflow is calculated
                    lastOverflowCount: this.isFirstPartitionCycle(state.chopSize)
                        ? state.overflow.length
                        : state.lastOverflowCount,
                    overflow,
                    repartitioning: true,
                    visible,
                };
            });
        } else {
            // repartition complete!
            this.setState({
                chopSize: this.defaultChopSize(),
                lastChopSize: null,
                repartitioning: false,
            });
        }
    }

    private defaultChopSize(): number {
        return halve(this.props.items.length);
    }

    private isFirstPartitionCycle(currentChopSize: number): boolean {
        return currentChopSize === this.defaultChopSize();
    }
}

function halve(num: number): number {
    return Math.ceil(num / 2);
}

function shiftElements<T>(leftArray: readonly T[], rightArray: readonly T[], num: number): [newFrom: T[], newTo: T[]] {
    // if num is positive then elements are shifted from left-to-right, if negative then right-to-left
    const allElements = leftArray.concat(rightArray);
    const newLeftLength = leftArray.length - num;

    if (newLeftLength <= 0) {
        return [[], allElements];
    } else if (newLeftLength >= allElements.length) {
        return [allElements, []];
    }

    const sliceIndex = allElements.length - newLeftLength;

    return [allElements.slice(0, -sliceIndex), allElements.slice(-sliceIndex)];
}

================================================================================

File: src\components\overflow-list\_overflow-list.scss
--------------------------------------------------------------------------------
// Copyright 2018 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

.#{$ns}-overflow-list {
  display: flex;
  flex-wrap: nowrap;
  min-width: 0;
}

.#{$ns}-overflow-list-spacer {
  flex-shrink: 1;
  width: 1px;
}

================================================================================

File: src\components\overlay\overlay.md
--------------------------------------------------------------------------------
---
tag: deprecated
---

@# Overlay

<div class="@ns-callout @ns-intent-danger @ns-icon-error @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated: use [**Overlay2**](#core/components/overlay2)

</h5>

This component is **deprecated since @blueprintjs/core v5.9.0** in favor of the new
**Overlay2** component which is compatible with React 18 strict mode. You should migrate to the
new API which will become the standard in a future major version of Blueprint.

</div>

**Overlay** is a generic low-level component for rendering content _on top of_ its siblings or above the entire
application.

It combines the functionality of the [**Portal**](#core/components/portal) component (which allows React elements to
escape their current DOM hierarchy) with a [**CSSTransitionGroup**](https://reactcommunity.org/react-transition-group/)
(to show elegant enter and leave transitions).

An optional "backdrop" element can be rendered behind the overlaid children to provide modal behavior, whereby the
overlay prevents interaction with anything behind it.

**Overlay** is the backbone of all the components listed in the **Overlays** group in the sidebar. Using **Overlay**
directly should be rare in your application; it should only be necessary if no existing component meets your needs.

@reactExample OverlayExample

@## Usage

**Overlay** is a controlled component that renders its children only when `isOpen={true}`. The optional backdrop element
will be inserted before the children if `hasBackdrop={true}`.

The `onClose` callback prop is invoked when user interaction causes the overlay to close, but your application is
responsible for updating the state that actually closes the overlay.

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">A note about overlay content positioning</h5>

When rendered inline, content will automatically be set to `position: absolute` to respect
document flow. Otherwise, content will be set to `position: fixed` to cover the entire viewport.

</div>

```tsx
<div>
    <Button text="Show overlay" onClick={this.toggleOverlay} />
    <Overlay isOpen={this.state.isOpen} onClose={this.toggleOverlay}>
        Overlaid contents...
    </Overlay>
</div>
```

@## Scrolling interactions

Overlays rely on fixed and absolute CSS positioning. By default, an overlay larger than the viewport will not be
scrollable, so any overflowing content will be hidden. Fortunately, making an overlay scrollable is very easy: pass
`Classes.OVERLAY_SCROLL_CONTAINER` in the Overlay `className` prop, and the component will take care of the rest.

```tsx
<Overlay className={Classes.OVERLAY_SCROLL_CONTAINER} />
```

Note that the [**Dialog**](https://blueprintjs.com/docs/#core/components/dialog) component applies this CSS class
automatically.

@## Props interface

@interface OverlayProps

================================================================================

File: src\components\overlay\overlay.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview This component is DEPRECATED, and the code is frozen.
 * All changes & bugfixes should be made to Overlay2 instead.
 */

/* eslint-disable deprecation/deprecation, @blueprintjs/no-deprecated-components */

import classNames from "classnames";
import * as React from "react";
import { CSSTransition, TransitionGroup } from "react-transition-group";

import { AbstractPureComponent, Classes } from "../../common";
import { DISPLAYNAME_PREFIX, type HTMLDivProps } from "../../common/props";
import { getActiveElement, isFunction } from "../../common/utils";
import { Portal } from "../portal/portal";

import type { OverlayProps } from "./overlayProps";
import { getKeyboardFocusableElements } from "./overlayUtils";

export interface OverlayState {
    hasEverOpened?: boolean;
}

/**
 * Overlay component.
 *
 * @deprecated use `Overlay2` instead
 * @see https://blueprintjs.com/docs/#core/components/overlay
 */
export class Overlay extends AbstractPureComponent<OverlayProps, OverlayState> {
    public static displayName = `${DISPLAYNAME_PREFIX}.Overlay`;

    public static defaultProps: OverlayProps = {
        autoFocus: true,
        backdropProps: {},
        canEscapeKeyClose: true,
        canOutsideClickClose: true,
        enforceFocus: true,
        hasBackdrop: true,
        isOpen: false,
        lazy: true,
        shouldReturnFocusOnClose: true,
        transitionDuration: 300,
        transitionName: Classes.OVERLAY,
        usePortal: true,
    };

    public static getDerivedStateFromProps({ isOpen: hasEverOpened }: OverlayProps) {
        if (hasEverOpened) {
            return { hasEverOpened };
        }
        return null;
    }

    private static openStack: Overlay[] = [];

    private static getLastOpened = () => Overlay.openStack[Overlay.openStack.length - 1];

    private isAutoFocusing = false;

    private lastActiveElementBeforeOpened: Element | null | undefined;

    public state: OverlayState = {
        hasEverOpened: this.props.isOpen,
    };

    /** Ref for container element, containing all children and the backdrop */
    public containerElement = React.createRef<HTMLDivElement>();

    // An empty, keyboard-focusable div at the beginning of the Overlay content
    private startFocusTrapElement = React.createRef<HTMLDivElement>();

    // An empty, keyboard-focusable div at the end of the Overlay content
    private endFocusTrapElement = React.createRef<HTMLDivElement>();

    public render() {
        // oh snap! no reason to render anything at all if we're being truly lazy
        if (this.props.lazy && !this.state.hasEverOpened) {
            return null;
        }

        const { autoFocus, children, className, enforceFocus, usePortal, isOpen } = this.props;

        // TransitionGroup types require single array of children; does not support nested arrays.
        // So we must collapse backdrop and children into one array, and every item must be wrapped in a
        // Transition element (no ReactText allowed).
        const childrenWithTransitions = isOpen ? React.Children.map(children, this.maybeRenderChild) ?? [] : [];

        const maybeBackdrop = this.maybeRenderBackdrop();
        if (maybeBackdrop !== null) {
            childrenWithTransitions.unshift(maybeBackdrop);
        }
        if (isOpen && (autoFocus || enforceFocus) && childrenWithTransitions.length > 0) {
            childrenWithTransitions.unshift(
                this.renderDummyElement("__start", {
                    className: Classes.OVERLAY_START_FOCUS_TRAP,
                    onFocus: this.handleStartFocusTrapElementFocus,
                    onKeyDown: this.handleStartFocusTrapElementKeyDown,
                    ref: this.startFocusTrapElement,
                }),
            );
            if (enforceFocus) {
                childrenWithTransitions.push(
                    this.renderDummyElement("__end", {
                        className: Classes.OVERLAY_END_FOCUS_TRAP,
                        onFocus: this.handleEndFocusTrapElementFocus,
                        ref: this.endFocusTrapElement,
                    }),
                );
            }
        }

        const containerClasses = classNames(
            Classes.OVERLAY,
            {
                [Classes.OVERLAY_OPEN]: isOpen,
                [Classes.OVERLAY_INLINE]: !usePortal,
            },
            className,
        );

        const transitionGroup = (
            <div
                aria-live="polite"
                className={containerClasses}
                onKeyDown={this.handleKeyDown}
                ref={this.containerElement}
            >
                <TransitionGroup appear={true} component={null}>
                    {childrenWithTransitions}
                </TransitionGroup>
            </div>
        );
        if (usePortal) {
            return (
                <Portal
                    className={this.props.portalClassName}
                    container={this.props.portalContainer}
                    // eslint-disable-next-line deprecation/deprecation
                    stopPropagationEvents={this.props.portalStopPropagationEvents}
                >
                    {transitionGroup}
                </Portal>
            );
        } else {
            return transitionGroup;
        }
    }

    public componentDidMount() {
        if (this.props.isOpen) {
            this.overlayWillOpen();
        }
    }

    public componentDidUpdate(prevProps: OverlayProps) {
        if (prevProps.isOpen && !this.props.isOpen) {
            this.overlayWillClose();
        } else if (!prevProps.isOpen && this.props.isOpen) {
            this.overlayWillOpen();
        }
    }

    public componentWillUnmount() {
        this.overlayWillClose();
    }

    /**
     * @public for testing
     * @internal
     */
    public bringFocusInsideOverlay() {
        // always delay focus manipulation to just before repaint to prevent scroll jumping
        return this.requestAnimationFrame(() => {
            // container element may be undefined between component mounting and Portal rendering
            // activeElement may be undefined in some rare cases in IE
            const activeElement = getActiveElement(this.containerElement.current);

            if (this.containerElement.current == null || activeElement == null || !this.props.isOpen) {
                return;
            }

            const container = this.containerElement.current;
            const isFocusOutsideModal = !container.contains(activeElement);
            if (isFocusOutsideModal) {
                this.startFocusTrapElement.current?.focus({ preventScroll: true });
                this.isAutoFocusing = false;
            }
        });
    }

    private maybeRenderChild = (child?: React.ReactNode) => {
        if (isFunction(child)) {
            child = child();
        }

        if (child == null) {
            return null;
        }

        // decorate the child with a few injected props
        const tabIndex = this.props.enforceFocus || this.props.autoFocus ? 0 : undefined;
        const decoratedChild =
            typeof child === "object" ? (
                React.cloneElement(child as React.ReactElement, {
                    className: classNames((child as React.ReactElement).props.className, Classes.OVERLAY_CONTENT),
                    tabIndex,
                })
            ) : (
                <span className={Classes.OVERLAY_CONTENT} tabIndex={tabIndex}>
                    {child}
                </span>
            );

        const { onOpening, onOpened, onClosing, transitionDuration, transitionName } = this.props;

        return (
            <CSSTransition
                classNames={transitionName}
                onEntering={onOpening}
                onEntered={onOpened}
                onExiting={onClosing}
                onExited={this.handleTransitionExited}
                timeout={transitionDuration}
                addEndListener={this.handleTransitionAddEnd}
            >
                {decoratedChild}
            </CSSTransition>
        );
    };

    private maybeRenderBackdrop() {
        const { backdropClassName, backdropProps, hasBackdrop, isOpen, transitionDuration, transitionName } =
            this.props;

        if (hasBackdrop && isOpen) {
            return (
                <CSSTransition
                    classNames={transitionName}
                    key="__backdrop"
                    timeout={transitionDuration}
                    addEndListener={this.handleTransitionAddEnd}
                >
                    <div
                        {...backdropProps}
                        className={classNames(Classes.OVERLAY_BACKDROP, backdropClassName, backdropProps?.className)}
                        onMouseDown={this.handleBackdropMouseDown}
                    />
                </CSSTransition>
            );
        } else {
            return null;
        }
    }

    private renderDummyElement(key: string, props: HTMLDivProps & { ref?: React.Ref<HTMLDivElement> }) {
        const { transitionDuration, transitionName } = this.props;
        return (
            <CSSTransition
                classNames={transitionName}
                key={key}
                addEndListener={this.handleTransitionAddEnd}
                timeout={transitionDuration}
                unmountOnExit={true}
            >
                <div tabIndex={0} {...props} />
            </CSSTransition>
        );
    }

    /**
     * Ensures repeatedly pressing shift+tab keeps focus inside the Overlay. Moves focus to
     * the `endFocusTrapElement` or the first keyboard-focusable element in the Overlay (excluding
     * the `startFocusTrapElement`), depending on whether the element losing focus is inside the
     * Overlay.
     */
    private handleStartFocusTrapElementFocus = (e: React.FocusEvent<HTMLDivElement>) => {
        if (!this.props.enforceFocus || this.isAutoFocusing) {
            return;
        }
        // e.relatedTarget will not be defined if this was a programmatic focus event, as is the
        // case when we call this.bringFocusInsideOverlay() after a user clicked on the backdrop.
        // Otherwise, we're handling a user interaction, and we should wrap around to the last
        // element in this transition group.
        if (
            e.relatedTarget != null &&
            this.containerElement.current?.contains(e.relatedTarget as Element) &&
            e.relatedTarget !== this.endFocusTrapElement.current
        ) {
            this.endFocusTrapElement.current?.focus({ preventScroll: true });
        }
    };

    /**
     * Wrap around to the end of the dialog if `enforceFocus` is enabled.
     */
    private handleStartFocusTrapElementKeyDown = (e: React.KeyboardEvent<HTMLDivElement>) => {
        if (!this.props.enforceFocus) {
            return;
        }
        if (e.shiftKey && e.key === "Tab") {
            const lastFocusableElement = getKeyboardFocusableElements(this.containerElement).pop();
            if (lastFocusableElement != null) {
                lastFocusableElement.focus();
            } else {
                this.endFocusTrapElement.current?.focus({ preventScroll: true });
            }
        }
    };

    /**
     * Ensures repeatedly pressing tab keeps focus inside the Overlay. Moves focus to the
     * `startFocusTrapElement` or the last keyboard-focusable element in the Overlay (excluding the
     * `startFocusTrapElement`), depending on whether the element losing focus is inside the
     * Overlay.
     */
    private handleEndFocusTrapElementFocus = (e: React.FocusEvent<HTMLDivElement>) => {
        // No need for this.props.enforceFocus check here because this element is only rendered
        // when that prop is true.
        // During user interactions, e.relatedTarget will be defined, and we should wrap around to the
        // "start focus trap" element.
        // Otherwise, we're handling a programmatic focus event, which can only happen after a user
        // presses shift+tab from the first focusable element in the overlay.
        if (
            e.relatedTarget != null &&
            this.containerElement.current?.contains(e.relatedTarget as Element) &&
            e.relatedTarget !== this.startFocusTrapElement.current
        ) {
            const firstFocusableElement = getKeyboardFocusableElements(this.containerElement).shift();
            // ensure we don't re-focus an already active element by comparing against e.relatedTarget
            if (!this.isAutoFocusing && firstFocusableElement != null && firstFocusableElement !== e.relatedTarget) {
                firstFocusableElement.focus();
            } else {
                this.startFocusTrapElement.current?.focus({ preventScroll: true });
            }
        } else {
            const lastFocusableElement = getKeyboardFocusableElements(this.containerElement).pop();
            if (lastFocusableElement != null) {
                lastFocusableElement.focus();
            } else {
                // Keeps focus within Overlay even if there are no keyboard-focusable children
                this.startFocusTrapElement.current?.focus({ preventScroll: true });
            }
        }
    };

    private overlayWillClose() {
        document.removeEventListener("focus", this.handleDocumentFocus, /* useCapture */ true);
        document.removeEventListener("mousedown", this.handleDocumentClick);

        const { openStack } = Overlay;
        const stackIndex = openStack.indexOf(this);
        if (stackIndex !== -1) {
            openStack.splice(stackIndex, 1);
            if (openStack.length > 0) {
                const lastOpenedOverlay = Overlay.getLastOpened();
                // Only bring focus back to last overlay if it had autoFocus _and_ enforceFocus enabled.
                // If `autoFocus={false}`, it's likely that the overlay never received focus in the first place,
                // so it would be surprising for us to send it there. See https://github.com/palantir/blueprint/issues/4921
                if (lastOpenedOverlay.props.autoFocus && lastOpenedOverlay.props.enforceFocus) {
                    lastOpenedOverlay.bringFocusInsideOverlay();
                    document.addEventListener("focus", lastOpenedOverlay.handleDocumentFocus, /* useCapture */ true);
                }
            }

            if (openStack.filter(o => o.props.usePortal && o.props.hasBackdrop).length === 0) {
                document.body.classList.remove(Classes.OVERLAY_OPEN);
            }
        }
    }

    private overlayWillOpen() {
        const { getLastOpened, openStack } = Overlay;
        if (openStack.length > 0) {
            document.removeEventListener("focus", getLastOpened().handleDocumentFocus, /* useCapture */ true);
        }
        openStack.push(this);

        if (this.props.autoFocus) {
            this.isAutoFocusing = true;
            this.bringFocusInsideOverlay();
        }

        if (this.props.enforceFocus) {
            // Focus events do not bubble, but setting useCapture allows us to listen in and execute
            // our handler before all others
            document.addEventListener("focus", this.handleDocumentFocus, /* useCapture */ true);
        }

        if (this.props.canOutsideClickClose && !this.props.hasBackdrop) {
            document.addEventListener("mousedown", this.handleDocumentClick);
        }

        if (this.props.hasBackdrop && this.props.usePortal) {
            // add a class to the body to prevent scrolling of content below the overlay
            document.body.classList.add(Classes.OVERLAY_OPEN);
        }

        this.lastActiveElementBeforeOpened = getActiveElement(this.containerElement.current);
    }

    private handleTransitionExited = (node: HTMLElement) => {
        if (this.props.shouldReturnFocusOnClose && this.lastActiveElementBeforeOpened instanceof HTMLElement) {
            this.lastActiveElementBeforeOpened.focus();
        }
        this.props.onClosed?.(node);
    };

    private handleBackdropMouseDown = (e: React.MouseEvent<HTMLDivElement>) => {
        const { backdropProps, canOutsideClickClose, enforceFocus, onClose } = this.props;
        if (canOutsideClickClose) {
            onClose?.(e);
        }
        if (enforceFocus) {
            this.bringFocusInsideOverlay();
        }
        backdropProps?.onMouseDown?.(e);
    };

    private handleDocumentClick = (e: MouseEvent) => {
        const { canOutsideClickClose, isOpen, onClose } = this.props;
        // get the actual target even in the Shadow DOM
        // see https://github.com/palantir/blueprint/issues/4220
        const eventTarget = (e.composed ? e.composedPath()[0] : e.target) as HTMLElement;

        const stackIndex = Overlay.openStack.indexOf(this);
        const isClickInThisOverlayOrDescendant = Overlay.openStack
            .slice(stackIndex)
            .some(({ containerElement: elem }) => {
                // `elem` is the container of backdrop & content, so clicking directly on that container
                // should not count as being "inside" the overlay.
                return elem.current?.contains(eventTarget) && !elem.current.isSameNode(eventTarget);
            });

        if (isOpen && !isClickInThisOverlayOrDescendant && canOutsideClickClose) {
            // casting to any because this is a native event
            onClose?.(e as any);
        }
    };

    /**
     * When multiple Overlays are open, this event handler is only active for the most recently
     * opened one to avoid Overlays competing with each other for focus.
     */
    private handleDocumentFocus = (e: FocusEvent) => {
        // get the actual target even in the Shadow DOM
        // see https://github.com/palantir/blueprint/issues/4220
        const eventTarget = e.composed ? e.composedPath()[0] : e.target;
        if (
            this.props.enforceFocus &&
            this.containerElement.current != null &&
            eventTarget instanceof Node &&
            !this.containerElement.current.contains(eventTarget as HTMLElement)
        ) {
            // prevent default focus behavior (sometimes auto-scrolls the page)
            e.preventDefault();
            e.stopImmediatePropagation();
            this.bringFocusInsideOverlay();
        }
    };

    private handleKeyDown = (e: React.KeyboardEvent<HTMLElement>) => {
        const { canEscapeKeyClose, onClose } = this.props;
        if (e.key === "Escape" && canEscapeKeyClose) {
            onClose?.(e);
            // prevent other overlays from closing
            e.stopPropagation();
            // prevent browser-specific escape key behavior (Safari exits fullscreen)
            e.preventDefault();
        }
    };

    private handleTransitionAddEnd = () => {
        // no-op
    };
}

================================================================================

File: src\components\overlay\overlayProps.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { Props } from "../../common/props";

export interface OverlayableProps extends OverlayLifecycleProps {
    /**
     * Whether the overlay should acquire application focus when it first opens.
     *
     * @default true
     */
    autoFocus?: boolean;

    /**
     * Whether pressing the `esc` key should invoke `onClose`.
     *
     * @default true
     */
    canEscapeKeyClose?: boolean;

    /**
     * Whether the overlay should prevent focus from leaving itself. That is, if the user attempts
     * to focus an element outside the overlay and this prop is enabled, then the overlay will
     * immediately bring focus back to itself. If you are nesting overlay components, either disable
     * this prop on the "outermost" overlays or mark the nested ones `usePortal={false}`.
     *
     * @default true
     */
    enforceFocus?: boolean;

    /**
     * If `true` and `usePortal={true}`, the `Portal` containing the children is created and attached
     * to the DOM when the overlay is opened for the first time; otherwise this happens when the
     * component mounts. Lazy mounting provides noticeable performance improvements if you have lots
     * of overlays at once, such as on each row of a table.
     *
     * @default true
     */
    lazy?: boolean;

    /**
     * Whether the application should return focus to the last active element in the
     * document after this overlay closes.
     *
     * @default true
     */
    shouldReturnFocusOnClose?: boolean;

    /**
     * Indicates how long (in milliseconds) the overlay's enter/leave transition takes.
     * This is used by React `CSSTransition` to know when a transition completes and must match
     * the duration of the animation in CSS. Only set this prop if you override Blueprint's default
     * transitions with new transitions of a different length.
     *
     * @default 300
     */
    transitionDuration?: number;

    /**
     * Whether the overlay should be wrapped in a `Portal`, which renders its contents in a new
     * element attached to `portalContainer` prop.
     *
     * This prop essentially determines which element is covered by the backdrop: if `false`,
     * then only its parent is covered; otherwise, the entire page is covered (because the parent
     * of the `Portal` is the `<body>` itself).
     *
     * Set this prop to `false` on nested overlays (such as `Dialog` or `Popover`) to ensure that they
     * are rendered above their parents.
     *
     * @default true
     */
    usePortal?: boolean;

    /**
     * Space-delimited string of class names applied to the `Portal` element if
     * `usePortal={true}`.
     */
    portalClassName?: string;

    /**
     * The container element into which the overlay renders its contents, when `usePortal` is `true`.
     * This prop is ignored if `usePortal` is `false`.
     *
     * @default document.body
     */
    portalContainer?: HTMLElement;

    /**
     * A list of DOM events which should be stopped from propagating through the Portal.
     * This prop is ignored if `usePortal` is `false`.
     *
     * @deprecated this prop's implementation no longer works in React v17+
     * @see https://legacy.reactjs.org/docs/portals.html#event-bubbling-through-portals
     * @see https://github.com/palantir/blueprint/issues/6124
     * @see https://github.com/palantir/blueprint/issues/6580
     */
    portalStopPropagationEvents?: Array<keyof HTMLElementEventMap>;

    /**
     * A callback that is invoked when user interaction causes the overlay to close, such as
     * clicking on the overlay or pressing the `esc` key (if enabled).
     *
     * Receives the event from the user's interaction, if there was an event (generally either a
     * mouse or key event). Note that, since this component is controlled by the `isOpen` prop, it
     * will not actually close itself until that prop becomes `false`.
     */
    onClose?: (event: React.SyntheticEvent<HTMLElement>) => void;
}

export interface OverlayLifecycleProps {
    /**
     * Lifecycle method invoked just before the CSS _close_ transition begins on
     * a child. Receives the DOM element of the child being closed.
     */
    onClosing?: (node: HTMLElement) => void;

    /**
     * Lifecycle method invoked just after the CSS _close_ transition ends but
     * before the child has been removed from the DOM. Receives the DOM element
     * of the child being closed.
     */
    onClosed?: (node: HTMLElement) => void;

    /**
     * Lifecycle method invoked just after mounting the child in the DOM but
     * just before the CSS _open_ transition begins. Receives the DOM element of
     * the child being opened.
     */
    onOpening?: (node: HTMLElement) => void;

    /**
     * Lifecycle method invoked just after the CSS _open_ transition ends.
     * Receives the DOM element of the child being opened.
     */
    onOpened?: (node: HTMLElement) => void;
}

export interface BackdropProps {
    /** CSS class names to apply to backdrop element. */
    backdropClassName?: string;

    /** HTML props for the backdrop element. */
    backdropProps?: React.HTMLProps<HTMLDivElement>;

    /**
     * Whether clicking outside the overlay element (either on backdrop when present or on document)
     * should invoke `onClose`.
     *
     * @default true
     */
    canOutsideClickClose?: boolean;

    /**
     * Whether a container-spanning backdrop element should be rendered behind the contents.
     * When `false`, users will be able to scroll through and interact with overlaid content.
     *
     * @default true
     */
    hasBackdrop?: boolean;
}

export interface OverlayProps extends OverlayableProps, BackdropProps, Props {
    /** Element to overlay. */
    children?: React.ReactNode;

    /**
     * Toggles the visibility of the overlay and its children.
     * This prop is required because the component is controlled.
     */
    isOpen: boolean;

    /**
     * Name of the transition for internal `CSSTransition`.
     * Providing your own name here will require defining new CSS transition properties.
     *
     * @default Classes.OVERLAY
     */
    transitionName?: string;
}

================================================================================

File: src\components\overlay\overlayUtils.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { OVERLAY_END_FOCUS_TRAP, OVERLAY_START_FOCUS_TRAP } from "../../common/classes";
import { getRef } from "../../common/refs";

/**
 * Returns the keyboard-focusable elements inside a given container element, ignoring focus traps
 * rendered by Overlay/Overlay2.
 */
export function getKeyboardFocusableElements(container: HTMLElement | React.RefObject<HTMLElement>): HTMLElement[] {
    const containerElement = getRef(container);
    const focusableElements: HTMLElement[] =
        containerElement != null
            ? Array.from(
                  // Order may not be correct if children elements use tabindex values > 0.
                  // Selectors derived from this SO question:
                  // https://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus
                  containerElement.querySelectorAll(
                      [
                          'a[href]:not([tabindex="-1"])',
                          'button:not([disabled]):not([tabindex="-1"])',
                          'details:not([tabindex="-1"])',
                          'input:not([disabled]):not([tabindex="-1"])',
                          'select:not([disabled]):not([tabindex="-1"])',
                          'textarea:not([disabled]):not([tabindex="-1"])',
                          '[tabindex]:not([tabindex="-1"])',
                      ].join(","),
                  ),
              )
            : [];

    return focusableElements.filter(
        el => !el.classList.contains(OVERLAY_START_FOCUS_TRAP) && !el.classList.contains(OVERLAY_END_FOCUS_TRAP),
    );
}

================================================================================

File: src\components\overlay\_overlay.scss
--------------------------------------------------------------------------------
// Copyright 2016 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";

$overlay-background-color: rgba($black, 0.7) !default;

// restricts scrolling of underlying content while the overlay is open
body.#{$ns}-overlay-open {
  overflow: hidden;
}

.#{$ns}-overlay {
  // 0-out all positions so page won't jump when position changes (0s already there)
  @include position-all(static, 0);
  z-index: $pt-z-index-overlay;

  &:not(.#{$ns}-overlay-open) {
    // because of the 0-position covering the viewport,
    // we must ignore the mouse when not open
    pointer-events: none;
  }

  // N.B. this class name is a bit of a misnomer since it is only being used by the Drawer component. It also
  // shares quite a bit with the "overlay-scroll-container" class, so it's due for a DRY refactor.
  &.#{$ns}-overlay-container {
    overflow: hidden;
    // container covers the entire viewport
    position: fixed;

    &.#{$ns}-overlay-inline {
      // when rendered inline, we want the overlay to position itself relative to
      // its parent container, not relative to the whole window. thus, we change
      // to position:absolute.
      position: absolute;
    }
  }

  &.#{$ns}-overlay-scroll-container {
    overflow: auto;
    // scroll container covers the entire viewport
    position: fixed;

    &.#{$ns}-overlay-inline {
      // when rendered inline, we want the overlay to position itself relative to
      // its parent container, not relative to the whole window. thus, we change
      // to position:absolute.
      position: absolute;
    }
  }

  &.#{$ns}-overlay-inline {
    display: inline;
    // inline overlays can overflow container by default (see Dialog & Popover)
    overflow: visible;
  }
}

// this class is added to each Overlay child so that users won't need to
// explicitly manage the position mode for inline and non-inline rendering.
.#{$ns}-overlay-content {
  // default fixed pulls it out of the flow and makes it viewport-relative
  position: fixed;
  z-index: $pt-z-index-overlay;

  .#{$ns}-overlay-inline &,
  .#{$ns}-overlay-scroll-container & {
    // but inline (or scrollable) overlays want their children to respect
    // the parent positioning context. also allows the content to scroll.
    position: absolute;
  }
}

// fixed position so the backdrop forecefully covers the whole screen
.#{$ns}-overlay-backdrop {
  @include position-all(fixed, 0);
  @include react-transition(
    "#{$ns}-overlay",
    (opacity: 0 1),
    $pt-transition-duration * 2,
    $before: "&"
  );
  background-color: $overlay-background-color;
  overflow: auto;
  user-select: none;
  z-index: $pt-z-index-overlay;

  &:focus {
    outline: none;
  }

  // as mentioned above: when inline, Overlay backdrop must respect parent
  .#{$ns}-overlay-inline & {
    position: absolute;
  }
}

================================================================================

File: src\components\overlay2\overlay2.md
--------------------------------------------------------------------------------
---
tag: new
---

@# Overlay2

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Migrating from [Overlay](#core/components/overlay)?

</h5>

[**OverlaysProvider**](#core/context/overlays-provider) and **Overlay2**, when used
together, are a replacement for **Overlay**. You are encouraged to use these new APIs, as they will
become the standard in a future major version of Blueprint. See the full
[migration guide](https://github.com/palantir/blueprint/wiki/Overlay2-migration) on the wiki.

</div>

**Overlay2** is a generic low-level component for rendering content _on top of_ its siblings or
above the entire application.

It combines the functionality of the [**Portal**](#core/components/portal) component (which allows
React elements to escape their current DOM hierarchy) with a
[**CSSTransitionGroup**](https://reactcommunity.org/react-transition-group/)
(to show elegant enter and leave transitions).

An optional "backdrop" element can be rendered behind the overlaid children to provide modal
behavior, whereby the overlay prevents interaction with anything behind it.

**Overlay2** is the backbone of all the components listed in the "Overlays" group in the sidebar.
Using **Overlay2** directly should be rare in your application; it should only be necessary if no
existing component meets your needs.

@reactExample Overlay2Example

@## Usage

**Overlay2** is a controlled component that renders its children only when `isOpen={true}`.
The optional backdrop element will be inserted before the children if `hasBackdrop={true}`.

The `onClose` callback prop is invoked when user interaction causes the overlay to close, but your
application is responsible for updating the state that actually closes the overlay.

**Overlay2** _strongly recommends_ usage only within a React subtree which has an
[**OverlaysProvider**](#core/context/overlays-provider). In Blueprint v5.x, the component
implements backwards-compatibilty (via the [`useOverlayStack()` hook](#core/hooks/use-overlay-stack))
such that it will work without one, but this functionality will be removed in a future major version.

```tsx
import { Button, Overlay2, OverlaysProvider } from "@blueprintjs/core";
import { useCallback, useState } from "react";

function Example() {
    const [isOpen, setIsOpen] = useState(false);
    const toggleOverlay = useCallback(() => setIsOpen(open => !open), [setIsOpen]);

    return (
        <OverlaysProvider>
            <div>
                <Button text="Show overlay" onClick={toggleOverlay} />
                <Overlay2 isOpen={isOpen} onClose={toggleOverlay}>
                    Overlaid contents...
                </Overlay2>
            </div>
        </OverlaysProvider>
    );
}
```

@## DOM layout

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">A note about overlay content positioning</h5>

When rendered inline, content will automatically be set to `position: absolute` to respect
document flow. Otherwise, content will be set to `position: fixed` to cover the entire viewport.

</div>

Overlays rely on fixed and absolute CSS positioning. By default, an overlay larger than the viewport
will not be scrollable, so any overflowing content will be hidden. Fortunately, making an overlay
scrollable is very easy: pass `Classes.OVERLAY_SCROLL_CONTAINER` in the Overlay2 `className` prop,
and the component will take care of the rest.

```tsx
<Overlay2 className={Classes.OVERLAY_SCROLL_CONTAINER} />
```

Note that the [**Dialog**](https://blueprintjs.com/docs/#core/components/dialog) component applies
this modifier class automatically.

@## Child refs

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">DOM ref(s) required</h5>

Overlay2 needs to be able to attach DOM refs to its child elements, so the children of this
component _must be a native DOM element_ or utilize
[`React.forwardRef()`](https://reactjs.org/docs/forwarding-refs.html) to forward any
injected ref to the underlying DOM element.

</div>

**Overlay2** utilizes the react-transition-group library to declaratively configure "enter" and
"exit" transitions for its contents; it does so by individually wrapping its child nodes with
[**CSSTransition**](https://reactcommunity.org/react-transition-group/css-transition). This
third-party component requires a DOM ref to its child node in order to work correctly in React 18
strict mode (where `ReactDOM.findDOMNode()` is not available). **Overlay2** can manage this ref for
you automatically in some cases, but it requires some user help to handle more advanced use cases:

### Single child with automatic ref

If you provide a _single_ child element to `<Overlay2>` and _do not_ set its `ref` prop, you
don't need to do anything. The component will generate a child ref and happily pass it along
to the underlying `<CSSTransition>`.

```tsx
function Example() {
    const [isOpen, setIsOpen] = React.useState<boolean>(true);
    return (
        <Overlay2 isOpen={isOpen}>
            <div>Contents</div>
        </Overlay2>
    );
}
```

### Single child with manual ref

If you provide a _single_ child element to `<Overlay2>` and _do_ set its `ref` prop, you must
pass the same ref to `<Overlay2 childRef={..}>`.

```tsx
function Example() {
    const [isOpen, setIsOpen] = React.useState<boolean>(true);
    const myRef = React.useRef<HTMLElement>();

    return (
        <Overlay2 isOpen={isOpen} childRef={myRef}>
            <div ref={myRef}>Contents</div>
        </Overlay2>
    );
}
```

### Multiple children

If you provide _multiple_ child elements to `<Overlay2>`, you must enumerate a collection of
refs for each of those elements and pass those along as a record (keyed by the elements'
corresponding React `key` values) to `<Overlay2 childRefs={...}>`.

```tsx
import { uniqueId } from "../utils";

function Example() {
    const [isOpen, setIsOpen] = React.useState<boolean>(true);
    const [childRefs, setChildRefs] = React.useState<Record<string, React.RefObject<HTMLDivElement>>>({});
    const [children, setChildren] = React.useState<Array<{ key: string }>>([]);
    const addChild = React.useCallback(() => {
        const newRef = React.createRef<HTMLDivElement>();
        const newKey = uniqueId();
        setChildren(oldChildren => [...oldChildren, { key: newKey }]);
        setChildRefs(oldRefs => ({ ...oldRefs, [newKey]: newRef }));
    }, []);

    return (
        <div>
            <Button onClick={addChild}>Add child</Button>
            <Overlay2 isOpen={isOpen} childRefs={childRefs}>
                {children.map(child => (
                    <div key={child.key} ref={childRefs[child.key]} />
                ))}
            </Overlay2>
        </div>
    );
}
```

@## Props interface

@interface Overlay2Props

================================================================================

File: src\components\overlay2\overlay2.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";
import { CSSTransition, TransitionGroup } from "react-transition-group";
import { useUID } from "react-uid";

import { Classes, mergeRefs } from "../../common";
import {
    OVERLAY_CHILD_REF_AND_REFS_MUTEX,
    OVERLAY_CHILD_REQUIRES_KEY,
    OVERLAY_WITH_MULTIPLE_CHILDREN_REQUIRES_CHILD_REFS,
} from "../../common/errors";
import { DISPLAYNAME_PREFIX, type HTMLDivProps } from "../../common/props";
import {
    ensureElement,
    getActiveElement,
    getRef,
    isEmptyString,
    isNodeEnv,
    isReactElement,
    setRef,
} from "../../common/utils";
import { hasDOMEnvironment } from "../../common/utils/domUtils";
import { useOverlayStack } from "../../hooks/overlays/useOverlayStack";
import { usePrevious } from "../../hooks/usePrevious";
import type { OverlayProps } from "../overlay/overlayProps";
import { getKeyboardFocusableElements } from "../overlay/overlayUtils";
import { Portal } from "../portal/portal";

import type { OverlayInstance } from "./overlayInstance";

export interface Overlay2Props extends OverlayProps, React.RefAttributes<OverlayInstance> {
    /**
     * If you provide a single child element to Overlay2 and attach your own `ref` to the node, you must pass the
     * same value here (otherwise, Overlay2 won't be able to render CSSTransition correctly).
     *
     * Mutually exclusive with the `childRefs` prop. This prop is a shorthand for `childRefs={{ [key: string]: ref }}`.
     */
    childRef?: React.RefObject<HTMLElement>;

    /**
     * If you provide a _multiple child elements_ to Overlay2, you must enumerate and generate a
     * collection of DOM refs to those elements and provide it here. The object's keys must correspond to the child
     * React element `key` values.
     *
     * Mutually exclusive with the `childRef` prop. If you only provide a single child element, consider using
     * `childRef` instead.
     */
    childRefs?: Record<string, React.RefObject<HTMLElement>>;
}

/**
 * Overlay2 component.
 *
 * @see https://blueprintjs.com/docs/#core/components/overlay2
 */
export const Overlay2 = React.forwardRef<OverlayInstance, Overlay2Props>((props, forwardedRef) => {
    const {
        autoFocus,
        backdropClassName,
        backdropProps,
        canEscapeKeyClose,
        canOutsideClickClose,
        childRef,
        childRefs,
        children,
        className,
        enforceFocus,
        hasBackdrop,
        isOpen,
        lazy,
        onClose,
        onClosed,
        onClosing,
        onOpened,
        onOpening,
        portalClassName,
        portalContainer,
        shouldReturnFocusOnClose,
        transitionDuration,
        transitionName,
        usePortal,
    } = props;

    useOverlay2Validation(props);
    const { closeOverlay, getLastOpened, getThisOverlayAndDescendants, openOverlay } = useOverlayStack();

    const [isAutoFocusing, setIsAutoFocusing] = React.useState(false);
    const [hasEverOpened, setHasEverOpened] = React.useState(false);
    const lastActiveElementBeforeOpened = React.useRef<Element>(null);

    /** Ref for container element, containing all children and the backdrop */
    const containerElement = React.useRef<HTMLDivElement>(null);

    /** Ref for backdrop element */
    const backdropElement = React.useRef<HTMLDivElement>(null);

    /* An empty, keyboard-focusable div at the beginning of the Overlay content */
    const startFocusTrapElement = React.useRef<HTMLDivElement>(null);

    /* An empty, keyboard-focusable div at the end of the Overlay content */
    const endFocusTrapElement = React.useRef<HTMLDivElement>(null);

    /**
     * Locally-generated DOM ref for a singleton child element.
     * This is only used iff the user does not specify the `childRef` or `childRefs` props.
     */
    const localChildRef = React.useRef<HTMLElement>(null);

    const bringFocusInsideOverlay = React.useCallback(() => {
        // always delay focus manipulation to just before repaint to prevent scroll jumping
        return requestAnimationFrame(() => {
            // container element may be undefined between component mounting and Portal rendering
            // activeElement may be undefined in some rare cases in IE
            const container = getRef(containerElement);
            const activeElement = getActiveElement(container);

            if (container == null || activeElement == null) {
                return;
            }

            // Overlay2 is guaranteed to be mounted here
            const isFocusOutsideModal = !container.contains(activeElement);
            if (isFocusOutsideModal) {
                getRef(startFocusTrapElement)?.focus({ preventScroll: true });
                setIsAutoFocusing(false);
            }
        });
    }, []);

    /** Unique ID for this overlay in the global stack */
    const id = useOverlay2ID();

    // N.B. use `null` here and not simply `undefined` because `useImperativeHandle` will set `null` on unmount,
    // and we need the following code to be resilient to that value.
    const instance = React.useRef<OverlayInstance>(null);

    /**
     * When multiple `enforceFocus` Overlays are open, this event handler is only active for the most
     * recently opened one to avoid Overlays competing with each other for focus.
     */
    const handleDocumentFocus = React.useCallback(
        (e: FocusEvent) => {
            // get the actual target even in the Shadow DOM
            // see https://github.com/palantir/blueprint/issues/4220
            const eventTarget = e.composed ? e.composedPath()[0] : e.target;
            const container = getRef(containerElement);
            if (container != null && eventTarget instanceof Node && !container.contains(eventTarget as HTMLElement)) {
                // prevent default focus behavior (sometimes auto-scrolls the page)
                e.preventDefault();
                e.stopImmediatePropagation();
                bringFocusInsideOverlay();
            }
        },
        [bringFocusInsideOverlay],
    );

    // N.B. this listener is only kept attached when `isOpen={true}` and `canOutsideClickClose={true}`
    const handleDocumentMousedown = React.useCallback(
        (e: MouseEvent) => {
            // get the actual target even in the Shadow DOM
            // see https://github.com/palantir/blueprint/issues/4220
            const eventTarget = (e.composed ? e.composedPath()[0] : e.target) as HTMLElement;

            const thisOverlayAndDescendants = getThisOverlayAndDescendants(id);
            const isClickInThisOverlayOrDescendant = thisOverlayAndDescendants.some(
                ({ containerElement: containerRef }) => {
                    // `elem` is the container of backdrop & content, so clicking directly on that container
                    // should not count as being "inside" the overlay.
                    const elem = getRef(containerRef);
                    return elem?.contains(eventTarget) && !elem.isSameNode(eventTarget);
                },
            );

            if (!isClickInThisOverlayOrDescendant) {
                // casting to any because this is a native event
                onClose?.(e as any);
            }
        },
        [getThisOverlayAndDescendants, id, onClose],
    );

    // send this instance's imperative handle to the the forwarded ref as well as our local ref
    const ref = React.useMemo(() => mergeRefs(forwardedRef, instance), [forwardedRef]);
    React.useImperativeHandle(
        ref,
        () => ({
            bringFocusInsideOverlay,
            containerElement,
            handleDocumentFocus,
            handleDocumentMousedown,
            id,
            props: {
                autoFocus,
                enforceFocus,
                hasBackdrop,
                usePortal,
            },
        }),
        [
            autoFocus,
            bringFocusInsideOverlay,
            enforceFocus,
            handleDocumentFocus,
            handleDocumentMousedown,
            hasBackdrop,
            id,
            usePortal,
        ],
    );

    const handleContainerKeyDown = React.useCallback(
        (e: React.KeyboardEvent<HTMLElement>) => {
            if (e.key === "Escape" && canEscapeKeyClose) {
                onClose?.(e);
                // prevent other overlays from closing
                e.stopPropagation();
                // prevent browser-specific escape key behavior (Safari exits fullscreen)
                e.preventDefault();
            }
        },
        [canEscapeKeyClose, onClose],
    );

    const overlayWillOpen = React.useCallback(() => {
        if (instance.current == null) {
            return;
        }

        const lastOpenedOverlay = getLastOpened();
        if (lastOpenedOverlay?.handleDocumentFocus !== undefined) {
            document.removeEventListener("focus", lastOpenedOverlay.handleDocumentFocus, /* useCapture */ true);
        }
        openOverlay(instance.current);

        if (autoFocus) {
            setIsAutoFocusing(true);
            bringFocusInsideOverlay();
        }

        setRef(lastActiveElementBeforeOpened, getActiveElement(getRef(containerElement)));
    }, [autoFocus, bringFocusInsideOverlay, getLastOpened, openOverlay]);

    const overlayWillClose = React.useCallback(() => {
        document.removeEventListener("focus", handleDocumentFocus, /* useCapture */ true);
        document.removeEventListener("mousedown", handleDocumentMousedown);

        // N.B. `instance.current` may be null at this point if we are cleaning up an open overlay during the unmount phase
        // (this is common, for example, with context menu's singleton `showContextMenu` / `hideContextMenu` imperative APIs).
        closeOverlay(id);
        const lastOpenedOverlay = getLastOpened();
        if (lastOpenedOverlay !== undefined) {
            // Only bring focus back to last overlay if it had autoFocus _and_ enforceFocus enabled.
            // If `autoFocus={false}`, it's likely that the overlay never received focus in the first place,
            // so it would be surprising for us to send it there. See https://github.com/palantir/blueprint/issues/4921
            if (lastOpenedOverlay.props.autoFocus && lastOpenedOverlay.props.enforceFocus) {
                lastOpenedOverlay.bringFocusInsideOverlay?.();
                if (lastOpenedOverlay.handleDocumentFocus !== undefined) {
                    document.addEventListener("focus", lastOpenedOverlay.handleDocumentFocus, /* useCapture */ true);
                }
            }
        }
    }, [closeOverlay, getLastOpened, handleDocumentFocus, handleDocumentMousedown, id]);

    const prevIsOpen = usePrevious(isOpen) ?? false;
    React.useEffect(() => {
        if (isOpen) {
            setHasEverOpened(true);
        }

        if (!prevIsOpen && isOpen) {
            // just opened
            overlayWillOpen();
        }

        if (prevIsOpen && !isOpen) {
            // just closed
            overlayWillClose();
        }
    }, [isOpen, overlayWillOpen, overlayWillClose, prevIsOpen]);

    // Important: clean up old document-level event listeners if their memoized values change (this is rare, but
    // may happen, for example, if a user forgets to use `React.useCallback` in the `props.onClose` value).
    // Otherwise, we will lose the reference to those values and create a memory leak since we won't be able
    // to successfully detach them inside overlayWillClose.
    React.useEffect(() => {
        if (!isOpen || !(canOutsideClickClose && !hasBackdrop)) {
            return;
        }

        document.addEventListener("mousedown", handleDocumentMousedown);

        return () => {
            document.removeEventListener("mousedown", handleDocumentMousedown);
        };
    }, [handleDocumentMousedown, isOpen, canOutsideClickClose, hasBackdrop]);
    React.useEffect(() => {
        if (!isOpen || !enforceFocus) {
            return;
        }

        // Focus events do not bubble, but setting useCapture allows us to listen in and execute
        // our handler before all others
        document.addEventListener("focus", handleDocumentFocus, /* useCapture */ true);

        return () => {
            document.removeEventListener("focus", handleDocumentFocus, /* useCapture */ true);
        };
    }, [handleDocumentFocus, enforceFocus, isOpen]);

    const overlayWillCloseRef = React.useRef(overlayWillClose);
    overlayWillCloseRef.current = overlayWillClose;
    React.useEffect(() => {
        // run cleanup code once on unmount, ensuring we call the most recent overlayWillClose callback
        // by storing in a ref and keeping up to date
        return () => {
            overlayWillCloseRef.current();
        };
    }, []);

    const handleTransitionExited = React.useCallback(
        (node: HTMLElement) => {
            const lastActiveElement = getRef(lastActiveElementBeforeOpened);
            if (shouldReturnFocusOnClose && lastActiveElement instanceof HTMLElement) {
                lastActiveElement.focus();
            }
            onClosed?.(node);
        },
        [onClosed, shouldReturnFocusOnClose],
    );

    // N.B. CSSTransition requires this callback to be defined, even if it's unused.
    const handleTransitionAddEnd = React.useCallback(() => {
        // no-op
    }, []);

    /**
     * Gets the relevant DOM ref for a child element using the `childRef` or `childRefs` props (if possible).
     * This ref is necessary for `CSSTransition` to work in React 18 without relying on `ReactDOM.findDOMNode`.
     *
     * Returns `undefined` if the user did not specify either of those props. In those cases, we use the ref we
     * have locally generated and expect that the user _did not_ specify their own `ref` on the child element
     * (it will get clobbered / overriden).
     *
     * @see https://reactcommunity.org/react-transition-group/css-transition
     */
    const getUserChildRef = React.useCallback(
        (child: React.ReactNode) => {
            if (childRef != null) {
                return childRef;
            } else if (childRefs != null) {
                const key = (child as React.ReactElement).key;
                if (key == null) {
                    if (!isNodeEnv("production")) {
                        console.error(OVERLAY_CHILD_REQUIRES_KEY);
                    }
                    return undefined;
                }
                return childRefs[key];
            }
            return undefined;
        },
        [childRef, childRefs],
    );

    const maybeRenderChild = React.useCallback(
        (child: React.ReactNode | undefined) => {
            if (child == null || isEmptyString(child)) {
                return null;
            }

            // decorate the child with a few injected props
            const userChildRef = getUserChildRef(child);
            const childProps = isReactElement(child) ? child.props : {};
            // if the child is a string, number, or fragment, it will be wrapped in a <span> element
            const decoratedChild = ensureElement(child, "span", {
                className: classNames(childProps.className, Classes.OVERLAY_CONTENT),
                // IMPORTANT: only inject our ref if the user didn't specify childRef or childRefs already. Otherwise,
                // we risk clobbering the user's ref (which we cannot inspect here while cloning/decorating the child).
                ref: userChildRef === undefined ? localChildRef : undefined,
                tabIndex: enforceFocus || autoFocus ? 0 : undefined,
            });
            const resolvedChildRef = userChildRef ?? localChildRef;

            return (
                <CSSTransition
                    addEndListener={handleTransitionAddEnd}
                    classNames={transitionName}
                    // HACKHACK: CSSTransition types are slightly incompatible with React types here.
                    // React prefers `| null` but not `| undefined` for the ref value, while
                    // CSSTransition _demands_ that `| undefined` be part of the element type.
                    nodeRef={resolvedChildRef as React.RefObject<HTMLElement | undefined>}
                    onEntered={getLifecycleCallbackWithChildRef(onOpened, resolvedChildRef)}
                    onEntering={getLifecycleCallbackWithChildRef(onOpening, resolvedChildRef)}
                    onExited={getLifecycleCallbackWithChildRef(handleTransitionExited, resolvedChildRef)}
                    onExiting={getLifecycleCallbackWithChildRef(onClosing, resolvedChildRef)}
                    timeout={transitionDuration}
                >
                    {decoratedChild}
                </CSSTransition>
            );
        },
        [
            autoFocus,
            enforceFocus,
            getUserChildRef,
            handleTransitionAddEnd,
            handleTransitionExited,
            onClosing,
            onOpened,
            onOpening,
            transitionDuration,
            transitionName,
        ],
    );

    const handleBackdropMouseDown = React.useCallback(
        (e: React.MouseEvent<HTMLDivElement>) => {
            if (canOutsideClickClose) {
                onClose?.(e);
            }
            if (enforceFocus) {
                bringFocusInsideOverlay();
            }
            backdropProps?.onMouseDown?.(e);
        },
        [backdropProps, bringFocusInsideOverlay, canOutsideClickClose, enforceFocus, onClose],
    );

    const renderDummyElement = React.useCallback(
        (key: string, dummyElementProps: HTMLDivProps & { ref?: React.Ref<HTMLDivElement> }) => (
            <CSSTransition
                addEndListener={handleTransitionAddEnd}
                classNames={transitionName}
                key={key}
                nodeRef={dummyElementProps.ref}
                timeout={transitionDuration}
                unmountOnExit={true}
            >
                <div tabIndex={0} {...dummyElementProps} />
            </CSSTransition>
        ),
        [handleTransitionAddEnd, transitionDuration, transitionName],
    );

    /**
     * Ensures repeatedly pressing shift+tab keeps focus inside the Overlay. Moves focus to
     * the `endFocusTrapElement` or the first keyboard-focusable element in the Overlay (excluding
     * the `startFocusTrapElement`), depending on whether the element losing focus is inside the
     * Overlay.
     */
    const handleStartFocusTrapElementFocus = React.useCallback(
        (e: React.FocusEvent<HTMLDivElement>) => {
            if (!enforceFocus || isAutoFocusing) {
                return;
            }
            // e.relatedTarget will not be defined if this was a programmatic focus event, as is the
            // case when we call this.bringFocusInsideOverlay() after a user clicked on the backdrop.
            // Otherwise, we're handling a user interaction, and we should wrap around to the last
            // element in this transition group.
            const container = getRef(containerElement);
            const endFocusTrap = getRef(endFocusTrapElement);
            if (
                e.relatedTarget != null &&
                container?.contains(e.relatedTarget as Element) &&
                e.relatedTarget !== endFocusTrap
            ) {
                endFocusTrap?.focus({ preventScroll: true });
            }
        },
        [enforceFocus, isAutoFocusing],
    );

    /**
     * Wrap around to the end of the dialog if `enforceFocus` is enabled.
     */
    const handleStartFocusTrapElementKeyDown = React.useCallback(
        (e: React.KeyboardEvent<HTMLDivElement>) => {
            if (!enforceFocus) {
                return;
            }
            if (e.shiftKey && e.key === "Tab") {
                const lastFocusableElement = getKeyboardFocusableElements(containerElement).pop();
                if (lastFocusableElement != null) {
                    lastFocusableElement.focus();
                } else {
                    getRef(endFocusTrapElement)?.focus({ preventScroll: true });
                }
            }
        },
        [enforceFocus],
    );

    /**
     * Ensures repeatedly pressing tab keeps focus inside the Overlay. Moves focus to the
     * `startFocusTrapElement` or the last keyboard-focusable element in the Overlay (excluding the
     * `startFocusTrapElement`), depending on whether the element losing focus is inside the
     * Overlay.
     */
    const handleEndFocusTrapElementFocus = React.useCallback(
        (e: React.FocusEvent<HTMLDivElement>) => {
            // No need for this.props.enforceFocus check here because this element is only rendered
            // when that prop is true.
            // During user interactions, e.relatedTarget will be defined, and we should wrap around to the
            // "start focus trap" element.
            // Otherwise, we're handling a programmatic focus event, which can only happen after a user
            // presses shift+tab from the first focusable element in the overlay.
            const startFocusTrap = getRef(startFocusTrapElement);
            if (
                e.relatedTarget != null &&
                getRef(containerElement)?.contains(e.relatedTarget as Element) &&
                e.relatedTarget !== startFocusTrap
            ) {
                const firstFocusableElement = getKeyboardFocusableElements(containerElement).shift();
                // ensure we don't re-focus an already active element by comparing against e.relatedTarget
                if (!isAutoFocusing && firstFocusableElement != null && firstFocusableElement !== e.relatedTarget) {
                    firstFocusableElement.focus();
                } else {
                    startFocusTrap?.focus({ preventScroll: true });
                }
            } else {
                const lastFocusableElement = getKeyboardFocusableElements(containerElement).pop();
                if (lastFocusableElement != null) {
                    lastFocusableElement.focus();
                } else {
                    // Keeps focus within Overlay even if there are no keyboard-focusable children
                    startFocusTrap?.focus({ preventScroll: true });
                }
            }
        },
        [isAutoFocusing],
    );

    const maybeBackdrop = React.useMemo(
        () =>
            hasBackdrop && isOpen ? (
                <CSSTransition
                    classNames={transitionName}
                    key="__backdrop"
                    nodeRef={backdropElement}
                    timeout={transitionDuration}
                    addEndListener={handleTransitionAddEnd}
                >
                    <div
                        {...backdropProps}
                        className={classNames(Classes.OVERLAY_BACKDROP, backdropClassName, backdropProps?.className)}
                        onMouseDown={handleBackdropMouseDown}
                        ref={backdropElement}
                    />
                </CSSTransition>
            ) : null,
        [
            backdropClassName,
            backdropProps,
            handleBackdropMouseDown,
            handleTransitionAddEnd,
            hasBackdrop,
            isOpen,
            transitionDuration,
            transitionName,
        ],
    );

    // no reason to render anything at all if we're being truly lazy
    if (lazy && !hasEverOpened) {
        return null;
    }

    // TransitionGroup types require single array of children; does not support nested arrays.
    // So we must collapse backdrop and children into one array, and every item must be wrapped in a
    // Transition element (no ReactText allowed).
    const childrenWithTransitions = isOpen ? React.Children.map(children, maybeRenderChild) ?? [] : [];

    // const maybeBackdrop = maybeRenderBackdrop();
    if (maybeBackdrop !== null) {
        childrenWithTransitions.unshift(maybeBackdrop);
    }
    if (isOpen && (autoFocus || enforceFocus) && childrenWithTransitions.length > 0) {
        childrenWithTransitions.unshift(
            renderDummyElement("__start", {
                className: Classes.OVERLAY_START_FOCUS_TRAP,
                onFocus: handleStartFocusTrapElementFocus,
                onKeyDown: handleStartFocusTrapElementKeyDown,
                ref: startFocusTrapElement,
            }),
        );
        if (enforceFocus) {
            childrenWithTransitions.push(
                renderDummyElement("__end", {
                    className: Classes.OVERLAY_END_FOCUS_TRAP,
                    onFocus: handleEndFocusTrapElementFocus,
                    ref: endFocusTrapElement,
                }),
            );
        }
    }

    const transitionGroup = (
        <div
            aria-live="polite"
            className={classNames(
                Classes.OVERLAY,
                {
                    [Classes.OVERLAY_OPEN]: isOpen,
                    [Classes.OVERLAY_INLINE]: !usePortal,
                },
                className,
            )}
            onKeyDown={handleContainerKeyDown}
            ref={containerElement}
        >
            <TransitionGroup appear={true} component={null}>
                {childrenWithTransitions}
            </TransitionGroup>
        </div>
    );

    if (usePortal) {
        return (
            <Portal className={portalClassName} container={portalContainer}>
                {transitionGroup}
            </Portal>
        );
    } else {
        return transitionGroup;
    }
});
Overlay2.defaultProps = {
    autoFocus: true,
    backdropProps: {},
    canEscapeKeyClose: true,
    canOutsideClickClose: true,
    enforceFocus: true,
    hasBackdrop: true,
    isOpen: false,
    lazy: hasDOMEnvironment(),
    shouldReturnFocusOnClose: true,
    transitionDuration: 300,
    transitionName: Classes.OVERLAY,
    usePortal: true,
};
Overlay2.displayName = `${DISPLAYNAME_PREFIX}.Overlay2`;

function useOverlay2Validation({ childRef, childRefs, children }: Overlay2Props) {
    const numChildren = React.Children.count(children);
    React.useEffect(() => {
        if (isNodeEnv("production")) {
            return;
        }

        if (childRef != null && childRefs != null) {
            console.error(OVERLAY_CHILD_REF_AND_REFS_MUTEX);
        }

        if (numChildren > 1 && childRefs == null) {
            console.error(OVERLAY_WITH_MULTIPLE_CHILDREN_REQUIRES_CHILD_REFS);
        }
    }, [childRef, childRefs, numChildren]);
}

/**
 * Generates a unique ID for a given Overlay which persists across the component's lifecycle.
 */
function useOverlay2ID(): string {
    // TODO: migrate to React.useId() in React 18
    const id = useUID();
    return `${Overlay2.displayName}-${id}`;
}

// N.B. the `onExiting` callback is not provided with the `node` argument as suggested in CSSTransition types since
// we are using the `nodeRef` prop, so we must inject it dynamically.
function getLifecycleCallbackWithChildRef(
    callback: ((node: HTMLElement) => void) | undefined,
    childRef: React.RefObject<HTMLElement> | undefined,
) {
    return () => {
        if (childRef?.current != null) {
            callback?.(childRef.current);
        }
    };
}

================================================================================

File: src\components\overlay2\overlayInstance.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { OverlayProps } from "../overlay/overlayProps";

/**
 * Public instance properties & methods for an overlay in the current overlay stack.
 */
export interface OverlayInstance {
    /**
     * Bring document focus inside this overlay element.
     * This should be defined if `props.enforceFocus={true}` or `props.autoFocus={true}`.
     */
    bringFocusInsideOverlay?: () => void;

    /** Reference to the overlay container element which may or may not be in a Portal. */
    containerElement: React.RefObject<HTMLDivElement>;

    /**
     * Document "focus" event handler which needs to be attached & detached appropriately.
     * This should be defined if `props.enforceFocus={true}`.
     */
    handleDocumentFocus?: (e: FocusEvent) => void;

    /**
     * Document "mousedown" event handler which needs to be attached & detached appropriately.
     * This should be defined if `props.canOutsideClickClose={true}` and `props.hasBackdrop={false}`.
     */
    handleDocumentMousedown?: (e: MouseEvent) => void;

    /** Unique ID for this overlay which helps to identify it across prop changes. */
    id: string;

    /** Subset of props necessary for some overlay stack focus management logic. */
    props: Pick<OverlayProps, "autoFocus" | "enforceFocus" | "usePortal" | "hasBackdrop">;
}

================================================================================

File: src\components\panel-stack\panel-stack.md
--------------------------------------------------------------------------------
---
tag: deprecated
---

@# Panel stack

<div class="@ns-callout @ns-intent-danger @ns-icon-error @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated: use [PanelStack2](#core/components/panel-stack2)

</h5>

This API is **deprecated since @blueprintjs/core v3.40.0** in favor of the new
**PanelStack2** component. You should migrate to the new API which will become the
standard in a future major version of Blueprint.

</div>

`PanelStack` manages a stack of panels and displays only the topmost panel.

Each panel appears with a header containing a "back" button to return to the
previous panel. The bottom-most `initialPanel` cannot be closed or removed from
the stack. Panels use
[`CSSTransition`](http://reactcommunity.org/react-transition-group/css-transition)
for seamless transitions.

By default, only the currently active panel is rendered to the DOM. This means
that other panels are unmounted and can lose their component state as a user
transitions between the panels. You can notice this in the example below as
the numeric counter is reset. To render all panels to the DOM and keep their
React trees mounted, change the `renderActivePanelOnly` prop.

@reactExample PanelStackExample

@## Panels

Panels are supplied as `IPanel` objects like `{ component, props, title }`,
where `component` and `props` are used to render the panel element and `title`
will appear in the header and back button. This breakdown allows the component
to avoid cloning elements. Note that each panel is only mounted when it is atop
the stack and is unmounted when it is closed or when a panel opens above it.

`PanelStack` injects its own `IPanelProps` into each panel (in addition to the
`props` defined alongside the `component`), providing methods to imperatively
close the current panel or open a new one on top of it.

```tsx
import { Button, IPanelProps, PanelStack } from "@blueprintjs/core";

class MyPanel extends React.Component<IPanelProps> {
    public render() {
        return <Button onClick={this.openSettingsPanel} text="Settings" />;
    }

    private openSettingsPanel() {
        // openPanel (and closePanel) are injected by PanelStack
        this.props.openPanel({
            component: SettingsPanel, // <- class or stateless function type
            props: { enabled: true }, // <- SettingsPanel props without IPanelProps
            title: "Settings", // <- appears in header and back button
        });
    }
}

class SettingsPanel extends React.Component<IPanelProps & { enabled: boolean }> {
    // ...
}

<PanelStack initialPanel={{ component: MyPanel, title: "Home" }} />;
```

@interface IPanel

@interface IPanelProps

@## Props interface

PanelStack can be operated as a controlled or uncontrolled component.

@interface IPanelStackProps

================================================================================

File: src\components\panel-stack\panelProps.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview This component is DEPRECATED, and the code is frozen.
 * All changes & bugfixes should be made to PanelStack2 instead.
 */

/* eslint-disable deprecation/deprecation */

import type * as React from "react";

/**
 * An object describing a panel in a `PanelStack`.
 *
 * @deprecated use `Panel<T>` with PanelStack2
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export interface IPanel<P = {}> {
    /**
     * The component type to render for this panel. This must be a reference to
     * the component class or SFC, _not_ a JSX element, so it can be re-created
     * dynamically when needed.
     */
    component: React.ComponentType<P & IPanelProps>;

    /**
     * HTML title to be passed to the <Text> component
     */
    htmlTitle?: string;

    /**
     * The props passed to the component type when it is rendered. The methods
     * in `IPanelProps` will be injected by `PanelStack`.
     */
    props?: P;

    /**
     * The title to be displayed above this panel. It is also used as the text
     * of the back button for any panel opened by this panel.
     */
    title?: React.ReactNode;
}

/**
 * Include this interface in your panel component's props type to access these
 * two functions which are injected by `PanelStack`.
 *
 * ```tsx
 * import { IPanelProps } from "@blueprintjs/core";
 * export class SettingsPanel extends React.Component<IPanelProps & ISettingsPanelProps> {...}
 * ```
 *
 * @deprecated use `PanelActions<T>` with PanelStack2
 */
export interface IPanelProps {
    /**
     * Call this method to programatically close this panel. If this is the only
     * panel on the stack then this method will do nothing.
     *
     * Remember that the panel header always contains a "back" button that
     * closes this panel on click (unless there is only one panel on the stack).
     */
    closePanel(): void;

    /**
     * Call this method to open a new panel on the top of the stack.
     */
    openPanel<P>(panel: IPanel<P>): void;
}

================================================================================

File: src\components\panel-stack\panelStack.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";
import { CSSTransition, TransitionGroup } from "react-transition-group";

import { AbstractPureComponent, Classes } from "../../common";
import * as Errors from "../../common/errors";
import type { Props } from "../../common/props";

import type { IPanel } from "./panelProps";
import { PanelView } from "./panelView";

/* eslint-disable deprecation/deprecation */

export interface PanelStackProps extends Props {
    /**
     * The initial panel to show on mount. This panel cannot be removed from the
     * stack and will appear when the stack is empty.
     * This prop is only used in uncontrolled mode and is thus mutually
     * exclusive with the `stack` prop.
     */
    initialPanel?: IPanel<any>;

    /**
     * Callback invoked when the user presses the back button or a panel invokes
     * the `closePanel()` injected prop method.
     */
    onClose?: (removedPanel: IPanel) => void;

    /**
     * Callback invoked when a panel invokes the `openPanel(panel)` injected
     * prop method.
     */
    onOpen?: (addedPanel: IPanel) => void;

    /**
     * If false, PanelStack will render all panels in the stack to the DOM, allowing their
     * React component trees to maintain state as a user navigates through the stack.
     * Panels other than the currently active one will be invisible.
     *
     * @default true
     */
    renderActivePanelOnly?: boolean;

    /**
     * Whether to show the header with the "back" button in each panel.
     *
     * @default true
     */
    showPanelHeader?: boolean;

    /**
     * The full stack of panels in controlled mode. The last panel in the stack
     * will be displayed.
     */
    stack?: Array<IPanel<any>>;
}

export interface PanelStackState {
    /** Whether the stack is currently animating the push or pop of a panel. */
    direction: "push" | "pop";

    /** The current stack of panels. The first panel in the stack will be displayed. */
    stack: IPanel[];
}

/**
 * Panel stack component.
 *
 * @see https://blueprintjs.com/docs/#core/components/panel-stack
 * @deprecated use `PanelStack2<T>`
 */

export class PanelStack extends AbstractPureComponent<PanelStackProps, PanelStackState> {
    public state: PanelStackState = {
        direction: "push",
        stack:
            this.props.stack != null
                ? this.props.stack.slice().reverse()
                : this.props.initialPanel !== undefined
                  ? [this.props.initialPanel]
                  : [],
    };

    public componentDidUpdate(prevProps: PanelStackProps, prevState: PanelStackState) {
        super.componentDidUpdate(prevProps, prevState);

        // Always update local stack if stack prop changes
        if (this.props.stack !== prevProps.stack && prevProps.stack != null) {
            this.setState({ stack: this.props.stack!.slice().reverse() });
        }

        // Only update animation direction if stack length changes
        const stackLength = this.props.stack != null ? this.props.stack.length : 0;
        const prevStackLength = prevProps.stack != null ? prevProps.stack.length : 0;
        if (stackLength !== prevStackLength && prevProps.stack != null) {
            this.setState({
                direction: prevProps.stack.length - this.props.stack!.length < 0 ? "push" : "pop",
            });
        }
    }

    public render() {
        const classes = classNames(
            Classes.PANEL_STACK,
            `${Classes.PANEL_STACK}-${this.state.direction}`,
            this.props.className,
        );
        return (
            <TransitionGroup className={classes} component="div">
                {this.renderPanels()}
            </TransitionGroup>
        );
    }

    protected validateProps(props: PanelStackProps) {
        if (
            (props.initialPanel == null && props.stack == null) ||
            (props.initialPanel != null && props.stack != null)
        ) {
            console.error(Errors.PANEL_STACK_INITIAL_PANEL_STACK_MUTEX);
        }
        if (props.stack != null && props.stack.length === 0) {
            console.error(Errors.PANEL_STACK_REQUIRES_PANEL);
        }
    }

    private renderPanels() {
        const { renderActivePanelOnly = true } = this.props;
        const { stack } = this.state;
        if (stack.length === 0) {
            return null;
        }
        const panelsToRender = renderActivePanelOnly ? [stack[0]] : stack;
        const panelViews = panelsToRender.map(this.renderPanel).reverse();
        return panelViews;
    }

    private renderPanel = (panel: IPanel, index: number) => {
        const { renderActivePanelOnly, showPanelHeader = true } = this.props;
        const { stack } = this.state;

        // With renderActivePanelOnly={false} we would keep all the CSSTransitions rendered,
        // therefore they would not trigger the "enter" transition event as they were entered.
        // To force the enter event, we want to change the key, but stack.length is not enough
        // and a single panel should not rerender as long as it's hidden.
        // This key contains two parts: first one, stack.length - index is constant (and unique) for each panel,
        // second one, active changes only when the panel becomes or stops being active.
        const layer = stack.length - index;
        const key = renderActivePanelOnly ? stack.length : layer;

        return (
            <CSSTransition classNames={Classes.PANEL_STACK} key={key} timeout={400}>
                <PanelView
                    onClose={this.handlePanelClose}
                    onOpen={this.handlePanelOpen}
                    panel={panel}
                    previousPanel={stack[index + 1]}
                    showHeader={showPanelHeader}
                />
            </CSSTransition>
        );
    };

    private handlePanelClose = (panel: IPanel) => {
        const { stack } = this.state;
        // only remove this panel if it is at the top and not the only one.
        if (stack[0] !== panel || stack.length <= 1) {
            return;
        }
        this.props.onClose?.(panel);
        if (this.props.stack == null) {
            this.setState(state => ({
                direction: "pop",
                stack: state.stack.slice(1),
            }));
        }
    };

    private handlePanelOpen = (panel: IPanel) => {
        this.props.onOpen?.(panel);
        if (this.props.stack == null) {
            this.setState(state => ({
                direction: "push",
                stack: [panel, ...state.stack],
            }));
        }
    };
}

================================================================================

File: src\components\panel-stack\panelView.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview This component is DEPRECATED, and the code is frozen.
 * All changes & bugfixes should be made to PanelStack2 instead.
 */

/* eslint-disable deprecation/deprecation */

import * as React from "react";

import { AbstractPureComponent, Classes } from "../../common";
import { Button } from "../button/buttons";
import { Text } from "../text/text";

import type { IPanel } from "./panelProps";

export interface IPanelViewProps {
    /**
     * Callback invoked when the user presses the back button or a panel invokes
     * the `closePanel()` injected prop method.
     */
    onClose: (removedPanel: IPanel<any>) => void;

    /**
     * Callback invoked when a panel invokes the `openPanel(panel)` injected
     * prop method.
     */
    onOpen: (addedPanel: IPanel<any>) => void;

    /** The panel to be displayed. */
    panel: IPanel;

    /** The previous panel in the stack, for rendering the "back" button. */
    previousPanel?: IPanel;

    /** Whether to show the header with the "back" button. */
    showHeader: boolean;
}

export class PanelView extends AbstractPureComponent<IPanelViewProps> {
    public render() {
        const { panel, onOpen } = this.props;
        // two <span> tags in header ensure title is centered as long as
        // possible, due to `flex: 1` magic.
        return (
            <div className={Classes.PANEL_STACK_VIEW}>
                {this.maybeRenderHeader()}
                <panel.component openPanel={onOpen} closePanel={this.handleClose} {...panel.props} />
            </div>
        );
    }

    private maybeRenderHeader() {
        if (!this.props.showHeader) {
            return null;
        }
        return (
            <div className={Classes.PANEL_STACK_HEADER}>
                <span>{this.maybeRenderBack()}</span>
                <Text className={Classes.HEADING} ellipsize={true} title={this.props.panel.htmlTitle}>
                    {this.props.panel.title}
                </Text>
                <span />
            </div>
        );
    }

    private maybeRenderBack() {
        if (this.props.previousPanel === undefined) {
            return null;
        }
        return (
            <Button
                aria-label="Back"
                className={Classes.PANEL_STACK_HEADER_BACK}
                icon="chevron-left"
                minimal={true}
                onClick={this.handleClose}
                small={true}
                text={this.props.previousPanel.title}
                title={this.props.previousPanel.htmlTitle}
            />
        );
    }

    private handleClose = () => this.props.onClose(this.props.panel);
}

================================================================================

File: src\components\panel-stack\_panel-stack.scss
--------------------------------------------------------------------------------
// Copyright 2018 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "@blueprintjs/core/src/common/react-transition";
@import "../card/card-variables";

.#{$ns}-panel-stack {
  overflow: hidden;
  position: relative;
}

.#{$ns}-panel-stack-header {
  align-items: center;
  box-shadow: 0 1px $pt-divider-black;
  display: flex;
  flex-shrink: 0;
  height: $pt-grid-size * 3;
  z-index: 1;

  .#{$ns}-dark & {
    box-shadow: 0 1px $pt-dark-divider-white;
  }

  // two span children act as spacers to keep the title centered.
  > span {
    align-items: stretch;
    display: flex;
    flex: 1;
  }

  .#{$ns}-heading {
    margin: 0 ($pt-grid-size * 0.5);
  }
}

.#{$ns}-button.#{$ns}-panel-stack-header-back {
  margin-left: $pt-grid-size * 0.5;
  padding-left: 0;
  white-space: nowrap;

  .#{$ns}-icon {
    // reduce margins around icon so it fits better in tight header
    margin: 0 2px;
  }
}

.#{$ns}-panel-stack-view {
  @include position-all(absolute, 0);

  background-color: $card-background-color;
  border-right: 1px solid $pt-divider-black;
  display: flex;
  flex-direction: column;

  // border between panels, visible during transition
  margin-right: -1px;
  overflow-y: auto;
  z-index: 1;

  .#{$ns}-dark & {
    background-color: $dark-card-background-color;
  }

  &:nth-last-child(n + 4) {
    display: none;
  }
}

// PUSH transition: enter from right (100%), existing panel moves off left.
.#{$ns}-panel-stack-push {
  @include react-transition-phase(
    "#{$ns}-panel-stack",
    "enter",
    (transform: translateX(100%) translate(0%), opacity: 0 1),
    $easing: ease,
    $duration: $pt-transition-duration * 4
  );
  @include react-transition-phase(
    "#{$ns}-panel-stack",
    "exit",
    (transform: translateX(-50%) translate(0%), opacity: 0 1),
    $easing: ease,
    $duration: $pt-transition-duration * 4
  );
}

// POP transition: enter from left (-50%), existing panel moves off right.
.#{$ns}-panel-stack-pop {
  @include react-transition-phase(
    "#{$ns}-panel-stack",
    "enter",
    (transform: translateX(-50%) translate(0%), opacity: 0 1),
    $easing: ease,
    $duration: $pt-transition-duration * 4
  );
  @include react-transition-phase(
    "#{$ns}-panel-stack",
    "exit",
    (transform: translateX(100%) translate(0%), opacity: 0 1),
    $easing: ease,
    $duration: $pt-transition-duration * 4
  );
}

================================================================================

File: src\components\panel-stack2\panel-stack2.md
--------------------------------------------------------------------------------
@# Panel stack (v2)

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Migrating from [PanelStack](#core/components/panel-stack)?

</h5>

__PanelStack2__ is a replacement for __PanelStack__. It will become the standard API in a future major version of
Blueprint. You are encouraged to use this new API now for forwards-compatibility. See the full
[migration guide](https://github.com/palantir/blueprint/wiki/PanelStack2-migration) on the wiki.

</div>

__PanelStack2__ manages a stack of panels and displays only the topmost panel.

Each panel appears with a header containing a "back" button to return to the previous panel. The bottom-most
`initialPanel` cannot be closed or removed from the stack. Panels use
[__CSSTransition__](http://reactcommunity.org/react-transition-group/css-transition) for seamless transitions.

By default, only the currently active panel is rendered to the DOM. This means that other panels are unmounted and can
lose their component state as a user transitions between the panels. You can notice this in the example below as the
numeric counter is reset. To render all panels to the DOM and keep their React trees mounted, change the
`renderActivePanelOnly` prop.

@reactExample PanelStack2Example

@## Panels

Panels are supplied as `Panel<T>` objects, where `renderPanel` and `props` are
used to render the panel element and `title` will appear in the header and back button.
This breakdown allows the component to avoid cloning elements.
Note that each panel is only mounted when it is atop the stack and is unmounted when
it is closed or when a panel opens above it.

`PanelStack2` injects panel action callbacks into each panel renderer in addition to
the `props` defined by `Panel<T>`. These allow you to close the current panel or open a
new one on top of it during the panel's lifecycle. For example:

```tsx
import { Button, PanelProps } from "@blueprintjs/core";

type SettingsPanelInfo = { /* ...  */ };
type AccountSettingsPanelInfo = { /* ...  */ };
type NotificationSettingsPanelInfo = { /* ...  */ };

const AccountSettingsPanel: React.FC<PanelProps<AccountSettingsPanelInfo>> = props => {
    // implementation
};

const NotificationSettingsPanel: React.FC<PanelProps<NotificationSettingsPanelInfo>> = props => {
    // implementation
};

const SettingsPanel: React.FC<PanelProps<SettingsPanelInfo>> = props => {
    const { openPanel, closePanel, ...info } = props;

    const openAccountSettings = () =>
        openPanel({
            props: {
                /* ... */
            },
            renderPanel: AccountSettingsPanel,
            title: "Account settings",
        });
    const openNotificationSettings = () =>
        openPanel({
            props: {
                /* ... */
            },
            renderPanel: NotificationSettingsPanel,
            title: "Notification settings",
        });

    return (
        <>
            <Button onClick={openAccountSettings} text="Account settings" />
            <Button onClick={openNotificationSettings} text="Notification settings" />
        </>
    );
}
```

@interface Panel

@interface PanelActions

@## Props interface

__PanelStack2__ can be operated as a controlled or uncontrolled component.

If controlled, panels should be added to and removed from the _end_ of the `stack` array.

@interface PanelStack2Props

================================================================================

File: src\components\panel-stack2\panelStack2.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";
import { CSSTransition, TransitionGroup } from "react-transition-group";

import { Classes, DISPLAYNAME_PREFIX, type Props } from "../../common";
import { usePrevious } from "../../hooks";

import type { Panel } from "./panelTypes";
import { PanelView2 } from "./panelView2";

/**
 * @template T type union of all possible panels in this stack
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export interface PanelStack2Props<T extends Panel<object>> extends Props {
    /**
     * The initial panel to show on mount. This panel cannot be removed from the
     * stack and will appear when the stack is empty.
     * This prop is only used in uncontrolled mode and is thus mutually
     * exclusive with the `stack` prop.
     */
    initialPanel?: T;

    /**
     * Callback invoked when the user presses the back button or a panel
     * closes itself with a `closePanel()` action.
     */
    onClose?: (removedPanel: T) => void;

    /**
     * Callback invoked when a panel opens a new panel with an `openPanel(panel)`
     * action.
     */
    onOpen?: (addedPanel: T) => void;

    /**
     * If false, PanelStack will render all panels in the stack to the DOM, allowing their
     * React component trees to maintain state as a user navigates through the stack.
     * Panels other than the currently active one will be invisible.
     *
     * @default true
     */
    renderActivePanelOnly?: boolean;

    /**
     * Whether to show the header with the "back" button in each panel.
     *
     * @default true
     */
    showPanelHeader?: boolean;

    /**
     * The full stack of panels in controlled mode. The last panel in the stack
     * will be displayed.
     */
    stack?: readonly T[];
}

interface PanelStack2Component {
    /**
     * @template T type union of all possible panels in this stack
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    <T extends Panel<object>>(props: PanelStack2Props<T>): React.JSX.Element | null;
    displayName: string;
}

/**
 * Panel stack (v2) component.
 *
 * @see https://blueprintjs.com/docs/#core/components/panel-stack2
 * @template T type union of all possible panels in this stack
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export const PanelStack2: PanelStack2Component = <T extends Panel<object>>(props: PanelStack2Props<T>) => {
    const {
        initialPanel,
        onClose,
        onOpen,
        renderActivePanelOnly = true,
        showPanelHeader = true,
        stack: propsStack,
    } = props;
    const isControlled = propsStack != null;

    const [localStack, setLocalStack] = React.useState<T[]>(initialPanel !== undefined ? [initialPanel] : []);
    const stack = React.useMemo(
        () => (isControlled ? propsStack.slice().reverse() : localStack),
        [localStack, isControlled, propsStack],
    );
    const prevStackLength = usePrevious(stack.length) ?? stack.length;
    const direction = stack.length - prevStackLength < 0 ? "pop" : "push";

    const handlePanelOpen = React.useCallback(
        (panel: T) => {
            onOpen?.(panel);
            if (!isControlled) {
                setLocalStack(prevStack => [panel, ...prevStack]);
            }
        },
        [onOpen, isControlled],
    );
    const handlePanelClose = React.useCallback(
        (panel: T) => {
            onClose?.(panel);
            if (!isControlled) {
                setLocalStack(prevStack => prevStack.slice(1));
            }
        },
        [onClose, isControlled],
    );

    // early return, after all hooks are called
    if (stack.length === 0) {
        return null;
    }

    const panelsToRender = renderActivePanelOnly ? [stack[0]] : stack;
    const panels = panelsToRender
        .map((panel: T, index: number) => {
            // With renderActivePanelOnly={false} we would keep all the CSSTransitions rendered,
            // therefore they would not trigger the "enter" transition event as they were entered.
            // To force the enter event, we want to change the key, but stack.length is not enough
            // and a single panel should not rerender as long as it's hidden.
            // This key contains two parts: first one, stack.length - index is constant (and unique) for each panel,
            // second one, active changes only when the panel becomes or stops being active.
            const layer = stack.length - index;
            const key = renderActivePanelOnly ? stack.length : layer;

            return (
                <CSSTransition classNames={Classes.PANEL_STACK2} key={key} timeout={400}>
                    <PanelView2<T>
                        onClose={handlePanelClose}
                        onOpen={handlePanelOpen}
                        panel={panel}
                        previousPanel={stack[index + 1]}
                        showHeader={showPanelHeader}
                    />
                </CSSTransition>
            );
        })
        .reverse();

    const classes = classNames(Classes.PANEL_STACK2, `${Classes.PANEL_STACK2}-${direction}`, props.className);

    return (
        <TransitionGroup className={classes} component="div">
            {panels}
        </TransitionGroup>
    );
};
PanelStack2.displayName = `${DISPLAYNAME_PREFIX}.PanelStack2`;

================================================================================

File: src\components\panel-stack2\panelTypes.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * An object describing a panel in a `PanelStack2`.
 */
export interface Panel<P> {
    /**
     * The renderer for this panel.
     */
    renderPanel: React.FC<PanelProps<P>>;

    /**
     * HTML title to be passed to the <Text> component
     */
    htmlTitle?: string;

    /**
     * The props passed to the component type when it is rendered. The methods
     * in `PanelActions` will be injected by `PanelStack2`.
     */
    props?: P;

    /**
     * The title to be displayed above this panel. It is also used as the text
     * of the back button for any panel opened by this panel.
     */
    title?: React.ReactNode;
}

export interface PanelActions {
    /**
     * Call this method to programatically close this panel. If this is the only
     * panel on the stack then this method will do nothing.
     *
     * Remember that the panel header always contains a "back" button that
     * closes this panel on click (unless there is only one panel on the stack).
     */
    closePanel(): void;

    /**
     * Call this method to open a new panel on the top of the stack.
     */
    openPanel<P>(panel: Panel<P>): void;
}

/**
 * Use this interface in your panel component's props type to access these
 * panel action callbacks which are injected by `PanelStack2`.
 *
 * See the code example in the docs website.
 *
 * @see https://blueprintjs.com/docs/#core/components/panel-stack2
 */
export type PanelProps<P> = P & PanelActions;

================================================================================

File: src\components\panel-stack2\panelView2.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

import { Classes, DISPLAYNAME_PREFIX } from "../../common";
import { Button } from "../button/buttons";
import { Text } from "../text/text";

import type { Panel, PanelProps } from "./panelTypes";

// eslint-disable-next-line @typescript-eslint/ban-types
export interface PanelView2Props<T extends Panel<object>> {
    /**
     * Callback invoked when the user presses the back button or a panel invokes
     * the `closePanel()` injected prop method.
     */
    onClose: (removedPanel: T) => void;

    /**
     * Callback invoked when a panel invokes the `openPanel(panel)` injected
     * prop method.
     */
    onOpen: (addedPanel: T) => void;

    /** The panel to be displayed. */
    panel: T;

    /** The previous panel in the stack, for rendering the "back" button. */
    previousPanel?: T;

    /** Whether to show the header with the "back" button. */
    showHeader: boolean;
}

interface PanelView2Component {
    // eslint-disable-next-line @typescript-eslint/ban-types
    <T extends Panel<object>>(props: PanelView2Props<T>): React.JSX.Element | null;
    displayName: string;
}

// eslint-disable-next-line @typescript-eslint/ban-types
export const PanelView2: PanelView2Component = <T extends Panel<object>>({
    panel,
    onClose,
    onOpen,
    previousPanel,
    showHeader,
}: PanelView2Props<T>) => {
    const hasPreviousPanel = previousPanel !== undefined;
    const handleClose = React.useCallback(() => {
        // only remove this panel if it is not the only one.
        if (hasPreviousPanel) {
            onClose(panel);
        }
    }, [onClose, panel, hasPreviousPanel]);

    const maybeBackButton =
        previousPanel === undefined ? null : (
            <Button
                aria-label="Back"
                className={Classes.PANEL_STACK_HEADER_BACK}
                icon="chevron-left"
                minimal={true}
                onClick={handleClose}
                small={true}
                text={previousPanel.title}
                title={previousPanel.htmlTitle}
            />
        );

    // `panel.renderPanel` is simply a function that returns a React.JSX.Element. It may be an FC which
    // uses hooks. In order to avoid React errors due to inconsistent hook calls, we must encapsulate
    // those hooks with their own lifecycle through a very simple wrapper component.
    const PanelWrapper: React.FC = React.useMemo(
        () => () =>
            // N.B. A type cast is required because of error TS2345, where technically `panel.props` could be
            // instantiated with a type unrelated to our generic constraint `T` here. We know
            // we're sending the right values here though, and it makes the consumer API for this
            // component type safe, so it's ok to do this...
            panel.renderPanel({
                closePanel: handleClose,
                openPanel: onOpen,
                ...panel.props,
            } as PanelProps<T>),
        [panel, handleClose, onOpen],
    );

    return (
        <div className={Classes.PANEL_STACK2_VIEW}>
            {showHeader && (
                <div className={Classes.PANEL_STACK2_HEADER}>
                    {/* two <span> tags here ensure title is centered as long as possible, with `flex: 1` styling */}
                    <span>{maybeBackButton}</span>
                    <Text className={Classes.HEADING} ellipsize={true} title={panel.htmlTitle}>
                        {panel.title}
                    </Text>
                    <span />
                </div>
            )}
            <PanelWrapper />
        </div>
    );
};
PanelView2.displayName = `${DISPLAYNAME_PREFIX}.PanelView2`;

================================================================================

File: src\components\panel-stack2\_panel-stack2.scss
--------------------------------------------------------------------------------
// Copyright 2021 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "@blueprintjs/core/src/common/react-transition";
@import "../card/card-variables";

.#{$ns}-panel-stack2 {
  overflow: hidden;
  position: relative;
}

.#{$ns}-panel-stack2-header {
  align-items: center;
  box-shadow: 0 1px $pt-divider-black;
  display: flex;
  flex-shrink: 0;
  height: $pt-grid-size * 3;
  z-index: 1;

  .#{$ns}-dark & {
    box-shadow: 0 1px $pt-dark-divider-white;
  }

  // two span children act as spacers to keep the title centered.
  > span {
    align-items: stretch;
    display: flex;
    flex: 1;
  }

  .#{$ns}-heading {
    margin: 0 ($pt-grid-size * 0.5);
  }
}

.#{$ns}-button.#{$ns}-panel-stack2-header-back {
  margin-left: $pt-grid-size * 0.5;
  padding-left: 0;
  white-space: nowrap;

  .#{$ns}-icon {
    // reduce margins around icon so it fits better in tight header
    margin: 0 2px;
  }
}

.#{$ns}-panel-stack2-view {
  @include position-all(absolute, 0);

  background-color: $card-background-color;
  border-right: 1px solid $pt-divider-black;
  display: flex;
  flex-direction: column;

  // border between panels, visible during transition
  margin-right: -1px;
  overflow-y: auto;
  z-index: 1;

  .#{$ns}-dark & {
    background-color: $dark-card-background-color;
  }

  &:nth-last-child(n + 4) {
    display: none;
  }
}

// PUSH transition: enter from right (100%), existing panel moves off left.
.#{$ns}-panel-stack2-push {
  @include react-transition-phase(
    "#{$ns}-panel-stack2",
    "enter",
    (transform: translateX(100%) translate(0%), opacity: 0 1),
    $easing: ease,
    $duration: $pt-transition-duration * 4
  );
  @include react-transition-phase(
    "#{$ns}-panel-stack2",
    "exit",
    (transform: translateX(-50%) translate(0%), opacity: 0 1),
    $easing: ease,
    $duration: $pt-transition-duration * 4
  );
}

// POP transition: enter from left (-50%), existing panel moves off right.
.#{$ns}-panel-stack2-pop {
  @include react-transition-phase(
    "#{$ns}-panel-stack2",
    "enter",
    (transform: translateX(-50%) translate(0%), opacity: 0 1),
    $easing: ease,
    $duration: $pt-transition-duration * 4
  );
  @include react-transition-phase(
    "#{$ns}-panel-stack2",
    "exit",
    (transform: translateX(100%) translate(0%), opacity: 0 1),
    $easing: ease,
    $duration: $pt-transition-duration * 4
  );
}

================================================================================

File: src\components\popover\customModifiers.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2022 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview custom Popper.js modifiers
 * @see https://popper.js.org/docs/v2/modifiers/#custom-modifiers
 */

import type { Modifier } from "@popperjs/core";

// tslint:disable object-literal-sort-keys

// adapted from https://popper.js.org/docs/v2/modifiers/community-modifiers/
export const matchReferenceWidthModifier: Modifier<"matchReferenceWidth", any> = {
    enabled: true,
    name: "matchReferenceWidth",
    phase: "beforeWrite",
    requires: ["computeStyles"],
    fn: ({ state }) => {
        state.styles.popper.width = `${state.rects.reference.width}px`;
    },
    effect: ({ state }) => {
        const referenceWidth = state.elements.reference.getBoundingClientRect().width;
        state.elements.popper.style.width = `${referenceWidth}px`;
    },
};

================================================================================

File: src\components\popover\menu-item.md
--------------------------------------------------------------------------------
@# MenuItem

A MenuItem is a single interactive item in a [Menu](#core/components/menu).

@reactExample MenuItemExample

@## Markup

This component renders an `<li>` element containing an `<a>` anchor element.
Use the required `text` prop for text label content.
To make the menu item interactive, provide the `href`, `target`, and `onClick` props as necessary.

MenuItem supports multiple "role structures" which allow it to be used in different contexts
depending on the `role` attribute of its parent `<ul>` list:

- `roleStructure="menuitem"` is the default. This is appropriate for a `<ul role="menu">` parent.
    The item will render with `<li role="none">` and `<a role="menuitem">`.
- `roleStructure="listoption"` is appropriate for a `<ul role="listbox">` parent, such as
    those found in Select2, Suggest2, and MultiSelect2 components. The item will render with
    `<li role="option">` and `<a>` (anchor role undefined).
- `roleStructure="listitem"` is appropriate for a `<ul>` (no role defined) or a `<ul role="list">` parent. The
    item will render with `<li>` and `<a>` (roles undefined).
- `roleStructure="none"` is useful when wrapping in a custom `<li>`. The
    item will render with `<li role="none">` and `<a>` (roles undefined).

@## Selection state

When `roleStructure="listoption"` is set, MenuItem has built-in support for indicating selection state
using an icon on the left side of the item element. This works for both single- and multi-selection, like the
kind you would find in Select2, Suggest2, or MultiSelect2 components.

Specify selection state with the `selected?: boolean | undefined` prop. Note that `undefined` is only recommended
with `roleStructure="menuitem"`, and an explicit boolean value (`true` or `false`) should be set when using
`roleSTructure="listoption"` &mdash; this ensures consistent padding on the left side of menu items which are
not currently selected.

Also note that the `icon` prop will take precedence over `selected` if specified, and using them both at the same
time is not recommended.

@## Submenus

Menu items may have submenus when nested MenuItem `children` are defined. These nested items will
be displayed inside a popover next to the active menu item on hover. Here's a code example:

```tsx
import { Menu, MenuItem } from "@blueprintjs/core";

function Example() {
    return (
        <Menu>
            <MenuItem text="See more">
                <MenuItem text="First submenu item" />
                <MenuItem text="Second submenu item" />
            </MenuItem>
        </Menu>
    )
}
```

@## Props interface

@interface MenuItemProps

================================================================================

File: src\components\popover\popover.md
--------------------------------------------------------------------------------
@# Popover

Popovers display floating content next to a target element.

The **Popover** component is built on top of the [**Popper.js**](https://popper.js.org) library.
Popper.js is a small library that offers a powerful, customizable, and performant positioning engine.

@reactExample PopoverExample

@## Usage

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

[OverlaysProvider](#core/context/overlays-provider) recommended

</h5>

This component renders an **Overlay2** which works best inside a React tree which includes an
**OverlaysProvider**. Blueprint v5.x includes a backwards-compatibile shim which allows this context
to be optional, but it will be required in a future major version. See the full
[migration guide](https://github.com/palantir/blueprint/wiki/Overlay2-migration) on the wiki.

</div>

**Popover** supports controlled and uncontrolled usage through `isOpen` and `defaultIsOpen`, respectively.
Use `onInteraction` in controlled mode to respond to changes in the `isOpen` state.

Supported user interactions are dictated by the `interactionKind` prop.

This component is quite powerful and has a wide range of features. Explore the
[**Concepts**](#core/components/popover.concepts) section below for more advanced
usage guides.

@## Props interface

@interface PopoverProps

@## Concepts

@### Structure

When creating a popover, you must specify both its **content** (via the `content` prop) and
its **target** (via the `renderTarget` prop or a single child element).

The **target** is rendered at the location of the Popover component in the React component tree. It acts
as the trigger for the popover; user interaction will show the popover based on the `interactionKind` prop.
In Popper.js terms, this is the popper "reference". There are two ways to render a Popover target, resulting
in different DOM layout depending on your application's needs:

-   The simplest way to specify a target is via `children`. Provide a single React child to
    `<Popover>` and the component will render that child wrapped in a `@ns-popover-target` HTML element.
    This wrapper is configured with event handling logic necessary for the Popover to function. Its tag name
    (e.g. `div`, `span`) and props can be customized with the `targetTagName` and `targetProps` props, respectively.

-   A more advanced API is available through the `renderTarget` prop. Here, Popover provides you with all the
    information necessary to render a functional popover with a [render prop](https://reactjs.org/docs/render-props.html).
    You are responsible for then propogating that information with an
    [object spread](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals)
    to the `React.JSX.Element` returned from `renderTarget`.

    -   If the rendered element is _not_ a native HTML element, you must ensure that it supports the
        `className`, `ref`, and `tabIndex` props (i.e. renders them out to the DOM).

    -   The benefit to this approach is a simplified DOM structure without an extra wrapper element around
        your popover target.

The **content** will be shown inside the popover itself. When opened, the popover will always be
positioned on the page next to the target; the `placement` prop determines its relative placement (on
which side of the target).

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">Button targets</h5>

Buttons make great popover targets, but the `disabled` attribute on a `<button>` blocks all
events, which interferes with the popover functioning. If you need to disable a button which
triggers a popover, you should use [`AnchorButton`](#core/components/button.anchor-button) instead.
See the [callout here](#core/components/button.props) for more details.

</div>

```tsx
import { Button, Classes, Popover } from "@blueprintjs/core";

export class PopoverExample extends React.PureComponent {
    public render() {
        // popover content gets no padding by default; add the "@ns-popover-content-sizing"
        // class to the popover to set nice padding between its border and content.
        return (
            <Popover
                interactionKind="click"
                popoverClassName={Classes.POPOVER_CONTENT_SIZING}
                placement="bottom"
                content={
                    <div>
                        <h5>Popover title</h5>
                        <p>...</p>
                        <Button className={Classes.POPOVER_DISMISS} text="Dismiss" />
                    </div>
                }
                renderTarget={({ isOpen, ...targetProps }) => (
                    <Button {...targetProps} intent="primary" text="Popover target" />
                )}
            />
        );
    }
}
```

@### Placement

The `placement` prop controls the popover's position relative to the target. Popover passes this prop directly
to Popper.js; it uses the same semantics and supported values
[as shown here in the docs](https://popper.js.org/docs/v2/constructors/#options).

`import { PopperPlacements } from "@blueprintjs/core"` defines the full set of supported values.
There are straightforward base placements (`"top"`, `"bottom"`, `"left"`, `"right"`) and their variations, which
each consist of two attributes:

-   Which <span class="docs-popover-placement-label-side">**side**</span> of the target the popover should render on.
-   The popover's <span class="docs-popover-placement-label-alignment">**alignment**</span> relative to the target.

These two attributes can be expressed with a single value having the following structure:

<pre class="docs-popover-placement-value-code-block">
    <span class="docs-popover-placement-label-side">[SIDE]</span>-<span class="docs-popover-placement-label-alignment">[ALIGNMENT]</span>
</pre>

The following example shows all supported `Position` values and how each behaves in practice.
Note that if <strong><code>\-<span class="docs-popover-position-label-alignment">[ALIGNMENT]</span></code></strong> is ommitted,
the popover will align to the **center** of the target.

@reactExample PopoverPlacementExample

#### Automatic placement

Lastly, there is an `"auto"` placement which picks the side with the best available space.
See the [popper.js docs](https://popper.js.org/docs/v2/constructors/#options) for more info.

The Popover's `placement` can also be chosen _automatically_ by specifying `"auto"`, `"auto-start"`, or `"auto-end"`.
All of these options choose and continually update the <span class="docs-popover-placement-label-side">**side**</span>
for you to avoid overflowing the boundary element (when scrolling within it, for instance).
The options differ in how they handle <span class="docs-popover-placement-label-alignment">**alignment**</span>:

-   In `"auto"` mode (the default value for the `placement` prop), the Popover will align itself to the center of the target as it flips sides.
-   In `"auto-start"` mode, the Popover will align itself to the `start` of the target (i.e., the top edge when the popover is on the left or right, or the left edge when the popover is on the top or bottom).
-   In `"auto-end"` mode, the Popover will align itself to the `end` of the target (i.e., the bottom edge when the popover is on the left or right, or the right edge when the popover is on the top or bottom).

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign">

You can also specify a specific initial placement (e.g. `"left"`, `"bottom-start"`) and still update the Popover's position
automatically by enabling the modifiers `flip` and `preventOverflow`.
[See below](#core/components/popover.modifiers) for information about modifiers.

</div>

@### Modifiers

Modifiers allow us to customize Popper.js's positioning behavior. **Popover** configures several of Popper.js's built-in
modifiers to handle things such as flipping, preventing overflow from a boundary element, and positioning the arrow.

You may override the default modifiers with the `modifiers` prop, which is an object with key-value pairs representing
the modifier name and its options object, respectively. See the
[Popper.js modifiers docs page](https://popper.js.org/docs/v2/modifiers/) for more info.

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">Auto placement requires flip modifier</h5>

Be careful when disabling the "flip" modifier, since the default "auto" placement relies on it. If you _do_ decide
to disable this modifier, be sure to also specify a placement which is not "auto".

</div>

You may also add custom modifiers using the `modifiersCustom` prop. See the
[Popper.js custom modifiers documentation](https://popper.js.org/docs/v2/modifiers/#custom-modifiers) for more info.

@### Controlled mode

If you prefer to have more control over your popover's behavior, you can specify the `isOpen`
property to use the component in **controlled mode**. You are now in charge of the component's
open state.

Providing a non-null value for `isOpen` disables all automatic interaction and instead invokes
the `onInteraction` callback prop any time the opened state _would have changed_ in response to
user interaction under the current `interactionKind`.

Note that there are cases where `onInteraction` is invoked with an unchanged open state.
It is important to pay attention to the value of the `nextOpenState` parameter and determine
in your application logic whether you should care about a particular invocation (for instance,
if the `nextOpenState` is not the same as the **Popover**'s current state).

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">Disabling controlled popovers</h5>

If `disabled={true}`, a controlled popover will remain closed even if `isOpen={true}`.
The popover will re-open when `disabled` is set to `false`.

</div>

#### Example controlled usage

```tsx
import { Button, Classes, Popover } from "@blueprintjs/core";

export class ControlledPopoverExample extends React.Component<{}, { isOpen: boolean }> {
    public state = { isOpen: false };

    public render() {
        return (
            <Popover
                content={
                    <div>
                        <h5>Popover Title</h5>
                        <p>...</p>
                        <Button className={Classes.POPOVER_DISMISS} text="Close popover" />
                    </div>
                }
                interactionKind="click"
                isOpen={this.state.isOpen}
                onInteraction={state => this.handleInteraction(state)}
                placement="right"
            >
                <Button intent="primary" text="Popover target" />
            </Popover>
        );
    }

    private handleInteraction(nextOpenState: boolean) {
        this.setState({ isOpen: nextOpenState });
    }
}
```

@### Interactions

The `interactionKind` prop governs how the popover should open and close in response to user interactions.
The supported values are:

-   `HOVER`
    -   **Opens when:** the target is hovered
    -   **Closes when:** the cursor is no longer inside the target _or_ the popover
-   `HOVER_TARGET_ONLY`:
    -   **Opens when:** the target is hovered
    -   **Closes when:** the cursor is no longer inside the target
-   `CLICK`:
    -   **Opens when:** the target is clicked, or when Enter or Shift key are pressed while target is focused
    -   **Closes when:** the user clicks anywhere outside of the popover (including the target)
-   `CLICK_TARGET_ONLY`:
    -   **Opens when:** the target is clicked, or when Enter or Shift key are pressed while target is focused
    -   **Closes when:** the target is clicked

The following example demonstrates the various interaction kinds (note: these Popovers contain
[MenuItem](#core/components/menu.menu-item)s with `shouldDismissPopover={false}`, for clarity):

@reactExample PopoverInteractionKindExample

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">Conditionally styling popover targets</h5>

When a popover is open, `Classes.POPOVER_OPEN` is applied to the target.
You can use this to style the target differently when the popover is open.

</div>

@### Closing on click

Sometimes it is desirable for an element inside a Popover's content to close the popover on click. Popover supports a
pair of CSS classes, `Classes.POPOVER_DISMISS` and `Classes.POPOVER_DISMISS_OVERRIDE`, which can be added to elements to
describe whether click events should dismiss the enclosing popover.

To mark an element (and its children) as "dismiss elements", you may add the class `Classes.POPOVER_DISMISS`.
For example, the **Cancel** and **Delete** buttons in the top-level [Popover example](#core/components/popover) have
this class, and all MenuItems receive this class by default (see `shouldDismissPopover` prop). To enable this behavior
on the entire popover body, pass `popoverClassName={Classes.POPOVER_DISMISS}`.

Cancel the dismiss behavior on subtrees by nesting `Classes.POPOVER_DISMISS_OVERRIDE` inside `Classes.POPOVER_DISMISS`.
Clicks originating inside disabled elements (either via the `disabled` attribute or `Classes.DISABLED`) will never
dismiss a popover.

Additionally, the prop `captureDismiss` (disabled by default) will prevent click events from dismissing _ancestor_
popovers (not the Popover immediately containing the dismiss element). MenuItem disables this feature such that clicking
any submenu item will close all submenus, which is desirable behavior for a menu tree.

```tsx
<div className={Classes.POPOVER_DISMISS}>
    <button>Click me to dismiss</button>
    <button disabled={true}>I will not dismiss</button>
    <div className={Classes.POPOVER_DISMISS_OVERRIDE}>
        <button>I too shall not dismiss</button>
    </div>
</div>
```

@reactExample PopoverDismissExample

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign">

Dismiss elements won't have any effect in a popover with `interactionKind="hover-target"` because there is no way to
interact with the popover content itself: the popover is dismissed the moment the user mouses away from the target.

</div>

@### Backdrop

The `hasBackdrop` prop governs whether a backdrop appears while the popover is open. When `true`:

-   **A transparent backdrop will render beneath the popover**. This backdrop
    covers the entire viewport and prevents interaction with the document until
    the popover is closed. This is useful for preventing stray clicks or hovers in
    your app when the user tries to close a popover.
-   **The popover will receive focus when opened**, allowing for better keyboard accessibility.

Clicking the backdrop will:

-   _in uncontrolled mode_, close the popover.
-   _in controlled mode_, invoke the `onInteraction` callback with an argument of `false`.

This backdrop behavior is only available for popovers with `interactionKind="click"`.
An error is thrown if used otherwise.

#### Styling the backdrop

By default, the popover backdrop is invisible, but you can easily add your own styles to
`.@ns-popover-backdrop` to customize the appearance of the backdrop (for example, you could give it
a translucent background color, like the backdrop for the [`Dialog`](#core/components/dialog) component).

The backdrop element has the same opacity-fade transition as the `Dialog` backdrop.

<div class="@ns-callout @ns-intent-danger @ns-icon-error @ns-callout-has-body-content">
    <h5 class="@ns-heading">Dangerous edge case</h5>

Rendering a `<Popover isOpen={true} hasBackdrop={true}>` outside the viewport bounds can easily break your application
by covering the UI with an invisible non-interactive backdrop. This edge case must be handled by your application code
or (if possible) avoided entirely.

</div>

@### Portal rendering

By default, popover contents are rendered in a [**Portal**](#core/components/portal) appended to `document.body`. This
allows the popover contents to "escape" the application DOM tree to avoid incompatible styles on ancestor elements.
(Incompatible styles typically include hidden `overflow` or complex `position` logic.) It also ensures that the popover
will appear above all other content, as its container element appears after the application container in the DOM.

Disable the `usePortal` prop to render popover contents in the normal document flow as a sibling of the target.
This behavior can be desirable to inherit CSS styles from surrounding elements, and can result in smoother performance
when scrolling. Not using a **Portal** works well for most layouts, because popovers style themselves to appear above
everything else on the page without needing to manually adjust z-indices, and Popper.js will keep them nicely positioned.

@reactExample PopoverPortalExample

@## Style

@### Dark theme

**Popover** automatically detects whether its trigger is nested inside a `.@ns-dark` container and applies the
same class to itself. You can also explicitly apply the dark theme to the React component by providing the prop
`popoverClassName="@ns-dark"`.

As a result, any component that you place inside a **Popover** (such as a `Menu`) automatically inherits the dark theme
styles. Note that [`Tooltip`](#core/components/tooltip) uses **Popover** internally, so it also benefits from this
behavior.

This behavior can be disabled (if the **Popover** uses a **Portal**) via the `inheritDarkTheme` prop.

@### Sizing

Popovers by default have a `max-width` but no `max-height`. To constrain the height of a popover and make its content
scrollable, add a custom class to your popover content element and attach styles to that class:

```tsx
<Popover content={<div className="custom-class">...</div>}>...</Popover>
```

```scss
.custom-class {
    max-height: $pt-grid-size * 15;
    overflow-y: auto;
}
```

@reactExample PopoverSizingExample

@### Minimal style

You can create a minimal popover by setting `minimal={true}`.
This removes the arrow from the popover and makes the transitions more subtle.

@reactExample PopoverMinimalExample

This minimal style is recommended for popovers that are not triggered by an obvious action like the
user clicking or hovering over something. For example, a minimal popover is useful for making
typeahead menus where the menu appears almost instantly after the user starts typing.

Minimal popovers are also useful for context menus that require quick enter and leave animations to
support fast workflows. You can see an example in the [context menus](#core/components/context-menu)
documentation.

@## Testing

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign">

Your best resource for strategies in popover testing is
[its own unit test suite.](https://github.com/palantir/blueprint/blob/develop/packages/core/test/popover/popoverTests.tsx)

</div>

#### Animation delays

**Popover** can be difficult to test because it uses **Portal** to inject its contents elsewhere in the DOM (outside the
usual flow); this can be simplified by setting `usePortal={false}` in tests. Hover interactions can also be tricky due
to delays and transitions; this can be resolved by zeroing the default hover delays.

```tsx
<Popover {...yourProps} usePortal={false} hoverCloseDelay={0} hoverOpenDelay={0}>
    {yourTarget}
</Popover>
```

#### Rendering delays

**Popover** delays rendering updates triggered on `mouseleave`, because the mouse might have moved from the popover to
the target, which may require special handling depending on the current
[`interactionKind`](#core/components/popover.interactions). Popper.js also throttles rendering updates to improve
performance. If your components are not updating in a synchronous fashion as expected, you may need to introduce a
`setTimeout` to wait for asynchronous Popover rendering to catch up:

```tsx
import { Classes, Overlay2, Popover } from "@blueprintjs/core";
import { assert } from "chai";
import { mount } from "enzyme";
import { Target } from "react-popper";

wrapper = mount(
    <Popover usePortal={false} interactionKind="hover" content={<div>Content</div>}>
        <div>Target</div>
    </Popover>,
);

wrapper.find(Target).simulate("mouseenter");

// hostNodes() is an Enzyme 3 helper that retains only native-HTML nodes.
wrapper.find(`.${Classes.POPOVER}`).hostNodes().simulate("mouseenter");
wrapper.find(`.${Classes.POPOVER}`).hostNodes().simulate("mouseleave");

setTimeout(() => {
    // Popover delays closing using setTimeout, so need to defer this check too.
    const isOpen = wrapper.find(Overlay2).prop("isOpen");
    assert.equal(isOpen, false);
});
```

#### Element refs

If `usePortal={false}` rendering is not an option, **Popover** instances expose `popoverElement` and `targetElement`
refs of the actual DOM elements. Importantly, `popoverElement` points to the `.@ns-popover` element inside the
**Portal** so you can use it to easily query popover contents without knowing precisely where they are in the DOM.
These properties exist primarily to simplify testing; do not rely on them for feature work.

```tsx
// using mount() from enzyme
const wrapper = mount(<Popover content={<div className="test">test</div>} />);
const { popoverElement } = wrapper.instance();
// popoverElement is the parent element of .@ns-popover
popoverElement.querySelector(".test").textContent; // "test"
```

================================================================================

File: src\components\popover\popover.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { State as PopperState, PositioningStrategy } from "@popperjs/core";
import classNames from "classnames";
import * as React from "react";
import {
    Manager,
    type Modifier,
    Popper,
    type PopperChildrenProps,
    Reference,
    type ReferenceChildrenProps,
} from "react-popper";

import {
    AbstractPureComponent,
    Classes,
    DISPLAYNAME_PREFIX,
    type HTMLDivProps,
    mergeRefs,
    refHandler,
    Utils,
} from "../../common";
import * as Errors from "../../common/errors";
import { Overlay2 } from "../overlay2/overlay2";
import { ResizeSensor } from "../resize-sensor/resizeSensor";
// eslint-disable-next-line import/no-cycle
import { Tooltip } from "../tooltip/tooltip";

import { matchReferenceWidthModifier } from "./customModifiers";
import { POPOVER_ARROW_SVG_SIZE, PopoverArrow } from "./popoverArrow";
import { positionToPlacement } from "./popoverPlacementUtils";
import type {
    DefaultPopoverTargetHTMLProps,
    PopoverClickTargetHandlers,
    PopoverHoverTargetHandlers,
    PopoverSharedProps,
} from "./popoverSharedProps";
import { getBasePlacement, getTransformOrigin } from "./popperUtils";
import type { PopupKind } from "./popupKind";

export const PopoverInteractionKind = {
    CLICK: "click" as const,
    CLICK_TARGET_ONLY: "click-target" as const,
    HOVER: "hover" as const,
    HOVER_TARGET_ONLY: "hover-target" as const,
};
// eslint-disable-next-line @typescript-eslint/no-redeclare
export type PopoverInteractionKind = (typeof PopoverInteractionKind)[keyof typeof PopoverInteractionKind];

export interface PopoverProps<TProps extends DefaultPopoverTargetHTMLProps = DefaultPopoverTargetHTMLProps>
    extends PopoverSharedProps<TProps> {
    /**
     * Whether the popover/tooltip should acquire application focus when it first opens.
     *
     * @default true for click interactions, false for hover interactions
     */
    autoFocus?: boolean;

    /** HTML props for the backdrop element. Can be combined with `backdropClassName`. */
    backdropProps?: React.HTMLProps<HTMLDivElement>;

    /**
     * The content displayed inside the popover.
     */
    content?: string | React.JSX.Element;

    /**
     * The kind of interaction that triggers the display of the popover.
     *
     * @default "click"
     */
    interactionKind?: PopoverInteractionKind;

    /**
     * The kind of popup displayed by the popover. Gets directly applied to the
     * `aria-haspopup` attribute of the target element. This property is
     * ignored if `interactionKind` is {@link PopoverInteractionKind.HOVER_TARGET_ONLY}.
     *
     * @default "menu" or undefined
     */
    popupKind?: PopupKind;

    /**
     * Enables an invisible overlay beneath the popover that captures clicks and
     * prevents interaction with the rest of the document until the popover is
     * closed. This prop is only available when `interactionKind` is
     * `PopoverInteractionKind.CLICK`. When popovers with backdrop are opened,
     * they become focused.
     *
     * @default false
     */
    hasBackdrop?: boolean;

    /**
     * Whether the application should return focus to the last active element in the
     * document after this popover closes.
     *
     * This is automatically set (overridden) to:
     *  - `false` for hover interaction popovers
     *  - `true` when a popover closes due to an ESC keypress
     *
     * If you are attaching a popover _and_ a tooltip to the same target, you must take
     * care to either disable this prop for the popover _or_ disable the tooltip's
     * `openOnTargetFocus` prop.
     *
     * @default false
     */
    shouldReturnFocusOnClose?: boolean;

    /**
     * Popper.js positioning strategy.
     *
     * @see https://popper.js.org/docs/v2/constructors/#strategy
     * @default "absolute"
     */
    positioningStrategy?: PositioningStrategy;
}

export interface PopoverState {
    hasDarkParent: boolean;
    // when an ESC keypress interaction closes the overlay, we want to force-enable `shouldReturnFocusOnClose` behavior
    isClosingViaEscapeKeypress: boolean;
    isOpen: boolean;
}

/**
 * Popover component, used to display a floating UI next to and tethered to a target element.
 *
 * @template T target element props interface. Consumers wishing to stay in sync with Blueprint's default target HTML
 * props interface should use the `DefaultPopoverTargetHTMLProps` type (although this is already the default type for
 * this type param).
 * @see https://blueprintjs.com/docs/#core/components/popover
 */
export class Popover<
    T extends DefaultPopoverTargetHTMLProps = DefaultPopoverTargetHTMLProps,
> extends AbstractPureComponent<PopoverProps<T>, PopoverState> {
    public static displayName = `${DISPLAYNAME_PREFIX}.Popover`;

    public static defaultProps: PopoverProps = {
        boundary: "clippingParents",
        captureDismiss: false,
        defaultIsOpen: false,
        disabled: false,
        fill: false,
        hasBackdrop: false,
        hoverCloseDelay: 300,
        hoverOpenDelay: 150,
        inheritDarkTheme: true,
        interactionKind: PopoverInteractionKind.CLICK,
        matchTargetWidth: false,
        minimal: false,
        openOnTargetFocus: true,
        // N.B. we don't set a default for `placement` or `position` here because that would trigger
        // a warning in validateProps if the other prop is specified by a user of this component
        positioningStrategy: "absolute",
        renderTarget: undefined,
        shouldReturnFocusOnClose: false,
        targetTagName: "span",
        transitionDuration: 300,
        usePortal: true,
    };

    public state: PopoverState = {
        hasDarkParent: false,
        isClosingViaEscapeKeypress: false,
        isOpen: this.getIsOpen(this.props),
    };

    /**
     * DOM element that contains the popover.
     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,
     * so this reference can be very useful for testing.
     *
     * @public for testing
     */
    public popoverElement: HTMLElement | null = null;

    /** Popover ref handler */
    private popoverRef: React.RefCallback<HTMLDivElement> = refHandler(this, "popoverElement", this.props.popoverRef);

    /**
     * Target DOM element ref.
     *
     * N.B. this must be a ref object since we pass it to `<ResizeSensor>`, which needs to know about the target
     * DOM element in order to observe its dimensions.
     *
     * @public for testing
     */
    public targetRef = React.createRef<HTMLElement>();

    /**
     * Overlay2 transition container element ref.
     */
    private transitionContainerElement = React.createRef<HTMLDivElement>();

    private cancelOpenTimeout?: () => void;

    // a flag that lets us detect mouse movement between the target and popover,
    // now that mouseleave is triggered when you cross the gap between the two.
    private isMouseInTargetOrPopover = false;

    // a flag that indicates whether the target previously lost focus to another
    // element on the same page.
    private lostFocusOnSamePage = true;

    // Reference to the Poppper.scheduleUpdate() function, this changes every time the popper is mounted
    private popperScheduleUpdate?: () => Promise<Partial<PopperState> | null>;

    private isControlled = () => this.props.isOpen !== undefined;

    // arrow is disabled if minimal, or if the arrow modifier was explicitly disabled
    private isArrowEnabled = () => !this.props.minimal && this.props.modifiers?.arrow?.enabled !== false;

    private isHoverInteractionKind = () => {
        return (
            this.props.interactionKind === PopoverInteractionKind.HOVER ||
            this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY
        );
    };

    // popper innerRef gives us a handle on the transition container, since that's what we render as the overlay child,
    // so if we want to look at our actual popover element, we need to reach inside a bit
    private getPopoverElement() {
        return this.popoverElement?.querySelector<HTMLElement>(`.${Classes.POPOVER}`);
    }

    private getIsOpen(props: PopoverProps<T>) {
        // disabled popovers should never be allowed to open.
        if (props.disabled) {
            return false;
        } else {
            return props.isOpen ?? props.defaultIsOpen!;
        }
    }

    public render() {
        const { disabled, placement, position = "auto", positioningStrategy } = this.props;
        const { isOpen } = this.state;

        if (this.getIsContentEmpty()) {
            // need to do this check in render(), because `isOpen` is derived from
            // state, and state can't necessarily be accessed in validateProps.
            if (!disabled && isOpen !== false && !Utils.isNodeEnv("production")) {
                console.warn(Errors.POPOVER_WARN_EMPTY_CONTENT);
            }
            // just render the target without a content overlay if there is no content to display
            return this.renderTarget({ ref: noop });
        }

        // Important: do not use <Reference innerRef> since it has a bug when used in React 18 strict mode
        // see https://github.com/floating-ui/react-popper/pull/459
        return (
            <Manager>
                <Reference>{this.renderTarget}</Reference>
                <Popper
                    innerRef={this.popoverRef}
                    placement={placement ?? positionToPlacement(position)}
                    strategy={positioningStrategy}
                    modifiers={this.getPopperModifiers()}
                >
                    {this.renderPopover}
                </Popper>
            </Manager>
        );
    }

    public componentDidMount() {
        this.updateDarkParent();
    }

    public componentDidUpdate(props: PopoverProps<T>, state: PopoverState) {
        super.componentDidUpdate(props, state);
        this.updateDarkParent();

        const nextIsOpen = this.getIsOpen(this.props);

        if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {
            this.setOpenState(nextIsOpen);
            // tricky: setOpenState calls setState only if this.props.isOpen is
            // not controlled, so we need to invoke setState manually here.
            this.setState({ isOpen: nextIsOpen });
        } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {
            // special case: close an uncontrolled popover when disabled is set to true
            this.setOpenState(false);
        }
    }

    protected validateProps(props: PopoverProps<T> & { children?: React.ReactNode }) {
        if (props.isOpen == null && props.onInteraction != null) {
            console.warn(Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);
        }
        if (props.hasBackdrop && !props.usePortal) {
            console.warn(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE);
        }
        if (props.hasBackdrop && props.interactionKind !== PopoverInteractionKind.CLICK) {
            console.warn(Errors.POPOVER_HAS_BACKDROP_INTERACTION);
        }
        if (props.placement !== undefined && props.position !== undefined) {
            console.warn(Errors.POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX);
        }

        const childrenCount = React.Children.count(props.children);
        const hasRenderTargetProp = props.renderTarget !== undefined;
        const hasTargetPropsProp = props.targetProps !== undefined;

        if (childrenCount === 0 && !hasRenderTargetProp) {
            console.warn(Errors.POPOVER_REQUIRES_TARGET);
        }
        if (childrenCount > 1) {
            console.warn(Errors.POPOVER_WARN_TOO_MANY_CHILDREN);
        }
        if (childrenCount > 0 && hasRenderTargetProp) {
            console.warn(Errors.POPOVER_WARN_DOUBLE_TARGET);
        }
        if (hasRenderTargetProp && hasTargetPropsProp) {
            console.warn(Errors.POPOVER_WARN_TARGET_PROPS_WITH_RENDER_TARGET);
        }
    }

    /**
     * Instance method to instruct the `Popover` to recompute its position.
     *
     * This method should only be used if you are updating the target in a way
     * that does not cause it to re-render, such as changing its _position_
     * without changing its _size_ (since `Popover` already repositions when it
     * detects a resize).
     */
    public reposition = () => this.popperScheduleUpdate?.();

    private renderTarget = ({ ref: popperChildRef }: ReferenceChildrenProps) => {
        const { children, className, disabled, fill, openOnTargetFocus, renderTarget } = this.props;
        const { isOpen } = this.state;
        const isControlled = this.isControlled();
        const isHoverInteractionKind = this.isHoverInteractionKind();

        let { targetTagName } = this.props;
        if (fill) {
            targetTagName = "div";
        }

        // N.B. react-popper has a wide type for this ref, but we can narrow it based on the source,
        // see https://github.com/floating-ui/react-popper/blob/beac280d61082852c4efc302be902911ce2d424c/src/Reference.js#L17
        const ref = mergeRefs(popperChildRef as React.RefCallback<HTMLElement>, this.targetRef);

        const targetEventHandlers: PopoverHoverTargetHandlers<T> | PopoverClickTargetHandlers<T> =
            isHoverInteractionKind
                ? {
                      // HOVER handlers
                      onBlur: this.handleTargetBlur,
                      onContextMenu: this.handleTargetContextMenu,
                      onFocus: this.handleTargetFocus,
                      onMouseEnter: this.handleMouseEnter,
                      onMouseLeave: this.handleMouseLeave,
                  }
                : {
                      // CLICK needs only one handler
                      onClick: this.handleTargetClick,
                      // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE
                      onKeyDown: this.handleKeyDown,
                  };
        // Ensure target is focusable if relevant prop enabled
        const targetTabIndex =
            !this.getIsContentEmpty() && !disabled && openOnTargetFocus && isHoverInteractionKind ? 0 : undefined;
        const ownTargetProps = {
            // N.B. this.props.className is passed along to renderTarget even though the user would have access to it.
            // If, instead, renderTarget is undefined and the target is provided as a child, this.props.className is
            // applied to the generated target wrapper element.
            className: classNames(className, Classes.POPOVER_TARGET, {
                [Classes.POPOVER_OPEN]: isOpen,
                // this class is mainly useful for button targets
                [Classes.ACTIVE]: isOpen && !isControlled && !isHoverInteractionKind,
            }),
            ref,
            ...targetEventHandlers,
        } satisfies React.HTMLProps<HTMLElement>;
        const childTargetProps = {
            "aria-expanded": isOpen,
            "aria-haspopup":
                this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY
                    ? undefined
                    : this.props.popupKind ?? "menu",
        } satisfies React.HTMLProps<HTMLElement>;

        const targetModifierClasses = {
            // this class is mainly useful for Blueprint <Button> targets; we should only apply it for
            // uncontrolled popovers when they are opened by a user interaction
            [Classes.ACTIVE]: isOpen && !isControlled && !isHoverInteractionKind,
            // similarly, this class is mainly useful for targets like <Button>, <InputGroup>, etc.
            [Classes.FILL]: fill,
        };

        let target: React.JSX.Element | undefined;

        if (renderTarget !== undefined) {
            target = renderTarget({
                ...ownTargetProps,
                ...childTargetProps,
                className: classNames(ownTargetProps.className, targetModifierClasses),
                // if the consumer renders a tooltip target, it's their responsibility to disable that tooltip
                // when *this* popover is open
                isOpen,
                tabIndex: targetTabIndex,
            });
        } else {
            const childTarget = Utils.ensureElement(React.Children.toArray(children)[0])!;

            if (childTarget === undefined) {
                return null;
            }

            const clonedTarget: React.JSX.Element = React.cloneElement(childTarget, {
                ...childTargetProps,
                className: classNames(childTarget.props.className, targetModifierClasses),
                // force disable single Tooltip child when popover is open
                disabled: isOpen && Utils.isElementOfType(childTarget, Tooltip) ? true : childTarget.props.disabled,
                tabIndex: childTarget.props.tabIndex ?? targetTabIndex,
            });
            const wrappedTarget = React.createElement(
                targetTagName!,
                {
                    ...ownTargetProps,
                    ...this.props.targetProps,
                },
                clonedTarget,
            );
            target = wrappedTarget;
        }

        // No need to use the merged `ref` here, that only needs to be forwarded to the child node so that React can
        // notify both popper.js and our components about the mounted DOM element.
        return (
            <ResizeSensor targetRef={this.targetRef} onResize={this.reposition}>
                {target}
            </ResizeSensor>
        );
    };

    private renderPopover = (popperProps: PopperChildrenProps) => {
        const { autoFocus, enforceFocus, backdropProps, canEscapeKeyClose, hasBackdrop, interactionKind, usePortal } =
            this.props;
        const { isClosingViaEscapeKeypress, isOpen } = this.state;

        // compute an appropriate transform origin so the scale animation points towards target
        const transformOrigin = getTransformOrigin(
            popperProps.placement,
            this.isArrowEnabled() ? (popperProps.arrowProps.style as any) : undefined,
        );

        // need to update our reference to this function on every render as it will change.
        this.popperScheduleUpdate = popperProps.update;

        const popoverHandlers: HTMLDivProps = {
            // always check popover clicks for dismiss class
            onClick: this.handlePopoverClick,
            // treat ENTER/SPACE keys the same as a click for accessibility
            onKeyDown: event => Utils.isKeyboardClick(event) && this.handlePopoverClick(event),
        };
        if (
            interactionKind === PopoverInteractionKind.HOVER ||
            (!usePortal && interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY)
        ) {
            popoverHandlers.onMouseEnter = this.handleMouseEnter;
            popoverHandlers.onMouseLeave = this.handleMouseLeave;
        }

        const basePlacement = getBasePlacement(popperProps.placement);
        const popoverClasses = classNames(
            Classes.POPOVER,
            {
                [Classes.DARK]: this.props.inheritDarkTheme && this.state.hasDarkParent,
                [Classes.MINIMAL]: this.props.minimal,
                [Classes.POPOVER_CAPTURING_DISMISS]: this.props.captureDismiss,
                [Classes.POPOVER_MATCH_TARGET_WIDTH]: this.props.matchTargetWidth,
                [Classes.POPOVER_REFERENCE_HIDDEN]: popperProps.isReferenceHidden === true,
                [Classes.POPOVER_POPPER_ESCAPED]: popperProps.hasPopperEscaped === true,
            },
            `${Classes.POPOVER_CONTENT_PLACEMENT}-${basePlacement}`,
            this.props.popoverClassName,
        );

        const defaultAutoFocus = this.isHoverInteractionKind() ? false : undefined;
        // if hover interaction, it doesn't make sense to take over focus control
        const shouldReturnFocusOnClose = this.isHoverInteractionKind()
            ? false
            : isClosingViaEscapeKeypress
              ? true
              : this.props.shouldReturnFocusOnClose;

        return (
            <Overlay2
                autoFocus={autoFocus ?? defaultAutoFocus}
                backdropClassName={Classes.POPOVER_BACKDROP}
                backdropProps={backdropProps}
                canEscapeKeyClose={canEscapeKeyClose}
                canOutsideClickClose={interactionKind === PopoverInteractionKind.CLICK}
                childRef={this.transitionContainerElement}
                enforceFocus={enforceFocus}
                hasBackdrop={hasBackdrop}
                isOpen={isOpen}
                lazy={this.props.lazy}
                onClose={this.handleOverlayClose}
                onClosed={this.props.onClosed}
                onClosing={this.props.onClosing}
                onOpened={this.props.onOpened}
                onOpening={this.props.onOpening}
                transitionDuration={this.props.transitionDuration}
                transitionName={Classes.POPOVER}
                usePortal={usePortal}
                portalClassName={this.props.portalClassName}
                portalContainer={this.props.portalContainer}
                // eslint-disable-next-line deprecation/deprecation
                portalStopPropagationEvents={this.props.portalStopPropagationEvents}
                shouldReturnFocusOnClose={shouldReturnFocusOnClose}
            >
                <div
                    className={Classes.POPOVER_TRANSITION_CONTAINER}
                    // We need to attach a ref that notifies both react-popper and our Popover component about the DOM
                    // element inside the Overlay2. We cannot re-use `PopperChildrenProps.ref` because Overlay2 only
                    // accepts a ref object (not a callback) due to a CSSTransition API limitation.
                    // N.B. react-popper has a wide type for this ref, but we can narrow it based on the source,
                    // see https://github.com/floating-ui/react-popper/blob/beac280d61082852c4efc302be902911ce2d424c/src/Popper.js#L94
                    ref={mergeRefs(popperProps.ref as React.RefCallback<HTMLElement>, this.transitionContainerElement)}
                    style={popperProps.style}
                >
                    <ResizeSensor onResize={this.reposition}>
                        <div
                            className={popoverClasses}
                            style={{ transformOrigin }}
                            ref={this.popoverRef}
                            {...popoverHandlers}
                        >
                            {this.isArrowEnabled() && (
                                <PopoverArrow arrowProps={popperProps.arrowProps} placement={popperProps.placement} />
                            )}
                            <div className={Classes.POPOVER_CONTENT}>{this.props.content}</div>
                        </div>
                    </ResizeSensor>
                </div>
            </Overlay2>
        );
    };

    private getPopperModifiers(): ReadonlyArray<Modifier<any>> {
        const { matchTargetWidth, modifiers, modifiersCustom } = this.props;
        const popperModifiers: Array<Modifier<any>> = [
            {
                enabled: this.isArrowEnabled(),
                name: "arrow",
                ...modifiers?.arrow,
            },
            {
                name: "computeStyles",
                ...modifiers?.computeStyles,
                options: {
                    adaptive: true,
                    // We disable the built-in gpuAcceleration so that
                    // Popper.js will return us easy to interpolate values
                    // (top, left instead of transform: translate3d)
                    // We'll then use these values to generate the needed
                    // css transform values blended with the react-spring values
                    gpuAcceleration: false,
                    ...modifiers?.computeStyles?.options,
                },
            },
            {
                enabled: this.isArrowEnabled(),
                name: "offset",
                ...modifiers?.offset,
                options: {
                    offset: [0, POPOVER_ARROW_SVG_SIZE / 2],
                    ...modifiers?.offset?.options,
                },
            },
            {
                name: "flip",
                ...modifiers?.flip,
                options: {
                    boundary: this.props.boundary,
                    rootBoundary: this.props.rootBoundary,
                    ...modifiers?.flip?.options,
                },
            },
            {
                name: "preventOverflow",
                ...modifiers?.preventOverflow,
                options: {
                    boundary: this.props.boundary,
                    rootBoundary: this.props.rootBoundary,
                    ...modifiers?.preventOverflow?.options,
                },
            },
        ];

        if (matchTargetWidth) {
            popperModifiers.push(matchReferenceWidthModifier);
        }

        if (modifiersCustom !== undefined) {
            popperModifiers.push(...modifiersCustom);
        }

        return popperModifiers;
    }

    private handleTargetFocus = (e: React.FocusEvent<HTMLElement>) => {
        if (this.props.openOnTargetFocus && this.isHoverInteractionKind()) {
            if (e.relatedTarget == null && !this.lostFocusOnSamePage) {
                // ignore this focus event -- the target was already focused but the page itself
                // lost focus (e.g. due to switching tabs).
                return;
            }
            this.handleMouseEnter(e as unknown as React.MouseEvent<HTMLElement>);
        }
    };

    private handleTargetBlur = (e: React.FocusEvent<HTMLElement>) => {
        if (this.props.openOnTargetFocus && this.isHoverInteractionKind()) {
            if (e.relatedTarget != null) {
                // if the next element to receive focus is within the popover, we'll want to leave the
                // popover open.
                if (
                    e.relatedTarget !== this.popoverElement &&
                    !this.isElementInPopover(e.relatedTarget as HTMLElement)
                ) {
                    this.handleMouseLeave(e as unknown as React.MouseEvent<HTMLElement>);
                }
            } else {
                this.handleMouseLeave(e as unknown as React.MouseEvent<HTMLElement>);
            }
        }
        this.lostFocusOnSamePage = e.relatedTarget != null;
    };

    private handleTargetContextMenu = (e: React.MouseEvent<HTMLElement>) => {
        // we assume that when someone prevents the default interaction on this event (a browser native context menu),
        // they are showing a custom context menu (as ContextMenu2 does); in this case, we should close this popover/tooltip
        if (e.defaultPrevented) {
            this.setOpenState(false, e);
        }
    };

    private handleMouseEnter = (e: React.MouseEvent<HTMLElement>) => {
        this.isMouseInTargetOrPopover = true;

        // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually
        // trigger the mouse leave event, as hovering over the popover shouldn't count.
        if (
            !this.props.usePortal &&
            this.isElementInPopover(e.target as Element) &&
            this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY &&
            !this.props.openOnTargetFocus
        ) {
            this.handleMouseLeave(e);
        } else if (!this.props.disabled) {
            // only begin opening popover when it is enabled
            this.setOpenState(true, e, this.props.hoverOpenDelay);
        }
    };

    private handleMouseLeave = (e: React.MouseEvent<HTMLElement>) => {
        this.isMouseInTargetOrPopover = false;

        // Wait until the event queue is flushed, because we want to leave the
        // popover open if the mouse entered the popover immediately after
        // leaving the target (or vice versa). Make sure to persist the event since
        // we need to access `nativeEvent` in `this.setOpenState()`.
        e.persist();
        this.setTimeout(() => {
            if (this.isMouseInTargetOrPopover) {
                return;
            }
            // user-configurable closing delay is helpful when moving mouse from target to popover
            this.setOpenState(false, e, this.props.hoverCloseDelay);
        });
    };

    private handlePopoverClick = (e: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => {
        const eventTarget = e.target as HTMLElement;
        const eventPopover = eventTarget.closest(`.${Classes.POPOVER}`);
        const eventPopoverV1 = eventTarget.closest(`.${Classes.POPOVER}`);
        const isEventFromSelf = (eventPopover ?? eventPopoverV1) === this.getPopoverElement();

        const isEventPopoverCapturing =
            eventPopover?.classList.contains(Classes.POPOVER_CAPTURING_DISMISS) ??
            eventPopoverV1?.classList.contains(Classes.POPOVER_CAPTURING_DISMISS) ??
            false;

        // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.
        const dismissElement = eventTarget.closest(`.${Classes.POPOVER_DISMISS}, .${Classes.POPOVER_DISMISS_OVERRIDE}`);
        const shouldDismiss = dismissElement?.classList.contains(Classes.POPOVER_DISMISS) ?? false;
        const isDisabled = eventTarget.closest(`:disabled, .${Classes.DISABLED}`) != null;

        if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {
            this.setOpenState(false, e);
        }
    };

    private handleOverlayClose = (e?: React.SyntheticEvent<HTMLElement>) => {
        if (this.targetRef.current == null || e === undefined) {
            return;
        }

        const event = (e.nativeEvent ?? e) as Event;
        const eventTarget = (event.composed ? event.composedPath()[0] : event.target) as HTMLElement;
        // if click was in target, target event listener will handle things, so don't close
        if (!Utils.elementIsOrContains(this.targetRef.current, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {
            this.setOpenState(false, e);
        }
    };

    private handleKeyDown = (e: React.KeyboardEvent<HTMLElement>) => {
        const isKeyboardClick = Utils.isKeyboardClick(e);

        // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE
        if (isKeyboardClick) {
            this.handleTargetClick(e);
        }
    };

    private handleTargetClick = (e: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => {
        // Target element(s) may fire simulated click event upon pressing ENTER/SPACE, which we should ignore
        // see: https://github.com/palantir/blueprint/issues/5775
        const shouldIgnoreClick = this.state.isOpen && this.isSimulatedButtonClick(e);
        if (!shouldIgnoreClick) {
            // ensure click did not originate from within inline popover before closing
            if (!this.props.disabled && !this.isElementInPopover(e.target as HTMLElement)) {
                if (this.props.isOpen == null) {
                    this.setState(prevState => ({ isOpen: !prevState.isOpen }));
                } else {
                    this.setOpenState(!this.props.isOpen, e);
                }
            }
        }
    };

    private isSimulatedButtonClick = (e: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => {
        return !e.isTrusted && (e.target as HTMLElement).matches(`.${Classes.BUTTON}`);
    };

    // a wrapper around setState({ isOpen }) that will call props.onInteraction instead when in controlled mode.
    // starts a timeout to delay changing the state if a non-zero duration is provided.
    private setOpenState(isOpen: boolean, e?: React.SyntheticEvent<HTMLElement>, timeout?: number) {
        // cancel any existing timeout because we have new state
        this.cancelOpenTimeout?.();
        if (timeout !== undefined && timeout > 0) {
            // Persist the react event since it will be used in a later macrotask.
            e?.persist();
            this.cancelOpenTimeout = this.setTimeout(() => {
                this.setOpenState(isOpen, e);
            }, timeout);
        } else {
            if (this.props.isOpen == null) {
                this.setState({ isOpen });
            } else {
                this.props.onInteraction?.(isOpen, e);
            }
            if (!isOpen) {
                // non-null assertion because the only time `e` is undefined is when in controlled mode
                // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true
                this.props.onClose?.(e!);
                this.setState({ isClosingViaEscapeKeypress: isEscapeKeypressEvent(e?.nativeEvent) });
            }
        }
    }

    private updateDarkParent() {
        if (this.props.usePortal && this.state.isOpen) {
            const hasDarkParent = this.targetRef.current?.closest(`.${Classes.DARK}`) != null;
            this.setState({ hasDarkParent });
        }
    }

    private isElementInPopover(element: Element) {
        return this.getPopoverElement()?.contains(element) ?? false;
    }

    private getIsContentEmpty() {
        const { content } = this.props;
        return content == null || (typeof content === "string" && content.trim() === "");
    }
}

function isEscapeKeypressEvent(e?: Event) {
    return e instanceof KeyboardEvent && e.key === "Escape";
}

function noop() {
    // no-op
}

================================================================================

File: src\components\popover\popoverArrow.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { Placement } from "@popperjs/core";
import * as React from "react";
import type { PopperArrowProps } from "react-popper";

import { Classes, DISPLAYNAME_PREFIX } from "../../common";

import { getBasePlacement } from "./popperUtils";

// these paths come from the Core Kit Sketch file
// https://github.com/palantir/blueprint/blob/develop/resources/sketch/Core%20Kit.sketch
const SVG_SHADOW_PATH =
    "M8.11 6.302c1.015-.936 1.887-2.922 1.887-4.297v26c0-1.378" +
    "-.868-3.357-1.888-4.297L.925 17.09c-1.237-1.14-1.233-3.034 0-4.17L8.11 6.302z";
const SVG_ARROW_PATH =
    "M8.787 7.036c1.22-1.125 2.21-3.376 2.21-5.03V0v30-2.005" +
    "c0-1.654-.983-3.9-2.21-5.03l-7.183-6.616c-.81-.746-.802-1.96 0-2.7l7.183-6.614z";

// additional space between arrow and edge of target
const ARROW_SPACING = 4;
export const POPOVER_ARROW_SVG_SIZE = 30;
export const TOOLTIP_ARROW_SVG_SIZE = 22;

/* istanbul ignore next */
/** Modifier helper function to compute arrow rotate() transform */
function getArrowAngle(placement?: Placement) {
    if (placement == null) {
        return 0;
    }
    // can only be top/left/bottom/right - auto is resolved internally
    switch (getBasePlacement(placement)) {
        case "top":
            return -90;
        case "left":
            return 180;
        case "bottom":
            return 90;
        default:
            return 0;
    }
}

/* istanbul ignore next */
/**
 * Popper's builtin "arrow" modifier options.padding doesn't seem to work for us, so we
 * need to compute our own offset in the direction of the popover relative to the reference.
 */
function getArrowReferenceOffsetStyle(placement: Placement) {
    const offset = POPOVER_ARROW_SVG_SIZE / 2 - ARROW_SPACING;
    switch (getBasePlacement(placement)) {
        case "top":
            return { bottom: -offset };
        case "left":
            return { right: -offset };
        case "bottom":
            return { top: -offset };
        default:
            return { left: -offset };
    }
}

export interface PopoverArrowProps {
    arrowProps: PopperArrowProps;
    placement: Placement;
}

export const PopoverArrow: React.FC<PopoverArrowProps> = ({ arrowProps: { ref, style }, placement }) => (
    // data attribute allows popper.js to position the arrow
    <div
        aria-hidden={true}
        className={Classes.POPOVER_ARROW}
        data-popper-arrow={true}
        ref={ref}
        style={{
            ...style,
            ...getArrowReferenceOffsetStyle(placement),
        }}
    >
        <svg
            viewBox={`0 0 ${POPOVER_ARROW_SVG_SIZE} ${POPOVER_ARROW_SVG_SIZE}`}
            style={{ transform: `rotate(${getArrowAngle(placement)}deg)` }}
        >
            <path className={Classes.POPOVER_ARROW + "-border"} d={SVG_SHADOW_PATH} />
            <path className={Classes.POPOVER_ARROW + "-fill"} d={SVG_ARROW_PATH} />
        </svg>
    </div>
);
PopoverArrow.displayName = `${DISPLAYNAME_PREFIX}.PopoverArrow`;

================================================================================

File: src\components\popover\popoverPlacementUtils.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { Placement } from "@popperjs/core";

import { PopoverPosition } from "./popoverPosition";

/**
 * Convert a position to a placement.
 *
 * @param position the position to convert
 */
export function positionToPlacement(position: PopoverPosition): Placement {
    /* istanbul ignore next */
    switch (position) {
        case PopoverPosition.TOP_LEFT:
            return "top-start";
        case PopoverPosition.TOP:
            return "top";
        case PopoverPosition.TOP_RIGHT:
            return "top-end";
        case PopoverPosition.RIGHT_TOP:
            return "right-start";
        case PopoverPosition.RIGHT:
            return "right";
        case PopoverPosition.RIGHT_BOTTOM:
            return "right-end";
        case PopoverPosition.BOTTOM_RIGHT:
            return "bottom-end";
        case PopoverPosition.BOTTOM:
            return "bottom";
        case PopoverPosition.BOTTOM_LEFT:
            return "bottom-start";
        case PopoverPosition.LEFT_BOTTOM:
            return "left-end";
        case PopoverPosition.LEFT:
            return "left";
        case PopoverPosition.LEFT_TOP:
            return "left-start";
        case "auto":
        case "auto-start":
        case "auto-end":
            // Return the string unchanged.
            return position;
        default:
            return assertNever(position);
    }
}

/* istanbul ignore next */
function assertNever(x: never): never {
    throw new Error("Unexpected position: " + x);
}

================================================================================

File: src\components\popover\popoverPosition.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Position } from "../../common";

export const PopoverPosition = {
    ...Position,
    AUTO: "auto" as const,
    AUTO_END: "auto-end" as const,
    AUTO_START: "auto-start" as const,
};
// eslint-disable-next-line @typescript-eslint/no-redeclare
export type PopoverPosition = (typeof PopoverPosition)[keyof typeof PopoverPosition];

================================================================================

File: src\components\popover\popoverSharedProps.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { Boundary, Modifier, Placement, RootBoundary, StrictModifiers } from "@popperjs/core";
import type * as React from "react";
import type { StrictModifier } from "react-popper";

import type { Props } from "../../common";
import type { OverlayableProps } from "../overlay/overlayProps";

import type { PopoverPosition } from "./popoverPosition";

export type { Boundary as PopperBoundary, Placement };
// copied from @popperjs/core, where it is not exported as public
export type StrictModifierNames = NonNullable<StrictModifiers["name"]>;

/**
 * Configuration object for customizing popper.js v2 modifiers in Popover and Tooltip.
 *
 * @see https://popper.js.org/docs/v2/modifiers/
 */
export type PopperModifierOverrides = Partial<{
    [M in StrictModifierNames]: Partial<Omit<StrictModifier<M>, "name">>;
}>;

/**
 * Custom popper.js v2 modifier for Popover and Tooltip.
 *
 * @see https://popper.js.org/docs/v2/modifiers/#custom-modifiers
 */
export type PopperCustomModifier = Partial<Modifier<any, object>>;

/**
 * Default props interface for the Popover target element.
 *
 * These props are applied to the generated target element (whose tag name is customizable via `targetTagName`)
 * or, when the `renderTarget` API is used, sent as props to that render function.
 *
 * This interface is generic enough to be compatible with the various HTML attributes Popover needs in
 * order to function properly, including things like event handlers and ARIA accessibility attributes.
 */
export type DefaultPopoverTargetHTMLProps = React.HTMLProps<HTMLElement>;

/**
 * Properties injected by Popover when rendering custom targets via the `renderTarget` API.
 *
 * @see https://blueprintjs.com/docs/#core/components/popover.structure
 */
export interface PopoverTargetProps
    extends Pick<React.HTMLAttributes<HTMLElement>, "aria-haspopup" | "aria-expanded" | "className" | "tabIndex"> {
    /** Target ref. */
    ref: React.Ref<any>;

    /** Whether the popover or tooltip is currently open. */
    isOpen: boolean;
}

/**
 * Event handlers injected by Popover for hover interaction popovers.
 */
export type PopoverHoverTargetHandlers<TProps extends DefaultPopoverTargetHTMLProps = DefaultPopoverTargetHTMLProps> =
    Pick<TProps, "onBlur" | "onContextMenu" | "onFocus" | "onMouseEnter" | "onMouseLeave">;

/**
 * Event handlers injected by Popover for click interaction popovers.
 */
export type PopoverClickTargetHandlers<TProps extends DefaultPopoverTargetHTMLProps = DefaultPopoverTargetHTMLProps> =
    Pick<TProps, "onClick" | "onKeyDown">;

/**
 * Props shared between `Popover` and `Tooltip`.
 *
 * @template TProps HTML props interface for target element,
 *                  defaults to props for HTMLElement in IPopoverProps and ITooltipProps
 */
export interface PopoverSharedProps<TProps extends DefaultPopoverTargetHTMLProps> extends OverlayableProps, Props {
    /** Interactive element which will trigger the popover. */
    children?: React.ReactNode;

    /**
     * A boundary element supplied to the "flip" and "preventOverflow" modifiers.
     * This is a shorthand for overriding Popper.js modifier options with the `modifiers` prop.
     *
     * @see https://popper.js.org/docs/v2/utils/detect-overflow/#boundary
     */
    boundary?: Boundary;

    /**
     * When enabled, clicks inside a `Classes.POPOVER_DISMISS` element
     * will only close the current popover and not outer popovers.
     * When disabled, the current popover and any ancestor popovers will be closed.
     *
     * @see http://blueprintjs.com/docs/#core/components/popover.closing-on-click
     * @default false
     */
    captureDismiss?: boolean;

    /**
     * Initial opened state when uncontrolled.
     *
     * @default false
     */
    defaultIsOpen?: boolean;

    /**
     * Prevents the popover from appearing when `true`.
     *
     * @default false
     */
    disabled?: boolean;

    /**
     * Whether the wrapper and target should take up the full width of their container.
     * Note that supplying `true` for this prop will force  `targetTagName="div"`.
     */
    fill?: boolean;

    /**
     * The amount of time in milliseconds the popover should remain open after
     * the user hovers off the trigger. The timer is canceled if the user mouses
     * over the target before it expires.
     *
     * @default 300
     */
    hoverCloseDelay?: number;

    /**
     * The amount of time in milliseconds the popover should wait before opening
     * after the user hovers over the trigger. The timer is canceled if the user
     * mouses away from the target before it expires.
     *
     * @default 150
     */
    hoverOpenDelay?: number;

    /**
     * Whether a popover that uses a `Portal` should automatically inherit the
     * dark theme from its parent.
     *
     * @default true
     */
    inheritDarkTheme?: boolean;

    /**
     * Whether the popover is visible. Passing this prop puts the popover in
     * controlled mode, where the only way to change visibility is by updating
     * this property. If `disabled={true}`, this prop will be ignored, and the
     * popover will remain closed.
     *
     * @default undefined
     */
    isOpen?: boolean;

    /**
     * Whether the popover content should be sized to match the width of the target.
     * This is sometimes useful for dropdown menus. This prop is implemented using
     * a Popper.js custom modifier.
     *
     * @default false
     */
    matchTargetWidth?: boolean;

    /**
     * Whether to apply minimal styling to this popover or tooltip. Minimal popovers
     * do not have an arrow pointing to their target and use a subtler animation.
     *
     * @default false
     */
    minimal?: boolean;

    /**
     * Overrides for Popper.js built-in modifiers.
     * Each override is is a full modifier object (omitting its name), keyed by its modifier name.
     *
     * For example, the arrow modifier can be disabled by providing `{ arrow: { enabled: false } }`.
     *
     * Some of Popover's default modifiers may get disabled under certain circumstances, but you may
     * choose to re-enable and customize them. For example, "offset" is disabled when `minimal={true}`,
     * but you can re-enable it with `{ offset: { enabled: true } }`.
     *
     * @see https://popper.js.org/docs/v2/modifiers/
     */
    modifiers?: PopperModifierOverrides;

    /**
     * Custom modifiers to add to the popper instance.
     *
     * @see https://popper.js.org/docs/v2/modifiers/#custom-modifiers
     */
    modifiersCustom?: readonly PopperCustomModifier[];

    /**
     * Callback invoked in controlled mode when the popover open state *would*
     * change due to user interaction.
     */
    onInteraction?: (nextOpenState: boolean, e?: React.SyntheticEvent<HTMLElement>) => void;

    /**
     * Whether the popover should open when its target is focused. If `true`,
     * target will render with `tabindex="0"` to make it focusable via keyboard
     * navigation.
     *
     * Note that this functionality is only enabled for hover interaction
     * popovers/tooltips.
     *
     * @default true
     */
    openOnTargetFocus?: boolean;

    /**
     * DOM ref attached to the `Classes.POPOVER` element.
     */
    popoverRef?: React.Ref<HTMLElement>;

    /**
     * Target renderer which receives props injected by Popover which should be spread onto
     * the rendered element. This function should return a single React node.
     *
     * Mutually exclusive with `children` and `targetTagName` props.
     */
    renderTarget?: (
        // N.B. we would like to discriminate between "hover" and "click" popovers here, so that we can be clear
        // about exactly which event handlers are passed here to be rendered on the target element, but unfortunately
        // we can't do that without breaking backwards-compatibility in the renderTarget API. Besides, that kind of
        // improvement would be better implemented if we added another type param to Popover, something like
        // Popover<TProps, "click" | "hover">. Instead of discriminating, we union the different possible event handlers
        // that may be passed (they are all optional properties anyway).
        props: PopoverTargetProps & PopoverHoverTargetHandlers<TProps> & PopoverClickTargetHandlers<TProps>,
    ) => React.JSX.Element;

    /**
     * A root boundary element supplied to the "flip" and "preventOverflow" modifiers.
     * This is a shorthand for overriding Popper.js modifier options with the `modifiers` prop.
     *
     * @see https://popper.js.org/docs/v2/utils/detect-overflow/#rootboundary
     */
    rootBoundary?: RootBoundary;

    /**
     * The placement (relative to the target) at which the popover should appear.
     * Mutually exclusive with `position` prop. Prefer using this over `position`,
     * as it more closely aligns with Popper.js semantics.
     *
     * The default value of `"auto"` will choose the best placement when opened
     * and will allow the popover to reposition itself to remain onscreen as the
     * user scrolls around.
     *
     * @default "auto"
     */
    placement?: Placement;

    /**
     * A space-delimited string of class names applied to the popover element.
     */
    popoverClassName?: string;

    /**
     * The position (relative to the target) at which the popover should appear.
     * Mutually exclusive with `placement` prop.
     *
     * The default value of `"auto"` will choose the best position when opened
     * and will allow the popover to reposition itself to remain onscreen as the
     * user scrolls around.
     *
     * @default "auto"
     */
    position?: PopoverPosition;

    /**
     * HTML tag name for the target element. This must be an HTML element to
     * ensure that it supports the necessary DOM event handlers.
     *
     * By default, a `<span>` tag is used so popovers appear as inline-block
     * elements and can be nested in text. Use `<div>` tag for a block element.
     *
     * If `fill` is set to `true`, this prop's default value will become `"div"`
     * instead of `"span"`.
     *
     * Note that _not all HTML tags are supported_; you will need to make sure
     * the tag you choose supports the HTML attributes Popover applies to the
     * target element.
     *
     * This prop is mutually exclusive with the `renderTarget` API.
     *
     * @default "span" ("div" if `fill={true}`)
     */
    targetTagName?: keyof React.JSX.IntrinsicElements;

    /**
     * HTML props for the target element. This is useful in some cases where you
     * need to render some simple attributes on the generated target element.
     *
     * For more complex use cases, consider using the `renderTarget` API instead.
     * This prop will be ignored if `renderTarget` is used.
     */
    targetProps?: TProps;

    /**
     * Whether the popover should be rendered inside a `Portal` attached to
     * `portalContainer` prop.
     *
     * Rendering content inside a `Portal` allows the popover content to escape
     * the physical bounds of its parent while still being positioned correctly
     * relative to its target. Using a `Portal` is necessary if any ancestor of
     * the target hides overflow or uses very complex positioning.
     *
     * Not using a `Portal` can result in smoother performance when scrolling
     * and allows the popover content to inherit CSS styles from surrounding
     * elements, but it remains subject to the overflow bounds of its ancestors.
     *
     * @default true
     */
    usePortal?: boolean;
}

================================================================================

File: src\components\popover\popperUtils.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { BasePlacement, Placement } from "@popperjs/core";

export { placements as PopperPlacements } from "@popperjs/core";

// Popper placement utils
// ======================

/** Converts a full placement to one of the four positions by stripping text after the `-`. */
export function getBasePlacement(placement: Placement) {
    return placement.split("-")[0] as BasePlacement;
}

/** Returns true if position is left or right. */
export function isVerticalPlacement(side: BasePlacement) {
    return ["left", "right"].indexOf(side) !== -1;
}

/** Returns the opposite position. */
export function getOppositePlacement(side: BasePlacement) {
    switch (side) {
        case "top":
            return "bottom";
        case "left":
            return "right";
        case "bottom":
            return "top";
        default:
            return "left";
    }
}

/** Returns the CSS alignment keyword corresponding to given placement. */
export function getAlignment(placement: Placement) {
    const align = placement.split("-")[1] as "start" | "end" | undefined;
    switch (align) {
        case "start":
            return "left";
        case "end":
            return "right";
        default:
            return "center";
    }
}

// Popper modifiers
// ================

/** Modifier helper function to compute popper transform-origin based on arrow position */
export function getTransformOrigin(placement: Placement, arrowStyles: { left: string; top: string } | undefined) {
    const basePlacement = getBasePlacement(placement);
    if (arrowStyles === undefined) {
        return isVerticalPlacement(basePlacement)
            ? `${getOppositePlacement(basePlacement)} ${getAlignment(basePlacement)}`
            : `${getAlignment(basePlacement)} ${getOppositePlacement(basePlacement)}`;
    } else {
        // const arrowSizeShift = state.elements.arrow.clientHeight / 2;
        const arrowSizeShift = 30 / 2;
        // can use keyword for dimension without the arrow, to ease computation burden.
        // move origin by half arrow's height to keep it centered.
        return isVerticalPlacement(basePlacement)
            ? `${getOppositePlacement(basePlacement)} ${parseInt(arrowStyles.top, 10) + arrowSizeShift}px`
            : `${parseInt(arrowStyles.left, 10) + arrowSizeShift}px ${getOppositePlacement(basePlacement)}`;
    }
}

================================================================================

File: src\components\popover\popupKind.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Specifies the popup kind for [aria-haspopup](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-haspopup).
 */
export enum PopupKind {
    /** The popup is a menu. */
    MENU = "menu",
    /** The popup is a listbox. */
    LISTBOX = "listbox",
    /** The popup is a tree. */
    TREE = "tree",
    /** The popup is a grid. */
    GRID = "grid",
    /** The popup is a dialog. */
    DIALOG = "dialog",
}

================================================================================

File: src\components\popover\tooltipContext.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

export interface TooltipContextState {
    forceDisabled?: boolean;
}

type TooltipAction = { type: "FORCE_DISABLED_STATE" } | { type: "RESET_DISABLED_STATE" };
const noOpDispatch: React.Dispatch<TooltipAction> = () => null;

export const TooltipContext = React.createContext<readonly [TooltipContextState, React.Dispatch<TooltipAction>]>([
    {},
    noOpDispatch,
]);

const tooltipContextReducer = (state: TooltipContextState, action: TooltipAction) => {
    switch (action.type) {
        case "FORCE_DISABLED_STATE":
            return { forceDisabled: true };
        case "RESET_DISABLED_STATE":
            return {};
        default:
            return state;
    }
};

interface TooltipProviderProps {
    children: React.ReactNode | ((ctxState: TooltipContextState) => React.ReactNode);
    forceDisable?: boolean;
}

export const TooltipProvider = ({ children, forceDisable }: TooltipProviderProps) => {
    const [state, dispatch] = React.useReducer(tooltipContextReducer, {});
    const contextValue = React.useMemo(() => [state, dispatch] as const, [state, dispatch]);

    React.useEffect(() => {
        if (forceDisable) {
            dispatch({ type: "FORCE_DISABLED_STATE" });
        } else {
            dispatch({ type: "RESET_DISABLED_STATE" });
        }
    }, [forceDisable]);

    return (
        <TooltipContext.Provider value={contextValue}>
            {typeof children === "function" ? children(state) : children}
        </TooltipContext.Provider>
    );
};

================================================================================

File: src\components\popover\_common.scss
--------------------------------------------------------------------------------
// Copyright 2021 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@use "sass:math";
@import "../../common/variables";
@import "../../common/react-transition";

$pt-popover-background-color: $white !default;
$pt-dark-popover-background-color: $dark-gray3 !default;

// $arrow-offset: amount to shift arrow along edge of popover
// $arrow-target-offset: amount to shift arrow relative to target (perpendicular to popover edge)

@mixin popover-sizing($arrow-square-size, $arrow-offset, $arrow-target-offset) {
  // since this is a 45-45-90 triangle, half hypotenuse === side * sqrt(2) / 2 === side / sqrt(2)
  // fun fact: there's no built-in square root function in SASS
  $arrow-diagonal-half-size: math.div($arrow-square-size, 1.41421356);
  // we want the margin to be the size of the part of the arrow that is showing plus
  // a little extra space.
  $content-margin: floor($arrow-diagonal-half-size + $arrow-target-offset);
  // we want to move the arrow out from where it's positioned by the gap amount
  // plus the extra amount of width that is added by its 45 deg rotation.
  $arrow-position: -$arrow-square-size * 0.5 + $arrow-offset;
  // because the 45 deg rotation will make out div stick out a little bit further,
  // we have to slide it over by that amount first and then by the set offset value
  $computed-arrow-offset: ($arrow-diagonal-half-size - $arrow-square-size) * 0.5 + $arrow-offset;

  .#{$ns}-popover-arrow {
    height: $arrow-square-size;
    position: absolute;
    width: $arrow-square-size;

    &::before {
      height: floor($arrow-diagonal-half-size - 1);
      margin: ceil(($arrow-square-size - $arrow-diagonal-half-size) * 0.5);
      // - 1 to compenstate for transparent pixel border shadow
      width: floor($arrow-diagonal-half-size - 1);
    }
  }
}

// set background and text colors. also set box-shadow if provided (so modifier styles don't have to
// reassign default shadows).

@mixin popover-appearance(
  $background-color,
  $text-color,
  $shadows,
  $arrow-box-shadow,
  $arrow-border-fill-opacity
) {
  box-shadow: $shadows;

  .#{$ns}-popover-content {
    background: $background-color;
  }

  // Some popovers (like tooltips) invert their foreground/background colors relative
  // to what we expect for the theme. In those cases, we need to override global typography
  // styles to get the right colors.
  .#{$ns}-popover-content,
  .#{$ns}-heading {
    color: $text-color;
  }

  .#{$ns}-popover-arrow::before {
    box-shadow: $arrow-box-shadow;
  }

  .#{$ns}-popover-arrow-border {
    fill: $black;
    fill-opacity: $arrow-border-fill-opacity;
  }

  .#{$ns}-popover-arrow-fill {
    fill: $background-color;

    @media (forced-colors: active) and (prefers-color-scheme: dark) {
      // Windows High Contrast dark theme
      fill: $pt-high-contrast-mode-border-color;
    }
  }

  @media (forced-colors: active) and (prefers-color-scheme: dark) {
    // Windows High Contrast dark theme
    border: 1px solid $pt-high-contrast-mode-border-color;
  }
}

@mixin fade-transition() {
  @include react-transition("#{$ns}-popover", (opacity: 0 1), $before: "&");
}

@mixin scale-transition() {
  @include react-transition(
    "#{$ns}-popover",
    (transform: scale(0.3) scale(1)),
    $duration: $pt-transition-duration * 3,
    $easing: $pt-transition-ease-bounce,
    $after: "> &"
  );
}

================================================================================

File: src\components\popover\_popover-in-button-group.scss
--------------------------------------------------------------------------------
// Copyright 2021 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "./common";
@import "@blueprintjs/core/src/components/button/common";

.#{$ns}-button-group {
  // support wrapping buttons in a tooltip, which adds a wrapper element
  &:not(.#{$ns}-minimal) {
    > .#{$ns}-popover-target:not(:first-child) .#{$ns}-button {
      border-bottom-left-radius: 0;
      border-top-left-radius: 0;
    }

    > .#{$ns}-popover-target:not(:last-child) .#{$ns}-button {
      border-bottom-right-radius: 0;
      border-top-right-radius: 0;
      margin-right: -$button-border-width;
    }
  }

  .#{$ns}-popover-target {
    display: flex;
    flex: 1 1 auto;
  }

  &.#{$ns}-vertical {
    &:not(.#{$ns}-minimal) {
      > .#{$ns}-popover-target:first-child .#{$ns}-button {
        border-radius: $pt-border-radius $pt-border-radius 0 0;
      }

      > .#{$ns}-popover-target:last-child .#{$ns}-button {
        border-radius: 0 0 $pt-border-radius $pt-border-radius;
      }

      > .#{$ns}-popover-target:not(:last-child) .#{$ns}-button {
        margin-bottom: -$button-border-width;
      }
    }
  }
}

================================================================================

File: src\components\popover\_popover-in-control-group.scss
--------------------------------------------------------------------------------
// Copyright 2021 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "./common";

.#{$ns}-control-group {
  // Add border radius inheritance to support components wrapped in a popover
  .#{$ns}-popover-target {
    border-radius: inherit;
  }
}

================================================================================

File: src\components\popover\_popover-in-label.scss
--------------------------------------------------------------------------------
// Copyright 2021 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "./common";

label.#{$ns}-label {
  .#{$ns}-popover-target {
    display: block;
    margin-top: $pt-grid-size * 0.5;
    text-transform: none;
  }
}

================================================================================

File: src\components\popover\_popover-in-submenu.scss
--------------------------------------------------------------------------------
// Copyright 2021 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "./common";
@import "@blueprintjs/core/src/components/menu/common";

.#{$ns}-submenu {
  .#{$ns}-popover-target {
    display: block;
  }

  &.#{$ns}-popover {
    box-shadow: none;
    // horizontal padding leaves some space from parent menu item, and extends mouse zone
    padding: 0 $half-grid-size;

    > .#{$ns}-popover-content {
      box-shadow: $pt-popover-box-shadow;
    }

    .#{$ns}-dark &,
    &.#{$ns}-dark {
      box-shadow: none;

      > .#{$ns}-popover-content {
        box-shadow: $pt-dark-popover-box-shadow;
      }
    }
  }
}


================================================================================

File: src\components\popover\_popover-in-tree.scss
--------------------------------------------------------------------------------
// Copyright 2021 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "./common";

.#{$ns}-tree-node-secondary-label {
  .#{$ns}-popover-target {
    align-items: center;
    display: flex;
  }
}

================================================================================

File: src\components\popover\_popover.scss
--------------------------------------------------------------------------------
// Copyright 2021 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@use "sass:color";
@import "./common";
@import "./popover-in-button-group";
@import "./popover-in-control-group";
@import "./popover-in-label";
@import "./popover-in-submenu";
@import "./popover-in-tree";

$popover-width: $pt-grid-size * 35 !default;
$popover-arrow-box-shadow: 1px 1px 6px rgba($black, $pt-drop-shadow-opacity) !default;
// Extra border shadow added here to match the one in $pt-dark-popover-box-shadow.
// We can't use a transparent color here because it is outset and will overlay other lines/borders underneath.
// Also, it needs to have slightly increased lightness because its apparent width makes it look darker otherwise.
$dark-popover-arrow-box-shadow:
  0 0 0 1px color.adjust($pt-dark-popover-border-color, $lightness: 10%),
  1px 1px 6px rgba($black, $pt-dark-drop-shadow-opacity) !default;

.#{$ns}-popover {
  @include popover-sizing(
    $arrow-square-size: 30px,
    $arrow-offset: 4px,
    $arrow-target-offset: -4px
  );
  @include popover-appearance(
    $pt-popover-background-color,
    inherit,
    $pt-popover-box-shadow,
    $popover-arrow-box-shadow,
    $pt-border-shadow-opacity
  );
  @include scale-transition();
  border-radius: $pt-border-radius;
  display: inline-block;
  z-index: $pt-z-index-overlay;

  .#{$ns}-popover-content {
    border-radius: $pt-border-radius;
    position: relative;
  }

  &.#{$ns}-popover-content-sizing {
    .#{$ns}-popover-content {
      max-width: $popover-width;
      padding: $pt-grid-size * 2;
    }

    // only inline popovers get a width if this class is applied.
    // note that an inline overlay will be an immediate next sibling
    // of the popover target as of Blueprint 2.0.
    .#{$ns}-popover-target + .#{$ns}-overlay & {
      width: $popover-width;
    }
  }

  &.#{$ns}-minimal {
    // Popover with no obvious trigger will never have margin because the arrow is hidden,
    // so it is safe to remove.
    margin: 0 !important; /* stylelint-disable-line declaration-no-important */

    .#{$ns}-popover-arrow {
      display: none;
    }

    &.#{$ns}-popover {
      @include react-transition(
        "#{$ns}-popover",
        (transform: scale(1) scale(1)),
        $duration: $pt-transition-duration,
        $after: "> &"
      );
    }
  }

  &.#{$ns}-popover-match-target-width {
    // parent element will have width styles set by our custom popper.js modifier,
    // so we should fill that container's width
    width: 100%;
  }

  &.#{$ns}-dark,
  .#{$ns}-dark & {
    @include popover-appearance(
      $pt-dark-popover-background-color,
      inherit,
      $pt-dark-popover-box-shadow,
      $dark-popover-arrow-box-shadow,
      $pt-dark-border-shadow-opacity
    );
  }

  @media (forced-colors: active) and (prefers-color-scheme: dark) {
    border: 1px solid $pt-high-contrast-mode-border-color;
    // Windows High Contrast dark theme
    box-shadow: none;
  }
}

// the box-shadow under the arrow SVG paths
.#{$ns}-popover-arrow::before {
  border-radius: $pt-border-radius - 1;
  content: "";
  display: block;
  position: absolute;
  transform: rotate(45deg);
}

.#{$ns}-overlay-backdrop.#{$ns}-popover-backdrop {
  background: rgba($white, 0);
}

.#{$ns}-popover-transition-container {
  @include fade-transition();

  // ensure element size exactly equals its children, no edge-case 4px spacing!
  // (try removing this property with Slider content in example)
  display: flex;
  z-index: $pt-z-index-overlay;

  &:focus {
    outline: none;
  }

  // popover content should ignore pointer events during a popover's exit transition
  &.#{$ns}-popover-leave .#{$ns}-popover-content {
    pointer-events: none;
  }

  // Popper.js applies this attribute when the target fully leaves boundaries
  // &[data-x-out-of-boundaries] {
  //   display: none;
  // }
}

span.#{$ns}-popover-target {
  // avoid `inline` elements as they won't account for padding etc
  display: inline-block;

  // this is important for span tag as default inline display height only includes text.
  // div tag can be used for display: block, which works fine.
}

.#{$ns}-popover-target {
  &.#{$ns}-fill {
    width: 100%;
  }
}

================================================================================

File: src\components\portal\portal.md
--------------------------------------------------------------------------------
@# Portal

The **Portal** component renders its children into a new DOM "subtree" outside of the current component
hierarchy. It is an essential piece of the [Overlay2](#core/components/overlay2) component, responsible for
ensuring that the overlay contents appear above the rest of the application. In most cases, you do not
need to use a Portal directly; this documentation is provided only for reference.

@## DOM Behavior

**Portal** component functions like a declarative `appendChild()`. The children of a **Portal** are inserted into a _new child_ of the target element. This target element is determined in the following order:

1. The `container` prop, if specified
2. The `portalContainer` from the closest [**PortalProvider**](#core/context/portal-provider), if specified
3. Otherwise `document.body`

**Portal** is used inside [Overlay2](#core/components/overlay2) to actually overlay the content on the
application.

<div class="@ns-callout @ns-intent-warning @ns-icon-move @ns-callout-has-body-content">
    <h5 class="@ns-heading">A note about responsive layouts</h5>

For a single-page app, if the `<body>` is styled with `width: 100%` and `height: 100%`, a `Portal`
may take up extra whitespace and cause the window to undesirably scroll. To fix this, instead
apply `position: absolute` to the `<body>` tag.

</div>

@## Props interface

@interface PortalProps

@## React context options

**Portal** supports some customization through [React context](https://react.dev/learn/passing-data-deeply-with-context).
Using this API can be helpful if you need to apply some custom styling or logic to _all_ Blueprint
components which use portals (popovers, tooltips, dialogs, etc.). You can do so by rendering a
[**PortalProvider**](#core/context/portal-provider) in your React tree
(usually, this should be done near the root of your application).

```tsx
import { Button, Popover, PortalProvider } from "@blueprintjs/core";
import * as React from "react";
import * as ReactDOM from "react-dom";

ReactDOM.render(
    <PortalProvider portalClassName="my-custom-class">
        <Popover content="My portal has a custom class">
            <Button text="Example" />
        </Popover>
    </PortalProvider>
    document.querySelector("#app"),
);
```

@interface PortalContextOptions

@## Legacy context options

<div class="@ns-callout @ns-intent-danger @ns-icon-error @ns-callout-has-body-content">
    <h5 class="@ns-heading">Legacy React API</h5>

This feature uses React's legacy context API. Support for this API will be removed in Blueprint v6.0.

</div>

**Portal** supports the following options via the [React legacy context API](https://reactjs.org/docs/legacy-context.html).
To use them, supply a child context to a subtree that contains the Portals you want to customize.

@interface PortalLegacyContext

================================================================================

File: src\components\portal\portal.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2022 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";
import * as ReactDOM from "react-dom";

import { Classes, DISPLAYNAME_PREFIX, type Props } from "../../common";
import type { ValidationMap } from "../../common/context";
import * as Errors from "../../common/errors";
import { isReact18 } from "../../common/utils/reactUtils";
import { PortalContext } from "../../context/portal/portalProvider";

export interface PortalProps extends Props {
    /** Contents to send through the portal. */
    children: React.ReactNode;

    /**
     * Callback invoked when the children of this `Portal` have been added to the DOM.
     */
    onChildrenMount?: () => void;

    /**
     * The HTML element that children will be mounted to.
     *
     * @default PortalProvider#portalContainer ?? document.body
     */
    container?: HTMLElement;

    /**
     * A list of DOM events which should be stopped from propagating through this portal element.
     *
     * @deprecated this prop's implementation no longer works in React v17+
     * @see https://legacy.reactjs.org/docs/portals.html#event-bubbling-through-portals
     * @see https://github.com/palantir/blueprint/issues/6124
     * @see https://github.com/palantir/blueprint/issues/6580
     */
    stopPropagationEvents?: Array<keyof HTMLElementEventMap>;
}

export interface PortalLegacyContext {
    /** Additional CSS classes to add to all `Portal` elements in this React context. */
    blueprintPortalClassName?: string;
}

/** @deprecated will be removed in Blueprint v6.0 */
const PORTAL_LEGACY_CONTEXT_TYPES: ValidationMap<PortalLegacyContext> = {
    blueprintPortalClassName: (obj: PortalLegacyContext, key: keyof PortalLegacyContext) => {
        if (obj[key] != null && typeof obj[key] !== "string") {
            return new Error(Errors.PORTAL_CONTEXT_CLASS_NAME_STRING);
        }
        return undefined;
    },
};

/**
 * Portal component.
 *
 * This component detaches its contents and re-attaches them to document.body.
 * Use it when you need to circumvent DOM z-stacking (for dialogs, popovers, etc.).
 * Any class names passed to this element will be propagated to the new container element on document.body.
 *
 * Portal supports both the newer React context API and the legacy context API.
 * Support for the legacy context API will be removed in Blueprint v6.0.
 *
 * @see https://blueprintjs.com/docs/#core/components/portal
 */
export function Portal(
    // eslint-disable-next-line deprecation/deprecation
    { className, stopPropagationEvents, container, onChildrenMount, children }: PortalProps,
    legacyContext: PortalLegacyContext = {},
) {
    const context = React.useContext(PortalContext);

    const portalContainer =
        container ?? context.portalContainer ?? (typeof document !== "undefined" ? document.body : undefined);

    const [portalElement, setPortalElement] = React.useState<HTMLElement>();

    const createPortalElement = React.useCallback(() => {
        const newPortalElement = document.createElement("div");
        newPortalElement.classList.add(Classes.PORTAL);
        maybeAddClass(newPortalElement.classList, className); // directly added to this portal element
        maybeAddClass(newPortalElement.classList, context.portalClassName); // added via PortalProvider context
        addStopPropagationListeners(newPortalElement, stopPropagationEvents);

        // TODO: remove legacy context support in Blueprint v6.0
        const blueprintPortalClassName = legacyContext.blueprintPortalClassName;
        if (blueprintPortalClassName != null && blueprintPortalClassName !== "") {
            console.error(Errors.PORTAL_LEGACY_CONTEXT_API);
            maybeAddClass(newPortalElement.classList, blueprintPortalClassName); // added via legacy context
        }

        return newPortalElement;
    }, [className, context.portalClassName, legacyContext.blueprintPortalClassName, stopPropagationEvents]);

    // create the container element & attach it to the DOM
    React.useEffect(() => {
        if (portalContainer == null) {
            return;
        }
        const newPortalElement = createPortalElement();
        portalContainer.appendChild(newPortalElement);
        setPortalElement(newPortalElement);

        return () => {
            removeStopPropagationListeners(newPortalElement, stopPropagationEvents);
            newPortalElement.remove();
            setPortalElement(undefined);
        };
    }, [portalContainer, createPortalElement, stopPropagationEvents]);

    // wait until next successful render to invoke onChildrenMount callback
    React.useEffect(() => {
        if (portalElement != null) {
            onChildrenMount?.();
        }
    }, [portalElement, onChildrenMount]);

    React.useEffect(() => {
        if (portalElement != null) {
            maybeAddClass(portalElement.classList, className);
            return () => maybeRemoveClass(portalElement.classList, className);
        }
        return undefined;
    }, [className, portalElement]);

    React.useEffect(() => {
        if (portalElement != null) {
            addStopPropagationListeners(portalElement, stopPropagationEvents);
            return () => removeStopPropagationListeners(portalElement, stopPropagationEvents);
        }
        return undefined;
    }, [portalElement, stopPropagationEvents]);

    // Only render `children` once this component has mounted in a browser environment, so they are
    // immediately attached to the DOM tree and can do DOM things like measuring or `autoFocus`.
    // See long comment on componentDidMount in https://reactjs.org/docs/portals.html#event-bubbling-through-portals
    if (typeof document === "undefined" || portalElement == null) {
        return null;
    } else {
        return ReactDOM.createPortal(children, portalElement);
    }
}

Portal.displayName = `${DISPLAYNAME_PREFIX}.Portal`;
// only use legacy context in React 16 or 17
if (!isReact18()) {
    // eslint-disable-next-line deprecation/deprecation
    Portal.contextTypes = PORTAL_LEGACY_CONTEXT_TYPES;
}

function maybeRemoveClass(classList: DOMTokenList, className?: string) {
    if (className != null && className !== "") {
        classList.remove(...className.split(" "));
    }
}

function maybeAddClass(classList: DOMTokenList, className?: string) {
    if (className != null && className !== "") {
        classList.add(...className.split(" "));
    }
}

function addStopPropagationListeners(portalElement: HTMLElement, eventNames?: Array<keyof HTMLElementEventMap>) {
    eventNames?.forEach(event => portalElement.addEventListener(event, handleStopProgation));
}

function removeStopPropagationListeners(portalElement: HTMLElement, events?: Array<keyof HTMLElementEventMap>) {
    events?.forEach(event => portalElement.removeEventListener(event, handleStopProgation));
}

function handleStopProgation(e: Event) {
    e.stopPropagation();
}

================================================================================

File: src\components\portal\_portal.scss
--------------------------------------------------------------------------------
// Copyright 2016 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

.#{$ns}-portal {
  left: 0;
  // take the portal out of the document flow to prevent browsers from autoscrolling to the bottom
  // of the document (where portals are appended) when programmatically focusing within a portal
  // child element. also, don't use `fixed`, because then Tether'd elements won't reposition
  // themselves properly as the document scrolls.
  position: absolute;
  // ensure content won't be horizontally scrunched
  right: 0;
  // ensure content still offsets from the top of the document
  top: 0;
}

================================================================================

File: src\components\progress-bar\progress-bar.md
--------------------------------------------------------------------------------
@# Progress bar

__ProgressBar__ indicates progress towards the completion of a task or an indeterminate loading state.

@reactExample ProgressExample

@## Props interface

__ProgressBar__ is a simple stateless component that renders the appropriate HTML markup. It supports a `value` prop
between 0 and 1 that determines the width of the progress meter. Omitting `value` will result in an "indeterminate"
progress meter that fills the entire bar.

@interface ProgressBarProps

@## CSS API

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use [`<ProgressBar>`](#core/components/progress-bar)

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

</div>

Set the current progress of the bar via a `width` style rule on the inner `.@ns-progress-meter` element. This is a very
simple CSS-only component, and input validation for `width` values is limited: values above `100%` appear as 100%
progress and values below `0%` appear as 0%.

Omitting `width` will result in an "indeterminate" progress meter that fills the entire bar.

@css progress-bar

================================================================================

File: src\components\progress-bar\progressBar.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes } from "../../common";
import { DISPLAYNAME_PREFIX, type IntentProps, type Props } from "../../common/props";
import { clamp } from "../../common/utils";

export interface ProgressBarProps extends Props, IntentProps {
    /**
     * Whether the background should animate.
     *
     * @default true
     */
    animate?: boolean;

    /**
     * Whether the background should be striped.
     *
     * @default true
     */
    stripes?: boolean;

    /**
     * A value between 0 and 1 (inclusive) representing how far along the operation is.
     * Values below 0 or above 1 will be interpreted as 0 or 1, respectively.
     * Omitting this prop will result in an "indeterminate" progress meter that fills the entire bar.
     */
    value?: number;
}

/**
 * Progress bar component.
 *
 * @see https://blueprintjs.com/docs/#core/components/progress-bar
 */
export class ProgressBar extends AbstractPureComponent<ProgressBarProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.ProgressBar`;

    public render() {
        const { animate = true, className, intent, stripes = true, value } = this.props;
        const classes = classNames(
            Classes.PROGRESS_BAR,
            Classes.intentClass(intent),
            { [Classes.PROGRESS_NO_ANIMATION]: !animate, [Classes.PROGRESS_NO_STRIPES]: !stripes },
            className,
        );
        const percent = value == null ? undefined : 100 * clamp(value, 0, 1);
        // don't set width if value is null (rely on default CSS value)
        const width = percent == null ? undefined : percent + "%";

        return (
            <div
                aria-valuemax={100}
                aria-valuemin={0}
                aria-valuenow={percent == null ? undefined : Math.round(percent)}
                className={classes}
                role="progressbar"
            >
                <div className={Classes.PROGRESS_METER} style={{ width }} />
            </div>
        );
    }
}

================================================================================

File: src\components\progress-bar\_common.scss
--------------------------------------------------------------------------------
// Copyright 2017 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";

$progress-track-color: rgba($gray1, 0.2) !default;
$progress-head-color: rgba($gray1, 0.8) !default;
$dark-progress-track-color: rgba($black, 0.5) !default;
$dark-progress-head-color: $gray3 !default;

================================================================================

File: src\components\progress-bar\_progress-bar.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "common";

/*
Progress bars

Markup:
<div class="#{$ns}-progress-bar {{.modifier}}">
  <div class="#{$ns}-progress-meter" style="width: 25%"></div>
</div>
<div class="#{$ns}-progress-bar #{$ns}-intent-primary {{.modifier}}">
  <div class="#{$ns}-progress-meter" style="width: 50%"></div>
</div>
<div class="#{$ns}-progress-bar #{$ns}-intent-success {{.modifier}}">
  <div class="#{$ns}-progress-meter" style="width: 75%"></div>
</div>
<div class="#{$ns}-progress-bar #{$ns}-intent-danger {{.modifier}}">
  <div class="#{$ns}-progress-meter" style="width: 100%"></div>
</div>

.#{$ns}-no-stripes   - No stripes
.#{$ns}-no-animation - No animation

Styleguide progress-bar
*/

$progress-bar-stripes-color: rgba($white, 0.2) !default;

$progress-bar-height: round($pt-grid-size * 0.8) !default;
$progress-bar-stripes-size: $pt-grid-size * 3 !default;
$progress-bar-border-radius: $pt-grid-size * 4 !default;

$progress-bar-gradient: linear-gradient(
  -45deg,
  $progress-bar-stripes-color 25%,
  transparent 25%,
  transparent 50%,
  $progress-bar-stripes-color 50%,
  $progress-bar-stripes-color 75%,
  transparent 75%
) !default;

@keyframes linear-progress-bar-stripes {
  from {
    background-position: 0 0;
  }

  to {
    background-position: $progress-bar-stripes-size 0;
  }
}

.#{$ns}-progress-bar {
  background: $progress-track-color;
  border-radius: $progress-bar-border-radius;
  display: block;
  height: $progress-bar-height;
  overflow: hidden;
  position: relative;
  width: 100%;

  .#{$ns}-progress-meter {
    background: $progress-bar-gradient;
    background-color: $progress-head-color;
    background-size: $progress-bar-stripes-size $progress-bar-stripes-size;
    border-radius: $progress-bar-border-radius;
    height: 100%;
    position: absolute;
    transition: width ($pt-transition-duration * 2) $pt-transition-ease;
    // initial state is a full bar, a la "indeterminate"
    width: 100%;
  }

  &:not(.#{$ns}-no-animation):not(.#{$ns}-no-stripes) .#{$ns}-progress-meter {
    animation: linear-progress-bar-stripes ($pt-transition-duration * 3) linear infinite reverse;
  }

  &.#{$ns}-no-stripes .#{$ns}-progress-meter {
    background-image: none;
  }
}

.#{$ns}-dark .#{$ns}-progress-bar {
  background: $dark-progress-track-color;

  .#{$ns}-progress-meter {
    background-color: $dark-progress-head-color;
  }
}

@each $intent, $color in $pt-intent-colors {
  .#{$ns}-progress-bar.#{$ns}-intent-#{$intent} .#{$ns}-progress-meter {
    background-color: $color;
  }
}

================================================================================

File: src\components\resize-sensor\resize-sensor.md
--------------------------------------------------------------------------------
@# Resize sensor

__ResizeSensor__ observes the DOM and provides a callback for `"resize"` events on a single child element.
It is a thin wrapper around [`ResizeObserver`][resizeobserver] to provide React bindings.

[resizeobserver]: https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">DOM ref required</h5>

ResizeSensor's implementation relies on a React ref being attached to a DOM element,
so the child of this component _must be a native DOM element_ or utilize
[`React.forwardRef()`](https://reactjs.org/docs/forwarding-refs.html) to forward any
injected ref to the underlying DOM element.

</div>

@## Usage

```tsx
import { ResizeEntry, ResizeSensor } from "@blueprintjs/core";

function handleResize(entries: ResizeEntry[]) {
    console.log(entries.map(e => `${e.contentRect.width} x ${e.contentRect.height}`));
}

<ResizeSensor onResize={handleResize}>
    <div style={{ width: this.props.width }} />
</ResizeSensor>
```

If you attach a `ref` to the child yourself, you must pass the same value to `ResizeSensor`
with the `targetRef` prop (otherwise, the component won't be able to attach one itself).

```tsx
const myRef = React.createRef();

<ResizeSensor targetRef={myRef} onResize={handleResize}>
    <div ref={myRef} style={{ width: this.props.width }} />
</ResizeSensor>
```

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">Asynchronous behavior</h5>

The `onResize` callback is invoked asynchronously after a resize is detected
and typically happens at the end of a frame (after layout, before paint).
Therefore, testing behavior that relies on this component involves setting a
timeout for the next frame.

</div>

@## Props interface

@interface ResizeSensorProps

================================================================================

File: src\components\resize-sensor\resizeSensor.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

import { AbstractPureComponent, DISPLAYNAME_PREFIX } from "../../common";

// backwards-compatible with @blueprintjs/core v4.x
export type ResizeEntry = ResizeObserverEntry;

/** `ResizeSensor` requires a single DOM element child and will error otherwise. */
export interface ResizeSensorProps {
    /**
     * Single child, must be an element and not a string or fragment.
     */
    children: React.JSX.Element;

    /**
     * Callback invoked when the wrapped element resizes.
     *
     * The `entries` array contains an entry for each observed element. In the
     * default case (no `observeParents`), the array will contain only one
     * element: the single child of the `ResizeSensor`.
     *
     * Note that this method is called _asynchronously_ after a resize is
     * detected and typically it will be called no more than once per frame.
     */
    onResize: (entries: ResizeObserverEntry[]) => void;

    /**
     * If `true`, all parent DOM elements of the container will also be
     * observed for size changes. The array of entries passed to `onResize`
     * will now contain an entry for each parent element up to the root of the
     * document.
     *
     * Only enable this prop if a parent element resizes in a way that does
     * not also cause the child element to resize.
     *
     * @default false
     */
    observeParents?: boolean;

    /**
     * If you attach a `ref` to the child yourself when rendering it, you must pass the
     * same value here (otherwise, ResizeSensor won't be able to attach its own).
     */
    targetRef?: React.RefObject<HTMLElement>;
}

/**
 * Resize sensor component.
 *
 * It requires a single DOM element child and will error otherwise.
 *
 * @see https://blueprintjs.com/docs/#core/components/resize-sensor
 **/
export class ResizeSensor extends AbstractPureComponent<ResizeSensorProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.ResizeSensor`;

    private targetRef = this.props.targetRef ?? React.createRef<HTMLElement>();

    private prevElement: HTMLElement | undefined = undefined;

    private observer: ResizeObserver | undefined;

    public render(): React.ReactNode {
        const onlyChild = React.Children.only(this.props.children);

        // If we're provided a mutable ref to the child element already, we must re-use that one. This is necessary
        // in cases where the child node is not a native DOM element and does not use `React.forwardRef`, since
        // there's no way for us to know how to attach to the underlying DOM node.
        if (this.props.targetRef !== undefined) {
            return onlyChild;
        }

        return React.cloneElement(onlyChild, { ref: this.targetRef });
    }

    public componentDidMount() {
        // ResizeObserver is available in all modern browsers supported by Blueprint but not in server-side rendering
        // and some test environments like jsdom, so we to do a feature check here.
        this.observer =
            globalThis.ResizeObserver != null
                ? new ResizeObserver(entries => this.props.onResize?.(entries))
                : undefined;
        this.observeElement();
    }

    public componentDidUpdate(prevProps: ResizeSensorProps) {
        this.observeElement(this.props.observeParents !== prevProps.observeParents);
    }

    public componentWillUnmount() {
        this.observer?.disconnect();
        this.prevElement = undefined;
    }

    /**
     * Observe the DOM element, if defined and different from the currently
     * observed element. Pass `force` argument to skip element checks and always
     * re-observe.
     */
    private observeElement(force = false) {
        if (this.observer === undefined) {
            return;
        }

        if (!(this.targetRef.current instanceof Element)) {
            // stop everything if not defined
            this.observer.disconnect();
            return;
        }

        if (this.targetRef.current === this.prevElement && !force) {
            // quit if given same element -- nothing to update (unless forced)
            return;
        } else {
            // clear observer list if new element
            this.observer.disconnect();
            // remember element reference for next time
            this.prevElement = this.targetRef.current;
        }

        // observer callback is invoked immediately when observing new elements
        this.observer.observe(this.targetRef.current);

        if (this.props.observeParents) {
            let parent = this.targetRef.current.parentElement;
            while (parent != null) {
                this.observer.observe(parent);
                parent = parent.parentElement;
            }
        }
    }
}

================================================================================

File: src\components\section\section.md
--------------------------------------------------------------------------------
---
tag: new
---

@# Section

The __Section__ component can be used to contain, structure, and create hierarchy for information in your UI. It makes use of some concepts from other more atomic Blueprint components:

- The overall appearance looks like a [__Card__](#core/components/card) (with limited `elevation` options)
- Contents may be collapsible like the [__Collapse__](#core/components/collapse) component

@reactExample SectionExample

@## Props interface

@interface SectionProps

@## Section card

Multiple __SectionCard__ child components can be added under one __Section__, they will be stacked vertically. This layout can be used to further group information.

```tsx
<Section>
    <SectionCard>{/* ... */}</SectionCard>
    <SectionCard>{/* ... */}</SectionCard>
</Section>
```

@interface SectionCardProps

================================================================================

File: src\components\section\section.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { ChevronDown, ChevronUp, type IconName } from "@blueprintjs/icons";

import { Classes, Elevation, Utils } from "../../common";
import { DISPLAYNAME_PREFIX, type HTMLDivProps, type MaybeElement, type Props } from "../../common/props";
import { uniqueId } from "../../common/utils";
import { Card } from "../card/card";
import { Collapse, type CollapseProps } from "../collapse/collapse";
import { H6 } from "../html/html";
import { Icon } from "../icon/icon";

/**
 * Subset of {@link Elevation} options which are visually supported by the {@link Section} component.
 *
 * Note that an elevation greater than 1 creates too much visual clutter/noise in the UI, especially when
 * multiple Sections are shown on a single page.
 */
export type SectionElevation = typeof Elevation.ZERO | typeof Elevation.ONE;

export interface SectionCollapseProps
    extends Pick<CollapseProps, "className" | "isOpen" | "keepChildrenMounted" | "transitionDuration"> {
    /**
     * Whether the component is initially open or closed.
     *
     * This prop has no effect if `collapsible={false}` or the component is in controlled mode,
     * i.e. when `isOpen` is **not** `undefined`.
     *
     * @default true
     */
    defaultIsOpen?: boolean;

    /**
     * Whether the component is open or closed.
     *
     * Passing a boolean value to `isOpen` will enabled controlled mode for the component.
     */
    isOpen?: boolean;

    /**
     * Callback invoked in controlled mode when the collapse toggle element is clicked.
     */
    onToggle?: () => void;
}

export interface SectionProps extends Props, Omit<HTMLDivProps, "title">, React.RefAttributes<HTMLDivElement> {
    /**
     * Whether this section's contents should be collapsible.
     *
     * @default false
     */
    collapsible?: boolean;

    /**
     * Subset of props to forward to the underlying {@link Collapse} component, with the addition of a
     * `defaultIsOpen` option which sets the default open state of the component when in uncontrolled mode.
     */
    collapseProps?: SectionCollapseProps;

    /**
     * Whether this section should use compact styles.
     *
     * @default false
     */
    compact?: boolean;

    /**
     * Visual elevation of this container element.
     *
     * @default Elevation.ZERO
     */
    elevation?: SectionElevation;

    /**
     * Name of a Blueprint UI icon (or an icon element) to render in the section's header.
     * Note that the header will only be rendered if `title` is provided.
     */
    icon?: IconName | MaybeElement;

    /**
     * Element to render on the right side of the section header.
     * Note that the header will only be rendered if `title` is provided.
     */
    rightElement?: React.JSX.Element;

    /**
     * Sub-title of the section.
     * Note that the header will only be rendered if `title` is provided.
     */
    subtitle?: React.JSX.Element | string;

    /**
     * Title of the section.
     * Note that the header will only be rendered if `title` is provided.
     */
    title?: React.JSX.Element | string;

    /**
     * Optional title renderer function. If provided, it is recommended to include a Blueprint `<H6>` element
     * as part of the title. The render function is supplied with `className` and `id` attributes which you must
     * forward to the DOM. The `title` prop is also passed along to this renderer via `props.children`.
     *
     * @default H6
     */
    titleRenderer?: React.FC<React.HTMLAttributes<HTMLElement>>;
}

/**
 * Section component.
 *
 * @see https://blueprintjs.com/docs/#core/components/section
 */
export const Section: React.FC<SectionProps> = React.forwardRef((props, ref) => {
    const {
        children,
        className,
        collapseProps,
        collapsible,
        compact,
        elevation,
        icon,
        rightElement,
        subtitle,
        title,
        titleRenderer = H6,
        ...htmlProps
    } = props;
    // Determine whether to use controlled or uncontrolled state.
    const isControlled = collapseProps?.isOpen != null;

    // The initial useState value is negated in order to conform to the `isCollapsed` expectation.
    const [isCollapsedUncontrolled, setIsCollapsed] = React.useState<boolean>(!(collapseProps?.defaultIsOpen ?? true));

    const isCollapsed = isControlled ? !collapseProps?.isOpen : isCollapsedUncontrolled;

    const toggleIsCollapsed = React.useCallback(() => {
        if (isControlled) {
            collapseProps?.onToggle?.();
        } else {
            setIsCollapsed(!isCollapsed);
        }
    }, [collapseProps, isCollapsed, isControlled]);

    const isHeaderRightContainerVisible = rightElement != null || collapsible;

    const sectionId = uniqueId("section");
    const sectionTitleId = title ? uniqueId("section-title") : undefined;

    return (
        <Card
            className={classNames(className, Classes.SECTION, {
                [Classes.COMPACT]: compact,
                [Classes.SECTION_COLLAPSED]: (collapsible && isCollapsed) || Utils.isReactNodeEmpty(children),
            })}
            elevation={elevation}
            ref={ref}
            aria-labelledby={sectionTitleId}
            {...htmlProps}
            id={sectionId}
        >
            {title && (
                <div
                    role={collapsible ? "button" : undefined}
                    aria-pressed={collapsible ? isCollapsed : undefined}
                    aria-expanded={collapsible ? isCollapsed : undefined}
                    aria-controls={collapsible ? sectionId : undefined}
                    className={classNames(Classes.SECTION_HEADER, {
                        [Classes.INTERACTIVE]: collapsible,
                    })}
                    onClick={collapsible ? toggleIsCollapsed : undefined}
                >
                    <div className={Classes.SECTION_HEADER_LEFT}>
                        {icon && <Icon icon={icon} aria-hidden={true} tabIndex={-1} className={Classes.TEXT_MUTED} />}
                        <div>
                            {React.createElement(
                                titleRenderer,
                                { className: Classes.SECTION_HEADER_TITLE, id: sectionTitleId },
                                title,
                            )}
                            {subtitle && (
                                <div className={classNames(Classes.TEXT_MUTED, Classes.SECTION_HEADER_SUB_TITLE)}>
                                    {subtitle}
                                </div>
                            )}
                        </div>
                    </div>
                    {isHeaderRightContainerVisible && (
                        <div className={Classes.SECTION_HEADER_RIGHT}>
                            {rightElement}
                            {collapsible &&
                                (isCollapsed ? (
                                    <ChevronDown className={Classes.TEXT_MUTED} />
                                ) : (
                                    <ChevronUp className={Classes.TEXT_MUTED} />
                                ))}
                        </div>
                    )}
                </div>
            )}

            {collapsible ? (
                <Collapse {...collapseProps} isOpen={!isCollapsed}>
                    {children}
                </Collapse>
            ) : (
                children
            )}
        </Card>
    );
});
Section.defaultProps = {
    compact: false,
    elevation: Elevation.ZERO,
};
Section.displayName = `${DISPLAYNAME_PREFIX}.Section`;

================================================================================

File: src\components\section\sectionCard.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Classes } from "../../common";
import { DISPLAYNAME_PREFIX, type HTMLDivProps, type Props } from "../../common/props";

export interface SectionCardProps extends Props, HTMLDivProps, React.RefAttributes<HTMLDivElement> {
    /**
     * Whether to apply visual padding inside the content container element.
     *
     * @default true
     */
    padded?: boolean;
}

/**
 * Section card component.
 *
 * @see https://blueprintjs.com/docs/#core/components/section.section-card
 */
export const SectionCard: React.FC<SectionCardProps> = React.forwardRef((props, ref) => {
    const { className, children, padded, ...htmlProps } = props;
    const classes = classNames(Classes.SECTION_CARD, { [Classes.PADDED]: padded }, className);
    return (
        <div className={classes} ref={ref} {...htmlProps}>
            {children}
        </div>
    );
});
SectionCard.defaultProps = {
    padded: true,
};
SectionCard.displayName = `${DISPLAYNAME_PREFIX}.SectionCard`;

================================================================================

File: src\components\section\_section.scss
--------------------------------------------------------------------------------
@use "sass:math";
@import "../../common/variables";

$section-min-height: $pt-grid-size * 5 !default;
$section-padding-vertical: $pt-grid-size !default;
$section-padding-horizontal: $pt-grid-size * 2 !default;
$section-card-padding: $pt-grid-size * 2 !default;

$section-min-height-compact: $pt-grid-size * 4 !default;
$section-padding-compact-vertical: 7px !default;
$section-padding-compact-horizontal: 15px !default;
$section-card-padding-compact: $pt-grid-size * 1.5 !default;

.#{$ns}-section {
  overflow: hidden;
  width: 100%;

  &,
  &.#{$ns}-compact {
    // override Card compact styles here
    padding: 0;
  }

  &-header {
    align-items: center;
    border-bottom: 1px solid $pt-divider-black;
    display: flex;
    gap: $pt-grid-size * 2;
    justify-content: space-between;
    min-height: $section-min-height;
    padding: 0 $section-padding-horizontal;
    position: relative;
    width: 100%;

    &.#{$ns}-dark,
    .#{$ns}-dark & {
      border-color: $pt-dark-divider-white;
    }

    &-left {
      align-items: center;
      display: flex;
      gap: $pt-grid-size;
      padding: $section-padding-vertical 0;
    }

    &-title {
      margin-bottom: 0;
    }

    &-sub-title {
      margin-top: 2px;
    }

    &-right {
      align-items: center;
      display: flex;
      gap: $pt-grid-size;
      margin-left: auto;
    }

    &-divider {
      align-self: stretch;
      margin: $pt-grid-size * 1.5 0;
    }

    &.#{$ns}-interactive {
      cursor: pointer;

      &:hover,
      &:active {
        background: $light-gray5;

        &.#{$ns}-dark,
        .#{$ns}-dark & {
          background: $dark-gray4;
        }
      }
    }
  }

  &-card {
    &.#{$ns}-padded {
      padding: $section-card-padding;
    }

    &:not(:last-child) {
      border-bottom: 1px solid $pt-divider-black;

      &.#{$ns}-dark,
      .#{$ns}-dark & {
        border-color: $pt-dark-divider-white;
      }
    }
  }

  &.#{$ns}-section-collapsed {
    .#{$ns}-section-header {
      border: none;
    }
  }

  &.#{$ns}-compact {
    .#{$ns}-section-header {
      min-height: $section-min-height-compact;
      padding: 0 $section-padding-compact-horizontal;

      &-left {
        padding: $section-padding-compact-vertical 0;
      }
    }

    .#{$ns}-section-card.#{$ns}-padded {
      padding: $section-card-padding-compact;
    }
  }
}

================================================================================

File: src\components\segmented-control\segmented-control.md
--------------------------------------------------------------------------------
---
tag: new
---

@# Segmented control

A **SegmentedControl** is a linear collection of buttons which allows a user to choose an option from multiple choices,
similar to a [**Radio**](#core/components/radio) group.

Compared to the [**ButtonGroup**](#core/components/button-group) component, **SegmentedControl** has affordances
to signify a selection UI and a reduced visual weight which is appropriate for forms.

@reactExample SegmentedControlExample

@## Usage

**SegmentedControl** can be used as either a controlled or uncontrolled component with the `value`, `defaultValue`,
and `onChange` props.

Options are specified as `OptionProps` objects, just like [RadioGroup](#core/components/radio.radiogroup) and
[HTMLSelect](#core/components/html-select).

```tsx
<SegmentedControl
    options={[
        {
            label: "List",
            value: "list",
        },
        {
            label: "Grid",
            value: "grid",
        },
        {
            label: "Gallery",
            value: "gallery",
        },
    ]}
    defaultValue="list"
/>
```

@## Props interface

@interface SegmentedControlProps

================================================================================

File: src\components\segmented-control\segmentedControl.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Classes, Intent } from "../../common";
import {
    type ControlledValueProps,
    DISPLAYNAME_PREFIX,
    type OptionProps,
    type Props,
    removeNonHTMLProps,
} from "../../common/props";
import { Button } from "../button/buttons";

export type SegmentedControlIntent = typeof Intent.NONE | typeof Intent.PRIMARY;

/**
 * SegmentedControl component props.
 */
export interface SegmentedControlProps
    extends Props,
        ControlledValueProps<string>,
        React.RefAttributes<HTMLDivElement> {
    /**
     * Whether the control should take up the full width of its container.
     *
     * @default false
     */
    fill?: boolean;

    /**
     * Whether the control should appear as an inline element.
     */
    inline?: boolean;

    /**
     * Whether this control should use large buttons.
     *
     * @default false
     */
    large?: boolean;

    /**
     * Visual intent to apply to the selected value.
     */
    intent?: SegmentedControlIntent;

    /**
     * List of available options.
     */
    options: Array<OptionProps<string>>;

    /**
     * Whether this control should use small buttons.
     *
     * @default false
     */
    small?: boolean;
}

/**
 * Segmented control component.
 *
 * @see https://blueprintjs.com/docs/#core/components/segmented-control
 */
export const SegmentedControl: React.FC<SegmentedControlProps> = React.forwardRef((props, ref) => {
    const {
        className,
        defaultValue,
        fill,
        inline,
        intent,
        large,
        onValueChange,
        options,
        small,
        value: controlledValue,
        ...htmlProps
    } = props;

    const [localValue, setLocalValue] = React.useState<string | undefined>(defaultValue);
    const selectedValue = controlledValue ?? localValue;

    const handleOptionClick = React.useCallback(
        (newSelectedValue: string, targetElement: HTMLElement) => {
            setLocalValue(newSelectedValue);
            onValueChange?.(newSelectedValue, targetElement);
        },
        [onValueChange],
    );

    const classes = classNames(Classes.SEGMENTED_CONTROL, className, {
        [Classes.FILL]: fill,
        [Classes.INLINE]: inline,
    });

    return (
        <div className={classes} ref={ref} {...removeNonHTMLProps(htmlProps)}>
            {options.map(option => (
                <SegmentedControlOption
                    {...option}
                    intent={intent}
                    isSelected={selectedValue === option.value}
                    key={option.value}
                    large={large}
                    onClick={handleOptionClick}
                    small={small}
                />
            ))}
        </div>
    );
});
SegmentedControl.defaultProps = {
    defaultValue: undefined,
    intent: Intent.NONE,
};
SegmentedControl.displayName = `${DISPLAYNAME_PREFIX}.SegmentedControl`;

interface SegmentedControlOptionProps
    extends OptionProps<string>,
        Pick<SegmentedControlProps, "intent" | "small" | "large"> {
    isSelected: boolean;
    onClick: (value: string, targetElement: HTMLElement) => void;
}

function SegmentedControlOption({ isSelected, label, onClick, value, ...buttonProps }: SegmentedControlOptionProps) {
    const handleClick = React.useCallback(
        (event: React.MouseEvent<HTMLElement>) => onClick?.(value, event.currentTarget),
        [onClick, value],
    );

    return <Button onClick={handleClick} minimal={!isSelected} text={label} {...buttonProps} />;
}
SegmentedControlOption.displayName = `${DISPLAYNAME_PREFIX}.SegmentedControlOption`;

================================================================================

File: src\components\segmented-control\_segmented-control.scss
--------------------------------------------------------------------------------
@use "sass:math";
@import "../../common/variables";

.#{$ns}-segmented-control {
  background-color: $light-gray5;
  border-radius: $pt-border-radius;
  display: flex;
  gap: 3px;
  padding: 3px;

  &.#{$ns}-inline {
    display: inline-flex;
  }

  &.#{$ns}-fill {
    width: 100%;

    > .#{$ns}-button {
      flex-grow: 1;
    }
  }

  > .#{$ns}-button:not(.#{$ns}-minimal) {
    &:not(.#{$ns}-intent-primary) {
      background-color: $white;

      .#{$ns}-dark & {
        background-color: $dark-gray5;
      }
    }
  }

  > .#{$ns}-button.#{$ns}-minimal {
    color: $pt-text-color-muted;

    .#{$ns}-dark & {
      color: $pt-dark-text-color-muted;
    }
  }

  > .#{$ns}-button.#{$ns}-minimal:disabled {
    color: $pt-text-color-disabled;

    .#{$ns}-dark & {
      color: $pt-dark-text-color-disabled;
    }
  }

  .#{$ns}-dark & {
    background-color: $dark-gray3;
  }
}

================================================================================

File: src\components\skeleton\skeleton.md
--------------------------------------------------------------------------------
@# Skeleton

Skeletons provide a loading state that mimics the shape of your yet-to-load content.

This "component" is a single constant `Classes.SKELETON` that, when applied to
an element through `className`, will cover its content with a loading animation.
The skeleton inherits the dimensions of whatever element the class is applied
to, so you should supply a placeholder while awaiting real content.

@css skeleton

@## CSS

Apply the class `.@ns-skeleton` to elements that you would like to cover up with
a loading animation.

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">Manually disable focusable elements</h5>

When using the `.@ns-skeleton` class on focusable elements such as inputs and buttons, be sure to disable the element,
via either the `disabled` or `tabindex="-1"` attributes. Failing to do so will allow these skeleton elements to be
focused when they shouldn't be.

</div>

================================================================================

File: src\components\skeleton\_common.scss
--------------------------------------------------------------------------------
// Copyright 2017 Palantir Technologies, Inc. All rights reserved.

@import "../../common/variables";

$skeleton-animation:
  ($pt-transition-duration * 10) linear infinite alternate skeleton-glow !default;
$skeleton-color-start: rgba($light-gray1, 0.2) !default;
$skeleton-color-end: rgba($gray1, 0.2) !default;

================================================================================

File: src\components\skeleton\_skeleton.scss
--------------------------------------------------------------------------------
// Copyright 2016 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "./common";

/*
Skeletons

Markup:
<div class="#{$ns}-card">
  <h5 class="#{$ns}-heading"><a class="{{.modifier}}" href="#" tabindex="-1">Card heading</a></h5>
  <p class="{{.modifier}}">
    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque eget tortor felis.
    Fusce dapibus metus in dapibus mollis. Quisque eget ex diam.
  </p>
  <button type="button" class="#{$ns}-button #{$ns}-icon-add {{.modifier}}" tabindex="-1">Submit</button>
</div>

.#{$ns}-skeleton - Render this element as a skeleton, an outline of its true self.

Styleguide skeleton
*/

@keyframes skeleton-glow {
  from {
    background: $skeleton-color-start;
    border-color: $skeleton-color-start;
  }

  to {
    background: $skeleton-color-end;
    border-color: $skeleton-color-end;
  }
}

// This class hides content with a glowing, rounded rectangle.
// CSS properties that should always override consumer values use the "!important" rule.
/* stylelint-disable declaration-no-important */
.#{$ns}-skeleton {
  animation: $skeleton-animation;

  // do not !important this for Firefox support
  background: $skeleton-color-start;

  // Prevent background color from extending to the border and overlappping
  background-clip: padding-box !important;
  border-color: $skeleton-color-start !important;
  border-radius: 2px;
  box-shadow: none !important;

  // Transparent text will occupy space but be invisible to the user
  color: transparent !important;
  cursor: default;
  pointer-events: none;
  user-select: none;

  // Make pseudo-elements (CSS icons) and children invisible
  &::before,
  &::after,
  * {
    visibility: hidden !important;
  }
}
/* stylelint-enable declaration-no-important */

================================================================================

File: src\components\slider\handle.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes, Utils } from "../../common";
import { DISPLAYNAME_PREFIX } from "../../common/props";
import { clamp } from "../../common/utils";

import type { HandleProps } from "./handleProps";
import { formatPercentage } from "./sliderUtils";

/**
 * Props for the internal <Handle> component needs some additional info from the parent Slider.
 */
export interface InternalHandleProps extends HandleProps {
    disabled?: boolean;
    label: React.JSX.Element | string | undefined;
    max: number;
    min: number;
    stepSize: number;
    tickSize: number;
    tickSizeRatio: number;
    vertical: boolean;
}

export interface HandleState {
    /** whether slider handle is currently being dragged */
    isMoving?: boolean;
}

// props that require number values, for validation
const NUMBER_PROPS = ["max", "min", "stepSize", "tickSize", "value"] satisfies Array<keyof InternalHandleProps>;

/** Internal component for a Handle with click/drag/keyboard logic to determine a new value. */
export class Handle extends AbstractPureComponent<InternalHandleProps, HandleState> {
    public static displayName = `${DISPLAYNAME_PREFIX}.SliderHandle`;

    public state = {
        isMoving: false,
    };

    private handleElement: HTMLElement | null = null;

    private refHandlers = {
        handle: (el: HTMLSpanElement) => (this.handleElement = el),
    };

    public componentDidMount() {
        // The first time this component renders, it has no ref to the handle and thus incorrectly centers the handle.
        // Therefore, on the first mount, force a re-render to center the handle with the ref'd component.
        this.forceUpdate();
    }

    public render() {
        const { className, disabled, label, min, max, value, vertical, htmlProps } = this.props;
        const { isMoving } = this.state;

        return (
            <span
                role="slider"
                tabIndex={0}
                {...htmlProps}
                className={classNames(Classes.SLIDER_HANDLE, { [Classes.ACTIVE]: isMoving }, className)}
                onKeyDown={disabled ? undefined : this.handleKeyDown}
                onKeyUp={disabled ? undefined : this.handleKeyUp}
                onMouseDown={disabled ? undefined : this.beginHandleMovement}
                onTouchStart={disabled ? undefined : this.beginHandleTouchMovement}
                ref={this.refHandlers.handle}
                style={this.getStyleProperties()}
                aria-valuemin={min}
                aria-valuemax={max}
                aria-valuenow={value}
                aria-disabled={disabled}
                aria-orientation={vertical ? "vertical" : "horizontal"}
            >
                {label == null ? null : <span className={Classes.SLIDER_LABEL}>{label}</span>}
            </span>
        );
    }

    public componentWillUnmount() {
        this.removeDocumentEventListeners();
    }

    /** Convert client pixel to value between min and max. */
    public clientToValue(clientPixel: number) {
        const { stepSize, tickSize, value, vertical } = this.props;
        if (this.handleElement == null) {
            return value;
        }

        // #1769: this logic doesn't work perfectly when the tick size is
        // smaller than the handle size; it may be off by a tick or two.
        const clientPixelNormalized = vertical ? window.innerHeight - clientPixel : clientPixel;
        const handleCenterPixel = this.getHandleElementCenterPixel(this.handleElement);
        const pixelDelta = clientPixelNormalized - handleCenterPixel;

        if (isNaN(pixelDelta)) {
            return value;
        }
        // convert pixels to range value in increments of `stepSize`
        return value + Math.round(pixelDelta / (tickSize * stepSize)) * stepSize;
    }

    public mouseEventClientOffset(event: MouseEvent | React.MouseEvent<HTMLElement>) {
        return this.props.vertical ? event.clientY : event.clientX;
    }

    public touchEventClientOffset(event: TouchEvent | React.TouchEvent<HTMLElement>) {
        const touch = event.changedTouches[0];
        return this.props.vertical ? touch.clientY : touch.clientX;
    }

    public beginHandleMovement = (event: MouseEvent | React.MouseEvent<HTMLElement>) => {
        document.addEventListener("mousemove", this.handleHandleMovement);
        document.addEventListener("mouseup", this.endHandleMovement);
        this.setState({ isMoving: true });
        this.changeValue(this.clientToValue(this.mouseEventClientOffset(event)));
    };

    public beginHandleTouchMovement = (event: TouchEvent | React.TouchEvent<HTMLElement>) => {
        document.addEventListener("touchmove", this.handleHandleTouchMovement);
        document.addEventListener("touchend", this.endHandleTouchMovement);
        document.addEventListener("touchcancel", this.endHandleTouchMovement);
        this.setState({ isMoving: true });
        this.changeValue(this.clientToValue(this.touchEventClientOffset(event)));
    };

    protected validateProps(props: InternalHandleProps) {
        for (const prop of NUMBER_PROPS) {
            if (typeof (props as any)[prop] !== "number") {
                throw new Error(`[Blueprint] <Handle> requires number value for ${prop} prop`);
            }
        }
    }

    private getStyleProperties = (): React.CSSProperties => {
        if (this.handleElement == null) {
            return {};
        }

        // The handle midpoint of RangeSlider is actually shifted by a margin to
        // be on the edge of the visible handle element. Because the midpoint
        // calculation does not take this margin into account, we instead
        // measure the long side (which is equal to the short side plus the
        // margin).

        const { min = 0, tickSizeRatio, value, vertical } = this.props;
        const { handleMidpoint } = this.getHandleMidpointAndOffset(this.handleElement, true);
        const offsetRatio = (value - min) * tickSizeRatio;
        const offsetCalc = `calc(${formatPercentage(offsetRatio)} - ${handleMidpoint}px)`;
        return vertical ? { bottom: offsetCalc } : { left: offsetCalc };
    };

    private endHandleMovement = (event: MouseEvent) => {
        this.handleMoveEndedAt(this.mouseEventClientOffset(event));
    };

    private endHandleTouchMovement = (event: TouchEvent) => {
        this.handleMoveEndedAt(this.touchEventClientOffset(event));
    };

    private handleMoveEndedAt = (clientPixel: number) => {
        this.removeDocumentEventListeners();
        this.setState({ isMoving: false });
        // always invoke onRelease; changeValue may call onChange if value is different
        const finalValue = this.changeValue(this.clientToValue(clientPixel));
        this.props.onRelease?.(finalValue);
    };

    private handleHandleMovement = (event: MouseEvent) => {
        this.handleMovedTo(this.mouseEventClientOffset(event));
    };

    private handleHandleTouchMovement = (event: TouchEvent) => {
        this.handleMovedTo(this.touchEventClientOffset(event));
    };

    private handleMovedTo = (clientPixel: number) => {
        if (this.state.isMoving && !this.props.disabled) {
            this.changeValue(this.clientToValue(clientPixel));
        }
    };

    private handleKeyDown = (event: React.KeyboardEvent<HTMLSpanElement>) => {
        const { stepSize, value } = this.props;
        const { key } = event;
        if (key === "ArrowDown" || key === "ArrowLeft") {
            this.changeValue(value - stepSize);
            // this key event has been handled! prevent browser scroll on up/down
            event.preventDefault();
        } else if (key === "ArrowUp" || key === "ArrowRight") {
            this.changeValue(value + stepSize);
            event.preventDefault();
        }
    };

    private handleKeyUp = (event: React.KeyboardEvent<HTMLSpanElement>) => {
        if (Utils.isArrowKey(event)) {
            this.props.onRelease?.(this.props.value);
        }
    };

    /** Clamp value and invoke callback if it differs from current value */
    private changeValue(newValue: number, callback = this.props.onChange) {
        newValue = this.clamp(newValue);
        if (!isNaN(newValue) && this.props.value !== newValue) {
            callback?.(newValue);
        }
        return newValue;
    }

    /** Clamp value between min and max props */
    private clamp(value: number) {
        return clamp(value, this.props.min, this.props.max);
    }

    private getHandleElementCenterPixel(handleElement: HTMLElement) {
        const { handleMidpoint, handleOffset } = this.getHandleMidpointAndOffset(handleElement);
        return handleOffset + handleMidpoint;
    }

    private getHandleMidpointAndOffset(handleElement: HTMLElement, useOppositeDimension = false) {
        if (handleElement == null) {
            return { handleMidpoint: 0, handleOffset: 0 };
        }

        const { vertical } = this.props;

        // N.B. element.clientHeight does not include border size.
        // Also, element.getBoundingClientRect() is useful to get the top & left position on the page, but
        // it fails to accurately measure element width & height inside absolutely-positioned and CSS-transformed
        // containers like Popovers, so we use element.offsetWidth & offsetHeight instead (see https://github.com/palantir/blueprint/issues/4417).
        const handleRect: DOMRect = handleElement.getBoundingClientRect();
        handleRect.width = handleElement.offsetWidth;
        handleRect.height = handleElement.offsetHeight;

        const sizeKey = vertical
            ? useOppositeDimension
                ? "width"
                : "height"
            : useOppositeDimension
              ? "height"
              : "width";

        // "bottom" value seems to be consistently incorrect, so explicitly
        // calculate it using the window offset instead.
        const handleOffset = vertical ? window.innerHeight - (handleRect.top + handleRect[sizeKey]) : handleRect.left;

        return { handleMidpoint: handleRect[sizeKey] / 2, handleOffset };
    }

    private removeDocumentEventListeners() {
        document.removeEventListener("mousemove", this.handleHandleMovement);
        document.removeEventListener("mouseup", this.endHandleMovement);
        document.removeEventListener("touchmove", this.handleHandleTouchMovement);
        document.removeEventListener("touchend", this.endHandleTouchMovement);
        document.removeEventListener("touchcancel", this.endHandleTouchMovement);
    }
}

================================================================================

File: src\components\slider\handleProps.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { CSSProperties, HTMLProps } from "react";

import type { Intent, Props } from "../../common";

export const HandleType = {
    /** A full handle appears as a small square. */
    FULL: "full" as const,

    /** A start handle appears as the left or top half of a square. */
    START: "start" as const,

    /** An end handle appears as the right or bottom half of a square. */
    END: "end" as const,
};
// eslint-disable-next-line @typescript-eslint/no-redeclare
export type HandleType = (typeof HandleType)[keyof typeof HandleType];

export const HandleInteractionKind = {
    /** Locked handles prevent other handles from being dragged past then. */
    LOCK: "lock" as const,

    /** Push handles move overlapping handles with them as they are dragged. */
    PUSH: "push" as const,

    /**
     * Handles marked "none" are not interactive and do not appear in the UI.
     * They serve only to break the track into subsections that can be colored separately.
     */
    NONE: "none" as const,
};
// eslint-disable-next-line @typescript-eslint/no-redeclare
export type HandleInteractionKind = (typeof HandleInteractionKind)[keyof typeof HandleInteractionKind];

export type HandleHtmlProps = Pick<HTMLProps<HTMLSpanElement>, "aria-label" | "aria-labelledby">;

export interface HandleProps extends Props {
    /** Numeric value of this handle. */
    value: number;

    /** Intent for the track segment immediately after this handle, taking priority over `intentBefore`. */
    intentAfter?: Intent;

    /** Intent for the track segment immediately before this handle. */
    intentBefore?: Intent;

    /** Style to use for the track segment immediately after this handle, taking priority over `trackStyleBefore`. */
    trackStyleAfter?: CSSProperties;

    /** Style to use for the track segment immediately before this handle */
    trackStyleBefore?: CSSProperties;

    /**
     * How this handle interacts with other handles.
     *
     * @default "lock"
     */
    interactionKind?: HandleInteractionKind;

    /**
     * Callback invoked when this handle's value is changed due to a drag
     * interaction. Note that "push" interactions can cause multiple handles to
     * update at the same time.
     */
    onChange?: (newValue: number) => void;

    /** Callback invoked when this handle is released (the end of a drag interaction). */
    onRelease?: (newValue: number) => void;

    /**
     * Handle appearance type.
     *
     * @default "full"
     */
    type?: HandleType;

    /**
     * A limited subset of HTML props to apply to the rendered `<span>` element.
     */
    htmlProps?: HandleHtmlProps;
}

================================================================================

File: src\components\slider\multiSlider.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import {
    AbstractPureComponent,
    Classes,
    DISPLAYNAME_PREFIX,
    Intent,
    type IntentProps,
    type Props,
    Utils,
} from "../../common";
import * as Errors from "../../common/errors";

import { Handle } from "./handle";
import { HandleInteractionKind, type HandleProps, HandleType } from "./handleProps";
import { argMin, fillValues, formatPercentage } from "./sliderUtils";

/**
 * SFC used to pass slider handle props to a `MultiSlider`.
 * This element is not rendered directly.
 */
const MultiSliderHandle: React.FC<HandleProps> = () => null;
MultiSliderHandle.displayName = `${DISPLAYNAME_PREFIX}.MultiSliderHandle`;

export interface SliderBaseProps extends Props, IntentProps {
    children?: React.ReactNode;

    /**
     * Whether the slider is non-interactive.
     *
     * @default false
     */
    disabled?: boolean;

    /**
     * Increment between successive labels. Must be greater than zero.
     *
     * @default inferred (if labelStepSize is undefined)
     */
    labelStepSize?: number;

    /**
     * Array of specific values for the label placement. This prop is mutually exclusive with
     * `labelStepSize`.
     */
    labelValues?: readonly number[];

    /**
     * Number of decimal places to use when rendering label value. Default value is the number of
     * decimals used in the `stepSize` prop. This prop has _no effect_ if you supply a custom
     * `labelRenderer` callback.
     *
     * @default inferred from stepSize
     */
    labelPrecision?: number;

    /**
     * Maximum value of the slider. Value must be a finite number.
     *
     * @default 10
     */
    max?: number;

    /**
     * Minimum value of the slider. Value must be a finite number.
     *
     * @default 0
     */
    min?: number;

    /**
     * Whether a solid bar should be rendered on the track between current and initial values,
     * or between handles for `RangeSlider`.
     *
     * @default true
     */
    showTrackFill?: boolean;

    /**
     * Increment between successive values; amount by which the handle moves. Must be greater than zero.
     *
     * @default 1
     */
    stepSize?: number;

    /**
     * Callback to render a single label. Useful for formatting numbers as currency or percentages.
     * If `true`, labels will use number value formatted to `labelPrecision` decimal places.
     * If `false`, labels will not be shown.
     *
     * The callback is provided a numeric value and optional rendering options, which include:
     * - isHandleTooltip: whether this label is being rendered within a handle tooltip
     *
     * @default true
     */
    labelRenderer?: boolean | ((value: number, opts?: { isHandleTooltip: boolean }) => string | React.JSX.Element);

    /**
     * Whether to show the slider in a vertical orientation.
     *
     * @default false
     */
    vertical?: boolean;
}

export interface MultiSliderProps extends SliderBaseProps {
    /** Default intent of a track segment, used only if no handle specifies `intentBefore/After`. */
    defaultTrackIntent?: Intent;

    /** Callback invoked when a handle value changes. Receives handle values in sorted order. */
    onChange?(values: number[]): void;

    /** Callback invoked when a handle is released. Receives handle values in sorted order. */
    onRelease?(values: number[]): void;
}

export interface SliderState {
    labelPrecision: number;
    /** the client size, in pixels, of one tick */
    tickSize: number;
    /** the size of one tick as a ratio of the component's client size */
    tickSizeRatio: number;
}

/**
 * Multi slider component.
 *
 * @see https://blueprintjs.com/docs/#core/components/sliders.multi-slider
 */
export class MultiSlider extends AbstractPureComponent<MultiSliderProps, SliderState> {
    public static defaultSliderProps: SliderBaseProps = {
        disabled: false,
        max: 10,
        min: 0,
        showTrackFill: true,
        stepSize: 1,
        vertical: false,
    };

    public static defaultProps: MultiSliderProps = {
        ...MultiSlider.defaultSliderProps,
        defaultTrackIntent: Intent.NONE,
    };

    public static displayName = `${DISPLAYNAME_PREFIX}.MultiSlider`;

    public static Handle = MultiSliderHandle;

    public static getDerivedStateFromProps(props: MultiSliderProps) {
        return { labelPrecision: MultiSlider.getLabelPrecision(props) };
    }

    private static getLabelPrecision({ labelPrecision, stepSize }: MultiSliderProps) {
        // infer default label precision from stepSize because that's how much the handle moves.
        return labelPrecision == null ? Utils.countDecimalPlaces(stepSize!) : labelPrecision;
    }

    public state: SliderState = {
        labelPrecision: getLabelPrecision(this.props),
        tickSize: 0,
        tickSizeRatio: 0,
    };

    private handleElements: Handle[] = [];

    private trackElement: HTMLElement | null = null;

    public getSnapshotBeforeUpdate(prevProps: MultiSliderProps): null {
        const prevHandleProps = getSortedInteractiveHandleProps(prevProps);
        const newHandleProps = getSortedInteractiveHandleProps(this.props);
        if (newHandleProps.length !== prevHandleProps.length) {
            // clear refs
            this.handleElements = [];
        }
        return null;
    }

    public render() {
        const classes = classNames(
            Classes.SLIDER,
            {
                [Classes.DISABLED]: this.props.disabled,
                [`${Classes.SLIDER}-unlabeled`]: this.props.labelRenderer === false,
                [Classes.VERTICAL]: this.props.vertical,
            },
            this.props.className,
        );
        return (
            <div className={classes} onMouseDown={this.maybeHandleTrackClick} onTouchStart={this.maybeHandleTrackTouch}>
                <div className={Classes.SLIDER_TRACK} ref={ref => (this.trackElement = ref)}>
                    {this.renderTracks()}
                </div>
                <div className={Classes.SLIDER_AXIS}>{this.renderLabels()}</div>
                {this.renderHandles()}
            </div>
        );
    }

    public componentDidMount() {
        this.updateTickSize();
    }

    public componentDidUpdate(prevProps: MultiSliderProps, prevState: SliderState) {
        super.componentDidUpdate(prevProps, prevState);
        this.updateTickSize();
    }

    protected validateProps(props: React.PropsWithChildren<MultiSliderProps>) {
        if (props.stepSize! <= 0) {
            throw new Error(Errors.SLIDER_ZERO_STEP);
        }
        if (props.labelStepSize !== undefined && props.labelValues !== undefined) {
            throw new Error(Errors.MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX);
        }
        if (props.labelStepSize !== undefined && props.labelStepSize! <= 0) {
            throw new Error(Errors.SLIDER_ZERO_LABEL_STEP);
        }
        if (props.min !== undefined && !isFinite(props.min)) {
            throw new Error(Errors.SLIDER_MIN);
        }
        if (props.max !== undefined && !isFinite(props.max)) {
            throw new Error(Errors.SLIDER_MAX);
        }

        let anyInvalidChildren = false;
        React.Children.forEach(props.children, child => {
            // allow boolean coercion to omit nulls and false values
            if (child && !Utils.isElementOfType(child, MultiSlider.Handle)) {
                anyInvalidChildren = true;
            }
        });
        if (anyInvalidChildren) {
            throw new Error(Errors.MULTISLIDER_INVALID_CHILD);
        }
    }

    private formatLabel(value: number, isHandleTooltip: boolean = false) {
        const { labelRenderer } = this.props;
        if (labelRenderer === false) {
            return undefined;
        } else if (Utils.isFunction(labelRenderer)) {
            return labelRenderer(value, { isHandleTooltip });
        } else {
            return value.toFixed(this.state.labelPrecision);
        }
    }

    private renderLabels() {
        if (this.props.labelRenderer === false) {
            return null;
        }

        const values = this.getLabelValues();
        const { max, min } = this.props;
        const labels = values.map((step, i) => {
            const offsetPercentage = formatPercentage((step - min!) / (max! - min!));
            const style = this.props.vertical ? { bottom: offsetPercentage } : { left: offsetPercentage };
            return (
                <div className={Classes.SLIDER_LABEL} key={i} style={style}>
                    {this.formatLabel(step)}
                </div>
            );
        });

        return labels;
    }

    private renderTracks() {
        const trackStops = getSortedHandleProps(this.props);
        trackStops.push({ value: this.props.max! });

        // render from current to previous, then increment previous
        let previous: HandleProps = { value: this.props.min! };
        const handles: React.JSX.Element[] = [];
        for (let index = 0; index < trackStops.length; index++) {
            const current = trackStops[index];
            handles.push(this.renderTrackFill(index, previous, current));
            previous = current;
        }
        return handles;
    }

    private renderTrackFill(index: number, start: HandleProps, end: HandleProps) {
        // ensure startRatio <= endRatio
        const [startRatio, endRatio] = [this.getOffsetRatio(start.value), this.getOffsetRatio(end.value)].sort(
            (left, right) => left - right,
        );
        const startOffset = formatPercentage(startRatio);
        const endOffset = formatPercentage(1 - endRatio);
        const orientationStyle: React.CSSProperties = this.props.vertical
            ? { bottom: startOffset, top: endOffset, left: 0 }
            : { left: startOffset, right: endOffset, top: 0 };

        const style: React.CSSProperties = {
            ...orientationStyle,
            ...(start.trackStyleAfter || end.trackStyleBefore || {}),
        };

        const classes = classNames(Classes.SLIDER_PROGRESS, Classes.intentClass(this.getTrackIntent(start, end)));
        return <div key={`track-${index}`} className={classes} style={style} />;
    }

    private renderHandles() {
        const { disabled, max, min, stepSize, vertical } = this.props;
        const handleProps = getSortedInteractiveHandleProps(this.props);

        if (handleProps.length === 0) {
            return null;
        }

        return handleProps.map(({ value, type, className, htmlProps }, index) => (
            <Handle
                htmlProps={htmlProps}
                className={classNames(
                    {
                        [Classes.START]: type === HandleType.START,
                        [Classes.END]: type === HandleType.END,
                    },
                    className,
                )}
                disabled={disabled}
                key={`${index}-${handleProps.length}`}
                label={this.formatLabel(value, true)}
                max={max!}
                min={min!}
                onChange={this.getHandlerForIndex(index, this.handleChange)}
                onRelease={this.getHandlerForIndex(index, this.handleRelease)}
                ref={this.addHandleRef}
                stepSize={stepSize!}
                tickSize={this.state.tickSize}
                tickSizeRatio={this.state.tickSizeRatio}
                value={value}
                vertical={vertical!}
            />
        ));
    }

    private addHandleRef = (ref: Handle) => {
        if (ref != null) {
            this.handleElements.push(ref);
        }
    };

    private maybeHandleTrackClick = (event: React.MouseEvent<HTMLDivElement>) => {
        if (this.canHandleTrackEvent(event)) {
            const foundHandle = this.nearestHandleForValue(this.handleElements, handle =>
                handle.mouseEventClientOffset(event),
            );
            if (foundHandle) {
                foundHandle.beginHandleMovement(event);
            }
        }
    };

    private maybeHandleTrackTouch = (event: React.TouchEvent<HTMLDivElement>) => {
        if (this.canHandleTrackEvent(event)) {
            const foundHandle = this.nearestHandleForValue(this.handleElements, handle =>
                handle.touchEventClientOffset(event),
            );
            if (foundHandle) {
                foundHandle.beginHandleTouchMovement(event);
            }
        }
    };

    private canHandleTrackEvent = (event: React.MouseEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement>) => {
        const target = event.target as HTMLElement;
        // ensure event does not come from inside the handle
        return !this.props.disabled && target.closest(`.${Classes.SLIDER_HANDLE}`) == null;
    };

    private nearestHandleForValue(handles: Handle[], getOffset: (handle: Handle) => number): Handle | undefined {
        return argMin(handles, handle => {
            const offset = getOffset(handle);
            const offsetValue = handle.clientToValue(offset);
            const handleValue = handle.props.value!;
            return Math.abs(offsetValue - handleValue);
        });
    }

    private getHandlerForIndex = (index: number, callback?: (values: number[]) => void) => {
        return (newValue: number) => {
            callback?.(this.getNewHandleValues(newValue, index));
        };
    };

    private getNewHandleValues(newValue: number, oldIndex: number) {
        const handleProps = getSortedInteractiveHandleProps(this.props);
        const oldValues = handleProps.map(handle => handle.value);
        const newValues = oldValues.slice();
        newValues[oldIndex] = newValue;
        newValues.sort((left, right) => left - right);

        const newIndex = newValues.indexOf(newValue);
        const lockIndex = this.findFirstLockedHandleIndex(oldIndex, newIndex);
        if (lockIndex === -1) {
            fillValues(newValues, oldIndex, newIndex, newValue);
        } else {
            // If pushing past a locked handle, discard the new value and only make the updates to clamp values against the lock.
            const lockValue = oldValues[lockIndex];
            fillValues(oldValues, oldIndex, lockIndex, lockValue);
            return oldValues;
        }

        return newValues;
    }

    private findFirstLockedHandleIndex(startIndex: number, endIndex: number): number {
        const inc = startIndex < endIndex ? 1 : -1;
        const handleProps = getSortedInteractiveHandleProps(this.props);

        for (let index = startIndex + inc; index !== endIndex + inc; index += inc) {
            if (handleProps[index].interactionKind !== HandleInteractionKind.PUSH) {
                return index;
            }
        }

        return -1;
    }

    private handleChange = (newValues: number[]) => {
        const handleProps = getSortedInteractiveHandleProps(this.props);
        const oldValues = handleProps.map(handle => handle.value);
        if (!Utils.arraysEqual(newValues, oldValues)) {
            this.props.onChange?.(newValues);
            handleProps.forEach((handle, index) => {
                if (oldValues[index] !== newValues[index]) {
                    handle.onChange?.(newValues[index]);
                }
            });
        }
    };

    private handleRelease = (newValues: number[]) => {
        const handleProps = getSortedInteractiveHandleProps(this.props);
        this.props.onRelease?.(newValues);
        handleProps.forEach((handle, index) => {
            handle.onRelease?.(newValues[index]);
        });
    };

    private getLabelValues() {
        const { labelStepSize, labelValues, min, max } = this.props;
        let values: number[] = [];
        if (labelValues !== undefined) {
            values = labelValues.slice();
        } else {
            for (let i = min!; i < max! || Utils.approxEqual(i, max!); i += labelStepSize ?? 1) {
                values.push(i);
            }
        }

        return values;
    }

    private getOffsetRatio(value: number) {
        return Utils.clamp((value - this.props.min!) * this.state.tickSizeRatio, 0, 1);
    }

    private getTrackIntent(start: HandleProps, end?: HandleProps): Intent {
        if (!this.props.showTrackFill) {
            return Intent.NONE;
        }
        if (start.intentAfter !== undefined) {
            return start.intentAfter;
        } else if (end !== undefined && end.intentBefore !== undefined) {
            return end.intentBefore;
        }
        return this.props.defaultTrackIntent!;
    }

    private updateTickSize() {
        if (this.trackElement != null) {
            const trackSize = this.props.vertical ? this.trackElement.clientHeight : this.trackElement.clientWidth;
            const tickSizeRatio = 1 / ((this.props.max as number) - (this.props.min as number));
            const tickSize = trackSize * tickSizeRatio;
            this.setState({ tickSize, tickSizeRatio });
        }
    }
}

function getLabelPrecision({ labelPrecision, stepSize = MultiSlider.defaultSliderProps.stepSize! }: MultiSliderProps) {
    // infer default label precision from stepSize because that's how much the handle moves.
    return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;
}

function getSortedInteractiveHandleProps(props: React.PropsWithChildren<MultiSliderProps>): HandleProps[] {
    return getSortedHandleProps(props, childProps => childProps.interactionKind !== HandleInteractionKind.NONE);
}

function getSortedHandleProps({ children }: MultiSliderProps, predicate: (props: HandleProps) => boolean = () => true) {
    const maybeHandles = React.Children.map(children, child =>
        Utils.isElementOfType(child, MultiSlider.Handle) && predicate(child.props) ? child.props : null,
    );
    let handles = maybeHandles != null ? maybeHandles : [];
    handles = handles.filter(handle => handle !== null);
    handles.sort((left, right) => left.value - right.value);
    return handles;
}

================================================================================

File: src\components\slider\rangeSlider.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

import { AbstractPureComponent, DISPLAYNAME_PREFIX, Intent } from "../../common";
import * as Errors from "../../common/errors";

import type { HandleHtmlProps } from "./handleProps";
import { MultiSlider, type SliderBaseProps } from "./multiSlider";

export type NumberRange = [number, number];

enum RangeIndex {
    START = 0,
    END = 1,
}

export interface RangeSliderProps extends SliderBaseProps {
    /**
     * Range value of slider. Handles will be rendered at each position in the range.
     *
     * @default [0, 10]
     */
    value?: NumberRange;

    /** Callback invoked when the range value changes. */
    onChange?(value: NumberRange): void;

    /** Callback invoked when a handle is released. */
    onRelease?(value: NumberRange): void;

    /** HTML props to apply to the slider Handles */
    handleHtmlProps?: { start?: HandleHtmlProps; end?: HandleHtmlProps };
}

/**
 * Range slider component.
 *
 * @see https://blueprintjs.com/docs/#core/components/sliders.range-slider
 */
export class RangeSlider extends AbstractPureComponent<RangeSliderProps> {
    public static defaultProps: RangeSliderProps = {
        ...MultiSlider.defaultSliderProps,
        intent: Intent.PRIMARY,
        value: [0, 10],
    };

    public static displayName = `${DISPLAYNAME_PREFIX}.RangeSlider`;

    public render() {
        const { value, handleHtmlProps, ...props } = this.props;
        return (
            <MultiSlider {...props}>
                <MultiSlider.Handle
                    value={value![RangeIndex.START]}
                    type="start"
                    intentAfter={props.intent}
                    htmlProps={handleHtmlProps?.start}
                />
                <MultiSlider.Handle value={value![RangeIndex.END]} type="end" htmlProps={handleHtmlProps?.end} />
            </MultiSlider>
        );
    }

    protected validateProps(props: RangeSliderProps) {
        const { value } = props;
        if (value == null || value[RangeIndex.START] == null || value[RangeIndex.END] == null) {
            throw new Error(Errors.RANGESLIDER_NULL_VALUE);
        }
    }
}

================================================================================

File: src\components\slider\slider.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

import { AbstractPureComponent, Intent } from "../../common";
import { DISPLAYNAME_PREFIX } from "../../common/props";

import type { HandleHtmlProps } from "./handleProps";
import { MultiSlider, type SliderBaseProps } from "./multiSlider";

export interface SliderProps extends SliderBaseProps {
    /**
     * Initial value of the slider. This determines the other end of the
     * track fill: from `initialValue` to `value`.
     *
     * @default 0
     */
    initialValue?: number;

    /**
     * Value of slider.
     *
     * @default 0
     */
    value?: number;

    /** Callback invoked when the value changes. */
    onChange?(value: number): void;

    /** Callback invoked when the handle is released. */
    onRelease?(value: number): void;

    /** A limited subset of HTML props to apply to the slider Handle */
    handleHtmlProps?: HandleHtmlProps;
}

/**
 * Slider component.
 *
 * @see https://blueprintjs.com/docs/#core/components/sliders.slider
 */
export class Slider extends AbstractPureComponent<SliderProps> {
    public static defaultProps: SliderProps = {
        ...MultiSlider.defaultSliderProps,
        initialValue: 0,
        intent: Intent.PRIMARY,
        value: 0,
    };

    public static displayName = `${DISPLAYNAME_PREFIX}.Slider`;

    public render() {
        const { initialValue, intent, value, onChange, onRelease, handleHtmlProps, ...props } = this.props;
        return (
            <MultiSlider {...props}>
                <MultiSlider.Handle
                    value={value!}
                    intentAfter={value! < initialValue! ? intent : undefined}
                    intentBefore={value! > initialValue! ? intent : undefined}
                    onChange={onChange}
                    onRelease={onRelease}
                    htmlProps={handleHtmlProps}
                />
                <MultiSlider.Handle value={initialValue!} interactionKind="none" />
            </MultiSlider>
        );
    }
}

================================================================================

File: src\components\slider\sliders.md
--------------------------------------------------------------------------------
@# Slider

A slider is a numeric input for choosing numbers between lower and upper bounds.
It also has a labeled axis that supports custom formatting.

To adjust a slider value, the user clicks and drags a handle or clicks the axis
to move the nearest handle to that spot. Users can also use arrow keys on the
keyboard to adjust individual handles.

Use `Slider` for choosing a single value, `RangeSlider` for choosing two values,
and `MultiSlider` for more advanced use cases.

@## Slider

Use `Slider` to choose a single value on a number line. It is a controlled
component, so the `value` prop determines its current appearance. Provide an
`onChange` handler to receive updates and an `onRelease` handler to determine
when the user has stopped interacting with the slider.

@reactExample SliderExample

@interface SliderProps

@## Range slider

Use `RangeSlider` to choose a range between upper and lower bounds. The
component functions identically to `Slider` with the addition of a second
handle. It exposes its selected value as `[number, number]`: a two-element array
with minimum and maximum range bounds.

`RangeSlider` is a controlled component, so the `value` prop determines its
current appearance. Provide an `onChange` handler to receive updates and an
`onRelease` handler to determine when the user has stopped interacting with the
slider.

@reactExample RangeSliderExample

@interface RangeSliderProps

@## Multi slider

`MultiSlider` is a flexible solution for picking arbitrary values on a number
line. It powers both `Slider` and `RangeSlider` internally and can be used for
implementing more advanced use cases than one or two numbers.

@reactExample MultiSliderExample

@interface MultiSliderProps

@### Handle

Handles for a `MultiSlider` are configured as `MultiSlider.Handle` children
elements, each with their own `value` and other properties.

```tsx
// RangeSlider looks roughly like this:
<MultiSlider onChange={...}>
    <MultiSlider.Handle
        value={startValue}
        type="start"
        intentAfter={Intent.PRIMARY}
        htmlProps={handleHtmlProps.start}
    />
    <MultiSlider.Handle
        value={endValue}
        type="end"
        htmlProps={handleHtmlProps.end}
    />
</MultiSlider>
```

@interface HandleProps

================================================================================

File: src\components\slider\sliderUtils.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Helper function for formatting ratios as CSS percentage values. */
export function formatPercentage(ratio: number) {
    return `${(ratio * 100).toFixed(2)}%`;
}

/**
 * Mutates the values array by filling all the values between start and end index (inclusive) with the fill value.
 */
export function fillValues<T>(values: T[], startIndex: number, endIndex: number, fillValue: T) {
    const inc = startIndex < endIndex ? 1 : -1;
    for (let index = startIndex; index !== endIndex + inc; index += inc) {
        values[index] = fillValue;
    }
}

/**
 * Returns the minimum element of an array as determined by comparing the results of calling the arg function on each
 * element of the array. The function will only be called once per element.
 */
export function argMin<T>(values: T[], argFn: (value: T) => any): T | undefined {
    if (values.length === 0) {
        return undefined;
    }

    let minValue = values[0];
    let minArg = argFn(minValue);

    for (let index = 1; index < values.length; index++) {
        const value = values[index];
        const arg = argFn(value);
        if (arg < minArg) {
            minValue = value;
            minArg = arg;
        }
    }

    return minValue;
}

================================================================================

File: src\components\slider\_common.scss
--------------------------------------------------------------------------------
// Copyright 2016 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "@blueprintjs/icons/lib/scss/variables";
@import "../../common/mixins";
@import "../button/common";

@mixin slider-orientation($size, $vertical: false) {
  $slider-min-size: $pt-grid-size * 15;

  @if $vertical == false {
    height: $size;
    min-width: $slider-min-size;
    width: 100%;
  } @else {
    // define the same rules for both vertical as for horizontal to ensure all
    // horizontal rules are fully overridden.
    height: $slider-min-size;
    min-width: $size;
    width: $size;
  }
}

@mixin slider-track-orientation($handle-size, $track-size, $vertical: false) {
  $slider-track-offset: ($handle-size - $track-size) * 0.5;

  @if $vertical == false {
    height: $track-size;
    left: 0;
    right: 0;
    top: $slider-track-offset;
  } @else {
    bottom: 0;
    height: auto; // override the non-vertical rule above
    left: $slider-track-offset;
    top: 0;
    width: $track-size;
  }
}

@mixin slider-label-orientation($label-offset, $vertical: false) {
  @if $vertical == false {
    transform: translate(-50%, $label-offset);
  } @else {
    transform: translate($label-offset, 50%);
  }
}

================================================================================

File: src\components\slider\_slider.scss
--------------------------------------------------------------------------------
// Copyright 2016 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../tooltip/tooltip";
@import "./common";

$handle-size: $pt-icon-size-standard !default;
$track-size: $handle-size - $pt-grid-size !default;
$label-offset: $handle-size + 4px !default;

$handle-border-shadow: 0 0 0 $button-border-width rgba($black, 0.5);
$handle-box-shadow:
  $handle-border-shadow,
  0 1px 1px rgba($black, 0.5) !default;
$handle-box-shadow-hover:
  $handle-border-shadow,
  0 1px 2px rgba($black, 0.6) !default;
$handle-box-shadow-active:
  inset 0 1px 1px rgba($black, 0.1),
  $handle-border-shadow,
  0 1px 2px rgba($black, 0.2) !default;

// retain legacy variable aliases so as to not break consumers
$handle-height: $handle-size !default;
$track-height: $track-size !default;

.#{$ns}-slider {
  @include slider-orientation($pt-input-height-large, $vertical: false);
  cursor: default;
  outline: none;
  position: relative;
  user-select: none;

  &:hover {
    cursor: pointer;
  }

  &:active {
    cursor: grabbing;
  }

  &.#{$ns}-disabled {
    cursor: not-allowed;
    opacity: 0.5;
  }

  &.#{$ns}-slider-unlabeled {
    height: $handle-size;
  }
}

.#{$ns}-slider-track,
.#{$ns}-slider-progress {
  @include slider-track-orientation($handle-size, $track-size, $vertical: false);
  position: absolute;
}

.#{$ns}-slider-track {
  border-radius: $pt-border-radius;
  overflow: hidden;
}

.#{$ns}-slider-progress {
  background: rgba($gray1, 0.2);

  .#{$ns}-dark & {
    background: rgba($black, 0.5);
  }

  @each $intent, $color in $pt-intent-colors {
    &.#{$ns}-intent-#{$intent} {
      background-color: $color;
    }
  }

  @media (forced-colors: active) and (prefers-color-scheme: dark) {
    background: ButtonText;
  }
}

.#{$ns}-slider-handle {
  @include pt-button();
  border-radius: $pt-border-radius;
  box-shadow: $handle-box-shadow;
  cursor: pointer;
  height: $handle-size;
  left: 0;
  position: absolute;
  top: 0;
  width: $handle-size;

  // ensure target handle's label always covers neighbors
  &:focus {
    z-index: 1;
  }

  &:hover {
    @include pt-button-hover();
    box-shadow: $handle-box-shadow-hover;
    cursor: grab;
    z-index: 2;
  }

  &.#{$ns}-active {
    @include pt-button-active();
    box-shadow: $handle-box-shadow-active;
    cursor: grabbing;
  }

  .#{$ns}-disabled & {
    background: $gray5;
    box-shadow: none;
    // easy way to avoid lots of special cases to ignore mouse states when disabled:
    pointer-events: none;
  }

  .#{$ns}-dark & {
    // don't use pt-dark-button() here, since we want to appear more like a light theme button
    background-color: $gray4;
    box-shadow: $dark-button-box-shadow;

    &:hover {
      background-color: $gray3;
      box-shadow: $dark-button-box-shadow-active;
    }

    &.#{$ns}-active {
      background-color: $gray2;
      box-shadow: inset 0 1px 1px rgba($black, 0.1), $dark-button-box-shadow-active;
    }
  }

  .#{$ns}-dark .#{$ns}-disabled & {
    background: $gray1;
    border-color: $gray1;
    box-shadow: none;
  }

  .#{$ns}-slider-label {
    background: $tooltip-background-color;
    border-radius: $pt-border-radius;
    box-shadow: $pt-tooltip-box-shadow;
    color: $tooltip-text-color;
    margin-left: $handle-size * 0.5;

    .#{$ns}-dark & {
      background: $dark-tooltip-background-color;
      box-shadow: $pt-dark-tooltip-box-shadow;
      color: $dark-tooltip-text-color;
    }

    .#{$ns}-disabled & {
      box-shadow: none;
    }
  }

  &.#{$ns}-start,
  &.#{$ns}-end {
    width: $handle-size * 0.5;
  }

  &.#{$ns}-start {
    border-bottom-right-radius: 0;
    border-top-right-radius: 0;
  }

  &.#{$ns}-end {
    border-bottom-left-radius: 0;
    border-top-left-radius: 0;
    margin-left: $handle-size * 0.5;

    .#{$ns}-slider-label {
      margin-left: 0;
    }
  }
}

.#{$ns}-slider-label {
  @include slider-label-orientation($label-offset);
  display: inline-block;
  font-size: $pt-font-size-small;
  line-height: 1;
  padding: ($pt-grid-size * 0.2) ($pt-grid-size * 0.5);
  position: absolute;
  vertical-align: top;
}

.#{$ns}-slider.#{$ns}-vertical {
  @include slider-orientation($pt-input-height-large, $vertical: true);

  .#{$ns}-slider-track,
  .#{$ns}-slider-progress {
    @include slider-track-orientation($handle-size, $track-size, $vertical: true);
  }

  .#{$ns}-slider-progress {
    top: auto;
  }

  .#{$ns}-slider-label {
    @include slider-label-orientation($label-offset, $vertical: true);
  }

  .#{$ns}-slider-handle {
    top: auto;

    .#{$ns}-slider-label {
      margin-left: 0;
      margin-top: -$handle-size * 0.5;
    }

    &.#{$ns}-end,
    &.#{$ns}-start {
      height: $handle-size * 0.5;
      margin-left: 0;
      width: $handle-size;
    }

    &.#{$ns}-start {
      border-bottom-right-radius: $pt-border-radius;
      border-top-left-radius: 0;

      .#{$ns}-slider-label {
        transform: translate($label-offset);
      }
    }

    &.#{$ns}-end {
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      border-top-left-radius: $pt-border-radius;
      margin-bottom: $handle-size * 0.5;
    }
  }
}

================================================================================

File: src\components\spinner\spinner.md
--------------------------------------------------------------------------------
@# Spinner

__Spinners__ indicate progress in a circular fashion. They're great for ongoing operations of indeterminate length and
can also represent known progress.

@reactExample SpinnerExample

@## Usage

__Spinner__ is a simple stateless component that renders SVG markup. It can be used safely in DOM and SVG containers as
it only renders SVG elements.

The `value` prop determines how much of the track is filled by the head. When this prop is defined, the spinner head
will smoothly animate as `value` changes. Omitting `value` will result in an "indeterminate" spinner where the head
spins indefinitely (this is the default appearance).

The `size` prop determines the pixel width/height of the spinner. Size constants are provided as an enum:
`SpinnerSize.SMALL`, `SpinnerSize.STANDARD`, and `SpinnerSize.LARGE`

@## Props interface

@interface SpinnerProps

================================================================================

File: src\components\spinner\spinner.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes } from "../../common";
import { SPINNER_WARN_CLASSES_SIZE } from "../../common/errors";
import { DISPLAYNAME_PREFIX, type IntentProps, type Props } from "../../common/props";
import { clamp } from "../../common/utils";

export enum SpinnerSize {
    SMALL = 20,
    STANDARD = 50,
    LARGE = 100,
}

// see http://stackoverflow.com/a/18473154/3124288 for calculating arc path
const R = 45;
const SPINNER_TRACK = `M 50,50 m 0,-${R} a ${R},${R} 0 1 1 0,${R * 2} a ${R},${R} 0 1 1 0,-${R * 2}`;

// unitless total length of SVG path, to which stroke-dash* properties are relative.
// https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/pathLength
// this value is the result of `<path d={SPINNER_TRACK} />.getTotalLength()` and works in all browsers:
const PATH_LENGTH = 280;

const MIN_SIZE = 10;
const STROKE_WIDTH = 4;
const MIN_STROKE_WIDTH = 16;

export interface SpinnerProps<T extends HTMLElement = HTMLElement> extends Props, IntentProps, React.HTMLAttributes<T> {
    /**
     * Width and height of the spinner in pixels. The size cannot be less than
     * 10px.
     *
     * Constants are available for common sizes:
     * - `SpinnerSize.SMALL = 20px`
     * - `SpinnerSize.STANDARD = 50px`
     * - `SpinnerSize.LARGE = 100px`
     *
     * @default SpinnerSize.STANDARD = 50
     */
    size?: number;

    /**
     * HTML tag for the two wrapper elements. If rendering a `<Spinner>` inside
     * an `<svg>`, change this to an SVG element like `"g"`.
     *
     * @default "div"
     */
    tagName?: keyof React.JSX.IntrinsicElements;

    /**
     * A value between 0 and 1 (inclusive) representing how far along the operation is.
     * Values below 0 or above 1 will be interpreted as 0 or 1 respectively.
     * Omitting this prop will result in an "indeterminate" spinner where the head spins indefinitely.
     */
    value?: number;
}

/**
 * Spinner component.
 *
 * @see https://blueprintjs.com/docs/#core/components/spinner
 */
export class Spinner extends AbstractPureComponent<SpinnerProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.Spinner`;

    public componentDidUpdate(prevProps: SpinnerProps) {
        if (prevProps.value !== this.props.value) {
            // IE/Edge: re-render after changing value to force SVG update
            this.forceUpdate();
        }
    }

    public render() {
        const { className, intent, value, tagName = "div", ...htmlProps } = this.props;
        const size = this.getSize();

        const classes = classNames(
            Classes.SPINNER,
            Classes.intentClass(intent),
            { [Classes.SPINNER_NO_SPIN]: value != null },
            className,
        );

        // keep spinner track width consistent at all sizes (down to about 10px).
        const strokeWidth = Math.min(MIN_STROKE_WIDTH, (STROKE_WIDTH * SpinnerSize.LARGE) / size);
        const strokeOffset = PATH_LENGTH - PATH_LENGTH * (value == null ? 0.25 : clamp(value, 0, 1));

        // multiple DOM elements around SVG are necessary to properly isolate animation:
        // - SVG elements in IE do not support anim/trans so they must be set on a parent HTML element.
        // - SPINNER_ANIMATION isolates svg from parent display and is always centered inside root element.
        return React.createElement(
            tagName,
            {
                "aria-label": "loading",
                "aria-valuemax": 100,
                "aria-valuemin": 0,
                "aria-valuenow": value === undefined ? undefined : value * 100,
                className: classes,
                role: "progressbar",
                ...htmlProps,
            },
            React.createElement(
                tagName,
                { className: Classes.SPINNER_ANIMATION },
                <svg
                    width={size}
                    height={size}
                    strokeWidth={strokeWidth.toFixed(2)}
                    viewBox={this.getViewBox(strokeWidth)}
                >
                    <path className={Classes.SPINNER_TRACK} d={SPINNER_TRACK} />
                    <path
                        className={Classes.SPINNER_HEAD}
                        d={SPINNER_TRACK}
                        pathLength={PATH_LENGTH}
                        strokeDasharray={`${PATH_LENGTH} ${PATH_LENGTH}`}
                        strokeDashoffset={strokeOffset}
                    />
                </svg>,
            ),
        );
    }

    protected validateProps({ className = "", size }: SpinnerProps) {
        if (size != null && (className.indexOf(Classes.SMALL) >= 0 || className.indexOf(Classes.LARGE) >= 0)) {
            console.warn(SPINNER_WARN_CLASSES_SIZE);
        }
    }

    /**
     * Resolve size to a pixel value.
     * Size can be set by className, props, default, or minimum constant.
     */
    private getSize() {
        const { className = "", size } = this.props;
        if (size == null) {
            // allow Classes constants to determine default size.
            if (className.indexOf(Classes.SMALL) >= 0) {
                return SpinnerSize.SMALL;
            } else if (className.indexOf(Classes.LARGE) >= 0) {
                return SpinnerSize.LARGE;
            }
            return SpinnerSize.STANDARD;
        }
        return Math.max(MIN_SIZE, size);
    }

    /** Compute viewbox such that stroked track sits exactly at edge of image frame. */
    private getViewBox(strokeWidth: number) {
        const radius = R + strokeWidth / 2;
        const viewBoxX = (50 - radius).toFixed(2);
        const viewBoxWidth = (radius * 2).toFixed(2);
        return `${viewBoxX} ${viewBoxX} ${viewBoxWidth} ${viewBoxWidth}`;
    }
}

================================================================================

File: src\components\spinner\_spinner.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "../progress-bar/common";

@keyframes pt-spinner-animation {
  from { transform: rotate(0deg); }
  to   { transform: rotate(360deg); }
}

.#{$ns}-spinner {
  align-items: center;
  // center animation container inside parent element to isolate layout
  display: flex;
  justify-content: center;

  // allow paths to overflow container -- critical for edges of circles!
  overflow: visible;
  vertical-align: middle;

  svg {
    display: block;
  }

  path {
    fill-opacity: 0%;
  }

  .#{$ns}-spinner-head {
    stroke: $progress-head-color;
    stroke-linecap: round;
    transform-origin: center;
    transition: stroke-dashoffset ($pt-transition-duration * 2) $pt-transition-ease;
  }

  .#{$ns}-spinner-track {
    stroke: $progress-track-color;
  }
}

// put the animation on a child HTML element to isolate it from display of parent
.#{$ns}-spinner-animation {
  animation: pt-spinner-animation ($pt-transition-duration * 5) linear infinite;

  .#{$ns}-no-spin > & {
    animation: none;
  }
}

.#{$ns}-dark .#{$ns}-spinner {
  .#{$ns}-spinner-head {
    stroke: $dark-progress-head-color;
  }

  .#{$ns}-spinner-track {
    stroke: $dark-progress-track-color;
  }
}

@each $intent, $color in $pt-intent-colors {
  .#{$ns}-spinner.#{$ns}-intent-#{$intent} .#{$ns}-spinner-head {
    stroke: $color;
  }
}

================================================================================

File: src\components\tabs\tab.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import type { IconName } from "@blueprintjs/icons";

import { AbstractPureComponent, Classes } from "../../common";
import { DISPLAYNAME_PREFIX, type HTMLDivProps, type MaybeElement, type Props } from "../../common/props";
import { isFunction } from "../../common/utils";
import type { TagProps } from "../tag/tag";

export type TabId = string | number;

export interface TabProps extends Props, Omit<HTMLDivProps, "id" | "title" | "onClick"> {
    /**
     * Content of tab title, rendered in a list above the active panel.
     * Can also be set via the `title` prop.
     */
    children?: React.ReactNode;

    /**
     * Whether the tab is disabled.
     *
     * @default false
     */
    disabled?: boolean;

    /**
     * Unique identifier used to control which tab is selected
     * and to generate ARIA attributes for accessibility.
     */
    id: TabId;

    /**
     * Panel content, rendered by the parent `Tabs` when this tab is active.
     * If omitted, no panel will be rendered for this tab.
     * Can either be an element or a renderer.
     */
    panel?: React.JSX.Element | ((props: { tabTitleId: string; tabPanelId: string }) => React.JSX.Element);

    /**
     * Space-delimited string of class names applied to tab panel container.
     */
    panelClassName?: string;

    /**
     * Content of tab title element, rendered in a list above the active panel.
     * Can also be set via React `children`.
     */
    title?: React.ReactNode;

    /** Name of a Blueprint UI icon (or an icon element) to render before the children. */
    icon?: IconName | MaybeElement;

    /**
     * Content to render inside a `<Tag>` after the children.
     * The tag is `minimal` by default; it can be further modified by using `tagProps`.
     */
    tagContent?: TagProps["children"];

    /**
     * Props to customize the `<Tag>` rendered after the children.
     * This has no effect if `tagContent` is `undefined`.
     */
    tagProps?: Omit<TagProps, "children">;
}

/**
 * Tab component.
 *
 * @see https://blueprintjs.com/docs/#core/components/tabs.tab
 */
export class Tab extends AbstractPureComponent<TabProps> {
    public static defaultProps: Partial<TabProps> = {
        disabled: false,
    };

    public static displayName = `${DISPLAYNAME_PREFIX}.Tab`;

    // this component is never rendered directly; see Tabs#renderTabPanel()
    /* istanbul ignore next */
    public render() {
        const { className, panel } = this.props;
        return (
            <div className={classNames(Classes.TAB_PANEL, className)} role="tablist">
                {isFunction(panel) ? panel({ tabTitleId: "", tabPanelId: "" }) : panel}
            </div>
        );
    }
}

================================================================================

File: src\components\tabs\tabs.md
--------------------------------------------------------------------------------
@# Tabs

The __Tabs__ component allows you to switch between displaying multiple panels of content.

@reactExample TabsExample

@## Usage

Tab selection is managed by `id`, much like the HTML `<select>` element respects `<option value>`. This is more
reliable than using a numeric index as it does not require translating between arbitrary indices and tab names.
It does, however, require that every `<Tab>` have a _locally unique `id` value_.

Arbitrary elements are supported in the tab list, and order is respected. Yes,
you can even insert things _between_ `<Tab>` elements.

```tsx
import { Tab, Tabs } from "@blueprintjs/core";

<Tabs id="TabsExample" onChange={this.handleTabChange} selectedTabId="rx">
    <Tab id="ng" title="Angular" panel={<AngularPanel />} />
    <Tab id="mb" title="Ember" panel={<EmberPanel />} panelClassName="ember-panel" />
    <Tab id="rx" title="React" panel={<ReactPanel />} />
    <Tab id="bb" disabled title="Backbone" panel={<BackbonePanel />} />
    <TabsExpander />
    <input className="@ns-input" type="text" placeholder="Search..." />
</Tabs>
```

@### Tabs

`<Tabs>` is the top-level component responsible for rendering the tab list and coordinating selection.
It can be used in controlled mode by providing `selectedTabId` and `onChange` props, or in
uncontrolled mode by optionally providing `defaultSelectedTabId` and `onChange`.

Children of `<Tabs>` are rendered in order in the tab list, which is a flex container.
`<Tab>` child elements are managed by the component; clicking one will change selection.
Other child elements are rendered in order; interactions are your responsibility.

Insert a `<TabsExpander />` between any two children to right-align all subsequent children
(or bottom-align when `vertical`).

@interface TabsProps

@### Tab

The __Tab__ component is a minimal wrapper with no functionality of its own&mdash;it is managed entirely by its
parent __Tabs__ component. Tab title text can be set either via `title` prop or via React children
(for more complex content).

The associated tab `panel` will be visible when the _Tab__ is active. Omitting the `panel` prop is supported; this can
be useful when you want the associated panel to appear elsewhere in the DOM (by rendering it yourself as needed).

@interface TabProps

@## CSS API

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use [`<Tabs>`](#core/components/tabs)

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

</div>

Blueprint offers tab styles with the class `@ns-tabs`. You should add the proper accessibility attributes
(`role`, `aria-selected`, and `aria-hidden`) as necessary if you choose to implement tabs with CSS.

`.@ns-tab-panel` elements with `aria-hidden="true"` are hidden automatically by the Blueprint CSS. You may also
omit hidden tabs from your markup to improve performance (the `Tabs` JavaScript component supports this through the
`renderActiveTabPanelOnly` prop).

@css tabs

================================================================================

File: src\components\tabs\tabs.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, type Props, Utils } from "../../common";

import { Tab, type TabId, type TabProps } from "./tab";
import { generateTabPanelId, generateTabTitleId, TabTitle } from "./tabTitle";

/**
 * Component that may be inserted between any two children of `<Tabs>` to right-align all subsequent children.
 */
export const TabsExpander: React.FC = () => <div className={Classes.FLEX_EXPANDER} />;

/** @deprecated use `TabsExpander` instead */
export const Expander = TabsExpander;

type TabElement = React.ReactElement<TabProps & { children: React.ReactNode }>;

const TAB_SELECTOR = `.${Classes.TAB}`;

export interface TabsProps extends Props {
    /**
     * Whether the selected tab indicator should animate its movement.
     *
     * @default true
     */
    animate?: boolean;

    /** Tab elements. */
    children?: React.ReactNode;

    /**
     * Initial selected tab `id`, for uncontrolled usage.
     * Note that this prop refers only to `<Tab>` children; other types of elements are ignored.
     *
     * @default first tab
     */
    defaultSelectedTabId?: TabId;

    /**
     * Unique identifier for this `Tabs` container. This will be combined with the `id` of each
     * `Tab` child to generate ARIA accessibility attributes. IDs are required and should be
     * unique on the page to support server-side rendering.
     */
    id: TabId;

    /**
     * If set to `true`, the tab titles will display with larger styling.
     * This will apply large styles only to the tabs at this level, not to nested tabs.
     *
     * @default false
     */
    large?: boolean;

    /**
     * Whether inactive tab panels should be removed from the DOM and unmounted in React.
     * This can be a performance enhancement when rendering many complex panels, but requires
     * careful support for unmounting and remounting.
     *
     * @default false
     */
    renderActiveTabPanelOnly?: boolean;

    /**
     * Selected tab `id`, for controlled usage.
     * Providing this prop will put the component in controlled mode.
     * Unknown ids will result in empty selection (no errors).
     */
    selectedTabId?: TabId;

    /**
     * Whether to show tabs stacked vertically on the left side.
     *
     * @default false
     */
    vertical?: boolean;

    /**
     * Whether to make the tabs list fill the height of its parent.
     *
     * This has no effect when `vertical={true}`.
     * This is not recommended when tab panels are defined within this component subtree, as the height computation will
     * include the panel height, which is usually not intended. Instead, it works well if the panels are rendered
     * elsewhere in the React tree.
     *
     * @default false
     */
    fill?: boolean;

    /**
     * A callback function that is invoked when a tab in the tab list is clicked.
     */
    onChange?(newTabId: TabId, prevTabId: TabId | undefined, event: React.MouseEvent<HTMLElement>): void;
}

export interface TabsState {
    indicatorWrapperStyle?: React.CSSProperties;
    selectedTabId?: TabId;
}

/**
 * Tabs component.
 *
 * @see https://blueprintjs.com/docs/#core/components/tabs
 */
export class Tabs extends AbstractPureComponent<TabsProps, TabsState> {
    /**
     * Insert a `TabsExpander` between any two children to right-align all subsequent children.
     *
     * @deprecated use `TabsExpander`
     */
    public static Expander = TabsExpander;

    public static Tab = Tab;

    public static defaultProps: Partial<TabsProps> = {
        animate: true,
        fill: false,
        large: false,
        renderActiveTabPanelOnly: false,
        vertical: false,
    };

    public static displayName = `${DISPLAYNAME_PREFIX}.Tabs`;

    public static getDerivedStateFromProps({ selectedTabId }: TabsProps) {
        if (selectedTabId !== undefined) {
            // keep state in sync with controlled prop, so state is canonical source of truth
            return { selectedTabId };
        }
        return null;
    }

    private tablistElement: HTMLDivElement | null = null;

    private refHandlers = {
        tablist: (tabElement: HTMLDivElement) => (this.tablistElement = tabElement),
    };

    constructor(props: TabsProps) {
        super(props);
        const selectedTabId = this.getInitialSelectedTabId();
        this.state = { selectedTabId };
    }

    public render() {
        const { indicatorWrapperStyle, selectedTabId } = this.state;

        const tabTitles = React.Children.map(this.props.children, this.renderTabTitle);

        const tabPanels = this.getTabChildren()
            .filter(this.props.renderActiveTabPanelOnly ? tab => tab.props.id === selectedTabId : () => true)
            .map(this.renderTabPanel);

        const tabIndicator = this.props.animate ? (
            <div className={Classes.TAB_INDICATOR_WRAPPER} style={indicatorWrapperStyle}>
                <div className={Classes.TAB_INDICATOR} />
            </div>
        ) : null;

        const classes = classNames(Classes.TABS, this.props.className, {
            [Classes.VERTICAL]: this.props.vertical,
            [Classes.FILL]: this.props.fill,
        });
        const tabListClasses = classNames(Classes.TAB_LIST, {
            [Classes.LARGE]: this.props.large,
        });

        return (
            <div className={classes}>
                <div
                    className={tabListClasses}
                    onKeyDown={this.handleKeyDown}
                    onKeyPress={this.handleKeyPress}
                    ref={this.refHandlers.tablist}
                    role="tablist"
                >
                    {tabIndicator}
                    {tabTitles}
                </div>
                {tabPanels}
            </div>
        );
    }

    public componentDidMount() {
        this.moveSelectionIndicator(false);
    }

    public componentDidUpdate(prevProps: TabsProps, prevState: TabsState) {
        if (this.state.selectedTabId !== prevState.selectedTabId) {
            this.moveSelectionIndicator();
        } else if (prevState.selectedTabId != null) {
            // comparing React nodes is difficult to do with simple logic, so
            // shallowly compare just their props as a workaround.
            const didChildrenChange = !Utils.arraysEqual(
                this.getTabChildrenProps(prevProps),
                this.getTabChildrenProps(),
                Utils.shallowCompareKeys,
            );
            if (didChildrenChange) {
                this.moveSelectionIndicator();
            }
        }
    }

    private getInitialSelectedTabId() {
        // NOTE: providing an unknown ID will hide the selection
        const { defaultSelectedTabId, selectedTabId } = this.props;
        if (selectedTabId !== undefined) {
            return selectedTabId;
        } else if (defaultSelectedTabId !== undefined) {
            return defaultSelectedTabId;
        } else {
            // select first tab in absence of user input
            const tabs = this.getTabChildren();
            return tabs.length === 0 ? undefined : tabs[0].props.id;
        }
    }

    private getKeyCodeDirection(e: React.KeyboardEvent<HTMLElement>) {
        if (e.key === "ArrowLeft" || e.key === "ArrowUp") {
            return -1;
        } else if (e.key === "ArrowRight" || e.key === "ArrowDown") {
            return 1;
        }
        return undefined;
    }

    private getTabChildrenProps(props: TabsProps & { children?: React.ReactNode } = this.props) {
        return this.getTabChildren(props).map(child => child.props);
    }

    /** Filters children to only `<Tab>`s */
    private getTabChildren(props: TabsProps & { children?: React.ReactNode } = this.props) {
        return React.Children.toArray(props.children).filter(isTabElement);
    }

    /** Queries root HTML element for all tabs with optional filter selector */
    private getTabElements(subselector = "") {
        if (this.tablistElement == null) {
            return [];
        }
        return Array.from(this.tablistElement.querySelectorAll(TAB_SELECTOR + subselector));
    }

    private handleKeyDown = (e: React.KeyboardEvent<HTMLDivElement>) => {
        const focusedElement = Utils.getActiveElement(this.tablistElement)?.closest(TAB_SELECTOR);
        // rest of this is potentially expensive and futile, so bail if no tab is focused
        if (focusedElement == null) {
            return;
        }

        // must rely on DOM state because we have no way of mapping `focusedElement` to a React.JSX.Element
        const enabledTabElements = this.getTabElements().filter(el => el.getAttribute("aria-disabled") === "false");
        const focusedIndex = enabledTabElements.indexOf(focusedElement);
        const direction = this.getKeyCodeDirection(e);

        if (focusedIndex >= 0 && direction !== undefined) {
            e.preventDefault();
            const { length } = enabledTabElements;
            // auto-wrapping at 0 and `length`
            const nextFocusedIndex = (focusedIndex + direction + length) % length;
            (enabledTabElements[nextFocusedIndex] as HTMLElement).focus();
        }
    };

    private handleKeyPress = (e: React.KeyboardEvent<HTMLDivElement>) => {
        const targetTabElement = (e.target as HTMLElement).closest<HTMLElement>(TAB_SELECTOR);
        if (targetTabElement != null && Utils.isKeyboardClick(e)) {
            e.preventDefault();
            targetTabElement.click();
        }
    };

    private handleTabClick = (newTabId: TabId, event: React.MouseEvent<HTMLElement>) => {
        this.props.onChange?.(newTabId, this.state.selectedTabId, event);
        if (this.props.selectedTabId === undefined) {
            this.setState({ selectedTabId: newTabId });
        }
    };

    /**
     * Calculate the new height, width, and position of the tab indicator.
     * Store the CSS values so the transition animation can start.
     */
    private moveSelectionIndicator(animate = true) {
        if (this.tablistElement == null || !this.props.animate) {
            return;
        }

        const tabIdSelector = `${TAB_SELECTOR}[data-tab-id="${this.state.selectedTabId}"]`;
        const selectedTabElement = this.tablistElement.querySelector<HTMLElement>(tabIdSelector);

        let indicatorWrapperStyle: React.CSSProperties = { display: "none" };
        if (selectedTabElement != null) {
            const { clientHeight, clientWidth, offsetLeft, offsetTop } = selectedTabElement;
            indicatorWrapperStyle = {
                height: clientHeight,
                transform: `translateX(${Math.floor(offsetLeft)}px) translateY(${Math.floor(offsetTop)}px)`,
                width: clientWidth,
            };

            if (!animate) {
                indicatorWrapperStyle.transition = "none";
            }
        }
        this.setState({ indicatorWrapperStyle });
    }

    private renderTabPanel = (tab: TabElement) => {
        const { className, panel, id, panelClassName } = tab.props;
        if (panel === undefined) {
            return undefined;
        }

        const tabTitleId = generateTabTitleId(this.props.id, id);
        const tabPanelId = generateTabPanelId(this.props.id, id);

        return (
            <div
                aria-labelledby={tabTitleId}
                aria-hidden={id !== this.state.selectedTabId}
                className={classNames(Classes.TAB_PANEL, className, panelClassName)}
                id={tabPanelId}
                key={id}
                role="tabpanel"
            >
                {Utils.isFunction(panel) ? panel({ tabTitleId, tabPanelId }) : panel}
            </div>
        );
    };

    private renderTabTitle = (child: React.ReactNode) => {
        if (isTabElement(child)) {
            const { id } = child.props;
            return (
                <TabTitle
                    {...child.props}
                    parentId={this.props.id}
                    onClick={this.handleTabClick}
                    selected={id === this.state.selectedTabId}
                />
            );
        }
        return child;
    };
}

function isTabElement(child: any): child is TabElement {
    return Utils.isElementOfType(child, Tab);
}

================================================================================

File: src\components\tabs\tabTitle.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, Classes, Intent } from "../../common";
import { DISPLAYNAME_PREFIX, removeNonHTMLProps } from "../../common/props";
import { Icon } from "../icon/icon";
import { Tag } from "../tag/tag";

import type { TabId, TabProps } from "./tab";

export interface TabTitleProps extends TabProps {
    /** Optional contents. */
    children?: React.ReactNode;

    /** Handler invoked when this tab is clicked. */
    onClick: (id: TabId, event: React.MouseEvent<HTMLElement>) => void;

    /** ID of the parent `Tabs` to which this tab belongs. Used to generate ID for ARIA attributes. */
    parentId: TabId;

    /** Whether the tab is currently selected. */
    selected: boolean;
}

export class TabTitle extends AbstractPureComponent<TabTitleProps> {
    public static displayName = `${DISPLAYNAME_PREFIX}.TabTitle`;

    public render() {
        const {
            className,
            children,
            disabled,
            id,
            parentId,
            selected,
            title,
            icon,
            tagContent,
            tagProps,
            ...htmlProps
        } = this.props;
        const intent = selected ? Intent.PRIMARY : Intent.NONE;

        return (
            <div
                {...removeNonHTMLProps(htmlProps)}
                aria-controls={generateTabPanelId(parentId, id)}
                aria-disabled={disabled}
                aria-expanded={selected}
                aria-selected={selected}
                className={classNames(Classes.TAB, className)}
                data-tab-id={id}
                id={generateTabTitleId(parentId, id)}
                onClick={disabled ? undefined : this.handleClick}
                role="tab"
                tabIndex={disabled ? undefined : selected ? 0 : -1}
            >
                {icon != null && <Icon icon={icon} intent={intent} className={Classes.TAB_ICON} />}
                {title}
                {children}
                {tagContent != null && (
                    <Tag
                        minimal={true}
                        intent={intent}
                        {...tagProps}
                        className={classNames(Classes.TAB_TAG, tagProps?.className)}
                    >
                        {tagContent}
                    </Tag>
                )}
            </div>
        );
    }

    private handleClick = (e: React.MouseEvent<HTMLElement>) => this.props.onClick(this.props.id, e);
}

export function generateTabPanelId(parentId: TabId, tabId: TabId) {
    return `${Classes.TAB_PANEL}_${parentId}_${tabId}`;
}

export function generateTabTitleId(parentId: TabId, tabId: TabId) {
    return `${Classes.TAB}-title_${parentId}_${tabId}`;
}

================================================================================

File: src\components\tabs\_tabs.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "../../common/mixins";

/*
Tabs

Markup:
<div class="#{$ns}-tabs">
    <ul class="#{$ns}-tab-list {{.modifier}}" role="tablist">
        <li class="#{$ns}-tab" role="tab" aria-selected="true">Selected tab</li>
        <li class="#{$ns}-tab" role="tab">Another tab</li>
        <li class="#{$ns}-tab" role="tab" aria-disabled="true">Disabled tab</li>
    </ul>
    <div class="#{$ns}-tab-panel" role="tabpanel">Selected panel</div>
    <div class="#{$ns}-tab-panel" role="tabpanel" aria-hidden="true">Another panel</div>
    <div class="#{$ns}-tab-panel" role="tabpanel" aria-hidden="true">Disabled panel</div>
</div>

.#{$ns}-large - Large tabs

Styleguide tabs
*/

$tab-color-selected: $pt-link-color !default;
$dark-tab-color-selected: $pt-dark-link-color !default;

$tab-indicator-width: 3px !default;

.#{$ns}-tabs:not(.#{$ns}-vertical).#{$ns}-fill {
  height: 100%;

  .#{$ns}-tab-list {
    height: 100%;
  }
}

.#{$ns}-tabs.#{$ns}-vertical {
  display: flex;

  // include '>' to ensure we're only modifying
  // these tabs, not tabs that might be further
  // down the DOM hierarchy (i.e. tabs in tabs)
  > .#{$ns}-tab-list {
    align-items: flex-start;
    flex-direction: column;

    .#{$ns}-tab {
      align-items: center;
      border-radius: $pt-border-radius;
      display: flex;
      padding: 0 $pt-grid-size;
      width: 100%;

      &[aria-selected="true"] {
        background-color: rgba($pt-intent-primary, 0.2);
        box-shadow: none;

        @media (forced-colors: active) and (prefers-color-scheme: dark) {
          background-color: $pt-high-contrast-mode-active-background-color;
          color: $black;
        }
      }
    }

    .#{$ns}-tab-indicator-wrapper .#{$ns}-tab-indicator {
      background-color: rgba($pt-intent-primary, 0.2);
      border-radius: $pt-border-radius;
      bottom: 0;
      height: auto;
      left: 0;
      right: 0;
      top: 0;
    }
  }

  // same consideration here: avoid styling any
  // other tabs that might be contained in this
  // vertical tab component
  > .#{$ns}-tab-panel {
    margin-top: 0;
    padding-left: $pt-grid-size * 2;
  }
}

.#{$ns}-tab-list {
  align-items: flex-end;
  border: none;
  column-gap: $pt-grid-size * 2;
  display: flex;
  flex: 0 0 auto;
  list-style: none;
  margin: 0;
  padding: 0;
  position: relative;
}

.#{$ns}-tab {
  @include overflow-ellipsis();
  align-items: center;
  align-self: stretch;
  color: $pt-text-color;
  cursor: pointer;
  display: flex;
  flex: 0 0 auto;
  font-size: $pt-font-size;
  line-height: $pt-button-height;
  max-width: 100%;
  position: relative;
  vertical-align: top;

  // support for links in tab titles #363
  a {
    color: inherit;
    display: block;
    text-decoration: none;
  }

  .#{$ns}-tab-indicator-wrapper ~ & {
    // these properties are only for static markup, therefore
    // we never want them if there's a tab indicator
    /* stylelint-disable declaration-no-important */
    background-color: transparent !important;
    box-shadow: none !important;
    /* stylelint-enable declaration-no-important */
  }

  &[aria-disabled="true"] {
    color: $pt-text-color-disabled;
    cursor: not-allowed;

    @media (forced-colors: active) and (prefers-color-scheme: dark) {
      // Windows High Contrast dark theme
      color: $pt-high-contrast-mode-disabled-text-color;
    }
  }

  &[aria-selected="true"] {
    border-radius: 0;
    box-shadow: inset 0 (-$tab-indicator-width) 0 $tab-color-selected;
  }

  &[aria-selected="true"],
  &:not([aria-disabled="true"]):hover {
    color: $tab-color-selected;

    @media (forced-colors: active) and (prefers-color-scheme: dark) {
      // Windows High Contrast dark theme
      color: $pt-high-contrast-mode-active-text-color;
    }
  }

  &:focus {
    -moz-outline-radius: 0;
  }

  .#{$ns}-large > & {
    font-size: $pt-font-size-large;
    line-height: $pt-button-height-large;
  }
}

.#{$ns}-tab-panel {
  margin-top: $pt-grid-size * 2;

  &[aria-hidden="true"] {
    display: none;
  }
}

.#{$ns}-tab-icon {
  margin-right: 7px;
}

.#{$ns}-tab-tag {
  margin-left: 7px;
}

.#{$ns}-tab-indicator-wrapper {
  left: 0;
  pointer-events: none;
  position: absolute;
  top: 0;
  transform: translateX(0), translateY(0);
  transition: height, transform, width;
  transition-duration: $pt-transition-duration * 2;
  transition-timing-function: $pt-transition-ease;

  .#{$ns}-tab-indicator {
    background-color: $tab-color-selected;
    bottom: 0;
    height: $tab-indicator-width;
    left: 0;
    position: absolute;
    right: 0;

    @media (forced-colors: active) and (prefers-color-scheme: dark) {
      // Windows High Contrast dark theme
      background-color: $pt-high-contrast-mode-active-background-color;
    }
  }

  &.#{$ns}-no-animation {
    transition: none;
  }

  .#{$ns}-tabs:not(.#{$ns}-vertical) & {
    height: 100%;
  }
}

.#{$ns}-dark {
  .#{$ns}-tab {
    color: $pt-dark-text-color;

    &[aria-disabled="true"] {
      color: $pt-dark-text-color-disabled;

      @media (forced-colors: active) and (prefers-color-scheme: dark) {
        // Windows High Contrast dark theme
        color: $pt-high-contrast-mode-disabled-text-color;
      }
    }

    &[aria-selected="true"] {
      box-shadow: inset 0 (-$tab-indicator-width) 0 $dark-tab-color-selected;
    }

    &[aria-selected="true"],
    &:not([aria-disabled="true"]):hover {
      color: $dark-tab-color-selected;

      @media (forced-colors: active) and (prefers-color-scheme: dark) {
        // Windows High Contrast dark theme
        color: $pt-high-contrast-mode-active-text-color;
      }
    }
  }

  .#{$ns}-tab-indicator {
    background-color: $dark-tab-color-selected;

    @media (forced-colors: active) and (prefers-color-scheme: dark) {
      // Windows High Contrast dark theme
      background-color: $pt-high-contrast-mode-active-background-color;
    }
  }
}

.#{$ns}-flex-expander {
  flex: 1 1;
}

================================================================================

File: src\components\tag\compound-tag.md
--------------------------------------------------------------------------------
---
tag: new
---

@# Compound Tag

**Compound Tag** is a variant of [**Tag**](#core/components/tag) which renders textual information in
a pair (sometimes referred to as a "key-value pair"). The content on the left and right is visually
segmented to signify the pairwise relationship. Just like **Tag**, this component supports a range
of visual modifiers for many different situations and its colors are designed to be accessible in
almost any context.

@reactExample CompoundTagExample

@## Usage

The `<CompoundTag>` component is a stateless wrapper around its content with support for an optional
close button and icons on the left and/or right side. It supports all valid `<span>` DOM attributes.

Content for the left side of the tag is specified with the `leftContent` prop, while the `children` node(s)
are rendered on the right side.

@## Props interface

@interface CompoundTagProps

================================================================================

File: src\components\tag\compoundTag.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Classes, DISPLAYNAME_PREFIX, Utils } from "../../common";
import { isReactNodeEmpty } from "../../common/utils";
import { Icon } from "../icon/icon";
import { Text } from "../text/text";

import { TagRemoveButton } from "./tagRemoveButton";
import type { TagSharedProps } from "./tagSharedProps";

export interface CompoundTagProps
    extends TagSharedProps,
        React.RefAttributes<HTMLSpanElement>,
        React.HTMLAttributes<HTMLSpanElement> {
    /**
     * Child nodes which will be rendered on the right side of the tag (e.g. the "value" in a key-value pair).
     */
    children: React.ReactNode;

    /**
     * Content to be rendered on the left side of the tag (e.g. the "key" in a key-value pair).
     * This prop must be defined; if you have no content to show here, then use a `<Tag>` instead.
     */
    leftContent: React.ReactNode;

    /**
     * Click handler for remove button.
     * The remove button will only be rendered if this prop is defined.
     */
    onRemove?: (e: React.MouseEvent<HTMLButtonElement>, tagProps: CompoundTagProps) => void;
}

/**
 * Compound tag component.
 *
 * @see https://blueprintjs.com/docs/#core/components/compound-tag
 */
export const CompoundTag: React.FC<CompoundTagProps> = React.forwardRef((props, ref) => {
    const {
        active,
        children,
        className,
        fill,
        icon,
        intent,
        interactive,
        leftContent,
        large,
        minimal,
        onRemove,
        rightIcon,
        round,
        tabIndex = 0,
        ...htmlProps
    } = props;

    const isRemovable = Utils.isFunction(onRemove);

    const tagClasses = classNames(
        Classes.TAG,
        Classes.COMPOUND_TAG,
        Classes.intentClass(intent),
        {
            [Classes.ACTIVE]: active,
            [Classes.FILL]: fill,
            [Classes.INTERACTIVE]: interactive,
            [Classes.LARGE]: large,
            [Classes.MINIMAL]: minimal,
            [Classes.ROUND]: round,
        },
        className,
    );

    return (
        <span {...htmlProps} className={tagClasses} tabIndex={interactive ? tabIndex : undefined} ref={ref}>
            <span className={Classes.COMPOUND_TAG_LEFT}>
                <Icon icon={icon} />
                <Text className={classNames(Classes.COMPOUND_TAG_LEFT_CONTENT, Classes.FILL)} tagName="span">
                    {leftContent}
                </Text>
            </span>
            <span className={Classes.COMPOUND_TAG_RIGHT}>
                {!isReactNodeEmpty(children) && (
                    <Text className={classNames(Classes.COMPOUND_TAG_RIGHT_CONTENT, Classes.FILL)} tagName="span">
                        {children}
                    </Text>
                )}
                <Icon icon={rightIcon} />
                {isRemovable && <TagRemoveButton {...props} />}
            </span>
        </span>
    );
});
CompoundTag.defaultProps = {
    active: false,
    fill: false,
    interactive: false,
    large: false,
    minimal: false,
    round: false,
};
CompoundTag.displayName = `${DISPLAYNAME_PREFIX}.CompoundTag`;

================================================================================

File: src\components\tag\tag.md
--------------------------------------------------------------------------------
@# Tag

**Tag** is a lightweight visual container for short strings of text. This flexible component may be used to label an
entity, display a list of selected items, and much more. **Tag** supports a range of visual modifiers for many
different situations; its colors are designed to be accessible in almost any context.

@reactExample TagExample

@## Usage

The `<Tag>` component is a stateless wrapper around its children with support for an optional close button.
It supports all valid `<span>` DOM attributes.

@## Props interface

@interface TagProps

@## CSS API

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use [`<Tag>`](#core/components/tag)

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

</div>

Create a tag with a `span.@ns-tag`. An optional "remove" button can be added with a `button.@ns-tag-remove` as the last
child.

@css tag

================================================================================

File: src\components\tag\tag.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import type { IconName } from "@blueprintjs/icons";

import { Classes, DISPLAYNAME_PREFIX, type IntentProps, type MaybeElement, type Props, Utils } from "../../common";
import { isReactNodeEmpty } from "../../common/utils";
import { Icon } from "../icon/icon";
import { Text } from "../text/text";

import { TagRemoveButton } from "./tagRemoveButton";
import type { TagSharedProps } from "./tagSharedProps";

export interface TagProps
    extends Props,
        IntentProps,
        TagSharedProps,
        React.RefAttributes<HTMLSpanElement>,
        React.HTMLAttributes<HTMLSpanElement> {
    /**
     * Child nodes which will be rendered inside a `<Text>` element.
     */
    children?: React.ReactNode;

    /**
     * HTML title to be passed to the <Text> component
     */
    htmlTitle?: string;

    /**
     * Name of a Blueprint UI icon (or an icon element) to render on the left side of the tag,
     * before the child nodes.
     */
    icon?: IconName | MaybeElement;

    /**
     * Whether tag content should be allowed to occupy multiple lines.
     * If `false`, a single line of text will be truncated with an ellipsis if it overflows.
     * Note that icons will be vertically centered relative to multiline text.
     *
     * @default false
     */
    multiline?: boolean;

    /**
     * Click handler for remove button.
     * The remove button will only be rendered if this prop is defined.
     */
    onRemove?: (e: React.MouseEvent<HTMLButtonElement>, tagProps: TagProps) => void;
}

/**
 * Tag component.
 *
 * @see https://blueprintjs.com/docs/#core/components/tag
 */
export const Tag: React.FC<TagProps> = React.forwardRef((props, ref) => {
    const {
        active,
        children,
        className,
        fill,
        icon,
        intent,
        interactive,
        large,
        minimal,
        multiline,
        onRemove,
        rightIcon,
        round,
        tabIndex = 0,
        htmlTitle,
        ...htmlProps
    } = props;

    const isRemovable = Utils.isFunction(onRemove);

    const tagClasses = classNames(
        Classes.TAG,
        Classes.intentClass(intent),
        {
            [Classes.ACTIVE]: active,
            [Classes.FILL]: fill,
            [Classes.INTERACTIVE]: interactive,
            [Classes.LARGE]: large,
            [Classes.MINIMAL]: minimal,
            [Classes.ROUND]: round,
        },
        className,
    );

    return (
        <span {...htmlProps} className={tagClasses} tabIndex={interactive ? tabIndex : undefined} ref={ref}>
            <Icon icon={icon} />
            {!isReactNodeEmpty(children) && (
                <Text className={Classes.FILL} ellipsize={!multiline} tagName="span" title={htmlTitle}>
                    {children}
                </Text>
            )}
            <Icon icon={rightIcon} />
            {isRemovable && <TagRemoveButton {...props} />}
        </span>
    );
});
Tag.defaultProps = {
    active: false,
    fill: false,
    interactive: false,
    large: false,
    minimal: false,
    round: false,
};
Tag.displayName = `${DISPLAYNAME_PREFIX}.Tag`;

================================================================================

File: src\components\tag\tagRemoveButton.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

import { IconSize, SmallCross } from "@blueprintjs/icons";

import { Classes, DISPLAYNAME_PREFIX } from "../../common";

import type { CompoundTagProps } from "./compoundTag";
import type { TagProps } from "./tag";

export type TagRemoveButtonProps = CompoundTagProps | TagProps;

export const TagRemoveButton = (props: TagRemoveButtonProps) => {
    const { className, large, onRemove, tabIndex } = props;
    const isLarge = large || className?.includes(Classes.LARGE);
    const handleRemoveClick = React.useCallback(
        (e: React.MouseEvent<HTMLButtonElement>) => {
            onRemove?.(e, props as any);
        },
        [onRemove, props],
    );
    return (
        <button
            aria-label="Remove tag"
            type="button"
            className={Classes.TAG_REMOVE}
            onClick={handleRemoveClick}
            tabIndex={tabIndex}
        >
            <SmallCross size={isLarge ? IconSize.LARGE : IconSize.STANDARD} />
        </button>
    );
};
TagRemoveButton.displayName = `${DISPLAYNAME_PREFIX}.TagRemoveButton`;

================================================================================

File: src\components\tag\tagSharedProps.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { IconName } from "@blueprintjs/icons";

import type { IntentProps, MaybeElement, Props } from "../../common";

export interface TagSharedProps extends Props, IntentProps {
    /**
     * Whether the tag should appear in an active state.
     *
     * @default false
     */
    active?: boolean;

    /**
     * Name of a Blueprint UI icon (or an icon element) to render on the left side of the tag,
     * before any content.
     */
    icon?: IconName | MaybeElement;

    /**
     * Whether the tag should take up the full width of its container.
     *
     * @default false
     */
    fill?: boolean;

    /**
     * Whether the tag should visually respond to user interactions. If set to `true`, hovering over the
     * tag will change its color and mouse cursor.
     *
     * Recommended when `onClick` is also defined.
     *
     * @default false
     */
    interactive?: boolean;

    /**
     * Whether this tag should use large styles.
     *
     * @default false
     */
    large?: boolean;

    /**
     * Whether this tag should use minimal styles.
     *
     * @default false
     */
    minimal?: boolean;

    /**
     * Callback invoked when the tag is clicked.
     * Recommended when `interactive` is `true`.
     */
    onClick?: (e: React.MouseEvent<HTMLSpanElement>) => void;

    /**
     * Name of a Blueprint UI icon (or an icon element) to render on the right side of the tag,
     * after the child node(s).
     */
    rightIcon?: IconName | MaybeElement;

    /**
     * Whether this tag should have rounded ends.
     *
     * @default false
     */
    round?: boolean;
}

================================================================================

File: src\components\tag\_common.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "../../common/variables-extended";

// Variables
// ---------------------------------------------------------------------------------------------------------------------

$tag-default-color: $gray1 !default;
$dark-tag-default-color: $gray5 !default;

$tag-height: $pt-grid-size * 2 !default;
$tag-line-height: $pt-icon-size-standard !default;
$tag-padding-top: ($tag-height - $tag-line-height) * 0.5 !default;
$tag-padding: $tag-padding-top * 3 !default;
$tag-margin: ($pt-input-height - $tag-height) * 0.5 !default;

$tag-height-large: $pt-grid-size * 3 !default;
$tag-line-height-large: $pt-icon-size-large !default;
$tag-padding-large: ($tag-height-large - $tag-line-height-large) !default;

$tag-icon-spacing: ($tag-height - 12px) * 0.5 !default;
$tag-icon-spacing-large: ($tag-height-large - $pt-icon-size-standard) * 0.5 !default;

$tag-round-adjustment: 2px !default;

$tag-intent-colors: (
  "primary": ($pt-intent-primary, $blue2, $blue1, $white),
  "success": ($pt-intent-success, $green2, $green1, $white),
  "warning": ($orange5, $orange4, $orange3, $pt-text-color),
  "danger": ($pt-intent-danger, $red2, $red1, $white)
) !default;

$minimal-tag-intent-colors: (
  "primary": ($pt-intent-primary, $blue2, $blue1),
  "success": ($pt-intent-success, $green2, $green1),
  "warning": ($pt-intent-warning, $orange2, $orange1),
  "danger": ($pt-intent-danger, $red2, $red1)
) !default;

$minimal-dark-tag-intent-colors: (
  "primary": ($pt-intent-primary, $blue5, $blue6),
  "success": ($pt-intent-success, $green5, $green6),
  "warning": ($pt-intent-warning, $orange5, $orange6),
  "danger": ($pt-intent-danger, $red5, $red6)
) !default;

// Mixins - Tag component
// ---------------------------------------------------------------------------------------------------------------------

@mixin pt-tag() {
  @include pt-flex-container(row, $tag-icon-spacing, inline);
  align-items: center;
  background-color: $tag-default-color;
  border: none;
  border-radius: $pt-border-radius;
  box-shadow: none;
  color: $white;
  font-size: $pt-font-size-small;
  line-height: $tag-line-height;
  max-width: 100%;
  min-height: $tag-height;
  min-width: $tag-height;
  padding: $tag-padding-top $tag-padding;
  position: relative;

  &:focus {
    @include focus-outline(0);
  }

  &.#{$ns}-interactive {
    cursor: pointer;

    &:hover {
      background: $dark-gray5;
    }

    &:active,
    &.#{$ns}-active {
      background: $dark-gray4;
    }
  }

  &.#{$ns}-round {
    border-radius: $tag-height-large;
    padding-left: $tag-padding + $tag-round-adjustment;
    // optical adjustment for rounded tags
    padding-right: $tag-padding + $tag-round-adjustment;
  }

  .#{$ns}-dark & {
    background-color: $dark-tag-default-color;
    color: $pt-text-color;

    > #{$icon-classes} {
      fill: currentcolor;
    }

    &.#{$ns}-interactive {
      &:hover {
        background: $gray4;
      }

      &:active,
      &.#{$ns}-active {
        background: $gray3;
      }
    }
  }

  > #{$icon-classes} {
    fill: $white;
  }

  @media (forced-colors: active) and (prefers-color-scheme: dark) {
    // Windows High Contrast dark theme
    border: 1px solid $pt-high-contrast-mode-border-color;
  }
}

@mixin pt-tag-large() {
  @include pt-flex-margin(row, $tag-icon-spacing-large);
  font-size: $pt-font-size;
  line-height: $tag-line-height-large;
  min-height: $tag-height-large;
  min-width: $tag-height-large;
  padding: ($tag-padding-large * 0.5) $tag-padding-large;

  &.#{$ns}-round {
    padding-left: $tag-padding-large + $tag-round-adjustment;
    // optical adjustment for rounded tags
    padding-right: $tag-padding-large + $tag-round-adjustment;
  }
}

@mixin pt-tag-intent(
  $background-color,
  $hover-color,
  $active-color,
  $text-color
) {
  background: $background-color;
  color: $text-color;

  &.#{$ns}-interactive {
    &:hover {
      background-color: $hover-color;
    }

    &:active,
    &.#{$ns}-active {
      background-color: $active-color;
    }
  }

  .#{$ns}-tag-remove {
    color: rgba($text-color, 0.7);

    &:hover,
    &:active {
      color: $text-color;
    }
  }
}

@mixin pt-tag-minimal() {
  > #{$icon-classes} {
    fill: $pt-icon-color;
  }

  &:not([class*="#{$ns}-intent-"]) {
    @include pt-tag-minimal-interactive($gray3, $black);

    background-color: rgba($gray3, 0.15);
    color: $pt-text-color;

    .#{$ns}-tag-remove {
      color: $gray1;

      &:hover,
      &:active {
        color: $dark-gray5;
      }
    }

    .#{$ns}-dark & {
      @include pt-tag-minimal-interactive($gray3, $white);

      background-color: rgba($gray3, 0.15);
      color: $pt-dark-text-color;

      .#{$ns}-tag-remove {
        color: $pt-dark-icon-color;

        &:hover,
        &:active {
          color: $light-gray1;
        }
      }
    }
  }
}

@mixin pt-tag-minimal-interactive($background-color, $text-color) {
  &.#{$ns}-interactive {
    cursor: pointer;

    &:hover {
      background-color: rgba($background-color, 0.3);
      color: $text-color;
    }

    &.#{$ns}-active,
    &:active {
      background-color: rgba($background-color, 0.35);
      color: $text-color;
    }
  }
}

@mixin pt-tag-minimal-intent(
  $background-color,
  $text-color,
  $hover-active-text-color
) {
  background-color: rgba($background-color, 0.1);
  color: $text-color;

  > #{$icon-classes} {
    fill: $text-color;
  }

  &.#{$ns}-interactive {
    &:hover {
      background-color: rgba($background-color, 0.2);
      color: $hover-active-text-color;
    }

    &:active,
    &.#{$ns}-active {
      background-color: rgba($background-color, 0.3);
      color: $hover-active-text-color;
    }
  }

  .#{$ns}-tag-remove {
    color: $text-color;

    &:hover,
    &:active {
      color: $hover-active-text-color;
    }
  }
}

@mixin pt-tag-minimal-dark-intent (
  $background-color,
  $text-color,
  $hover-active-text-color
) {
  background-color: rgba($background-color, 0.2);
  color: $text-color;

  &.#{$ns}-interactive {
    &:hover {
      background-color: rgba($background-color, 0.3);
      color: $hover-active-text-color;
    }

    &:active,
    &.#{$ns}-active {
      background-color: rgba($background-color, 0.35);
      color: $hover-active-text-color;
    }
  }

  .#{$ns}-tag-remove {
    color: $text-color;

    &:hover,
    &:active {
      color: $hover-active-text-color;
    }
  }
}

@mixin pt-tag-remove() {
  background: none;
  border: none;
  color: rgba($white, 0.7);
  cursor: pointer;
  display: flex;
  margin-bottom: -$tag-padding-top;
  /* stylelint-disable-next-line declaration-no-important */
  margin-right: -$tag-padding !important;
  // top/bottom to allow for padding to enlarge click area,
  // right to tuck remove button into padding space.
  margin-top: -$tag-padding-top;
  padding: $tag-padding-top;
  padding-left: 0;

  &:hover {
    background: none;
    color: inherit;
    text-decoration: none;
  }

  .#{$ns}-icon:first-child {
    color: inherit;
  }

  &:hover,
  &:active {
    color: $white;
  }

  // CSS API support
  &:empty::before {
    @include pt-icon();
    content: map-get($blueprint-icon-codepoints, "small-cross");
  }

  .#{$ns}-large & {
    /* stylelint-disable-next-line declaration-no-important */
    margin-right: -$tag-padding-large !important;
    padding: 0 ($tag-padding-large * 0.5) 0 0;

    &:empty::before {
      @include pt-icon-sized($pt-icon-size-large);
    }
  }

  .#{$ns}-dark & {
    color: rgba($dark-gray1, 0.7);

    &:hover,
    &:active {
      color: $dark-gray1;
    }
  }
}

// Mixins - CompoundTag component
// ---------------------------------------------------------------------------------------------------------------------

@mixin compound-tag-colors(
  /* each list is a (default, hover, active) tuple of background colors */
  $left-colors,
  $right-colors
) {
  // override default tag background styles: this is important for minimal tags with opacity values
  // which we want to define _absolutely_ in our design system and not by stacking opacities on top of each other.
  background: none;

  .#{$ns}-compound-tag-left {
    background-color: nth($left-colors, 1);
  }

  .#{$ns}-compound-tag-right {
    background-color: nth($right-colors, 1);
  }

  &.#{$ns}-interactive {
    &:hover {
      .#{$ns}-compound-tag-left {
        background-color: nth($left-colors, 2);
      }

      .#{$ns}-compound-tag-right {
        background-color: nth($right-colors, 2);
      }
    }

    &:active,
    &.#{$ns}-active {
      .#{$ns}-compound-tag-left {
        background-color: nth($left-colors, 3);
      }

      .#{$ns}-compound-tag-right {
        background-color: nth($right-colors, 3);
      }
    }
  }
}

@mixin minimal-compound-tag-colors($base-color) {
  $left-colors: (rgba($base-color, 0.2), rgba($base-color, 0.3), rgba($base-color, 0.4));
  $right-colors: (rgba($base-color, 0.1), rgba($base-color, 0.2), rgba($base-color, 0.3));

  @include compound-tag-colors($left-colors, $right-colors);
}

@mixin dark-minimal-compound-tag-colors($base-color) {
  $left-colors: (rgba($base-color, 0.4), rgba($base-color, 0.5), rgba($base-color, 0.55));
  $right-colors: (rgba($base-color, 0.2), rgba($base-color, 0.3), rgba($base-color, 0.35));

  @include compound-tag-colors($left-colors, $right-colors);
}

================================================================================

File: src\components\tag\_compound-tag.scss
--------------------------------------------------------------------------------
// Copyright 2024 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "../../common/variables-extended";
@import "../../common/mixins";
@import "./common";

/*
Compound Tags
*/

// some of these values are copied from _common.scss, but our mixins have a different shape here
$compound-tag-left-default-colors: ($dark-gray5, $dark-gray4, $dark-gray3) !default;
$compound-tag-right-default-colors: ($gray1, $dark-gray5, $dark-gray4) !default;
$dark-compound-tag-left-default-colors: ($gray4, $gray3, $gray2) !default;
$dark-compound-tag-right-default-colors: ($gray5, $gray4, gray3) !default;

// one shade darker than $tag-intent-colors
$compound-tag-left-intent-colors: (
  "primary": ($blue2, $blue1, $blue0),
  "success": ($green2, $green1, $green0),
  "warning": ($orange4, $orange3, $orange2),
  "danger": ($red2, $red1, $red0),
) !default;

.#{$ns}-compound-tag {
  // Variants: default & interactive
  @include compound-tag-colors(
    $compound-tag-left-default-colors,
    $compound-tag-right-default-colors
  );
  padding: 0;

  // Layout
  .#{$ns}-compound-tag-left,
  .#{$ns}-compound-tag-right {
    align-items: center;
    display: inline-flex;
    padding: 2px 4px;
  }

  .#{$ns}-compound-tag-left {
    border-bottom-left-radius: $pt-border-radius;
    border-top-left-radius: $pt-border-radius;
    margin-right: 0; // override pt-tag() pt-flex-container() style

    > #{$icon-classes} {
      margin-right: 4px;
    }
  }

  .#{$ns}-compound-tag-right {
    border-bottom-right-radius: $pt-border-radius;
    border-top-right-radius: $pt-border-radius;
    flex-grow: 1;
    padding: 2px 4px;

    > #{$icon-classes} {
      margin-left: 4px;
    }

    .#{$ns}-compound-tag-right-text {
      flex-grow: 1;
    }

    .#{$ns}-tag-remove {
      margin-left: 2px;
      // overriding pt-tag-remove() style
      /* stylelint-disable-next-line declaration-no-important */
      margin-right: -4px !important;
    }
  }

  // Variant: round
  &.#{$ns}-round {
    $tag-round-horizontal-padding: ($tag-height * 0.5) - $tag-round-adjustment;
    padding: 0;

    .#{$ns}-compound-tag-left {
      border-bottom-left-radius: $tag-height;
      border-top-left-radius: $tag-height;
      padding-left: $tag-round-horizontal-padding;
    }

    .#{$ns}-compound-tag-right {
      border-bottom-right-radius: $tag-height;
      border-top-right-radius: $tag-height;
      padding-right: $tag-round-horizontal-padding;
    }
  }

  // Variant: large
  &.#{$ns}-large {
    padding: 0;

    .#{$ns}-compound-tag-left,
    .#{$ns}-compound-tag-right {
      padding: 5px 8px;
    }

    .#{$ns}-compound-tag-left {
      > #{$icon-classes} {
        margin-right: 7px;
      }
    }

    .#{$ns}-compound-tag-right {
      > #{$icon-classes} {
        margin-left: 7px;
      }
    }

    .#{$ns}-tag-remove {
      margin-left: 7px;
      // overriding pt-tag-remove() style
      /* stylelint-disable-next-line declaration-no-important */
      margin-right: -10px !important;
    }

    // Variant: large & round
    &.#{$ns}-round {
      $tag-round-horizontal-padding-large: ($tag-padding-large) + $tag-round-adjustment;
      padding: 0;

      .#{$ns}-compound-tag-left {
        border-bottom-left-radius: $tag-height-large;
        border-top-left-radius: $tag-height-large;
        padding-left: $tag-round-horizontal-padding-large;
      }

      .#{$ns}-compound-tag-right {
        border-bottom-right-radius: $tag-height-large;
        border-top-right-radius: $tag-height-large;
        padding-right: $tag-round-horizontal-padding-large;
      }
    }
  }

  &.#{$ns}-minimal {
    // Variants: minimal default & interactive
    &:not([class*="#{$ns}-intent-"]) {
      @include minimal-compound-tag-colors($gray1);
    }

    // Variant: minimal intent
    @each $intent, $color in $pt-intent-colors {
      &.#{$ns}-intent-#{$intent} {
        @include minimal-compound-tag-colors($color);
      }
    }
  }

  .#{$ns}-dark & {
    // Variants: dark default & interactive
    @include compound-tag-colors(
      $dark-compound-tag-left-default-colors,
      $dark-compound-tag-right-default-colors
    );

    // Variant: dark intent
    // colors are identical to light theme, so we don't need any styles here

    &.#{$ns}-minimal {
      // Variants: dark minimal default & interactive
      &:not([class*="#{$ns}-intent-"]) {
        @include dark-minimal-compound-tag-colors($gray1);
      }

      // Variant: dark minimal intent
      @each $intent, $color in $pt-intent-colors {
        &.#{$ns}-intent-#{$intent} {
          @include dark-minimal-compound-tag-colors($color);
        }
      }
    }
  }

  // Important: these styles must come last to override dark theme default (no intent) styles
  // Variant: intent
  @each $intent, $left-colors in $compound-tag-left-intent-colors {
    &.#{$ns}-intent-#{$intent} {
      $right-colors: map-get($tag-intent-colors, $intent);

      @include compound-tag-colors($left-colors, $right-colors);
    }
  }
}

================================================================================

File: src\components\tag\_tag.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "../../common/variables-extended";
@import "./common";

/*
Tags

Markup:
<span class="#{$ns}-tag {{.modifier}}">125</span>
<span class="#{$ns}-tag {{.modifier}}">Done</span>
<span class="#{$ns}-tag {{.modifier}}">
  Tracking
  <button class="#{$ns}-tag-remove"></button>
</span>
<span class="#{$ns}-tag {{.modifier}}">
  Crushed
  <button class="#{$ns}-tag-remove"></button>
</span>
<span class="#{$ns}-tag {{.modifier}}">
  A rather long string of text that wraps to multiple lines
  demonstrates the position of the remove button.
  <button class="#{$ns}-tag-remove"></button>
</span>

.#{$ns}-large - Large
.#{$ns}-minimal - Minimal appearance
.#{$ns}-round - Rounded corners, ideal for badges
.#{$ns}-interactive - Hover and active effects
.#{$ns}-intent-primary - Primary intent
.#{$ns}-intent-success - Success intent
.#{$ns}-intent-warning - Warning intent
.#{$ns}-intent-danger  - Danger intent

Styleguide tag
*/

.#{$ns}-tag {
  @include pt-tag();

  &.#{$ns}-large,
  .#{$ns}-large & {
    @include pt-tag-large();
  }

  @each $intent, $colors in $tag-intent-colors {
    &.#{$ns}-intent-#{$intent} {
      @include pt-tag-intent($colors...);
    }
  }

  &.#{$ns}-fill {
    display: flex;
    width: 100%;
  }

  &.#{$ns}-minimal {
    @include pt-tag-minimal();

    @each $intent, $colors in $minimal-tag-intent-colors {
      &.#{$ns}-intent-#{$intent} {
        @include pt-tag-minimal-intent($colors...);
      }
    }

    @each $intent, $colors in $minimal-dark-tag-intent-colors {
      &.#{$ns}-intent-#{$intent} {
        .#{$ns}-dark & {
          @include pt-tag-minimal-dark-intent($colors...);
        }
      }
    }
  }
}

.#{$ns}-tag-remove {
  @include pt-tag-remove();
}

================================================================================

File: src\components\tag-input\resizableInput.tsx
--------------------------------------------------------------------------------
/* !
 * (c) Copyright 2022 Palantir Technologies Inc. All rights reserved.
 */

import * as React from "react";

import { Classes, DISPLAYNAME_PREFIX, type HTMLInputProps } from "../../common";

export type Ref = HTMLInputElement;

export const ResizableInput = React.forwardRef<Ref, HTMLInputProps>(function ResizableInput(props, ref) {
    const [content, setContent] = React.useState("");
    const [width, setWidth] = React.useState(0);
    const span = React.useRef<HTMLSpanElement>(null);

    React.useEffect(() => {
        if (span.current != null) {
            setWidth(span.current.offsetWidth);
        }
    }, [content]);

    const { onChange, style, ...otherProps } = props;

    const handleInputChange: React.ChangeEventHandler<HTMLInputElement> = evt => {
        onChange?.(evt);
        setContent(evt?.target?.value ?? "");
    };

    return (
        <>
            <span ref={span} className={Classes.RESIZABLE_INPUT_SPAN} aria-hidden={true}>
                {/* Need to replace spaces with the html character for them to be preserved */}
                {content.replace(/ /g, "\u00a0")}
            </span>
            <input {...otherProps} type="text" style={{ ...style, width }} onChange={handleInputChange} ref={ref} />
        </>
    );
});
ResizableInput.displayName = `${DISPLAYNAME_PREFIX}.ResizableInput`;

================================================================================

File: src\components\tag-input\tag-input.md
--------------------------------------------------------------------------------
@# Tag input

**TagInput** displays [**Tag**](#core/components/tag) elements inside an input, followed by an interactive text input.
The container is styled to look like a Blueprint input; the actual editable element appears after the last tag.
Clicking anywhere on the container will focus the text input.

@reactExample TagInputExample

<div class="@ns-callout @ns-intent-success @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">Looking for a dropdown menu?</h5>

[The **MultiSelect** component in the **@blueprintjs/select** package](#select/multi-select)
composes this component with a dropdown menu.

</div>

@## Usage

**TagInput** must be controlled, which means the `values` prop is required and event handlers are strongly suggested.
Typing in the input and pressing <kbd>Enter</kbd> will **add new items** by invoking callbacks. If `addOnBlur` is
set to `true`, clicking outside of the component will also trigger the callback to add new items. A `separator` prop is
supported to allow multiple items to be added at once; the default splits on commas and newlines.

**Tags** may be removed by clicking their <span class="@ns-icon-standard @ns-icon-cross"></span> buttons or by pressing
either <kbd>backspace</kbd> or <kbd>delete</kbd> repeatedly. Pressing <kbd>delete</kbd> mimics the behavior of deleting
in a text editor, where trying to delete at the end of the line will do nothing. Arrow keys can also be used to focus
on a particular tag before removing it. The cursor must be at the beginning of the text input for these interactions.

**Tag** appearance can be customized with `tagProps`: supply an object to apply the same props to every tag, or supply
a callback to apply dynamic props per tag. Tag `values` must be an array of strings so you may need a transformation
step between your state and these props.

**TagInput** provides granular `onAdd` and `onRemove` **event props** which are passed the added or removed items in
response to the user interactions above. It also provides `onChange`, which combines both events and is passed the
updated `values` array, with new items appended to the end and removed items filtered away.

The `<input>` element can be controlled directly via the `inputValue` and `onInputChange` props. Additional properties
(such as custom event handlers) can be forwarded to the input via `inputProps`.

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">Handling long words</h5>

Set an explicit `width` on the container element to cause long tags to wrap onto multiple lines.
Either supply a specific pixel value, or use `<TagInput className={Classes.FILL}>`
to fill its container's width (try this in the example above).

</div>

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">Disabling a tag input</h5>

Disabling this component requires setting the `disabled` prop to `true`
and separately disabling the component's `rightElement` as appropriate
(because `TagInput` accepts any `React.JSX.Element` as its `rightElement`).

</div>

@## Props interface

@interface TagInputProps

================================================================================

File: src\components\tag-input\tagInput.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { type IconName, IconSize } from "@blueprintjs/icons";

import { AbstractPureComponent, Classes, refHandler, setRef, Utils } from "../../common";
import {
    DISPLAYNAME_PREFIX,
    type HTMLInputProps,
    type IntentProps,
    type MaybeElement,
    type Props,
} from "../../common/props";
import { getActiveElement } from "../../common/utils";
import { Icon } from "../icon/icon";
import { Tag, type TagProps } from "../tag/tag";

import { ResizableInput } from "./resizableInput";

/**
 * The method in which a `TagInput` value was added.
 * - `"default"` - indicates that a value was added by manual selection.
 * - `"blur"` - indicates that a value was added when the `TagInput` lost focus.
 *   This is only possible when `addOnBlur=true`.
 * - `"paste"` - indicates that a value was added via paste. This is only
 *   possible when `addOnPaste=true`.
 */
export type TagInputAddMethod = "default" | "blur" | "paste";

export interface TagInputProps extends IntentProps, Props {
    /**
     * If true, `onAdd` will be invoked when the input loses focus.
     * Otherwise, `onAdd` is only invoked when `enter` is pressed.
     *
     * @default false
     */
    addOnBlur?: boolean;

    /**
     * If true, `onAdd` will be invoked when the user pastes text containing the `separator`
     * into the input. Otherwise, pasted text will remain in the input.
     *
     * __Note:__ For example, if `addOnPaste=true` and `separator="\n"` (new line), then:
     * - Pasting `"hello"` will _not_ invoke `onAdd`
     * - Pasting `"hello\n"` will invoke `onAdd` with `["hello"]`
     * - Pasting `"hello\nworld"` will invoke `onAdd` with `["hello", "world"]`
     *
     * @default true
     */
    addOnPaste?: boolean;

    /**
     * Whether the component should automatically resize as a user types in the text input.
     * This will have no effect when `fill={true}`.
     *
     * @default false
     */
    autoResize?: boolean;

    /**
     * Optional child elements which will be rendered between the selected tags and
     * the text input. Rendering children is usually unnecessary.
     *
     * @default undefined
     */
    children?: React.ReactNode;

    /**
     * Whether the component is non-interactive.
     * Note that you'll also need to disable the component's `rightElement`,
     * if appropriate.
     *
     * @default false
     */
    disabled?: boolean;

    /** Whether the tag input should take up the full width of its container. */
    fill?: boolean;

    /**
     * React props to pass to the `<input>` element.
     * Note that `ref` and `key` are not supported here; use `inputRef` below.
     * Also note that `inputProps.style.width` will be overriden if `autoResize={true}`.
     */
    inputProps?: HTMLInputProps;

    /** Ref handler for the `<input>` element. */
    inputRef?: React.Ref<HTMLInputElement>;

    /** Controlled value of the `<input>` element. This is shorthand for `inputProps={{ value }}`. */
    inputValue?: string;

    /** Whether the tag input should use a large size. */
    large?: boolean;

    /** Name of a Blueprint UI icon (or an icon element) to render on the left side of the input. */
    leftIcon?: IconName | MaybeElement;

    /**
     * Callback invoked when new tags are added by the user pressing `enter` on the input.
     * Receives the current value of the input field split by `separator` into an array.
     * New tags are expected to be appended to the list.
     *
     * The input will be cleared after `onAdd` is invoked _unless_ the callback explicitly
     * returns `false`. This is useful if the provided `value` is somehow invalid and should
     * not be added as a tag.
     */
    onAdd?: (values: string[], method: TagInputAddMethod) => boolean | void;

    /**
     * Callback invoked when new tags are added or removed. Receives the updated list of `values`:
     * new tags are appended to the end of the list, removed tags are removed at their index.
     *
     * Like `onAdd`, the input will be cleared after this handler is invoked _unless_ the callback
     * explicitly returns `false`.
     *
     * This callback essentially implements basic `onAdd` and `onRemove` functionality and merges
     * the two handlers into one to simplify controlled usage.
     * ```
     */
    onChange?: (values: React.ReactNode[]) => boolean | void;

    /**
     * Callback invoked when the value of `<input>` element is changed.
     * This is shorthand for `inputProps={{ onChange }}`.
     */
    onInputChange?: React.FormEventHandler<HTMLInputElement>;

    /**
     * Callback invoked when the user depresses a keyboard key.
     * Receives the event and the index of the active tag (or `undefined` if
     * focused in the input).
     */
    onKeyDown?: (event: React.KeyboardEvent<HTMLElement>, index?: number) => void;

    /**
     * Callback invoked when the user releases a keyboard key.
     * Receives the event and the index of the active tag (or `undefined` if
     * focused in the input).
     */
    onKeyUp?: (event: React.KeyboardEvent<HTMLElement>, index?: number) => void;

    /**
     * Callback invoked when the user clicks the X button on a tag.
     * Receives value and index of removed tag.
     */
    onRemove?: (value: React.ReactNode, index: number) => void;

    /**
     * Input placeholder text which will not appear if `values` contains any items
     * (consistent with default HTML input behavior).
     * Use `inputProps.placeholder` if you want the placeholder text to _always_ appear.
     *
     * If you define both `placeholder` and `inputProps.placeholder`, then the former will appear
     * when `values` is empty and the latter at all other times.
     */
    placeholder?: string;

    /**
     * Element to render on right side of input.
     * For best results, use a small spinner or minimal button (button height will adjust if `TagInput` uses large styles).
     * Other elements will likely require custom styles for correct positioning.
     */
    rightElement?: React.JSX.Element;

    /**
     * Separator pattern used to split input text into multiple values. Default value splits on commas and newlines.
     * Explicit `false` value disables splitting (note that `onAdd` will still receive an array of length 1).
     *
     * @default /[,\n\r]/
     */
    separator?: string | RegExp | false;

    /**
     * React props to pass to each `Tag`. Provide an object to pass the same props to every tag,
     * or a function to customize props per tag.
     *
     * If you define `onRemove` here then you will have to implement your own tag removal
     * handling as `TagInput`'s own `onRemove` handler will never be invoked.
     */
    tagProps?: TagProps | ((value: React.ReactNode, index: number) => TagProps);

    /**
     * Controlled tag values. Each value will be rendered inside a `Tag`, which can be customized
     * using `tagProps`. Therefore, any valid React node can be used as a `TagInput` value; falsy
     * values will not be rendered.
     */
    values: readonly React.ReactNode[];
}

export interface TagInputState {
    activeIndex: number;
    inputValue: string;
    isInputFocused: boolean;
    prevInputValueProp?: string;
}

/** special value for absence of active tag */
const NONE = -1;

/**
 * Tag input component.
 *
 * @see https://blueprintjs.com/docs/#core/components/tag-input
 */
export class TagInput extends AbstractPureComponent<TagInputProps, TagInputState> {
    public static displayName = `${DISPLAYNAME_PREFIX}.TagInput`;

    public static defaultProps: Partial<TagInputProps> = {
        addOnBlur: false,
        addOnPaste: true,
        autoResize: false,
        inputProps: {},
        separator: /[,\n\r]/,
        tagProps: {},
    };

    public static getDerivedStateFromProps(
        props: Readonly<TagInputProps>,
        state: Readonly<TagInputState>,
    ): Partial<TagInputState> | null {
        if (props.inputValue !== state.prevInputValueProp) {
            return {
                inputValue: props.inputValue,
                prevInputValueProp: props.inputValue,
            };
        }
        return null;
    }

    public state: TagInputState = {
        activeIndex: NONE,
        inputValue: this.props.inputValue || "",
        isInputFocused: false,
    };

    public inputElement: HTMLInputElement | null = null;

    private handleRef: React.Ref<HTMLInputElement> = refHandler(this, "inputElement", this.props.inputRef);

    public render() {
        const { autoResize, className, disabled, fill, inputProps, intent, large, leftIcon, placeholder, values } =
            this.props;

        const classes = classNames(
            Classes.INPUT,
            Classes.TAG_INPUT,
            {
                [Classes.ACTIVE]: this.state.isInputFocused,
                [Classes.DISABLED]: disabled,
                [Classes.FILL]: fill,
                [Classes.LARGE]: large,
            },
            Classes.intentClass(intent),
            className,
        );
        const isLarge = classes.indexOf(Classes.LARGE) > NONE;

        // use placeholder prop only if it's defined and values list is empty or contains only falsy values
        const isSomeValueDefined = values.some(val => !!val);
        const resolvedPlaceholder = placeholder == null || isSomeValueDefined ? inputProps?.placeholder : placeholder;

        // final props that may be sent to <input> or <ResizableInput>
        const resolvedInputProps = {
            value: this.state.inputValue,
            ...inputProps,
            className: classNames(Classes.INPUT_GHOST, inputProps?.className),
            disabled,
            onChange: this.handleInputChange,
            onFocus: this.handleInputFocus,
            onKeyDown: this.handleInputKeyDown,
            onKeyUp: this.handleInputKeyUp,
            onPaste: this.handleInputPaste,
            placeholder: resolvedPlaceholder,
            ref: this.handleRef,
        } satisfies React.HTMLProps<HTMLElement>;

        return (
            <div className={classes} onBlur={this.handleContainerBlur} onClick={this.handleContainerClick}>
                <Icon
                    className={Classes.TAG_INPUT_ICON}
                    icon={leftIcon}
                    size={isLarge ? IconSize.LARGE : IconSize.STANDARD}
                />
                <div className={Classes.TAG_INPUT_VALUES}>
                    {values.map(this.maybeRenderTag)}
                    {this.props.children}
                    {autoResize ? <ResizableInput {...resolvedInputProps} /> : <input {...resolvedInputProps} />}
                </div>
                {this.props.rightElement}
            </div>
        );
    }

    public componentDidUpdate(prevProps: TagInputProps) {
        if (prevProps.inputRef !== this.props.inputRef) {
            setRef(prevProps.inputRef, null);
            this.handleRef = refHandler(this, "inputElement", this.props.inputRef);
            setRef(this.props.inputRef, this.inputElement);
        }
    }

    private addTags = (value: string, method: TagInputAddMethod = "default") => {
        const { inputValue, onAdd, onChange, values } = this.props;
        const newValues = this.getValues(value);
        let shouldClearInput = onAdd?.(newValues, method) !== false && inputValue === undefined;
        // avoid a potentially expensive computation if this prop is omitted
        if (Utils.isFunction(onChange)) {
            shouldClearInput = onChange([...values, ...newValues]) !== false && shouldClearInput;
        }
        // only explicit return false cancels text clearing
        if (shouldClearInput) {
            this.setState({ inputValue: "" });
        }
    };

    private maybeRenderTag = (tag: React.ReactNode, index: number) => {
        if (!tag) {
            return null;
        }
        const { large, tagProps } = this.props;
        const props = Utils.isFunction(tagProps) ? tagProps(tag, index) : tagProps;
        return (
            <Tag
                active={index === this.state.activeIndex}
                data-tag-index={index}
                key={tag + "__" + index}
                large={large}
                onRemove={this.props.disabled ? undefined : this.handleRemoveTag}
                {...props}
            >
                {tag}
            </Tag>
        );
    };

    private getNextActiveIndex(direction: number) {
        const { activeIndex } = this.state;
        if (activeIndex === NONE) {
            // nothing active & moving left: select last defined value. otherwise select nothing.
            return direction < 0 ? this.findNextIndex(this.props.values.length, -1) : NONE;
        } else {
            // otherwise, move in direction and clamp to bounds.
            // note that upper bound allows going one beyond last item
            // so focus can move off the right end, into the text input.
            return this.findNextIndex(activeIndex, direction);
        }
    }

    private findNextIndex(startIndex: number, direction: number) {
        const { values } = this.props;
        let index = startIndex + direction;
        while (index > 0 && index < values.length && !values[index]) {
            index += direction;
        }
        return Utils.clamp(index, 0, values.length);
    }

    /**
     * Splits inputValue on separator prop,
     * trims whitespace from each new value,
     * and ignores empty values.
     */
    private getValues(inputValue: string) {
        const { separator } = this.props;
        // NOTE: split() typings define two overrides for string and RegExp.
        // this does not play well with our union prop type, so we'll just declare it as a valid type.
        return (separator === false ? [inputValue] : inputValue.split(separator as string))
            .map(val => val.trim())
            .filter(val => val.length > 0);
    }

    private handleContainerClick = () => {
        this.inputElement?.focus();
    };

    private handleContainerBlur = ({ currentTarget }: React.FocusEvent<HTMLDivElement>) => {
        this.requestAnimationFrame(() => {
            // we only care if the blur event is leaving the container.
            // defer this check using rAF so activeElement will have updated.
            const isFocusInsideContainer = currentTarget.contains(getActiveElement(this.inputElement));
            if (!isFocusInsideContainer) {
                if (this.props.addOnBlur && this.state.inputValue !== undefined && this.state.inputValue.length > 0) {
                    this.addTags(this.state.inputValue, "blur");
                }
                this.setState({ activeIndex: NONE, isInputFocused: false });
            }
        });
    };

    private handleInputFocus = (event: React.FocusEvent<HTMLInputElement>) => {
        this.setState({ isInputFocused: true });
        this.props.inputProps?.onFocus?.(event);
    };

    private handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        this.setState({ activeIndex: NONE, inputValue: event.currentTarget.value });
        this.props.onInputChange?.(event);
        this.props.inputProps?.onChange?.(event);
    };

    private handleInputKeyDown = (event: React.KeyboardEvent<HTMLInputElement>) => {
        const { selectionEnd, value } = event.currentTarget;
        const { activeIndex } = this.state;

        let activeIndexToEmit = activeIndex;

        // do not add a new tag if the user is composing (e.g. for Japanese or Chinese)
        if (event.key === "Enter" && !event.nativeEvent.isComposing && value.length > 0) {
            this.addTags(value, "default");
        } else if (selectionEnd === 0 && this.props.values.length > 0) {
            // cursor at beginning of input allows interaction with tags.
            // use selectionEnd to verify cursor position and no text selection.
            if (event.key === "ArrowLeft" || event.key === "ArrowRight") {
                const nextActiveIndex = this.getNextActiveIndex(event.key === "ArrowRight" ? 1 : -1);
                if (nextActiveIndex !== activeIndex) {
                    event.stopPropagation();
                    activeIndexToEmit = nextActiveIndex;
                    this.setState({ activeIndex: nextActiveIndex });
                }
            } else if (event.key === "Backspace") {
                this.handleBackspaceToRemove(event);
            } else if (event.key === "Delete") {
                this.handleDeleteToRemove(event);
            }
        }

        this.invokeKeyPressCallback("onKeyDown", event, activeIndexToEmit);
    };

    private handleInputKeyUp = (event: React.KeyboardEvent<HTMLInputElement>) => {
        this.invokeKeyPressCallback("onKeyUp", event, this.state.activeIndex);
    };

    private handleInputPaste = (event: React.ClipboardEvent<HTMLInputElement>) => {
        const { separator } = this.props;
        const value = event.clipboardData.getData("text");

        if (!this.props.addOnPaste || value.length === 0) {
            return;
        }

        // special case as a UX nicety: if the user pasted only one value with no delimiters in it, leave that value in
        // the input field so that the user can refine it before converting it to a tag manually.
        if (separator === false || value.split(separator!).length === 1) {
            return;
        }

        event.preventDefault();
        this.addTags(value, "paste");
    };

    private handleRemoveTag = (event: React.MouseEvent<HTMLSpanElement>) => {
        // using data attribute to simplify callback logic -- one handler for all children
        const index = +event.currentTarget.parentElement!.getAttribute("data-tag-index")!;
        this.removeIndexFromValues(index);
    };

    private handleBackspaceToRemove(event: React.KeyboardEvent<HTMLInputElement>) {
        const previousActiveIndex = this.state.activeIndex;
        // always move leftward one item (this will focus last item if nothing is focused)
        this.setState({ activeIndex: this.getNextActiveIndex(-1) });
        // delete item if there was a previous valid selection (ignore first backspace to focus last item)
        if (this.isValidIndex(previousActiveIndex)) {
            event.stopPropagation();
            this.removeIndexFromValues(previousActiveIndex);
        }
    }

    private handleDeleteToRemove(event: React.KeyboardEvent<HTMLInputElement>) {
        const { activeIndex } = this.state;
        if (this.isValidIndex(activeIndex)) {
            event.stopPropagation();
            this.removeIndexFromValues(activeIndex);
        }
    }

    /** Remove the item at the given index by invoking `onRemove` and `onChange` accordingly. */
    private removeIndexFromValues(index: number) {
        const { onChange, onRemove, values } = this.props;
        onRemove?.(values[index], index);
        onChange?.(values.filter((_, i) => i !== index));
    }

    private invokeKeyPressCallback(
        propCallbackName: "onKeyDown" | "onKeyUp",
        event: React.KeyboardEvent<HTMLInputElement>,
        activeIndex: number,
    ) {
        this.props[propCallbackName]?.(event, activeIndex === NONE ? undefined : activeIndex);
        this.props.inputProps![propCallbackName]?.(event);
    }

    /** Returns whether the given index represents a valid item in `this.props.values`. */
    private isValidIndex(index: number) {
        return index !== NONE && index < this.props.values.length;
    }
}

================================================================================

File: src\components\tag-input\_resizable-input.scss
--------------------------------------------------------------------------------
@import "../../common/variables";
@import "../tag/common";

.#{$ns}-resizable-input-span {
  max-height: 0;
  max-width: 100%;
  min-width: $pt-grid-size * 8;
  opacity: 0;
  overflow: hidden;
  position: absolute;
  white-space: nowrap;
  z-index: -1;
}

================================================================================

File: src\components\tag-input\_tag-input.scss
--------------------------------------------------------------------------------
// Copyright 2017 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "../forms/common";
@import "../tag/common";

$tag-input-padding: ($pt-input-height - $tag-height) * 0.5 !default;

$tag-input-icon-padding: ($pt-input-height - $pt-icon-size-standard) * 0.5 !default;
$tag-input-icon-padding-large: ($pt-input-height-large - $pt-icon-size-large) * 0.5 !default;

.#{$ns}-tag-input {
  @include pt-flex-container(row, $fill: ".#{$ns}-tag-input-values");
  align-items: flex-start;
  cursor: text;
  height: auto;
  line-height: inherit;
  min-height: $pt-input-height;
  padding-left: $tag-input-padding;
  padding-right: 0;

  .#{$ns}-tag-input-icon {
    color: $pt-icon-color;
    margin-left: $tag-input-icon-padding - $tag-input-padding;
    margin-right: $tag-input-icon-padding;
    // margins to center icon in one-line input
    margin-top: $tag-input-icon-padding;
  }

  .#{$ns}-tag-input-values {
    @include pt-flex-container(row, $tag-input-padding);
    align-items: center;
    // fill vertical height
    align-self: stretch;
    flex-wrap: wrap;
    margin-right: $tag-input-icon-padding;
    margin-top: $tag-input-padding;
    // allow tags to ellipse and not overflow the container
    min-width: 0;
    position: relative;

    // use the larger, conventional input padding when there are no tags and no left icon present.
    // see: https://github.com/palantir/blueprint/issues/2872
    &:first-child {
      .#{$ns}-tag ~ .#{$ns}-input-ghost {
        padding-left: 0;
      }

      .#{$ns}-input-ghost {
        // some padding-left is already applied on the root component, so we should subtract that
        padding-left: $input-padding-horizontal - $tag-input-padding;
      }
    }

    > * {
      margin-bottom: $tag-input-padding;
    }
  }

  .#{$ns}-tag {
    // NOTE: in order to wrap long words, you must set explicit width on TagInput,
    // or use .#{$ns}-fill CSS class modifier.
    overflow-wrap: break-word;

    &.#{$ns}-active {
      @include focus-outline(0);
    }
  }

  .#{$ns}-input-ghost {
    // input fills remaining line
    flex: 1 1 auto;
    line-height: $tag-height;
    // essentially a min-width, cuz flex allows it to grow or shrink:
    width: $pt-grid-size * 8;

    &:disabled,
    &.#{$ns}-disabled {
      cursor: not-allowed;
    }
  }

  .#{$ns}-button,
  .#{$ns}-spinner {
    margin: ($pt-input-height - $pt-button-height-small) * 0.5;
    margin-left: 0;
  }

  .#{$ns}-button {
    @include pt-button-height-small();
  }

  &.#{$ns}-large {
    @include pt-flex-margin(row, $tag-input-icon-padding-large);
    height: auto;
    min-height: $pt-input-height-large;

    .#{$ns}-tag-input-icon {
      margin-left: $tag-input-icon-padding-large - $tag-input-padding;
      margin-top: $tag-input-icon-padding-large;
    }

    .#{$ns}-input-ghost {
      line-height: $tag-height-large;
    }

    .#{$ns}-button {
      @include pt-button-height-default();
      margin: ($pt-input-height-large - $pt-button-height) * 0.5;
      margin-left: 0;
    }

    .#{$ns}-spinner {
      margin: ($pt-input-height-large - $pt-button-height-small) * 0.5;
      margin-left: 0;
    }
  }

  &.#{$ns}-active {
    background-color: $input-background-color;
    box-shadow: input-transition-shadow($input-shadow-color-focus, true), $input-box-shadow-focus;

    @each $intent, $color in $pt-intent-colors {
      &.#{$ns}-intent-#{$intent} {
        box-shadow: input-transition-shadow($color, true), $input-box-shadow-focus;
      }
    }
  }

  .#{$ns}-dark &,
  &.#{$ns}-dark {
    .#{$ns}-tag-input-icon {
      color: $pt-dark-icon-color;
    }

    .#{$ns}-input-ghost {
      @include pt-dark-input-placeholder();

      color: $dark-input-color;
    }

    &.#{$ns}-active {
      background-color: $dark-input-background-color;
      box-shadow: dark-input-transition-shadow($dark-input-shadow-color-focus, true),
                  $pt-dark-input-box-shadow;

      @each $intent, $color in $pt-dark-input-intent-box-shadow-colors {
        &.#{$ns}-intent-#{$intent} {
          box-shadow: input-transition-shadow($color, true), $pt-dark-input-box-shadow;
        }
      }
    }
  }
}

// TODO: this is probably a useful modifier that we should pull into core, and use in EditableText
.#{$ns}-input-ghost {
  @include pt-input-placeholder();
  background: none;

  // reset browser input styles (we're using an input solely because you can type in it)
  border: none;
  box-shadow: none;
  padding: 0;

  &:focus {
    // remove focus state too
    /* stylelint-disable-next-line declaration-no-important */
    outline: none !important;
  }
}

================================================================================

File: src\components\text\text.md
--------------------------------------------------------------------------------
@# Text

The __Text__ component adds accessible overflow behavior to a line of text by conditionally adding the title attribute
and truncating with an ellipsis when content overflows its container.

@reactExample TextExample

@## Props interface

__Text__ accepts and renders arbitrary children. It is intended that these children render as text.

@interface TextProps

================================================================================

File: src\components\text\text.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Classes, mergeRefs } from "../../common";
import { DISPLAYNAME_PREFIX, type Props } from "../../common/props";
import { useIsomorphicLayoutEffect } from "../../hooks/useIsomorphicLayoutEffect";

export interface TextProps
    extends Props,
        React.RefAttributes<HTMLElement>,
        Omit<React.HTMLAttributes<HTMLElement>, "title"> {
    children?: React.ReactNode;

    /**
     * Indicates that this component should be truncated with an ellipsis if it overflows its container.
     * The `title` attribute will also be added when content overflows to show the full text of the children on hover.
     *
     * @default false
     */
    ellipsize?: boolean;

    /**
     * HTML tag name to use for rendered element.
     *
     * @default "div"
     */
    tagName?: keyof React.JSX.IntrinsicElements;

    /**
     * HTML title of the element
     */
    title?: string;
}

/**
 * Text component.
 *
 * @see https://blueprintjs.com/docs/#core/components/text
 */
export const Text: React.FC<TextProps> = React.forwardRef<HTMLElement, TextProps>(
    ({ children, tagName = "div", title, className, ellipsize, ...htmlProps }, forwardedRef) => {
        const contentMeasuringRef = React.useRef<HTMLElement>();
        const textRef = React.useMemo(() => mergeRefs(contentMeasuringRef, forwardedRef), [forwardedRef]);
        const [textContent, setTextContent] = React.useState<string>("");
        const [isContentOverflowing, setIsContentOverflowing] = React.useState<boolean>();

        // try to be conservative about running this effect, since querying scrollWidth causes the browser to reflow / recalculate styles,
        // which can be very expensive for long lists (for example, in long Menus)
        useIsomorphicLayoutEffect(() => {
            if (contentMeasuringRef.current?.textContent != null) {
                setIsContentOverflowing(
                    ellipsize! && contentMeasuringRef.current.scrollWidth > contentMeasuringRef.current.clientWidth,
                );
                setTextContent(contentMeasuringRef.current.textContent);
            }
        }, [contentMeasuringRef, children, ellipsize]);

        return React.createElement(
            tagName,
            {
                ...htmlProps,
                className: classNames(
                    {
                        [Classes.TEXT_OVERFLOW_ELLIPSIS]: ellipsize,
                    },
                    className,
                ),
                ref: textRef,
                title: title ?? (isContentOverflowing ? textContent : undefined),
            },
            children,
        );
    },
);
Text.defaultProps = {
    ellipsize: false,
};
Text.displayName = `${DISPLAYNAME_PREFIX}.Text`;

================================================================================

File: src\components\toast\overlayToaster.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";
import * as ReactDOM from "react-dom";

import { AbstractPureComponent, Classes, Position } from "../../common";
import {
    TOASTER_CREATE_ASYNC_NULL,
    TOASTER_CREATE_NULL,
    TOASTER_MAX_TOASTS_INVALID,
    TOASTER_WARN_INLINE,
} from "../../common/errors";
import { DISPLAYNAME_PREFIX } from "../../common/props";
import { isElementOfType, isNodeEnv } from "../../common/utils";
import type { DOMMountOptions } from "../../common/utils/mountOptions";
import { Overlay2 } from "../overlay2/overlay2";

import type { OverlayToasterProps } from "./overlayToasterProps";
import { Toast } from "./toast";
import { Toast2 } from "./toast2";
import type { Toaster, ToastOptions } from "./toaster";
import type { ToastProps } from "./toastProps";

export interface OverlayToasterState {
    toasts: ToastOptions[];
    toastRefs: Record<string, React.RefObject<HTMLElement>>;
}

export type OverlayToasterCreateOptions = DOMMountOptions<OverlayToasterProps>;

/**
 * OverlayToaster component.
 *
 * @see https://blueprintjs.com/docs/#core/components/toast
 */
export class OverlayToaster extends AbstractPureComponent<OverlayToasterProps, OverlayToasterState> implements Toaster {
    public static displayName = `${DISPLAYNAME_PREFIX}.OverlayToaster`;

    public static defaultProps: OverlayToasterProps = {
        autoFocus: false,
        canEscapeKeyClear: true,
        position: Position.TOP,
        usePortal: true,
    };

    /**
     * Create a new `Toaster` instance that can be shared around your application.
     * The `Toaster` will be rendered into a new element appended to the given container.
     */
    public static create(props?: OverlayToasterProps, container = document.body): Toaster {
        if (props != null && props.usePortal != null && !isNodeEnv("production")) {
            console.warn(TOASTER_WARN_INLINE);
        }
        const containerElement = document.createElement("div");
        container.appendChild(containerElement);
        const toaster = ReactDOM.render<OverlayToasterProps>(
            <OverlayToaster {...props} usePortal={false} />,
            containerElement,
        ) as OverlayToaster;
        if (toaster == null) {
            throw new Error(TOASTER_CREATE_NULL);
        }
        return toaster;
    }

    /**
     * Similar to {@link OverlayToaster.create}, but returns a Promise to a
     * Toaster instance after it's rendered and mounted to the DOM.
     *
     * This API will replace the synchronous {@link OverlayToaster.create} in a
     * future major version of Blueprint to reflect React 18+'s new asynchronous
     * rendering API.
     */
    public static createAsync(props?: OverlayToasterProps, options?: OverlayToasterCreateOptions): Promise<Toaster> {
        if (props != null && props.usePortal != null && !isNodeEnv("production")) {
            console.warn(TOASTER_WARN_INLINE);
        }

        const container = options?.container ?? document.body;
        const domRenderer = options?.domRenderer ?? ReactDOM.render;

        const toasterComponentRoot = document.createElement("div");
        container.appendChild(toasterComponentRoot);

        return new Promise<Toaster>((resolve, reject) => {
            try {
                domRenderer(<OverlayToaster {...props} ref={handleRef} usePortal={false} />, toasterComponentRoot);
            } catch (error) {
                // Note that we're catching errors from the domRenderer function
                // call, but not errors when rendering <OverlayToaster>, which
                // happens in a separate scheduled tick. Wrapping the
                // OverlayToaster in an error boundary would be necessary to
                // capture rendering errors, but that's still a bit unreliable
                // and would only catch errors rendering the initial mount.
                reject(error);
            }

            // We can get a rough guarantee that the OverlayToaster has been
            // mounted to the DOM by waiting until the ref callback here has
            // been fired.
            //
            // This is the approach suggested under "What about the render
            // callback?" at https://github.com/reactwg/react-18/discussions/5.
            function handleRef(ref: OverlayToaster | null) {
                if (ref == null) {
                    reject(new Error(TOASTER_CREATE_ASYNC_NULL));
                    return;
                }

                resolve(ref);
            }
        });
    }

    public state: OverlayToasterState = {
        toastRefs: {},
        toasts: [],
    };

    // auto-incrementing identifier for un-keyed toasts
    private toastId = 0;

    private toastRefs: Record<string, React.RefObject<HTMLElement>> = {};

    /** Compute a new collection of toast refs (usually after updating toasts) */
    private getToastRefs = (toasts: ToastOptions[]) => {
        return toasts.reduce<typeof this.toastRefs>((refs, toast) => {
            refs[toast.key!] = React.createRef<HTMLElement>();
            return refs;
        }, {});
    };

    public show(props: ToastProps, key?: string) {
        if (this.props.maxToasts) {
            // check if active number of toasts are at the maxToasts limit
            this.dismissIfAtLimit();
        }
        const options = this.createToastOptions(props, key);
        this.setState(prevState => {
            const toasts =
                key === undefined || this.isNewToastKey(key)
                    ? // prepend a new toast
                      [options, ...prevState.toasts]
                    : // update a specific toast
                      prevState.toasts.map(t => (t.key === key ? options : t));
            return { toasts, toastRefs: this.getToastRefs(toasts) };
        });
        return options.key;
    }

    public dismiss(key: string, timeoutExpired = false) {
        this.setState(prevState => {
            const toasts = prevState.toasts.filter(t => {
                const matchesKey = t.key === key;
                if (matchesKey) {
                    t.onDismiss?.(timeoutExpired);
                }
                return !matchesKey;
            });
            return { toasts, toastRefs: this.getToastRefs(toasts) };
        });
    }

    public clear() {
        this.state.toasts.forEach(t => t.onDismiss?.(false));
        this.setState({ toasts: [], toastRefs: {} });
    }

    public getToasts() {
        return this.state.toasts;
    }

    public render() {
        const classes = classNames(Classes.TOAST_CONTAINER, this.getPositionClasses(), this.props.className);
        return (
            <Overlay2
                autoFocus={this.props.autoFocus}
                canEscapeKeyClose={this.props.canEscapeKeyClear}
                canOutsideClickClose={false}
                className={classes}
                childRefs={this.toastRefs}
                enforceFocus={false}
                hasBackdrop={false}
                isOpen={this.state.toasts.length > 0 || this.props.children != null}
                onClose={this.handleClose}
                shouldReturnFocusOnClose={false}
                // $pt-transition-duration * 3 + $pt-transition-duration / 2
                transitionDuration={350}
                transitionName={Classes.TOAST}
                usePortal={this.props.usePortal}
            >
                {this.state.toasts.map(this.renderToast, this)}
                {this.renderChildren()}
            </Overlay2>
        );
    }

    protected validateProps({ maxToasts }: OverlayToasterProps) {
        // maximum number of toasts should not be a number less than 1
        if (maxToasts !== undefined && maxToasts < 1) {
            throw new Error(TOASTER_MAX_TOASTS_INVALID);
        }
    }

    /**
     * If provided `Toast` children, automaticaly upgrade them to `Toast2` elements so that `Overlay2` can inject
     * refs into them for use by `CSSTransition`. This is a bit hacky but ensures backwards compatibility for
     * `OverlayToaster`. It should be an uncommon code path in most applications, since we expect most usage to
     * occur via the imperative toaster APIs.
     *
     * We can remove this indirection once `Toast2` fully replaces `Toast` in a future major version.
     *
     * TODO(@adidahiya): Blueprint v6.0
     */
    private renderChildren() {
        return React.Children.map(this.props.children, child => {
            // eslint-disable-next-line deprecation/deprecation
            if (isElementOfType(child, Toast)) {
                return <Toast2 {...child.props} />;
            } else {
                return child;
            }
        });
    }

    private isNewToastKey(key: string) {
        return this.state.toasts.every(toast => toast.key !== key);
    }

    private dismissIfAtLimit() {
        if (this.state.toasts.length === this.props.maxToasts) {
            // dismiss the oldest toast to stay within the maxToasts limit
            this.dismiss(this.state.toasts[this.state.toasts.length - 1].key!);
        }
    }

    private renderToast = (toast: ToastOptions) => {
        return <Toast2 {...toast} onDismiss={this.getDismissHandler(toast)} />;
    };

    private createToastOptions(props: ToastProps, key = `toast-${this.toastId++}`) {
        // clone the object before adding the key prop to avoid leaking the mutation
        return { ...props, key };
    }

    private getPositionClasses() {
        const positions = this.props.position!.split("-");
        // NOTE that there is no -center class because that's the default style
        return [
            ...positions.map(p => `${Classes.TOAST_CONTAINER}-${p.toLowerCase()}`),
            `${Classes.TOAST_CONTAINER}-${this.props.usePortal ? "in-portal" : "inline"}`,
        ];
    }

    private getDismissHandler = (toast: ToastOptions) => (timeoutExpired: boolean) => {
        this.dismiss(toast.key, timeoutExpired);
    };

    private handleClose = (e: React.SyntheticEvent<HTMLElement>) => {
        // NOTE that `e` isn't always a KeyboardEvent but that's the only type we care about
        if ((e as React.KeyboardEvent<HTMLElement>).key === "Escape") {
            this.clear();
        }
    };
}

================================================================================

File: src\components\toast\overlayToasterProps.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { Position, Props } from "../../common";

export type ToasterPosition =
    | typeof Position.TOP
    | typeof Position.TOP_LEFT
    | typeof Position.TOP_RIGHT
    | typeof Position.BOTTOM
    | typeof Position.BOTTOM_LEFT
    | typeof Position.BOTTOM_RIGHT;

/**
 * Props supported by the `<OverlayToaster>` component.
 * These props can be passed as an argument to the static `Toaster.create(props?, container?)` method.
 */
export interface OverlayToasterProps extends Props {
    /**
     * Whether a toast should acquire application focus when it first opens.
     * This is disabled by default so that toasts do not interrupt the user's flow.
     * Note that `enforceFocus` is always disabled for `Toaster`s.
     *
     * @default false
     */
    autoFocus?: boolean;

    /**
     * Whether pressing the `esc` key should clear all active toasts.
     *
     * @default true
     */
    canEscapeKeyClear?: boolean;

    /** Toasts to display inside the Overlay2. */
    children?: React.ReactNode;

    /**
     * Whether the toaster should be rendered into a new element attached to `document.body`.
     * If `false`, then positioning will be relative to the parent element.
     *
     * This prop is ignored by `Toaster.create()` as that method always appends a new element
     * to the container.
     *
     * @default true
     */
    usePortal?: boolean;

    /**
     * Position of `Toaster` within its container.
     *
     * @default Position.TOP
     */
    position?: ToasterPosition;

    /**
     * The maximum number of active toasts that can be displayed at once.
     *
     * When the limit is about to be exceeded, the oldest active toast is removed.
     *
     * @default undefined
     */
    maxToasts?: number;
}

================================================================================

File: src\components\toast\toast.md
--------------------------------------------------------------------------------
@# Toast

A toast is a lightweight, ephemeral notice from an application in direct response to a user's action.

**Toasts** can be configured to appear at either the top or the bottom of an application window.
It is possible to show more than one toast on-screen at a time.

@reactExample ToastExample

@## Usage

@### Toast

**Toasts** have a built-in timeout of five seconds. Users can also dismiss them manually by clicking
the &times; button. overing the cursor over a toast prevents it from disappearing. When the cursor
leaves the toast, the toast's timeout restarts. Similarly, focussing the toast DOM element (for
example, by hitting the `tab` key) halts the timeout, and blurring restarts the timeout.

You may add one additional action button to a toast. You might use this to provide an undo button,
for example.

You may also apply the same visual intents to **Toasts** as other core components like
[**Buttons**](#core/components/button.css).

@interface ToastProps

@### OverlayToaster

The **OverlayToaster** component (previously named **Toaster**) is a stateful container for a single
list of toasts. Internally, it uses [**Overlay2**](#core/components/overlay2) to manage children and
transitions. It can be vertically aligned along the top or bottom edge of its container (new toasts
will slide in from that edge) and horizontally aligned along the left edge, center, or right edge
of its container.

There are three ways to use **OverlayToaster**:

1. **Recommended**: use the `OverlayToaster.createAsync()` static method to create a new `Toaster` instance:

    ```ts
    const myToaster: Toaster = await OverlayToaster.createAsync({ position: "bottom" });
    myToaster.show({ ...toastOptions });
    ```

    We recommend calling `OverlayToaster.createAsync` once in your application and
    [sharing the generated instance](#core/components/toast.example) throughout your application.

    A synchronous `OverlayToaster.create()` static method is also available, but will be phased out
    since React 18+ no longer synchronously renders components to the DOM.

    ```ts
    const myToaster: Toaster = OverlayToaster.create({ position: "bottom" });
    myToaster.show({ ...toastOptions });
    ```

2. Render an `<OverlayToaster>` with `<Toast2>` children:
    ```ts
    render(
        <OverlayToaster>
            <Toast2 {...toastOptions} />
        </OverlayToaster>,
        targetElement,
    );
    ```
3. Use a ref callback or object to access toaster instance methods.
    - Example with ref callback:
    ```ts
    render(<OverlayToaster ref={(ref: Toaster | null) => ref?.show({ ...toastOptions })} />, targetElement);
    ```
    - Example with ref object (note that React type constraints require us to use the more specific `OverlayToaster` type):
    ```ts
    const myToaster = React.createRef<OverlayToaster>();
    render(<OverlayToaster ref={myToaster} />, targetElement);
    myToaster.current?.show({ ...toastOptions });
    ```

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">Working with multiple toasters</h5>

You can have multiple toasters in a single application, but you must ensure that each has a unique
`position` to prevent overlap.

</div>

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">Toaster focus</h5>

**OverlayToaster** always disables Overlay2's `enforceFocus` behavior (meaning that you're not blocked
from accessing other parts of the application while a toast is active), and by default also
disables `autoFocus` (meaning that focus will not switch to a toast when it appears). You can
enable `autoFocus` for an individual `OverlayToaster` via a prop, if desired.

</div>

@interface OverlayToasterProps

@## Static usage

**OverlayToaster** provides the static `createAsync` method that returns a new `Toaster`, rendered
into an element attached to `<body>`. A toaster instance has a collection of methods to show and
hide toasts in its given container.

```ts
OverlayToaster.createAsync(props?: OverlayToasterProps, options?: OverlayToasterCreateOptions): Promise<Toaster>;
```

@interface OverlayToasterCreateOptions

The toaster will be rendered into a new element appended to the given `container`.
The `container` determines which element toasts are positioned relative to; the default value of
`<body>` allows them to use the entire viewport.

The return type is `Promise<Toaster>`, which is a minimal interface that exposes only the instance
methods detailed below. It can be thought of as `OverlayToaster` minus the `React.Component` methods,
because the `OverlayToaster` should not be treated as a normal React component.

A promise is returned as React components cannot be rendered synchronously after React version 18.
If this makes `Toaster` usage difficult outside of a function that's not `async`, it's still
possible to attach `.then()` handlers to the returned toaster.

```ts
function synchronousFn() {
    const toasterPromise = OverlayToaster.createAsync({});
    toasterPromise.then(toaster => toaster.show({ message: "Toast!" }));
}
```

Note that `OverlayToaster.createAsync()` will throw an error if invoked inside a component lifecycle
method, as `ReactDOM.render()` will return `null` resulting in an inaccessible toaster instance.

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">Beware of memory leaks</h5>

The static `createAsync` and `create` methods create a new `OverlayToaster` instance for the full lifetime of your
application. Since there's no React parent component, these methods create a new DOM node as a container for the
rendered `<OverlayToaster>` component. Every `createAsync` call will add a new DOM node. We do not recommend creating a
new `Toaster` every time a toast needs to be shown. To minimize leaking:

1. Call `OverlayToaster.createAsync` once in an application and [share the instance](#core/components/toast.example).
2. Consider one of the alternative APIs that mount the `<OverlayToaster>` somewhere in the application's React component tree. This provides component lifecycle management out of the box. See [_React component usage_](#core/components/toast.react-component-usage) for an example.

</div>

@interface Toaster

@### Example

Your application can contain several `ToasterInstance`s and easily share them across the codebase as modules.

The following code samples demonstrate our preferred pattern for intergrating a toaster into a React application:

#### `toaster.ts`

```ts
import { OverlayToaster, Position } from "@blueprintjs/core";

/** Singleton toaster instance. Create separate instances for different options. */
export const AppToaster = OverlayToaster.createAsync({
    className: "recipe-toaster",
    position: Position.TOP,
});
```

#### `application.tsx`

```tsx
import { Button } from "@blueprintjs/core";
import * as React from "react";
import { AppToaster } from "./toaster";

export class App extends React.PureComponent {
    render() {
        return <Button onClick={this.showToast} text="Toast please" />;
    }

    showToast = async () => {
        // create toasts in response to interactions.
        // in most cases, it's enough to simply create and forget (thanks to timeout).
        (await AppToaster).show({ message: "Toasted." });
    };
}
```

The example below uses the `OverlayToaster.createAsync()` static method. Clicking the button will create a new toaster mounted to `<body>`, show a message, and unmount the toaster from the DOM once the message is dismissed.

@reactExample ToastCreateAsyncExample

#### React 18

To maintain backwards compatibility with React 16 and 17, `OverlayToaster.createAsync` uses `ReactDOM.render` out of the box. This triggers a [console warning on React 18](https://react.dev/blog/2022/03/08/react-18-upgrade-guide#updates-to-client-rendering-apis).
A future major version of Blueprint will drop support for React versions before 18 and switch the
default rendering function from `ReactDOM.render` to `createRoot`.

If you're using React 18, we recommend passing in a custom `domRenderer` function.

```tsx
import { OverlayToaster } from "@blueprintjs/core";
import { createRoot } from "react-dom/client";

const toaster = await OverlayToaster.createAsync(toasterProps, {
    // Use createRoot() instead of ReactDOM.render(). This can be deleted after
    // a future Blueprint version uses createRoot() for Toasters by default.
    domRenderer: (toaster, containerElement) => createRoot(containerElement).render(toaster),
});

toaster.show({ message: "Hello React 18!" });
```

@## React component usage

Render the `<OverlayToaster>` component like any other element and supply `<Toast2>` elements as
`children`. You can optionally attach a `ref` handler to access the instance methods, but we
strongly recommend using the [`OverlayToaster.create` static method](#core/components/toast.static-usage)
documented above instead. Note that `children` and `ref` can be used together, but `children` will
always appear _after_ toasts created with `ref.show()`.

```tsx
import { Button, OverlayToaster, Position, Toast2, ToastOptions } from "@blueprintjs/core";
import * as React from "react";

function MyComponent() {
    const [toasts, setToasts] = React.useState<ToastOptions[]>([]);
    const toaster = React.useRef<OverlayToaster>(null);

    const addToastViaRef = React.useCallback(() => {
        toaster.current?.show({ message: "Toasted!" });
    }, []);

    const addToastLocally = React.useCallback(() => {
        setToasts(t => [...t, { key: "toasted", message: "Toasted!" }]);
    }, []);

    return (
        <div>
            <Button onClick={addToastViaRef} text="Procure toast remotely" />
            <Button onClick={addToastLocally} text="Procure toast locally" />
            <OverlayToaster position={Position.TOP_RIGHT} ref={toaster}>
                {/* "Toasted!" will appear here after clicking button. */}
                {toasts.map(toast => (
                    <Toast2 key={toast.key} {...toast} />
                ))}
            </OverlayToaster>
        </div>
    );
}
```

================================================================================

File: src\components\toast\toast.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview This component is DEPRECATED, and the code is frozen.
 * All changes & bugfixes should be made to Toast2 instead.
 */

/* eslint-disable deprecation/deprecation, @blueprintjs/no-deprecated-components */

import classNames from "classnames";
import * as React from "react";

import { Cross } from "@blueprintjs/icons";

import { AbstractPureComponent, Classes } from "../../common";
import { DISPLAYNAME_PREFIX } from "../../common/props";
import { ButtonGroup } from "../button/buttonGroup";
import { AnchorButton, Button } from "../button/buttons";
import { Icon } from "../icon/icon";

import type { ToastProps } from "./toastProps";

/**
 * Toast component.
 *
 * @deprecated use `Toast2` instead, which forwards DOM refs and is thus compatible with `Overlay2`.
 * @see https://blueprintjs.com/docs/#core/components/toast
 */
export class Toast extends AbstractPureComponent<ToastProps> {
    public static defaultProps: ToastProps = {
        className: "",
        isCloseButtonShown: true,
        message: "",
        timeout: 5000,
    };

    public static displayName = `${DISPLAYNAME_PREFIX}.Toast`;

    public render(): React.JSX.Element {
        const { className, icon, intent, message, isCloseButtonShown } = this.props;
        return (
            <div
                className={classNames(Classes.TOAST, Classes.intentClass(intent), className)}
                onBlur={this.startTimeout}
                onFocus={this.clearTimeouts}
                onMouseEnter={this.clearTimeouts}
                onMouseLeave={this.startTimeout}
                tabIndex={0}
            >
                <Icon icon={icon} />
                <span className={Classes.TOAST_MESSAGE} role="alert">
                    {message}
                </span>
                <ButtonGroup minimal={true}>
                    {this.maybeRenderActionButton()}
                    {isCloseButtonShown && (
                        <Button aria-label="Close" icon={<Cross />} onClick={this.handleCloseClick} />
                    )}
                </ButtonGroup>
            </div>
        );
    }

    public componentDidMount() {
        this.startTimeout();
    }

    public componentDidUpdate(prevProps: ToastProps) {
        if (prevProps.timeout !== this.props.timeout) {
            if (this.props.timeout! > 0) {
                this.startTimeout();
            } else {
                this.clearTimeouts();
            }
        }
    }

    public componentWillUnmount() {
        this.clearTimeouts();
    }

    private maybeRenderActionButton() {
        const { action } = this.props;
        if (action == null) {
            return undefined;
        } else {
            return <AnchorButton {...action} intent={undefined} onClick={this.handleActionClick} />;
        }
    }

    private handleActionClick = (e: React.MouseEvent<HTMLElement>) => {
        this.props.action?.onClick?.(e);
        this.triggerDismiss(false);
    };

    private handleCloseClick = () => this.triggerDismiss(false);

    private triggerDismiss(didTimeoutExpire: boolean) {
        this.clearTimeouts();
        this.props.onDismiss?.(didTimeoutExpire);
    }

    private startTimeout = () => {
        this.clearTimeouts();
        if (this.props.timeout! > 0) {
            this.setTimeout(() => this.triggerDismiss(true), this.props.timeout);
        }
    };
}

================================================================================

File: src\components\toast\toast2.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Cross } from "@blueprintjs/icons";

import { Classes } from "../../common";
import { DISPLAYNAME_PREFIX } from "../../common/props";
import { useTimeout } from "../../hooks/useTimeout";
import { ButtonGroup } from "../button/buttonGroup";
import { AnchorButton, Button } from "../button/buttons";
import { Icon } from "../icon/icon";

import type { ToastProps } from "./toastProps";

/**
 * Toast2 component.
 *
 * Compared to the deprecated `Toast` component, this is a function component which forwards DOM
 * refs and is thus compatible with `Overlay2`.
 *
 * @see https://blueprintjs.com/docs/#core/components/toast2
 */
export const Toast2 = React.forwardRef<HTMLDivElement, ToastProps>((props, ref) => {
    const { action, className, icon, intent, isCloseButtonShown, message, onDismiss, timeout } = props;

    const [isTimeoutStarted, setIsTimeoutStarted] = React.useState(false);
    const startTimeout = React.useCallback(() => setIsTimeoutStarted(true), []);
    const clearTimeout = React.useCallback(() => setIsTimeoutStarted(false), []);

    // Per docs: "Providing a value less than or equal to 0 will disable the timeout (this is discouraged)."
    const isTimeoutEnabled = timeout != null && timeout > 0;

    // timeout is triggered & cancelled by updating `isTimeoutStarted` state
    useTimeout(
        () => {
            triggerDismiss(true);
        },
        isTimeoutStarted && isTimeoutEnabled ? timeout : null,
    );

    // start timeout on mount or change, cancel on unmount
    React.useEffect(() => {
        if (isTimeoutEnabled) {
            startTimeout();
        } else {
            clearTimeout();
        }
        return clearTimeout;
    }, [clearTimeout, startTimeout, isTimeoutEnabled, timeout]);

    const triggerDismiss = React.useCallback(
        (didTimeoutExpire: boolean) => {
            clearTimeout();
            onDismiss?.(didTimeoutExpire);
        },
        [clearTimeout, onDismiss],
    );

    const handleCloseClick = React.useCallback(() => triggerDismiss(false), [triggerDismiss]);

    const handleActionClick = React.useCallback(
        (e: React.MouseEvent<HTMLElement>) => {
            action?.onClick?.(e);
            triggerDismiss(false);
        },
        [action, triggerDismiss],
    );

    return (
        <div
            className={classNames(Classes.TOAST, Classes.intentClass(intent), className)}
            // Pause timeouts if users are hovering over or click on the toast. The toast may have
            // actions the user wants to click. It'd be a poor experience to "pull the toast" out
            // from under them.
            onBlur={startTimeout}
            onFocus={clearTimeout}
            onMouseEnter={clearTimeout}
            onMouseLeave={startTimeout}
            ref={ref}
            tabIndex={0}
        >
            <Icon icon={icon} />
            <span className={Classes.TOAST_MESSAGE} role="alert">
                {message}
            </span>
            <ButtonGroup minimal={true}>
                {action && <AnchorButton {...action} intent={undefined} onClick={handleActionClick} />}
                {isCloseButtonShown && <Button aria-label="Close" icon={<Cross />} onClick={handleCloseClick} />}
            </ButtonGroup>
        </div>
    );
});
Toast2.defaultProps = {
    className: "",
    isCloseButtonShown: true,
    message: "",
    timeout: 5000,
};
Toast2.displayName = `${DISPLAYNAME_PREFIX}.Toast2`;

================================================================================

File: src\components\toast\toaster.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { OverlayToaster } from "./overlayToaster";
import type { OverlayToasterProps } from "./overlayToasterProps";
import type { ToastProps } from "./toastProps";

export type ToastOptions = ToastProps & { key: string };
/** Instance methods available on a toaster component instance. */
export interface Toaster {
    /**
     * Shows a new toast to the user, or updates an existing toast corresponding to the provided key (optional).
     *
     * Returns the unique key of the toast.
     */
    show(props: ToastProps, key?: string): string;

    /** Dismiss the given toast instantly. */
    dismiss(key: string): void;

    /** Dismiss all toasts instantly. */
    clear(): void;

    /** Returns the props for all current toasts. */
    getToasts(): ToastOptions[];
}

export type ToasterInstance = Toaster;
// merges with declaration of `Toaster` type in `toasterTypes.ts`
// kept for backwards-compatibility with v4.x
// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Toaster = {
    // eslint-disable-next-line deprecation/deprecation
    create: deprecatedToasterCreate,
};

/** @deprecated use OverlayToaster.create() instead */
function deprecatedToasterCreate(props?: OverlayToasterProps, container = document.body): Toaster {
    return OverlayToaster.create(props, container);
}

================================================================================

File: src\components\toast\toastProps.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ActionProps, IntentProps, LinkProps, MaybeElement, Props } from "../../common/props";
import type { IconName } from "../icon/icon";

export interface ToastProps extends Props, IntentProps {
    /**
     * Action rendered as a minimal `AnchorButton`. The toast is dismissed automatically when the
     * user clicks the action button. Note that the `intent` prop is ignored (the action button
     * cannot have its own intent color that might conflict with the toast's intent). Omit this
     * prop to omit the action button.
     */
    action?: ActionProps & LinkProps;

    /** Name of a Blueprint UI icon (or an icon element) to render before the message. */
    icon?: IconName | MaybeElement;

    /**
     * Whether to show the close button in the toast.
     *
     * @default true
     */
    isCloseButtonShown?: boolean;

    /** Message to display in the body of the toast. */
    message: React.ReactNode;

    /**
     * Callback invoked when the toast is dismissed, either by the user or by the timeout.
     * The value of the argument indicates whether the toast was closed because the timeout expired.
     */
    onDismiss?: (didTimeoutExpire: boolean) => void;

    /**
     * Milliseconds to wait before automatically dismissing toast.
     * Providing a value less than or equal to 0 will disable the timeout (this is discouraged).
     *
     * @default 5000
     */
    timeout?: number;
}

================================================================================

File: src\components\toast\_toast.scss
--------------------------------------------------------------------------------
// Copyright 2016 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "../../common/react-transition";

$toast-height: $pt-button-height-large !default;
$toast-min-width: $pt-grid-size * 30 !default;
$toast-max-width: $pt-grid-size * 50 !default;
$toast-margin: $pt-grid-size * 2 !default;

$toast-intent-colors: (
  "primary": ($pt-intent-primary, $white, $blue2, $blue1),
  "success": ($pt-intent-success, $white, $green2, $green1),
  "warning": ($orange5, $dark-gray1, $orange4, $orange3),
  "danger": ($pt-intent-danger, $white, $red2, $red1),
) !default;

@mixin pt-toast-intent(
  $background-color,
  $text-and-focus-color,
  $button-hover-color,
  $button-active-color,
) {
  background-color: $background-color;
  color: $text-and-focus-color;

  .#{$ns}-icon:first-child {
    color: rgba($text-and-focus-color, 0.7);
  }

  // HACKHACK custom colors for buttons on intent background so they always show up nice
  /* stylelint-disable declaration-no-important */
  .#{$ns}-button {
    background-color: $background-color !important;
    color: $text-and-focus-color !important;

    &:hover {
      background-color: $button-hover-color !important;
      color: $text-and-focus-color !important;
    }

    &:active {
      background-color: $button-active-color !important;
      color: $text-and-focus-color !important;
    }

    &:focus {
      // blue outline color shows poorly on colored bg
      outline-color: rgba($text-and-focus-color, 0.75);
    }

    &:last-child > .#{$ns}-icon-cross {
      color: rgba($text-and-focus-color, 0.7) !important;
    }
  }
  /* stylelint-enable declaration-no-important */
}

.#{$ns}-toast {
  // toast transition properties
  $enter-translate: (transform: translateY(-$toast-height) translateY(0));
  $leave-blur: (opacity: 0 1, filter: blur($pt-grid-size) blur(0));

  // new toasts slide in from the top
  @include react-transition-phase(
    "#{$ns}-toast",
    "enter",
    $enter-translate,
    $duration: $pt-transition-duration * 3,
    $easing: $pt-transition-ease-bounce,
    $before: "&"
  );
  @include react-transition-phase(
    "#{$ns}-toast",
    "enter",
    $enter-translate,
    $duration: $pt-transition-duration * 3,
    $easing: $pt-transition-ease-bounce,
    $before: "&",
    $after: "~ &"
  );
  // leaving toasts simply fade away
  @include react-transition-phase(
    "#{$ns}-toast",
    "exit",
    $leave-blur,
    $duration: $pt-transition-duration * 3,
    $before: "&"
  );
  // younger siblings of leaving toasts wait a moment before moving to fill gap
  @include react-transition-phase(
    "#{$ns}-toast",
    "exit",
    $enter-translate,
    $delay: $pt-transition-duration * 0.5,
    $before: "&",
    $after: "~ &"
  );
  align-items: flex-start;
  background-color: $white;
  border-radius: $pt-border-radius;
  box-shadow: $pt-toast-box-shadow;
  display: flex;
  margin: $toast-margin 0 0;
  max-width: $toast-max-width;
  min-width: $toast-min-width;

  // toast is interactive even though container isn't
  pointer-events: all;

  // override inline styles (#367): toasts rely on relative positioning for stacking.
  /* stylelint-disable-next-line declaration-no-important */
  position: relative !important;

  .#{$ns}-button-group {
    flex: 0 0 auto;
    padding: ($toast-height - $pt-button-height) * 0.5;
    padding-left: 0;
  }

  > .#{$ns}-icon {
    color: $pt-icon-color;
    margin: ($toast-height - $pt-icon-size-standard) * 0.5;
    margin-right: 0;
  }

  &.#{$ns}-dark,
  .#{$ns}-dark & {
    background-color: $dark-gray5;
    box-shadow: $pt-dark-toast-box-shadow;

    > .#{$ns}-icon {
      color: $pt-dark-icon-color;
    }

    // increase contrast for default intent in dark mode
    .#{$ns}-button .#{$ns}-icon {
      color: rgba($white, 0.7);
    }
  }

  &[class*="#{$ns}-intent-"] {
    a {
      color: rgba($white, 0.7);

      &:hover {
        color: $white;
      }
    }

    > .#{$ns}-icon {
      color: $white;
    }
  }

  @each $intent, $colors in $toast-intent-colors {
    &.#{$ns}-intent-#{$intent} {
      @include pt-toast-intent($colors...);
    }
  }
}

.#{$ns}-toast-message {
  flex: 1 1 auto;
  padding: centered-text($toast-height);
  word-break: break-word;
}

.#{$ns}-toast-container {
  align-items: center;
  // override inline overlay styles (#2626)
  /* stylelint-disable-next-line declaration-no-important */
  display: flex !important;
  flex-direction: column;
  left: 0;
  // toasts have margin-top so omit it on container

  // prevent container from scrolling as new toasts enter (from bottom)
  overflow: hidden;

  // ensure there's enough space for full box-shadow
  padding: 0 $toast-margin $toast-margin;

  // container will not block clicks on elements behind it
  pointer-events: none;

  right: 0;

  // #975 ensure toasts are on top of everything (esp dialogs)
  z-index: $pt-z-index-overlay * 2;

  &.#{$ns}-toast-container-in-portal {
    position: fixed;
  }

  &.#{$ns}-toast-container-inline {
    position: absolute;
  }

  &.#{$ns}-toast-container-top {
    top: 0;
  }

  &.#{$ns}-toast-container-bottom {
    bottom: 0;
    flex-direction: column-reverse;
    top: auto;
  }

  &.#{$ns}-toast-container-left {
    align-items: flex-start;
  }

  &.#{$ns}-toast-container-right {
    align-items: flex-end;
  }
}

.#{$ns}-toast-container-bottom .#{$ns}-toast {
  // minimal diff in react-transition styles so we can avoid calling those mixins again
  &.#{$ns}-toast-enter:not(.#{$ns}-toast-enter-active),
  &.#{$ns}-toast-enter:not(.#{$ns}-toast-enter-active) ~ .#{$ns}-toast,
  &.#{$ns}-toast-appear:not(.#{$ns}-toast-appear-active),
  &.#{$ns}-toast-appear:not(.#{$ns}-toast-appear-active) ~ .#{$ns}-toast,
  &.#{$ns}-toast-exit-active ~ .#{$ns}-toast,
  &.#{$ns}-toast-leave-active ~ .#{$ns}-toast {
    transform: translateY($toast-margin + $toast-height);
  }
}

================================================================================

File: src\components\tooltip\tooltip.md
--------------------------------------------------------------------------------
@# Tooltip

__Tooltip__ is a lightweight popover for showing additional information during hover interactions.

@reactExample TooltipExample

@## Usage

__Tooltip__ passes most of its props to [__Popover__](#core/components/popover), with some exceptions.
Notably, it only supports hover interactions.

When creating a tooltip, you must specify both its **content** (via the `content` prop) and
its **target** (either as children, or via the `renderTarget` prop). See the
[Popover "Structure" docs](#core/components/popover.structure) for more info on rendering a tooltip target.

The **content** will be shown inside the tooltip itself. When opened, the tooltip will always be
positioned on the page next to the target; the `placement` prop determines its relative placement (on
which side of the target).

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">Button targets</h5>

Buttons make great tooltip targets, but the `disabled` attribute will prevent all
events so the enclosing __Tooltip__ will not know when to respond.
Use [__AnchorButton__](#core/components/button.anchor-button) instead;
see the [callout here](#core/components/button.props) for more details.

</div>

@## Props interface

@interface TooltipProps

@## Combining with Popover

A single target can be wrapped in both a popover and a tooltip.

You must put the `<Tooltip>` _inside_ the `<Popover>` (and the target inside the `<Tooltip>`, so the hierarchy
is `Popover > Tooltip > target`). This order is required because the tooltip needs information from the popover to
disable itself when the popover is open, thus preventing both elements from appearing at the same time.

Also, you must take care to either set `<Popover shouldReturnFocusOnClose={false}>` or
`<Tooltip openOnTargetFocus={false}>` in this scenario in order to avoid undesirable UX where the tooltip could open
automatically when a user doesn't want it to.

```tsx
import { Button, mergeRefs, Popover, Tooltip } from "@blueprintjs/core";

<Popover
    content={<h1>Popover!</h1>}
    renderTarget={({ isOpen: isPopoverOpen, ref: ref1, ...popoverProps }) => (
        <Tooltip
            content="I have a popover!"
            disabled={isPopoverOpen}
            openOnTargetFocus={false}
            renderTarget={({ isOpen: isTooltipOpen, ref: ref2, ...tooltipProps }) => (
                <Button
                    {...popoverProps}
                    {...tooltipProps}
                    active={isPopoverOpen}
                    ref={mergeRefs(ref1, ref2)}
                    text="Hover and click me"
                />
            )}
        />
    )}
/>;
```

================================================================================

File: src\components\tooltip\tooltip.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { AbstractPureComponent, DISPLAYNAME_PREFIX, type IntentProps } from "../../common";
import * as Classes from "../../common/classes";
// eslint-disable-next-line import/no-cycle
import { Popover, type PopoverInteractionKind } from "../popover/popover";
import { TOOLTIP_ARROW_SVG_SIZE } from "../popover/popoverArrow";
import type { DefaultPopoverTargetHTMLProps, PopoverSharedProps } from "../popover/popoverSharedProps";
import { TooltipContext, type TooltipContextState, TooltipProvider } from "../popover/tooltipContext";

export interface TooltipProps<TProps extends DefaultPopoverTargetHTMLProps = DefaultPopoverTargetHTMLProps>
    extends Omit<PopoverSharedProps<TProps>, "shouldReturnFocusOnClose">,
        IntentProps {
    /**
     * The content that will be displayed inside of the tooltip.
     */
    content: React.JSX.Element | string;

    /**
     * Whether to use a compact appearance, which reduces the visual padding around
     * tooltip content.
     *
     * @default false
     */
    compact?: boolean;

    /**
     * The amount of time in milliseconds the tooltip should remain open after
     * the user hovers off the trigger. The timer is canceled if the user mouses
     * over the target before it expires.
     *
     * @default 0
     */
    hoverCloseDelay?: number;

    /**
     * The amount of time in milliseconds the tooltip should wait before opening
     * after the user hovers over the trigger. The timer is canceled if the user
     * mouses away from the target before it expires.
     *
     * @default 100
     */
    hoverOpenDelay?: number;

    /**
     * The kind of hover interaction that triggers the display of the tooltip.
     * Tooltips do not support click interactions.
     *
     * @default PopoverInteractionKind.HOVER_TARGET_ONLY
     */
    interactionKind?: typeof PopoverInteractionKind.HOVER | typeof PopoverInteractionKind.HOVER_TARGET_ONLY;

    /**
     * Indicates how long (in milliseconds) the tooltip's appear/disappear
     * transition takes. This is used by React `CSSTransition` to know when a
     * transition completes and must match the duration of the animation in CSS.
     * Only set this prop if you override Blueprint's default transitions with
     * new transitions of a different length.
     *
     * @default 100
     */
    transitionDuration?: number;
}

/**
 * Tooltip component.
 *
 * @see https://blueprintjs.com/docs/#core/components/tooltip
 */
export class Tooltip<
    T extends DefaultPopoverTargetHTMLProps = DefaultPopoverTargetHTMLProps,
> extends AbstractPureComponent<TooltipProps<T>> {
    public static displayName = `${DISPLAYNAME_PREFIX}.Tooltip`;

    public static defaultProps: Partial<TooltipProps> = {
        compact: false,
        hoverCloseDelay: 0,
        hoverOpenDelay: 100,
        interactionKind: "hover-target",
        minimal: false,
        transitionDuration: 100,
    };

    private popoverRef = React.createRef<Popover<T>>();

    public render() {
        // if we have an ancestor TooltipContext, we should take its state into account in this render path,
        // it was likely created by a parent ContextMenu
        return (
            <TooltipContext.Consumer>
                {([state]) => <TooltipProvider {...state}>{this.renderPopover}</TooltipProvider>}
            </TooltipContext.Consumer>
        );
    }

    public reposition() {
        this.popoverRef.current?.reposition();
    }

    // any descendant ContextMenus may update this ctxState
    private renderPopover = (ctxState: TooltipContextState) => {
        const { children, compact, disabled, intent, popoverClassName, ...restProps } = this.props;
        const popoverClasses = classNames(Classes.TOOLTIP, Classes.intentClass(intent), popoverClassName, {
            [Classes.COMPACT]: compact,
        });

        return (
            <Popover
                modifiers={{
                    arrow: {
                        enabled: !this.props.minimal,
                    },
                    offset: {
                        options: {
                            offset: [0, TOOLTIP_ARROW_SVG_SIZE / 2],
                        },
                    },
                }}
                {...restProps}
                autoFocus={false}
                canEscapeKeyClose={false}
                disabled={ctxState.forceDisabled ?? disabled}
                enforceFocus={false}
                lazy={true}
                popoverClassName={popoverClasses}
                portalContainer={this.props.portalContainer}
                ref={this.popoverRef}
            >
                {children}
            </Popover>
        );
    };
}

================================================================================

File: src\components\tooltip\_common.scss
--------------------------------------------------------------------------------
// Copyright 2021 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

$tooltip-background-color: $dark-gray5 !default;
$tooltip-text-color: $light-gray5 !default;

$dark-tooltip-background-color: $light-gray3 !default;
$dark-tooltip-text-color: $dark-gray5 !default;

$tooltip-padding-vertical: $pt-grid-size !default;
$tooltip-padding-horizontal: 1.2 * $pt-grid-size !default;

================================================================================

File: src\components\tooltip\_tooltip.scss
--------------------------------------------------------------------------------
// Copyright 2021 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "../../common/variables";
@import "../../common/typography-colors";
@import "../popover/common";
@import "./common";

$tooltip-arrow-box-shadow: 1px 1px 6px rgba($black, $pt-drop-shadow-opacity) !default;
$dark-tooltip-arrow-box-shadow: 1px 1px 6px rgba($black, $pt-dark-drop-shadow-opacity) !default;

$tooltip-padding-compact-vertical: 0.5 * $pt-grid-size !default;
$tooltip-padding-compact-horizontal: 0.7 * $pt-grid-size !default;

.#{$ns}-tooltip {
  @include popover-sizing(
    $arrow-square-size: 22px,
    $arrow-offset: 3px,
    $arrow-target-offset: -4px
  );
  @include popover-appearance(
    $tooltip-background-color,
    $tooltip-text-color,
    $pt-tooltip-box-shadow,
    $tooltip-arrow-box-shadow,
    $pt-border-shadow-opacity
  );
  // lightweight scale for tooltips
  @include react-transition(
    "#{$ns}-popover",
    (transform: scale(0.8) scale(1)),
    $duration: $pt-transition-duration,
    $after: "> &"
  );
  // override typography & icon colors because we use a dark background
  @include pt-dark-typography-colors();

  .#{$ns}-popover-content {
    padding: $tooltip-padding-vertical $tooltip-padding-horizontal;
  }

  &.#{$ns}-compact {
    .#{$ns}-popover-content {
      line-height: 1rem; // ensure a consistent line height
      padding: $tooltip-padding-compact-vertical $tooltip-padding-compact-horizontal;
    }

    // Compact tooltip content is usually just a single line with default line-height, where the slight vertical
    // misalignment of <Code> spans inside text stands out more than it does elsewhere in the design system. We apply
    // a small typographic adjustment here to counteract this problem.
    // TODO(adahiya): consider applying this more broadly to fix the root problem...
    .#{$ns}-code {
      vertical-align: text-bottom;
    }
  }

  // need to adjust arrow placement a little bit for tooltips
  &.#{$ns}-popover-placement-top .#{$ns}-popover-arrow { transform: translateY(-3px); }
  &.#{$ns}-popover-placement-left .#{$ns}-popover-arrow { transform: translateX(-3px); }
  &.#{$ns}-popover-placement-bottom .#{$ns}-popover-arrow { transform: translateY(3px); }
  &.#{$ns}-popover-placement-right .#{$ns}-popover-arrow { transform: translateX(3px); }

  &.#{$ns}-dark,
  .#{$ns}-dark & {
    @include popover-appearance(
      $dark-tooltip-background-color,
      $dark-tooltip-text-color,
      $pt-dark-tooltip-box-shadow,
      $dark-tooltip-arrow-box-shadow,
      $pt-dark-border-shadow-opacity
    );
    // override typography because we use a light background
    @include pt-typography-colors();
  }

  @each $intent, $color in $pt-intent-colors {
    &.#{$ns}-intent-#{$intent} {
      .#{$ns}-popover-content {
        background: $color;
        color: $white;
      }

      .#{$ns}-popover-arrow-fill {
        fill: $color;

        @media (forced-colors: active) and (prefers-color-scheme: dark) {
          // In Windows high contrast mode, just force the color to be the same as the border.
          fill: $pt-high-contrast-mode-border-color;
        }
      }
    }
  }
}

.#{$ns}-tooltip-indicator {
  border-bottom: dotted 1px;
  cursor: help;
}

================================================================================

File: src\components\tree\tree.md
--------------------------------------------------------------------------------
@# Tree

__Trees__ display hierarchical data.

@reactExample TreeExample

@## Props interface

__Tree__ is a stateless component. Its contents are dictated by the `contents` prop, which is an array of `<TreeNode>`
elements (see [below](#components/tree.tree-node)). The tree is multi-rooted if `contents` contains more than one
top-level object.

A variety of interaction callbacks are also exposed as props. All interaction callbacks supply a parameter `nodePath`,
which is an array of numbers representing a node's position in the tree. For example, `[2, 0]` represents the first
child (`0`) of the third top-level node (`2`).

@interface TreeProps

@### Instance methods

*   `Tree.getNodeContentElement(nodeId: string | number): HTMLElement | undefined` &ndash;
    Returns the underlying HTML element of the `Tree` node with an id of `nodeId`.
    This element does not contain the children of the node, only its label and controls.
    If the node is not currently mounted, `undefined` is returned.

@### Tree node

__TreeNode__ elements determine the contents, appearance, and state of each node in the tree.

For example, `icon` controls the icon displayed for the node, and `isExpanded` determines whether the node's children
are shown.

@interface TreeNodeProps

@## CSS API

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated API: use [`<Tree>`](#core/components/tree)

</h5>

CSS APIs for Blueprint components are considered deprecated, as they are verbose, error-prone, and they
often fall out of sync as the design system is updated. You should use the React component APIs instead.

</div>

@css tree

================================================================================

File: src\components\tree\tree.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { Classes, DISPLAYNAME_PREFIX, type Props } from "../../common";

import { TreeNode } from "./treeNode";
import type { TreeEventHandler, TreeNodeInfo } from "./treeTypes";

// eslint-disable-next-line @typescript-eslint/ban-types
export interface TreeProps<T = {}> extends Props {
    /**
     * Whether to use a compact appearance which reduces the visual padding around node content.
     */
    compact?: boolean;

    /**
     * The data specifying the contents and appearance of the tree.
     */
    contents: ReadonlyArray<TreeNodeInfo<T>>;

    /**
     * Invoked when a node is clicked anywhere other than the caret for expanding/collapsing the node.
     */
    onNodeClick?: TreeEventHandler<T>;

    /**
     * Invoked when caret of an expanded node is clicked.
     */
    onNodeCollapse?: TreeEventHandler<T>;

    /**
     * Invoked when a node is right-clicked or the context menu button is pressed on a focused node.
     */
    onNodeContextMenu?: TreeEventHandler<T>;

    /**
     * Invoked when a node is double-clicked. Be careful when using this in combination with
     * an `onNodeClick` (single-click) handler, as the way this behaves can vary between browsers.
     * See http://stackoverflow.com/q/5497073/3124288
     */
    onNodeDoubleClick?: TreeEventHandler<T>;

    /**
     * Invoked when the caret of a collapsed node is clicked.
     */
    onNodeExpand?: TreeEventHandler<T>;

    /**
     * Invoked when the mouse is moved over a node.
     */
    onNodeMouseEnter?: TreeEventHandler<T>;

    /**
     * Invoked when the mouse is moved out of a node.
     */
    onNodeMouseLeave?: TreeEventHandler<T>;
}

/**
 * Tree component.
 *
 * @see https://blueprintjs.com/docs/#core/components/tree
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export class Tree<T = {}> extends React.Component<TreeProps<T>> {
    public static displayName = `${DISPLAYNAME_PREFIX}.Tree`;

    public static ofType<U>() {
        return Tree as new (props: TreeProps<U>) => Tree<U>;
    }

    public static nodeFromPath<U>(
        path: readonly number[],
        treeNodes?: ReadonlyArray<TreeNodeInfo<U>>,
    ): TreeNodeInfo<U> {
        if (path.length === 1) {
            return treeNodes![path[0]];
        } else {
            return Tree.nodeFromPath(path.slice(1), treeNodes![path[0]].childNodes);
        }
    }

    private nodeRefs: { [nodeId: string]: HTMLElement } = {};

    public render() {
        return (
            <div
                className={classNames(Classes.TREE, this.props.className, {
                    [Classes.COMPACT]: this.props.compact,
                })}
            >
                {this.renderNodes(this.props.contents, [], Classes.TREE_ROOT)}
            </div>
        );
    }

    /**
     * Returns the underlying HTML element of the `Tree` node with an id of `nodeId`.
     * This element does not contain the children of the node, only its label and controls.
     * If the node is not currently mounted, `undefined` is returned.
     */
    public getNodeContentElement(nodeId: string | number): HTMLElement | undefined {
        return this.nodeRefs[nodeId];
    }

    private renderNodes(
        treeNodes: ReadonlyArray<TreeNodeInfo<T>> | undefined,
        currentPath?: number[],
        className?: string,
    ) {
        if (treeNodes == null) {
            return null;
        }

        const nodeItems = treeNodes.map((node, i) => {
            const elementPath = currentPath!.concat(i);
            return (
                <TreeNode<T>
                    {...node}
                    key={node.id}
                    contentRef={this.handleContentRef}
                    depth={elementPath.length - 1}
                    onClick={this.handleNodeClick}
                    onContextMenu={this.handleNodeContextMenu}
                    onCollapse={this.handleNodeCollapse}
                    onDoubleClick={this.handleNodeDoubleClick}
                    onExpand={this.handleNodeExpand}
                    onMouseEnter={this.handleNodeMouseEnter}
                    onMouseLeave={this.handleNodeMouseLeave}
                    path={elementPath}
                >
                    {this.renderNodes(node.childNodes, elementPath)}
                </TreeNode>
            );
        });

        return <ul className={classNames(Classes.TREE_NODE_LIST, className)}>{nodeItems}</ul>;
    }

    private handleContentRef = (node: TreeNodeInfo<T>, element: HTMLElement | null) => {
        if (element != null) {
            this.nodeRefs[node.id] = element;
        } else {
            // don't want our object to get bloated with old keys
            delete this.nodeRefs[node.id];
        }
    };

    private handleNodeCollapse = (node: TreeNodeInfo<T>, path: number[], e: React.MouseEvent<HTMLElement>) => {
        this.props.onNodeCollapse?.(node, path, e);
    };

    private handleNodeClick = (node: TreeNodeInfo<T>, path: number[], e: React.MouseEvent<HTMLElement>) => {
        this.props.onNodeClick?.(node, path, e);
    };

    private handleNodeContextMenu = (node: TreeNodeInfo<T>, path: number[], e: React.MouseEvent<HTMLElement>) => {
        this.props.onNodeContextMenu?.(node, path, e);
    };

    private handleNodeDoubleClick = (node: TreeNodeInfo<T>, path: number[], e: React.MouseEvent<HTMLElement>) => {
        this.props.onNodeDoubleClick?.(node, path, e);
    };

    private handleNodeExpand = (node: TreeNodeInfo<T>, path: number[], e: React.MouseEvent<HTMLElement>) => {
        this.props.onNodeExpand?.(node, path, e);
    };

    private handleNodeMouseEnter = (node: TreeNodeInfo<T>, path: number[], e: React.MouseEvent<HTMLElement>) => {
        this.props.onNodeMouseEnter?.(node, path, e);
    };

    private handleNodeMouseLeave = (node: TreeNodeInfo<T>, path: number[], e: React.MouseEvent<HTMLElement>) => {
        this.props.onNodeMouseLeave?.(node, path, e);
    };
}

================================================================================

File: src\components\tree\treeNode.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import classNames from "classnames";
import * as React from "react";

import { ChevronRight } from "@blueprintjs/icons";

import { Classes, DISPLAYNAME_PREFIX } from "../../common";
import { Collapse } from "../collapse/collapse";
import { Icon } from "../icon/icon";

import type { TreeEventHandler, TreeNodeInfo } from "./treeTypes";

// eslint-disable-next-line @typescript-eslint/ban-types
export interface TreeNodeProps<T = {}> extends TreeNodeInfo<T> {
    children?: React.ReactNode;
    contentRef?: (node: TreeNodeInfo<T>, element: HTMLDivElement | null) => void;
    depth: number;
    key?: string | number;
    onClick?: TreeEventHandler<T>;
    onCollapse?: TreeEventHandler<T>;
    onContextMenu?: TreeEventHandler<T>;
    onDoubleClick?: TreeEventHandler<T>;
    onExpand?: TreeEventHandler<T>;
    onMouseEnter?: TreeEventHandler<T>;
    onMouseLeave?: TreeEventHandler<T>;
    path: number[];
}

/**
 * Tree node component.
 *
 * @see https://blueprintjs.com/docs/#core/components/tree.tree-node
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export class TreeNode<T = {}> extends React.Component<TreeNodeProps<T>> {
    public static displayName = `${DISPLAYNAME_PREFIX}.TreeNode`;

    /** @deprecated no longer necessary now that the TypeScript parser supports type arguments on JSX element tags */
    public static ofType<U>() {
        return TreeNode as new (props: TreeNodeProps<U>) => TreeNode<U>;
    }

    public render() {
        const { children, className, disabled, icon, isExpanded, isSelected, label } = this.props;
        const classes = classNames(
            Classes.TREE_NODE,
            {
                [Classes.DISABLED]: disabled,
                [Classes.TREE_NODE_SELECTED]: isSelected,
                [Classes.TREE_NODE_EXPANDED]: isExpanded,
            },
            className,
        );

        const contentClasses = classNames(
            Classes.TREE_NODE_CONTENT,
            `${Classes.TREE_NODE_CONTENT}-${this.props.depth}`,
        );

        const eventHandlers =
            disabled === true
                ? {}
                : {
                      onClick: this.handleClick,
                      onContextMenu: this.handleContextMenu,
                      onDoubleClick: this.handleDoubleClick,
                      onMouseEnter: this.handleMouseEnter,
                      onMouseLeave: this.handleMouseLeave,
                  };

        return (
            <li className={classes}>
                <div className={contentClasses} ref={this.handleContentRef} {...eventHandlers}>
                    {this.maybeRenderCaret()}
                    <Icon className={Classes.TREE_NODE_ICON} icon={icon} aria-hidden={true} tabIndex={-1} />
                    <span className={Classes.TREE_NODE_LABEL}>{label}</span>
                    {this.maybeRenderSecondaryLabel()}
                </div>
                <Collapse isOpen={isExpanded}>{children}</Collapse>
            </li>
        );
    }

    private maybeRenderCaret() {
        const { children, isExpanded, disabled, hasCaret = React.Children.count(children) > 0 } = this.props;
        if (hasCaret) {
            const caretClasses = classNames(
                Classes.TREE_NODE_CARET,
                isExpanded ? Classes.TREE_NODE_CARET_OPEN : Classes.TREE_NODE_CARET_CLOSED,
            );
            return (
                <ChevronRight
                    title={isExpanded ? "Collapse group" : "Expand group"}
                    className={caretClasses}
                    onClick={disabled === true ? undefined : this.handleCaretClick}
                />
            );
        }
        return <span className={Classes.TREE_NODE_CARET_NONE} />;
    }

    private maybeRenderSecondaryLabel() {
        if (this.props.secondaryLabel != null) {
            return <span className={Classes.TREE_NODE_SECONDARY_LABEL}>{this.props.secondaryLabel}</span>;
        } else {
            return undefined;
        }
    }

    private handleCaretClick = (e: React.MouseEvent<HTMLElement>) => {
        e.stopPropagation();
        const { isExpanded, onCollapse, onExpand } = this.props;
        (isExpanded ? onCollapse : onExpand)?.(this.props, this.props.path, e);
    };

    private handleClick = (e: React.MouseEvent<HTMLDivElement>) => {
        this.props.onClick?.(this.props, this.props.path, e);
    };

    private handleContentRef = (element: HTMLDivElement | null) => {
        this.props.contentRef?.(this.props, element);
    };

    private handleContextMenu = (e: React.MouseEvent<HTMLDivElement>) => {
        this.props.onContextMenu?.(this.props, this.props.path, e);
    };

    private handleDoubleClick = (e: React.MouseEvent<HTMLDivElement>) => {
        this.props.onDoubleClick?.(this.props, this.props.path, e);
    };

    private handleMouseEnter = (e: React.MouseEvent<HTMLDivElement>) => {
        this.props.onMouseEnter?.(this.props, this.props.path, e);
    };

    private handleMouseLeave = (e: React.MouseEvent<HTMLDivElement>) => {
        this.props.onMouseLeave?.(this.props, this.props.path, e);
    };
}

================================================================================

File: src\components\tree\treeTypes.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { MaybeElement } from "../../common/props";
import type { IconName } from "../icon/icon";

// eslint-disable-next-line @typescript-eslint/ban-types
export interface TreeNodeInfo<T = {}> {
    /**
     * A space-delimited list of class names for this tree node element.
     */
    className?: string;

    /**
     * Child tree nodes of this node.
     */
    childNodes?: Array<TreeNodeInfo<T>>;

    /**
     * Whether this tree node is non-interactive. Enabling this prop will ignore
     * mouse event handlers (in particular click, down, enter, leave).
     */
    disabled?: boolean;

    /**
     * Whether the caret to expand/collapse a node should be shown.
     * If not specified, this will be true if the node has children and false otherwise.
     */
    hasCaret?: boolean;

    /**
     * The name of a Blueprint icon (or an icon element) to render next to the node's label.
     */
    icon?: IconName | MaybeElement;

    /**
     * A unique identifier for the node.
     */
    id: string | number;

    /**
     */
    isExpanded?: boolean;

    /**
     * Whether this node is selected.
     *
     * @default false
     */
    isSelected?: boolean;

    /**
     * The main label for the node.
     */
    label: string | React.JSX.Element;

    /**
     * A secondary label/component that is displayed at the right side of the node.
     */
    secondaryLabel?: string | MaybeElement;

    /**
     * An optional custom user object to associate with the node.
     * This property can then be used in the `onClick`, `onContextMenu` and `onDoubleClick`
     * event handlers for doing custom logic per node.
     */
    nodeData?: T;
}

// eslint-disable-next-line @typescript-eslint/ban-types
export type TreeEventHandler<T = {}> = (
    node: TreeNodeInfo<T>,
    nodePath: number[],
    e: React.MouseEvent<HTMLElement>,
) => void;

================================================================================

File: src\components\tree\_tree.scss
--------------------------------------------------------------------------------
// Copyright 2015 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "@blueprintjs/icons/lib/scss/variables";
@import "../../common/variables";
@import "../../common/variables-extended";
@import "../../common/mixins";

/*
Trees

Markup:
<div class="#{$ns}-tree #{$ns}-elevation-0">
  <ul class="#{$ns}-tree-node-list #{$ns}-tree-root">
    <li class="#{$ns}-tree-node #{$ns}-tree-node-expanded">
      <div class="#{$ns}-tree-node-content">
        <span class="#{$ns}-tree-node-caret #{$ns}-tree-node-caret-open #{$ns}-icon-standard"></span>
        <span class="#{$ns}-tree-node-icon #{$ns}-icon-standard #{$ns}-icon-folder-close"></span>
        <span class="#{$ns}-tree-node-label">Label</span>
        <span class="#{$ns}-tree-node-secondary-label">Secondary label</span>
      </div>
      <ul class="#{$ns}-tree-node-list">
        <li class="#{$ns}-tree-node">
          <div class="#{$ns}-tree-node-content">
            <span class="#{$ns}-tree-node-caret-none #{$ns}-icon-standard"></span>
            <span class="#{$ns}-tree-node-icon #{$ns}-icon-standard #{$ns}-icon-document"></span>
          <span class="#{$ns}-tree-node-label">A Document</span>
          </div>
        </li>
        <li class="#{$ns}-tree-node">
          <div class="#{$ns}-tree-node-content">
            <span class="#{$ns}-tree-node-caret-none #{$ns}-icon-standard"></span>
            <span class="#{$ns}-tree-node-icon #{$ns}-icon-standard #{$ns}-icon-document"></span>
            <span class="#{$ns}-tree-node-label">Another Document</span>
          </div>
        </li>
      </ul>
    </li>
  </ul>
</div>

Styleguide tree
*/

$tree-row-height: $pt-grid-size * 3 !default;
$tree-icon-spacing: ($tree-row-height - $pt-icon-size-standard) * 0.5 !default;

$tree-row-height-compact: 24px !default;
$tree-icon-spacing-compact: ($tree-row-height-compact - $pt-icon-size-standard) * 0.5 !default;

$tree-intent-icon-colors: (
  "primary": $blue5,
  "success": $green5,
  "warning": $orange5,
  "danger" : $red5,
) !default;

.#{$ns}-tree {
  #{$icon-classes} {
    color: $pt-icon-color;

    @each $intent, $colors in $pt-intent-colors {
      &.#{$ns}-intent-#{$intent} {
        @include intent-color($intent);
      }
    }
  }
}

.#{$ns}-tree-node-list {
  list-style: none;
  margin: 0;
  padding-left: 0;
}

.#{$ns}-tree-root {
  background-color: transparent;
  cursor: default;
  padding-left: 0;
  // lets us position hover/selection effects based on the width of the whole tree
  position: relative;
}

@for $i from 0 through 20 {
  .#{$ns}-tree-node-content-#{$i} {
    padding-left: ($tree-row-height - $tree-icon-spacing) * $i;
  }
}

.#{$ns}-tree-node-content {
  align-items: center;
  background: none;
  display: flex;
  height: $tree-row-height;
  padding-right: $pt-grid-size * 0.5;
  width: 100%;

  &:hover {
    background-color: rgba($gray3, 0.15);
  }

  &:active {
    background-color: rgba($gray3, 0.3);
  }
}

.#{$ns}-tree-node-caret,
.#{$ns}-tree-node-caret-none {
  min-width: $tree-row-height;
}

.#{$ns}-tree-node-caret {
  @include pt-icon-colors();
  cursor: pointer;
  padding: $tree-icon-spacing;
  transform: rotate(0deg);
  transition: transform ($pt-transition-duration * 2) $pt-transition-ease;

  &:hover {
    color: $pt-text-color;
  }

  &.#{$ns}-tree-node-caret-open {
    transform: rotate(90deg);
  }

  // CSS API support
  &.#{$ns}-icon-standard::before {
    content: map-get($blueprint-icon-codepoints, "chevron-right");
  }
}

.#{$ns}-tree-node-icon {
  margin-right: $tree-icon-spacing;
  position: relative;
}

.#{$ns}-tree-node-label {
  @include overflow-ellipsis();
  flex: 1 1 auto;
  position: relative;
  user-select: none;

  span {
    // prevents spans from interfering with text overflows (e.g. when Tooltips are used in labels)
    display: inline;
  }
}

.#{$ns}-tree-node-secondary-label {
  padding: 0 ($pt-grid-size * 0.5);
  user-select: none;

  .#{$ns}-popover-wrapper,
  .#{$ns}-popover-target {
    align-items: center;
    display: flex;
  }
}

.#{$ns}-tree-node.#{$ns}-disabled {
  .#{$ns}-tree-node-content {
    background-color: inherit;
    color: $pt-text-color-disabled;
    cursor: not-allowed;
  }

  .#{$ns}-tree-node-caret,
  .#{$ns}-tree-node-icon {
    color: $pt-text-color-disabled;
    cursor: not-allowed;
  }
}

.#{$ns}-tree-node.#{$ns}-tree-node-selected > .#{$ns}-tree-node-content {
  background-color: $pt-intent-primary;

  &,
  #{$icon-classes} {
    color: $white;
  }

  .#{$ns}-tree-node-caret {
    &::before {
      color: rgba($white, 0.7);
    }

    &:hover::before {
      color: $white;
    }
  }
}

// Variant: compact
.#{$ns}-tree.#{$ns}-compact {
  .#{$ns}-tree-node-content {
    height: $tree-row-height-compact;
  }

  .#{$ns}-tree-node-caret {
    margin-right: 3px;
    min-width: $tree-row-height-compact;
    padding: $tree-icon-spacing-compact;
  }
}

// Variant: dark theme
.#{$ns}-dark {
  .#{$ns}-tree-node-content {
    &:hover {
      background-color: rgba($gray1, 0.3);
    }
  }

  .#{$ns}-tree {
    #{$icon-classes} {
      color: $pt-dark-icon-color;

      @each $intent, $color in $tree-intent-icon-colors {
        &.#{$ns}-intent-#{$intent} {
          color: $color;
        }
      }
    }
  }

  .#{$ns}-tree-node {
    &:not(.#{$ns}-disabled) {
      .#{$ns}-tree-node-caret:hover {
        color: $pt-dark-text-color;
      }
    }

    &.#{$ns}-tree-node-selected > .#{$ns}-tree-node-content {
      background-color: $pt-intent-primary;

      #{$icon-classes} {
        color: $white;
      }
    }
  }
}

================================================================================

File: src\context\blueprint-provider.md
--------------------------------------------------------------------------------
---
tag: new
---

@# BlueprintProvider

**BlueprintProvider** is a compound [React context](https://react.dev/learn/passing-data-deeply-with-context)
provider which enables & manages various global behaviors of Blueprint applications. It must be rendered
at the root of your application and may only be used once as a singleton provider.

Concretely, this provider renders the following provider components _in the correct nesting order_
and allows customization of their options via props:

-   [**OverlaysProvider**](#core/context/overlays-provider)
-   [**HotkeysProvider**](#core/context/hotkeys-provider)
-   [**PortalProvider**](#core/context/portal-provider)

## Usage

To use **BlueprintProvider**, wrap your application with it at the root level:

```tsx
import { BlueprintProvider } from "@blueprintjs/core";
import * as React from "react";
import * as ReactDOM from "react-dom";

ReactDOM.render(
    <BlueprintProvider>
        <div>My app has overlays, hotkeys, and portal customization 😎</div>
    </BlueprintProvider>,
    document.querySelector("#app"),
);
```

## Props interface

@interface BlueprintProviderProps

================================================================================

File: src\context\blueprintProvider.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

import { HotkeysProvider, type HotkeysProviderProps } from "./hotkeys/hotkeysProvider";
import { OverlaysProvider, type OverlaysProviderProps } from "./overlays/overlaysProvider";
import { type PortalContextOptions, PortalProvider } from "./portal/portalProvider";

// for some props interfaces, it helps to prefix their property names with the name of the provider
// to avoid any ambiguity in the API
type HotkeysProviderPrefix<T> = {
    [Property in keyof T as `hotkeysProvider${Capitalize<string & Property>}`]: T[Property];
};

export interface BlueprintProviderProps
    extends OverlaysProviderProps,
        PortalContextOptions,
        HotkeysProviderPrefix<HotkeysProviderProps> {
    // no props of its own, `children` comes from `OverlaysProviderProps`
}

/**
 * Composite Blueprint context provider which enables & manages various global behaviors of Blueprint applications.
 *
 * @see https://blueprintjs.com/docs/#core/context/blueprint-provider
 */
export const BlueprintProvider = ({ children, hotkeysProviderValue, ...props }: BlueprintProviderProps) => {
    return (
        <PortalProvider {...props}>
            <OverlaysProvider>
                <HotkeysProvider value={hotkeysProviderValue} {...props}>
                    {children}
                </HotkeysProvider>
            </OverlaysProvider>
        </PortalProvider>
    );
};

================================================================================

File: src\context\context.md
--------------------------------------------------------------------------------
@# Context

<!-- Exact ordering of items in the navbar: -->

@page blueprint-provider
@page hotkeys-provider
@page overlays-provider
@page portal-provider

================================================================================

File: src\context\index.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { BlueprintProvider, type BlueprintProviderProps } from "./blueprintProvider";
export {
    HotkeysContext,
    type HotkeysContextInstance,
    HotkeysProvider,
    type HotkeysProviderProps,
} from "./hotkeys/hotkeysProvider";
export {
    OverlaysContext,
    OverlaysProvider,
    type OverlaysContextState,
    type OverlaysProviderProps,
} from "./overlays/overlaysProvider";
export { PortalContext, type PortalContextOptions, PortalProvider } from "./portal/portalProvider";

================================================================================

File: src\context\hotkeys\hotkeys-provider.md
--------------------------------------------------------------------------------
@# HotkeysProvider

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Migrating from [**HotkeysTarget**](#core/legacy/hotkeys-legacy)?

</h5>

**HotkeysProvider** and `useHotkeys`, used together, are a replacement for **HotkeysTarget**.
You are encouraged to use this new API, as it will become the standard APIs in a future major version of Blueprint.
See the full [migration guide](https://github.com/palantir/blueprint/wiki/HotkeysTarget-&-useHotkeys-migration)
on the wiki.

</div>

**HotkeysProvider** generates a React context necessary for the [`useHotkeys` hook](#core/hooks/use-hotkeys)
to maintain state for the globally-accessible hotkeys dialog. As your application runs and components
are mounted/unmounted, global and local hotkeys are registered/unregistered with this context and
the dialog displays/hides the relevant information. You can try it out in the Blueprint docs app
by navigating around and triggering the dialog with the <kbd>?</kbd> key.

@## Usage

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Consider [**BlueprintProvider**](#core/context/blueprint-provider)

</h5>

**BlueprintProvider** is a new composite React context provider for Blueprint applications which
enables & configures multiple providers automatically and is simpler to use than individual lower-level providers.

</div>

To use **HotkeysProvider**, wrap your application with it at the root level:

```tsx
import { HotkeysProvider } from "@blueprintjs/core";
import * as React from "react";
import * as ReactDOM from "react-dom";

ReactDOM.render(
    <HotkeysProvider>
        <div>My app has hotkeys 😎</div>
    </HotkeysProvider>,
    document.querySelector("#app"),
);
```

@## Advanced usage

**HotkeysProvider** should not be nested, except in special cases. If you have a rendering boundary within your application
through which React context is not preserved (for example, a plugin system which uses `ReactDOM.render()`) and you wish
to use hotkeys in a descendant part of the tree below such a boundary, you may render a descendant provider and initialize
it with the root context instance. This ensures that there will only be one "global" hotkeys dialogs in an application
which has multiple **HotkeysProviders**.

```tsx
import { HotkeyConfig, HotkeysContext, HotkeysProvider, HotkeysTarget2 } from "@blueprintjs/core";
import React, { useContext, useEffect, useRef } from "react";
import * as ReactDOM from "react-dom";

function App() {
    const appHotkeys: HotkeyConfig[] = [
        {
            combo: "o",
            global: true,
            label: "Open",
            onKeyDown: () => console.info("open"),
        },
    ];

    return (
        <HotkeysProvider>
            <div>
                <HotkeysTarget2 hotkeys={appHotkeys}>
                    <div>My app has hotkeys 😎</div>
                </HotkeysTarget2>
                <PluginSlot>
                    <Plugin />
                </PluginSlot>
            </div>
        </HotkeysProvider>
    );
}

function Plugin() {
    const pluginHotkeys: HotkeyConfig[] = [
        {
            combo: "f",
            global: true,
            label: "Search",
            onKeyDown: () => console.info("search"),
        },
    ];

    return (
        <HotkeysTarget2 hotkeys={pluginHotkeys}>
            <div>This plugin also has hotkeys</div>
        </HotkeysTarget2>
    );
}

function PluginSlot(props) {
    const hotkeysContext = useContext(HotkeysContext);
    const ref = useRef<HTMLDivElement>();

    useEffect(() => {
        if (ref.current != null) {
            ReactDOM.render(<HotkeysProvider value={hotkeysContext}>{props.children}</HotkeysProvider>, ref.current);
        }
    }, [ref, hotkeysContext, props.children]);

    return <div ref={ref} />;
}
```

@## Props interface

@interface HotkeysProviderProps

================================================================================

File: src\context\hotkeys\hotkeysProvider.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

import { shallowCompareKeys } from "../../common/utils";
import { HotkeysDialog2, type HotkeysDialogProps } from "../../components/hotkeys/hotkeysDialog2";
import type { HotkeyConfig } from "../../hooks";

interface HotkeysContextState {
    /**
     * Whether the context instance is being used within a tree which has a <HotkeysProvider>.
     * It's technically ok if this is false, but not recommended, since that means any hotkeys
     * bound with that context instance will not show up in the hotkeys help dialog.
     */
    hasProvider: boolean;

    /** List of hotkeys accessible in the current scope, registered by currently mounted components, can be global or local. */
    hotkeys: HotkeyConfig[];

    /** Whether the global hotkeys dialog is open. */
    isDialogOpen: boolean;
}

type HotkeysAction =
    | { type: "ADD_HOTKEYS" | "REMOVE_HOTKEYS"; payload: HotkeyConfig[] }
    | { type: "CLOSE_DIALOG" | "OPEN_DIALOG" };

export type HotkeysContextInstance = readonly [HotkeysContextState, React.Dispatch<HotkeysAction>];

const initialHotkeysState: HotkeysContextState = { hasProvider: false, hotkeys: [], isDialogOpen: false };
const noOpDispatch: React.Dispatch<HotkeysAction> = () => null;

/**
 * A React context used to register and deregister hotkeys as components are mounted and unmounted in an application.
 * Users should take care to make sure that only _one_ of these is instantiated and used within an application, especially
 * if using global hotkeys.
 *
 * You will likely not be using this HotkeysContext directly, except in cases where you need to get a direct handle on an
 * existing context instance for advanced use cases involving nested HotkeysProviders.
 *
 * For more information, see the [HotkeysProvider documentation](https://blueprintjs.com/docs/#core/context/hotkeys-provider).
 */
export const HotkeysContext = React.createContext<HotkeysContextInstance>([initialHotkeysState, noOpDispatch]);

const hotkeysReducer = (state: HotkeysContextState, action: HotkeysAction) => {
    switch (action.type) {
        case "ADD_HOTKEYS":
            // only pick up unique hotkeys which haven't been registered already
            const newUniqueHotkeys = [];
            for (const a of action.payload) {
                let isUnique = true;
                for (const b of state.hotkeys) {
                    isUnique &&= !shallowCompareKeys(a, b, { exclude: ["onKeyDown", "onKeyUp"] });
                }
                if (isUnique) {
                    newUniqueHotkeys.push(a);
                }
            }
            return {
                ...state,
                hotkeys: [...state.hotkeys, ...newUniqueHotkeys],
            };
        case "REMOVE_HOTKEYS":
            return {
                ...state,
                hotkeys: state.hotkeys.filter(key => action.payload.indexOf(key) === -1),
            };
        case "OPEN_DIALOG":
            return { ...state, isDialogOpen: true };
        case "CLOSE_DIALOG":
            return { ...state, isDialogOpen: false };
        default:
            return state;
    }
};

export interface HotkeysProviderProps {
    /** Optional props to customize the rendered hotkeys dialog. */
    dialogProps?: Partial<Omit<HotkeysDialogProps, "hotkeys">>;

    /** If provided, this dialog render function will be used in place of the default implementation. */
    renderDialog?: (state: HotkeysContextState, contextActions: { handleDialogClose: () => void }) => React.JSX.Element;

    /** If provided, we will use this context instance instead of generating our own. */
    value?: HotkeysContextInstance;
}

/**
 * Hotkeys context provider, necessary for the `useHotkeys` hook.
 *
 * @see https://blueprintjs.com/docs/#core/context/hotkeys-provider
 */
export const HotkeysProvider = ({
    children,
    dialogProps,
    renderDialog,
    value,
}: React.PropsWithChildren<HotkeysProviderProps>) => {
    const hasExistingContext = value != null;
    const fallbackReducer = React.useReducer(hotkeysReducer, { ...initialHotkeysState, hasProvider: true });
    const [state, dispatch] = value ?? fallbackReducer;
    // The `useState` array isn't stable between renders -- so memo it outselves
    const contextValue = React.useMemo(() => [state, dispatch] as const, [state, dispatch]);
    const handleDialogClose = React.useCallback(() => dispatch({ type: "CLOSE_DIALOG" }), [dispatch]);

    const dialog = renderDialog?.(state, { handleDialogClose }) ?? (
        <HotkeysDialog2
            {...dialogProps}
            isOpen={state.isDialogOpen}
            hotkeys={state.hotkeys}
            onClose={handleDialogClose}
        />
    );

    // if we are working with an existing context, we don't need to generate our own dialog
    return (
        <HotkeysContext.Provider value={contextValue}>
            {children}
            {hasExistingContext ? undefined : dialog}
        </HotkeysContext.Provider>
    );
};

================================================================================

File: src\context\overlays\overlays-provider.md
--------------------------------------------------------------------------------
---
tag: new
---

@# OverlaysProvider

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Migrating from [Overlay](#core/components/overlay)?

</h5>

**OverlaysProvider** and [**Overlay2**](#core/components/overlay2), when used
together, are a replacement for **Overlay**. You are encouraged to use these new APIs, as they will
become the standard in a future major version of Blueprint. See the full
[migration guide](https://github.com/palantir/blueprint/wiki/Overlay2-migration) on the wiki.

</div>

**OverlaysProvider** is responsible for managing global overlay state in an application,
specifically the stack of all overlays which are currently open. It provides the necessary
[React context](https://react.dev/learn/passing-data-deeply-with-context) for the
[**Overlay2** component](#core/components/overlay2).

## Usage

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Consider [**BlueprintProvider**](#core/context/blueprint-provider)

</h5>

**BlueprintProvider** is a new composite React context provider for Blueprint applications which
enables & configures multiple providers automatically and is simpler to use than individual lower-level providers.

</div>

To use **OverlaysProvider**, wrap your application with it at the root level:

```tsx
import { OverlaysProvider } from "@blueprintjs/core";
import * as React from "react";
import * as ReactDOM from "react-dom";

ReactDOM.render(
    <OverlaysProvider>
        <div>My app has overlays 😎</div>
    </OverlaysProvider>,
    document.querySelector("#app"),
);
```

@## Props interface

**OverlaysProvider** has no props other than `children`.

================================================================================

File: src\context\overlays\overlaysProvider.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

import type { OverlayInstance } from "../../components/overlay2/overlayInstance";

// N.B. using a mutable ref for the stack is much easier to work with in the world of hooks and FCs.
// This matches the mutable global behavior of the old Overlay implementation in Blueprint v5. An alternative
// approach was considered with an immutable array data structure and a reducer, but that implementation
// caused lots of unnecessary invalidation of `React.useCallback()` for document-level event handlers, which
// led to memory leaks and bugs.
export interface OverlaysContextState {
    /**
     * Whether the context instance is being used within a tree which has an `<OverlaysProvider>`.
     * `useOverlayStack()` will work if this is `false` in Blueprint v5, but this will be unsupported
     * in Blueprint v6; all applications with overlays will be required to configure a provider to
     * manage global overlay state.
     *
     * @see https://github.com/palantir/blueprint/wiki/Overlay2-migration
     */
    hasProvider: boolean;

    /**
     * The application-wide global overlay stack.
     */
    stack: React.MutableRefObject<OverlayInstance[]>;
}

/**
 * A React context used to interact with the overlay stack in an application.
 * Users should take care to make sure that only _one_ of these is instantiated and used within an
 * application.
 *
 * You will likely not be using this OverlaysContext directly, it's mostly used internally by the
 * Overlay2 component.
 *
 * For more information, see the [OverlaysProvider documentation](https://blueprintjs.com/docs/#core/context/overlays-provider).
 */
export const OverlaysContext = React.createContext<OverlaysContextState>({
    hasProvider: false,
    stack: { current: [] },
});

export interface OverlaysProviderProps {
    /** The component subtree which will have access to this overlay stack context. */
    children: React.ReactNode;
}

/**
 * Overlays context provider, necessary for the `useOverlayStack` hook.
 *
 * @see https://blueprintjs.com/docs/#core/context/overlays-provider
 */
export const OverlaysProvider = ({ children }: OverlaysProviderProps) => {
    const stack = React.useRef<OverlayInstance[]>([]);
    const contextValue = React.useMemo(() => ({ hasProvider: true, stack }), [stack]);
    return <OverlaysContext.Provider value={contextValue}>{children}</OverlaysContext.Provider>;
};

================================================================================

File: src\context\portal\portal-provider.md
--------------------------------------------------------------------------------
---
tag: new
---

@# PortalProvider

PortalProvider generates a React context necessary for customizing global [Portal](#core/components/portal)
options. It uses the [React context API](https://reactjs.org/docs/context.html).

@## Usage

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Consider [**BlueprintProvider**](#core/context/blueprint-provider)

</h5>

**BlueprintProvider** is a new composite React context provider for Blueprint applications which
enables & configures multiple providers automatically and is simpler to use than individual lower-level providers.

</div>

To use **PortalProvider**, wrap your application with it at the root level:

```tsx
import { PortalProvider, Dialog } from "@blueprintjs/core";
import * as React from "react";
import * as ReactDOM from "react-dom";

ReactDOM.render(
    <PortalProvider portalClassName="my-portal">
        <Dialog isOpen={true}>
            <span>This dialog will have a custom class on its portal element.</span>
        </Dialog>
    </PortalProvider>,
    document.querySelector("#app"),
);
```

@## Props interface

@interface PortalContextOptions

================================================================================

File: src\context\portal\portalProvider.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2022 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

export interface PortalContextOptions {
    /** Additional CSS classes to add to all `Portal` elements in this React context. */
    portalClassName?: string;
    /** The HTML element that all `Portal` elements in this React context will be added as children to  */
    portalContainer?: HTMLElement;
}

/**
 * A React context to set options for all portals in a given subtree.
 * Do not use this PortalContext directly, instead use PortalProvider to set the options.
 */
export const PortalContext = React.createContext<PortalContextOptions>({});

/**
 * Portal context provider.
 *
 * @see https://blueprintjs.com/docs/#core/context/portal-provider
 */
export const PortalProvider = ({
    children,
    portalClassName,
    portalContainer,
}: React.PropsWithChildren<PortalContextOptions>) => {
    const contextOptions = React.useMemo<PortalContextOptions>(
        () => ({
            portalClassName,
            portalContainer,
        }),
        [portalClassName, portalContainer],
    );
    return <PortalContext.Provider value={contextOptions}>{children}</PortalContext.Provider>;
};

================================================================================

File: src\docs\accessibility.md
--------------------------------------------------------------------------------
@# Accessibility

Blueprint strives to provide accessible components out of the box. Many of the JS components
will apply accessible HTML attributes to support different modes of usage.

@## Focus management

Focus states (that glowy blue outline around the active element) are essential for keyboard
navigation to indicate which element is currently active. They are less important, and
occasionally outright intrusive, when using a mouse because you can click wherever you want at
any time.

Blueprint includes a utility that manages the appearance of focus styles. When enabled, focus styles
will be hidden while the user interacts using the mouse and will appear when the
<kbd>tab</kbd> key is pressed to begin keyboard navigation. Try this out for yourself
below.

**You must explictly enable this feature in your app (and you probably want to):**

```ts
import { FocusStyleManager } from "@blueprintjs/core";

FocusStyleManager.onlyShowFocusOnTabs();
```

Note that the focus style for text inputs (a slightly thicker colored border) is not removed by this
utility because it is always useful to know where you're typing.

@reactExample FocusExample

@### JavaScript API

This behavior is controlled by a singleton instance called `FocusStyleManager` that lives in the
__@blueprintjs/core__ package. It supports the following public methods:

- `FocusStyleManager.isActive(): boolean`: Returns whether the `FocusStyleManager` is currently running.
- `FocusStyleManager.onlyShowFocusOnTabs(): void`: Enable behavior which hides focus styles during mouse interaction.
- `FocusStyleManager.alwaysShowFocus(): void`: Stop this behavior (focus styles are always visible).

@### Selectively ignoring the focus style manager

There is an escape hatch to allow components to ignore the focus style manager. This
can be useful when you do want to always show the focus outline, but only for certain
components, like a tree. This is done by applying `Classes.FOCUS_STYLE_MANAGER_IGNORE`
to a container element.

```tsx
import { Classes } from "@blueprintjs/core";

const MyComponent = () => ({
    <div classname={Classes.FOCUS_STYLE_MANAGER_IGNORE}>
        // Any components here will always show the focus outline when clicked.
    </div>
})
```


@## Color contrast

Colors have been designed to be accessible to as many people as possible, even those who are
visually impaired or experiencing any kind of colorblindness. Our colors have not only been chosen
to go well together, but to also adhere to [WCAG 2.0](https://www.w3.org/TR/WCAG20/) standards.

@### Focus indication contrast
Focus indication states generally adhere to
[WCAG 2.2 focus appearance](https://www.w3.org/WAI/WCAG22/Understanding/focus-appearance.html).
Default focus indication states should support a minimum 3:1 contrast ratio on
[background colors](#core/colors) up to `$light-gray1` in light theme, and `$dark-gray5` in dark theme.

Components that appear with an `intent` outline, such as [`InputGroup`](#core/components/input-group),
[`EditableText`](#core/components/editable-text), [`NumericInput`](#core/components/numeric-input), and other
similarly styled components have some exceptions to this rule. In light theme, all intents support a minimum contrast
ratio of 3:1 for the full range of background colors up to `$light-gray1`, besides `"warning"`,
which supports a 3:1 contrast ratio up to `$light-gray4`.
In dark theme, all intents support a minimum contrast ratio of 3:1 up to `$dark-gray4`, expect for `"warning"`,
which supports the full range of background colors up to `$dark-gray5`.

================================================================================

File: src\docs\classes.md
--------------------------------------------------------------------------------
@# Classes

Blueprint packages provide React components in JS files and associated styles in
a CSS file. Each package exports a `Classes` constants object in JavaScript that
contains keys of the form `NAMED_CONSTANT` for every CSS class used. This
separation allows us to change CSS classes between versions without breaking
downstream users (although in practice this happens very rarely).

**Avoid referencing hardcoded Blueprint class names in your JS or CSS code.**

```tsx
// Don't do this! Avoid hardcoding Blueprint class names.
<button className="@ns-button @ns-large">Don't do this!</button>
```

The **best practice** is to add your own class to an element and then reference
that class whenever needed.

```tsx
<Button className="my-custom-class" text="customized button" />
```

```scss
.my-custom-class {
    width: 4000px;
}
```

In cases where adding and styling a new class is impractical or undesirable, use
the `Classes` constants or `$ns` Sass/Less variable. The `Classes` constants can
be particularly useful when writing UI tests.

```tsx
// use Classes constants for forward-compatible custom elements.
import { Classes } from "@blueprintjs/core";
<a className={Classes.MENU_ITEM}>custom menu item</a>;
```

```scss
// interpolate the $ns variable to generate forward-compatible class names.
// this approach is *not encouraged* as it increases maintenance cost.
@import "@blueprintjs/core/lib/scss/variables";
.#{$ns}-menu-item {
}
```

@## Modifiers

Blueprint components support a range of **modifiers** to adjust their
appearance. Some commonly used modifiers are `intent`, `large`, and `minimal`.
While modifiers are typically implemented as simple CSS classes, it is always
preferrable to use the corresponding prop on a React component.

```tsx
// Prefer props over modifier classes.
<Button intent="primary" minimal={true}>Good stuff</Button>

// Don't do this!
<Button className={classNames(Classes.INTENT_PRIMARY, Classes.MINIMAL)}>Don't do this!</Button>
```

Another important note: Since modifiers typically correspond directly to CSS classes, they will often
cascade to children and _cannot be disabled_ on descendants. If a `<ButtonGroup>`
is marked `minimal={true}`, then setting `<Button minimal={false}>` on a child
will have _no effect_ since `Classes.MINIMAL` cannot be removed or overriden
by a descendant.

@## Namespacing

All Blueprint CSS classes begin with a namespace prefix to isolate our styles
from other frameworks: `.button` is a very common name, but only Blueprint
defines `.@ns-button`.

This CSS namespace is versioned by major version of the library so two major versions of Blueprint
can be used together on a single page.

### Custom namespace

The CSS namespace can be changed _at build time_ to produce a custom Blueprint build.
With this approach, you will import Blueprint's Sass sources from `/lib/scss/` instead of the CSS files from the
`/lib/css/` folders.

You must use [Dart Sass](https://sass-lang.com/dart-sass) and set up a few important bits of build configuration:

1. Sass `loadPaths` must include the `node_modules` folder where `@blueprintjs` packages are installed
1. A custom function implementation for `svg-icon()` must be defined
1. You must copy the [resources/icons folder](https://github.com/palantir/blueprint/tree/develop/resources/icons) from
    the Blueprint repo into your project (in the future, this may not be required once Blueprint starts publishing
    these SVG files in a public NPM package).

The __@blueprintjs/node-build-scripts__ package provides some utility functions to help with this. Here's a code example
for a custom Sass compiler that can import Blueprint `.scss` sources:

```js
import { sassNodeModulesLoadPaths, sassSvgInlinerFactory } from "@blueprintjs/node-build-scripts";
import * as sass from "sass";

const result = await sass.compileAsync("path/to/input.scss", {
    loadPaths: sassNodeModulesLoadPaths,
    functions: {
        /**
         * Sass function to inline a UI icon svg and change its path color.
         *
         * Usage:
         * svg-icon("16px/icon-name.svg", (path: (fill: $color)) )
         */
        "svg-icon($path, $selectors: null)": sassSvgInlinerFactory("path/to/resources/icons", {
            optimize: true,
            encodingFormat: "uri",
        }),
    },
});
```

In addition to the JS API, you can specify this configuration with Webpack's sass-loader:

```js
// webpack.config.mjs

import { sassNodeModulesLoadPaths, sassSvgInlinerFactory } from "@blueprintjs/node-build-scripts";
import * as sass from "sass";

const functions = {
    /**
     * Sass function to inline a UI icon svg and change its path color.
     *
     * Usage:
     * svg-icon("16px/icon-name.svg", (path: (fill: $color)) )
     */
    "svg-icon($path, $selectors: null)": sassSvgInlinerFactory("path/to/resources/icons", {
        optimize: true,
        encodingFormat: "uri",
    }),
};

export default {
    module: {
        rules: [
            {
                test: /\.scss$/,
                use: {
                    loader: require.resolve("sass-loader"),
                    options: {
                        sassOptions: {
                            loadPaths: sassNodeModulesLoadPaths,
                            functions,
                        },
                    },
                },
            },
        ],
    },
};
```

Once you have this build configuration set up, you can proceed to customize Sass and JS variables:

1. Define the `$ns` Sass variable in your app styles _before_ importing `blueprint.scss`.
1. When bundling your JS JS code, define the `BLUEPRINT_NAMESPACE` variable to the same value; this will update the generated `Classes` constants. The easiest way to do is with webpack's [DefinePlugin](https://webpack.js.org/plugins/define-plugin/).

```js
plugins: [
    new webpack.DefinePlugin({
        BLUEPRINT_NAMESPACE: "my-custom-namespace",
    }),
];
```

@## Linting

The [**@blueprintjs/eslint-config**](https://www.npmjs.com/package/@blueprintjs/eslint-config)
NPM package provides advanced configuration for [ESLint](https://eslint.org/). Blueprint is
currently transitioning from [TSLint](https://palantir.github.io/tslint/) to ESLint, and as
such, rules are being migrated from TSLint to ESLint. In the meantime, some TSLint rules are
being run using ESLint.

The [**@blueprintjs/eslint-plugin**](https://www.npmjs.com/package/@blueprintjs/eslint-plugin)
NPM package includes a custom `blueprint-html-components` rule that will warn on usages of
JSX intrinsic elements (`<h1>`) that have a Blueprint alternative (`<H1>`). See
the package's [README](https://www.npmjs.com/package/@blueprintjs/eslint-plugin)
for usage instructions.

================================================================================

File: src\docs\colors.md
--------------------------------------------------------------------------------
@# Colors

@## Gray scale

Black, white and everything in between.

The gray scale should be used for the main UI frame: containers, headers, sections, boxes, etc.

If you need to call attention to a particular element (buttons, icons, tooltips, etc.),
use one of the [core colors](#core/colors.core-colors) instead.

@reactDocs BlackWhitePalette
@reactDocs GrayscalePalette

@## Core colors

Core colors are used to support user interface design by calling
attention to specific elements, such as buttons, callouts, icons, etc.

Each core color is mapped to what we call a __visual intent__. Intents
are used to convey the status and tone of UI elements:

- _Blue_ (intent: primary) elevates elements from the typical gray scale UI frame.
- _Green_ (intent: success) indicates successful operations.
- _Orange_ (intent: warning) indicates warnings and intermediate states.
- _Red_ (intent: danger) indicates errors and potentially destructive operations.

Blueprint's core colors are designed to:

- go well together and be used alongside each other in any application.
- adhere to [WCAG 2.0](https://www.w3.org/TR/WCAG20/) standards, and therefore are
highly accessible to visually impaired and color blind users.

Many Blueprint components support the `intent` prop, which may be set to a string
literal constant such as `intent="primary"`.

@reactDocs CoreColorsPalette

@## Extended colors

Extended colors should typically be reserved for data visualizations: any time
you need to represent data of some sort, you can use these.
These colors are less strict on [WCAG 2.0](https://www.w3.org/TR/WCAG20/)
accessibility standards and should therefore not be used for typical user
interface design — take a look at [core colors](#colors.core-colors) instead.

@reactDocs ExtendedColorsPalette

@## Usage

Blueprint provides variables for colors in Sass, Less, and JavaScript.
[Semantic aliases for common colors](#core/variables.color-aliases) are also provided in Sass and Less.

Example in Sass:

```scss
@import "@blueprintjs/core/lib/scss/variables";

.rule {
    color: $pt-link-color;
    background: $black;
}
```

Example in Less:

```less
@import "@blueprintjs/core/lib/less/variables";

.rule {
    color: @pt-link-color;
    background: @black;
}
```

Hex values for these colors can be accessed in JavaScript through the `Colors` export.
Note that aliases are not currently available in JavaScript.

```tsx
import { Colors } from "@blueprintjs/core";

<div style={{ color: Colors.BLUE3, background: Colors.BLACK }} />
```

@## Color schemes

Use the following color scheme generators to produce color schemes for your data visualizations.
First, choose the kind of scheme based on the type of your data, then customize the number of values
using the forms below. Finally, copy the colors array into your application and make it live!

The following schemes have been carefully crafted to be visually striking and easily understandable
while remaining accessible to visually impaired and color blind users.

@### Sequential color schemes

Sequential color schemes imply order and are best suited for representing data that
ranges from low-to-high values either on an ordinal or on a numerical scale.

@reactDocs SequentialSchemePalette

@### Diverging color schemes

Diverging color schemes put equal emphasis on mid-range values and extremes
at both ends of the data range.

@reactDocs DivergingSchemePalette

@### Qualitative color schemes

Qualitative color schemes use a series of unrelated colors to create a
scheme that does not imply order, merely difference in kind.

@reactDocs QualitativeSchemePalette


================================================================================

File: src\docs\index.md
--------------------------------------------------------------------------------
---
reference: core
---

@# Core

The __@blueprintjs/core__ NPM package is the basis of any Blueprint app. It includes many (30+)
React components covering all the basic bases, from buttons to form controls to tooltips and trees.
It also includes CSS styles for every component and the tools to style your own components and apps
with Sass and Less variables and an elegant color palette.

Make sure to review the [getting started docs for installation info](#blueprint/getting-started).

Note that the core package depends on __@blueprintjs/icons__ which provides 500+ UI icons.
You must include the icons CSS file in your app alongside the core CSS file.

@page accessibility
@page classes
@page colors
@page typography
@page variables
@page components
@page context
@page hooks
@page legacy

================================================================================

File: src\docs\typography.md
--------------------------------------------------------------------------------
@# Typography

@## Usage

Keep in mind these general web typography guidelines when building your applications.

- The default text color in all components is compliant with the recommended
[WCAG 2.0](https://www.w3.org/TR/WCAG20/) minimum contrast ratio.
- If you choose to go with a custom text color, make sure the background behind it provides
proper contrast.
- Try not to explicitly write pixel values for your font-size or line-height CSS rules.
Instead, reference the classes and variables we provide in Blueprint (`.@ns-ui-text`,
`$@ns-font-size-large`, etc.).

@## UI text

Blueprint does not include any fonts of its own; it will use the default sans-serif operating system font.
A handful of utility CSS classes can be combined freely to further customize a block of text.

The base font size for Blueprint web applications is 14px. This should be the default type size
for most short strings of text which are not headings or titles. If you wish to reset some
element's font size and line height to the default base styles, use the `.@ns-ui-text` class.

For longer blocks of running text, such as articles or documents, see [running text styles](#core/typography.running-text).

@css ui-text

@## Running text

Longform text, such as rendered Markdown documents, benefit from increased spacing and support for unclassed textual elements.
Apply `.@ns-running-text` to the parent element to apply the following styles to all children:

- `<h*>`, `<ul>`, `<ol>`, `<blockquote>`, `<code>`, `<pre>`, `<kbd>` tags do not require additional CSS classes for styles. This is great for rendered Markdown documents.
- `<h*>` tag margins are adjusted to provide clear separation between sections in a document.
- `<ul>` and `<ol>` tags receive [`.@ns-list`](#core/typography.lists) styles for legibility.

@css running-text

@## Headings

Apply the `.@ns-heading` class to one of the six `<h*>` tags (or nest them inside a `.@ns-running-text` container)
to adjust font size and line height.

@css headings

@## Links

Simply use an `<a href="">` tag as you normally would. No class is necessary for Blueprint styles.
Links are underlined only when hovered.

Putting an icon inside a link will cause it to inherit the link's text color.

@## Preformatted text

Use `.@ns-code` for inline code elements (typically with the `<code>` tag).
Use `.@ns-code-block` for mulitline blocks of code (typically on a `<pre>` tag).
Note that `<pre>` blocks will retain _all_ whitespace so you'll have to format the content accordingly.

When nested inside a `.@ns-running-text` container, use the `<pre>` or `<code>` tags directly without CSS classes.

@css preformatted

@## Block quotes

Block quotes receive a left border and padding to distinguish them from body text.

Use the `.@ns-blockquote` class or nest a `<blockquote>` element inside a `.@ns-running-text` container.

@css blockquote

@## Lists

Blueprint provides a small amount of global styling and a few modifier classes for list elements.

`<ul>` and `<ol>` elements in blocks with the `.@ns-running-text` modifier class will
automatically assume the `.@ns-list` styles to promote readability.

Use `.@ns-list-unstyled` to remove list item decorations and margins and padding.

Note that these classes must be applied to each nested `<ul>` or `<ol>` element in a tree.

@css lists

@## Internationalization

I18n in Blueprint is straightforward. React components expose props for customizing any strings;
use the library of your choice for managing internationalized strings.

@### Right-to-left text

Use the utility class `.@ns-rtl`.

@css rtl

@## Dark theme

Blueprint provides two UI color themes: light and dark. The light theme is active by default. The
dark theme can be applied by adding the class `@ns-dark` to a container element to theme all nested
elements.

Once applied, the dark theme will cascade to nested `.@ns-*` elements inside a `.@ns-dark` container.
There is no way to nest light-themed elements inside a dark container.

Most elements only support the dark theme when nested inside a `.@ns-dark` container because it does
not make sense to mark individual elements as dark. The dark container is therefore responsible for
setting a dark background color.

The following elements and components support the `.@ns-dark` class directly (i.e, `.@ns-card.@ns-dark`)
and can be used as a container for nested dark children:

- `Card`
- Overlays: `Dialog`, `Popover`, `Tooltip`, `Toast`
- `Popover` and `Tooltip` will automatically detect when their trigger is inside a `.@ns-dark`
container and add the same class to themselves.

Rather than illustrating dark components inline, this documentation site provides a site-wide switch
in the sidebar to enable the dark theme. Try it out as you read the docs.

================================================================================

File: src\docs\variables.md
--------------------------------------------------------------------------------
@# Variables

Available for use with Sass and Less.

```scss
// Sass
@import "path/to/@blueprintjs/core/lib/scss/variables";
```

```less
// Less
@import "path/to/@blueprintjs/core/lib/less/variables";
```

The Sass `$` convention is used in this documentation for consistency with the original source code.
Every variable mentioned below is also available in `variables.less` with an `@` prefix instead of `$`.

@## Font variables

Typically, correct typography styles should be achieved by using the proper HTML tag (`<p>` for
text, `<h*>` for headings, `<code>` for code, etc.). The following variables are provided for the
rare cases where custom styling is necessary and should be used sparingly:

- `$pt-font-family`
- `$pt-font-family-monospace`
- `$pt-font-size`
- `$pt-font-size-small`
- `$pt-font-size-large`
- `$pt-line-height`

@## Icon variables

Most icons should be displayed using the `<Icon>` component from `@blueprintjs/icons` or the
`icon` and `iconName` prop APIs available on many Blueprint components. These APIs have the advantage
of rendering SVGs directly onto the page.

In some cases you may use the icon fonts instead with the CSS API targeting selectors of the kind
`span.@ns-icon-*` (be sure to include `.@ns-icon-standard` or `.@ns-icon-large` as well).

In rare cases, you may need direct access to the code points the icon font. Blueprint provides these
variables in Sass as a map and in TypeScript as an object (see the [Icons section](#icons) for the
full list of identifiers):

```scss
@import "@blueprintjs/icons/lib/scss/variables";

.my-custom-icon {
    content: map-get($blueprint-icon-codepoints, "tick");
}
```

```ts
import { getIconContentString } from "@blueprintjs/icons";

document.querySelector(".my-custom-icon").style.content = getIconContentString("tick");
```

Sass variables are also provided for the two icon font families and their pixel sizes:

- `$blueprint-icons-16`
- `$blueprint-icons-20`
- `$pt-icon-size-standard`
- `$pt-icon-size-large`

@## Grids & dimensions

Sizes of common components. Most sizing variables are based on `$pt-grid-size`, which has
a value of `10px`. Custom components should adhere to the relevant `height` variable.

- `$pt-grid-size`
- `$pt-border-radius`
- `$pt-button-height`
- `$pt-button-height-large`
- `$pt-input-height`
- `$pt-input-height-large`
- `$pt-navbar-height`

@### Grid system

Blueprint doesn't provide a grid system. In general, you should try to use the `$pt-grid-size`
variable to generate layout & sizing style rules in your CSS codebase.

In lieu of a full grid system, you should try to use the __CSS flexible box layout model__ (a.k.a.
"flexbox"). It's quite powerful on its own and allows you to build robust, responsive layouts
without writing much CSS. Here are some resources for learning flexbox:
- [MDN guide](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Flexible_boxes)
- [CSS Tricks guide](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)

@## Layering

Blueprint provides variables for three z-index layers. This should be enough for most use cases,
especially if you make correct use of [stacking context][MDN]. [Overlay2](#core/components/overlay2)
components such as dialogs and popovers use these z-index values to configure their stacking
contexts.

- `$pt-z-index-base`
- `$pt-z-index-content`
- `$pt-z-index-overlay`

[MDN]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context

@## Light theme styles

Use these when you need to build custom UI components that look similar to Blueprint's
light theme components.

- `$pt-dialog-box-shadow`
- `$pt-input-box-shadow`
- `$pt-popover-box-shadow`
- `$pt-tooltip-box-shadow`

@## Dark theme styles

Use these when you need to build custom UI components that look similar to Blueprint's
dark theme components.

- `$pt-dark-dialog-box-shadow`
- `$pt-dark-input-box-shadow`
- `$pt-dark-popover-box-shadow`
- `$pt-dark-tooltip-box-shadow`

@## Elevation drop shadows

Use these when you need to apply a drop shadow to custom UI components to simulate height.
These elevations correspond to those of the [Card](#core/components/card.elevation) component.

- `$pt-elevation-shadow-0`
- `$pt-elevation-shadow-1`
- `$pt-elevation-shadow-2`
- `$pt-elevation-shadow-3`
- `$pt-elevation-shadow-4`

Use these for drop shadows in dark theme.

- `$pt-dark-elevation-shadow-0`
- `$pt-dark-elevation-shadow-1`
- `$pt-dark-elevation-shadow-2`
- `$pt-dark-elevation-shadow-3`
- `$pt-dark-elevation-shadow-4`

@## Color aliases

These variables are semantic aliases of our [colors](#core/colors).
They are used throughout Blueprint itself to ensure consistent color usage across components
and are available in the Sass or Less variables files.

<table class="@ns-html-table docs-color-aliases-table">
    <thead>
        <tr>
            <th></th>
            <th>Variable</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <div class="docs-color-bubble alias-intent-primary"></div>
            </td>
            <td><code>$pt-intent-primary</code></td>
            <td>Primary intent color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-intent-success"></div>
            </td>
            <td><code>$pt-intent-success</code></td>
            <td>Success intent color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-intent-warning"></div>
            </td>
            <td><code>$pt-intent-warning</code></td>
            <td>Warning intent color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-intent-danger"></div>
            </td>
            <td><code>$pt-intent-danger</code></td>
            <td>Danger intent color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-app-background-color"></div>
            </td>
            <td><code>$pt-app-background-color</code></td>
            <td>Application background color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-dark-app-background-color"></div>
            </td>
            <td><code>$pt-dark-app-background-color</code></td>
            <td>Dark theme application background color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-text-color"></div>
            </td>
            <td><code>$pt-text-color</code></td>
            <td>Default text color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-text-color-muted"></div>
            </td>
            <td><code>$pt-text-color-muted</code></td>
            <td>Muted text color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-text-color-disabled"></div>
            </td>
            <td><code>$pt-text-color-disabled</code></td>
            <td>Disabled text color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-heading-color"></div>
            </td>
            <td><code>$pt-heading-color</code></td>
            <td>Text color for headers</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-link-color"></div>
            </td>
            <td><code>$pt-link-color</code></td>
            <td>Text color for links</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-dark-text-color"></div>
            </td>
            <td><code>$pt-dark-text-color</code></td>
            <td>Dark theme default text color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-dark-text-color-muted"></div>
            </td>
            <td><code>$pt-dark-text-color-muted</code></td>
            <td>Dark theme muted text color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-dark-text-color-disabled"></div>
            </td>
            <td><code>$pt-dark-text-color-disabled</code></td>
            <td>Dark theme disabled text color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-dark-heading-color"></div>
            </td>
            <td><code>$pt-dark-heading-color</code></td>
            <td>Dark theme text color for headers</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-dark-link-color"></div>
            </td>
            <td><code>$pt-dark-link-color</code></td>
            <td>Dark theme text color for links</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-text-selection-color"></div>
            </td>
            <td><code>$pt-text-selection-color</code></td>
            <td>Text selection color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-icon-color"></div>
            </td>
            <td><code>$pt-icon-color</code></td>
            <td>Default icon color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-icon-color-hover"></div>
            </td>
            <td><code>$pt-icon-color-hover</code></td>
            <td>Hovered icon color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-icon-color-disabled"></div>
            </td>
            <td><code>$pt-icon-color-disabled</code></td>
            <td>Disabled icon color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-icon-color-selected"></div>
            </td>
            <td><code>$pt-icon-color-selected</code></td>
            <td>Selected icon color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-dark-icon-color"></div>
            </td>
            <td><code>$pt-dark-icon-color</code></td>
            <td>Dark theme default icon color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-dark-icon-color-hover"></div>
            </td>
            <td><code>$pt-dark-icon-color-hover</code></td>
            <td>Dark theme hovered icon color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-dark-icon-color-disabled"></div>
            </td>
            <td><code>$pt-dark-icon-color-disabled</code></td>
            <td>Dark theme disabled icon color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-dark-icon-color-selected"></div>
            </td>
            <td><code>$pt-dark-icon-color-selected</code></td>
            <td>Dark theme selected icon color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-divider-black"></div>
            </td>
            <td><code>$pt-divider-black</code></td>
            <td>Black divider color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-dark-divider-black"></div>
            </td>
            <td><code>$pt-dark-divider-black</code></td>
            <td>Dark theme black divider color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-dark-divider-white"></div>
            </td>
            <td><code>$pt-dark-divider-white</code></td>
            <td>Dark theme white divider color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-code-text-color"></div>
            </td>
            <td><code>$pt-code-text-color</code></td>
            <td>Code text color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-code-background-color"></div>
            </td>
            <td><code>$pt-code-background-color</code></td>
            <td>Code background color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-dark-code-text-color"></div>
            </td>
            <td><code>$pt-dark-code-text-color</code></td>
            <td>Dark theme code text color</td>
        </tr>
        <tr>
            <td>
                <div class="docs-color-bubble alias-dark-code-background-color"></div>
            </td>
            <td><code>$pt-dark-code-background-color</code></td>
            <td>Dark theme code background color</td>
        </tr>
    </tbody>
</table>


================================================================================

File: src\hooks\hooks.md
--------------------------------------------------------------------------------
@# Hooks

<!-- Exact ordering of items in the navbar: -->

@page use-hotkeys
@page use-overlay-stack

================================================================================

File: src\hooks\index.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export type { HotkeyConfig } from "./hotkeys/hotkeyConfig";
export { useHotkeys, type UseHotkeysOptions, type UseHotkeysReturnValue } from "./hotkeys/useHotkeys";
export { useOverlayStack } from "./overlays/useOverlayStack";
export { useAsyncControllableValue } from "./useAsyncControllableValue";
export { useIsomorphicLayoutEffect } from "./useIsomorphicLayoutEffect";
export { usePrevious } from "./usePrevious";

================================================================================

File: src\hooks\useAsyncControllableValue.ts
--------------------------------------------------------------------------------
/* !
 * (c) Copyright 2023 Palantir Technologies Inc. All rights reserved.
 */

import * as React from "react";

interface UseAsyncControllableValueProps<E extends HTMLInputElement | HTMLTextAreaElement> {
    value?: React.InputHTMLAttributes<E>["value"];
    onChange?: React.ChangeEventHandler<E>;
    onCompositionStart?: React.CompositionEventHandler<E>;
    onCompositionEnd?: React.CompositionEventHandler<E>;
}

/**
 * The amount of time (in milliseconds) which the input will wait after a compositionEnd event before
 * unlocking its state value for external updates via props. See `handleCompositionEnd` for more details.
 */
export const ASYNC_CONTROLLABLE_VALUE_COMPOSITION_END_DELAY = 10;

/**
 * A hook to workaround the following [React bug](https://github.com/facebook/react/issues/3926).
 * This bug is reproduced when an input receives CompositionEvents
 * (for example, through IME composition) and has its value prop updated asychronously.
 * This might happen if a component chooses to do async validation of a value
 * returned by the input's `onChange` callback.
 */
export function useAsyncControllableValue<E extends HTMLInputElement | HTMLTextAreaElement>(
    props: UseAsyncControllableValueProps<E>,
) {
    const { onCompositionStart, onCompositionEnd, value: propValue, onChange } = props;

    // The source of truth for the input value. This is not updated during IME composition.
    // It may be updated by a parent component.
    const [value, setValue] = React.useState(propValue);

    // The latest input value, which updates during IME composition.
    const [nextValue, setNextValue] = React.useState(propValue);

    // Whether we are in the middle of a composition event.
    const [isComposing, setIsComposing] = React.useState(false);

    // Whether there is a pending update we are expecting from a parent component.
    const [hasPendingUpdate, setHasPendingUpdate] = React.useState(false);

    const cancelPendingCompositionEnd = React.useRef<() => void>();

    const handleCompositionStart: React.CompositionEventHandler<E> = React.useCallback(
        event => {
            cancelPendingCompositionEnd.current?.();
            setIsComposing(true);
            onCompositionStart?.(event);
        },
        [onCompositionStart],
    );

    // creates a timeout which will set `isComposing` to false after a delay
    // returns a function which will cancel the timeout if called before it fires
    const createOnCancelPendingCompositionEnd = React.useCallback(() => {
        const timeoutId = window.setTimeout(
            () => setIsComposing(false),
            ASYNC_CONTROLLABLE_VALUE_COMPOSITION_END_DELAY,
        );
        return () => window.clearTimeout(timeoutId);
    }, []);

    const handleCompositionEnd: React.CompositionEventHandler<E> = React.useCallback(
        event => {
            // In some non-latin languages, a keystroke can end a composition event and immediately afterwards start another.
            // This can lead to unexpected characters showing up in the text input. In order to circumvent this problem, we
            // use a timeout which creates a delay which merges the two composition events, creating a more natural and predictable UX.
            // `this.state.nextValue` will become "locked" (it cannot be overwritten by the `value` prop) until a delay (10ms) has
            // passed without a new composition event starting.
            cancelPendingCompositionEnd.current = createOnCancelPendingCompositionEnd();
            onCompositionEnd?.(event);
        },
        [createOnCancelPendingCompositionEnd, onCompositionEnd],
    );

    const handleChange: React.ChangeEventHandler<E> = React.useCallback(
        event => {
            const { value: targetValue } = event.target;
            setNextValue(targetValue);
            onChange?.(event);
        },
        [onChange],
    );

    // don't derive anything from props if:
    // - in uncontrolled mode, OR
    // - currently composing, since we'll do that after composition ends
    const shouldDeriveFromProps = !(isComposing || propValue === undefined);

    if (shouldDeriveFromProps) {
        const userTriggeredUpdate = nextValue !== value;

        if (userTriggeredUpdate && propValue === nextValue) {
            // parent has processed and accepted our update
            setValue(propValue);
            setHasPendingUpdate(false);
        } else if (userTriggeredUpdate && propValue === value) {
            // we have sent the update to our parent, but it has not been processed yet. just wait.
            // DO NOT set nextValue here, since that will temporarily render a potentially stale controlled value,
            // causing the cursor to jump once the new value is accepted
            if (!hasPendingUpdate) {
                // make sure to setState only when necessary to avoid infinite loops
                setHasPendingUpdate(true);
            }
        } else if (userTriggeredUpdate && propValue !== value) {
            // accept controlled update overriding user action
            setValue(propValue);
            setNextValue(propValue);
            setHasPendingUpdate(false);
        } else if (!userTriggeredUpdate) {
            // accept controlled update, could be confirming or denying user action
            if (value !== propValue || hasPendingUpdate) {
                // make sure to setState only when necessary to avoid infinite loops
                setValue(propValue);
                setNextValue(propValue);
                setHasPendingUpdate(false);
            }
        }
    }

    return {
        onChange: handleChange,
        onCompositionEnd: handleCompositionEnd,
        onCompositionStart: handleCompositionStart,
        // render the pending value even if it is not confirmed by a parent's async controlled update
        // so that the cursor does not jump to the end of input as reported in
        // https://github.com/palantir/blueprint/issues/4298
        value: isComposing || hasPendingUpdate ? nextValue : value,
    };
}

================================================================================

File: src\hooks\useIsomorphicLayoutEffect.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

import { hasDOMEnvironment } from "../common/utils/domUtils";

/**
 * @returns the appropriate React layout effect hook for the current environment (server or client).
 */
export const useIsomorphicLayoutEffect = hasDOMEnvironment() ? React.useLayoutEffect : React.useEffect;

================================================================================

File: src\hooks\usePrevious.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2022 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

/** React hook which tracks the previous state of a given value. */
export function usePrevious<T>(value: T) {
    // create a new reference
    const ref = React.useRef<T>();

    // store current value in ref
    React.useEffect(() => {
        ref.current = value;
    }, [value]);

    // return previous value (happens before update in useEffect above)
    return ref.current;
}

================================================================================

File: src\hooks\useTimeout.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

import { useIsomorphicLayoutEffect } from "./useIsomorphicLayoutEffect";

/**
 * React hook wrapper for setTimeout(), adapted from usehooks-ts.
 * The provided callback is invoked after the specified delay in milliseconds.
 * If the delay is null or the component is unmounted, any pending timeout is cleared.
 *
 * @see https://usehooks-ts.com/react-hook/use-timeout
 */
export function useTimeout(callback: () => void, delay: number | null) {
    const savedCallback = React.useRef(callback);

    // remember the latest callback if it changes
    useIsomorphicLayoutEffect(() => {
        savedCallback.current = callback;
    }, [callback]);

    // set up the timeout
    React.useEffect(() => {
        // Don't schedule if no delay is specified.
        // Note: 0 is a valid value for delay.
        if (!delay && delay !== 0) {
            return;
        }

        const id = setTimeout(() => savedCallback.current(), delay);

        return () => clearTimeout(id);
    }, [delay]);
}

================================================================================

File: src\hooks\hotkeys\hotkeyConfig.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export interface HotkeyConfig {
    /**
     * Whether the hotkey should be triggerable when focused in a text input.
     *
     * @default false
     */
    allowInInput?: boolean;

    /**
     * Hotkey combination string (AKA "key combo"), such as "space" or "cmd+n".
     */
    combo: string;

    /**
     * Whether the hotkey cannot be triggered.
     *
     * @default false
     */
    disabled?: boolean;

    /**
     * Human-friendly label for the hotkey.
     */
    label: React.ReactNode;

    /**
     * If `false`, the hotkey is active only when the target is focused. If
     * `true`, the hotkey can be triggered regardless of what component is
     * focused.
     *
     * @default false
     */
    global?: boolean;

    /**
     * Unless the hotkey is global, you must specify a group where the hotkey
     * will be displayed in the hotkeys dialog. This string will be displayed
     * in a header at the start of the group of hotkeys.
     */
    group?: string;

    /**
     * When `true`, invokes `event.preventDefault()` before the respective `onKeyDown` and
     * `onKeyUp` callbacks are invoked. Enabling this can simplify handler implementations.
     *
     * @default false
     */
    preventDefault?: boolean;

    /**
     * When `true`, invokes `event.stopPropagation()` before the respective `onKeyDown` and
     * `onKeyUp` callbacks are invoked. Enabling this can simplify handler implementations.
     *
     * @default false
     */
    stopPropagation?: boolean;

    /**
     * `keydown` event handler.
     */
    onKeyDown?(e: KeyboardEvent): any;

    /**
     * `keyup` event handler.
     */
    onKeyUp?(e: KeyboardEvent): any;
}

================================================================================

File: src\hooks\hotkeys\use-hotkeys.md
--------------------------------------------------------------------------------
@# useHotkeys

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Migrating from [**HotkeysTarget**](#core/legacy/hotkeys-legacy)?

</h5>

`useHotkeys()` is a replacement for **HotkeysTarget**. You are encouraged to use this new API in your function
components, or the [**HotkeysTarget2** component](#core/components/hotkeys-target2) in your component classes,
as they will become the standard APIs in a future major version of Blueprint. See the full
[migration guide](https://github.com/palantir/blueprint/wiki/HotkeysTarget-&-useHotkeys-migration) on the wiki.

</div>

The `useHotkeys()` hook adds hotkey / keyboard shortcut interactions to your application using a custom React hook.
Compared to the deprecated [Hotkeys API](#core/legacy/hotkeys-legacy), it works with function components and its
corresponding [context provider](#core/context/hotkeys-provider) allows more customization of the hotkeys dialog.

Focus on the piano below to try its hotkeys. The global hotkeys dialog can be shown using the <kbd>?</kbd> key.

@reactExample UseHotkeysExample

@## Usage

First, make sure [**HotkeysProvider**](#core/context/hotkeys-provider) is configured correctly at the root of your
React application.

Then, to register hotkeys and generate the relevant event handlers, use the hook like so:

```tsx
import { InputGroup, KeyComboTag, useHotkeys } from "@blueprintjs/core";
import React, { createRef, useCallback, useMemo } from "react";

export default function () {
    const inputRef = createRef<HTMLInputElement>();
    const handleRefresh = useCallback(() => console.info("Refreshing data..."), []);
    const handleFocus = useCallback(() => inputRef.current?.focus(), [inputRef]);

    // important: hotkeys array must be memoized to avoid infinitely re-binding hotkeys
    const hotkeys = useMemo(
        () => [
            {
                combo: "R",
                global: true,
                label: "Refresh data",
                onKeyDown: handleRefresh,
            },
            {
                combo: "F",
                group: "Input",
                label: "Focus text input",
                onKeyDown: handleFocus,
            },
        ],
        [handleRefresh, handleFocus],
    );
    const { handleKeyDown, handleKeyUp } = useHotkeys(hotkeys);

    return (
        <div tabIndex={0} onKeyDown={handleKeyDown} onKeyUp={handleKeyUp}>
            Press <KeyComboTag combo="R" /> to refresh data, <KeyComboTag combo="F" /> to focus the input...
            <InputGroup inputRef={inputRef} />
        </div>
    );
}
```

**Important**: the `hotkeys` array must be memoized, as shown above, to prevent the hook from re-binding
hotkeys on every render.

Hotkeys must define a group, or be marked as global. The hook will automatically bind global event handlers
and configure the <kbd>?</kbd> key to open the generated hotkeys dialog, but it is up to you to bind _local_
event handlers with the returned `handleKeyDown` and `handleKeyUp` functions. The hook takes an optional
second parameter which can customize some of its default behavior.

@## Hook options

@interface UseHotkeysOptions

@method useHotkeys

@## Hotkey configuration

@interface HotkeyConfig

@## Key combos

Each hotkey must be assigned a key combo that will trigger its events. A key combo consists of zero or more modifier
keys (`alt`, `ctrl`, `shift`, `meta`, `cmd`) and exactly one action key, such as `A`, `return`, or `up`.

Some key combos have aliases. For example, `shift + 1` can equivalently be expressed as `!` and `cmd` is equal to
`meta`. However, normal alphabetic characters do not have this aliasing, so `X` is equivalent to `x` but is not
equivalent to `shift + x`.

Examples of valid key combos:

-   `cmd+plus`
-   `!` or, equivalently `shift+1`
-   `return` or, equivalently `enter`
-   `alt + shift + x`
-   `ctrl + left`

Note that spaces are ignored.

### Named keys

-   `plus`
-   `minus`
-   `backspace`
-   `tab`
-   `enter`
-   `capslock`
-   `esc`
-   `space`
-   `pageup`
-   `pagedown`
-   `end`
-   `home`
-   `left`
-   `up`
-   `right`
-   `down`
-   `ins`
-   `del`

### Aliased keys

-   `option` &rarr; `alt`
-   `cmd` &rarr; `meta`
-   `command` &rarr; `meta`
-   `return` &rarr; `enter`
-   `escape` &rarr; `esc`
-   `win` &rarr; `meta`

The special modifier `mod` will choose the OS-preferred modifier key: `cmd` for macOS and iOS, or `ctrl` for Windows
and Linux.

@## Key combo tester

Below is a little widget to quickly help you try out hotkey combos and see how they will appear in the dialog. See the
[Key combos section](#core/hooks/use-hotkeys.key-combos) above for more info.

@reactExample HotkeyTesterExample

================================================================================

File: src\hooks\hotkeys\useHotkeys.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as React from "react";

import { HOTKEYS_PROVIDER_NOT_FOUND } from "../../common/errors";
import { elementIsTextInput } from "../../common/utils/domUtils";
import { comboMatches, getKeyCombo, type KeyCombo, parseKeyCombo } from "../../components/hotkeys/hotkeyParser";
import { HotkeysContext } from "../../context";

import type { HotkeyConfig } from "./hotkeyConfig";

export interface UseHotkeysOptions {
    /**
     * A custom document to reference when binding global event handlers.
     * This can be useful when using iframes in an application.
     *
     * @default window.document
     */
    document?: Document;

    /**
     * The key combo which will trigger the hotkeys dialog to open.
     *
     * @default "?"
     */
    showDialogKeyCombo?: string;
}

export interface UseHotkeysReturnValue {
    handleKeyDown: React.KeyboardEventHandler<HTMLElement>;
    handleKeyUp: React.KeyboardEventHandler<HTMLElement>;
}

/**
 * React hook to register global and local hotkeys for a component.
 *
 * @see https://blueprintjs.com/docs/#core/hooks/use-hotkeys
 * @param keys list of hotkeys to configure
 * @param options hook options
 */
export function useHotkeys(keys: readonly HotkeyConfig[], options: UseHotkeysOptions = {}): UseHotkeysReturnValue {
    const { document = getDefaultDocument(), showDialogKeyCombo = "?" } = options;
    const localKeys = React.useMemo(
        () =>
            keys
                .filter(k => !k.global)
                .map(k => ({
                    combo: parseKeyCombo(k.combo),
                    config: k,
                })),
        [keys],
    );
    const globalKeys = React.useMemo(
        () =>
            keys
                .filter(k => k.global)
                .map(k => ({
                    combo: parseKeyCombo(k.combo),
                    config: k,
                })),
        [keys],
    );

    // register keys with global context
    const [state, dispatch] = React.useContext(HotkeysContext);

    React.useEffect(() => {
        if (!state.hasProvider) {
            console.warn(HOTKEYS_PROVIDER_NOT_FOUND);
        }
    }, [state.hasProvider]);

    // we can still bind the hotkeys if there is no HotkeysProvider, they just won't show up in the dialog
    React.useEffect(() => {
        const payload = [...globalKeys.map(k => k.config), ...localKeys.map(k => k.config)];
        dispatch({ type: "ADD_HOTKEYS", payload });
        return () => dispatch({ type: "REMOVE_HOTKEYS", payload });
    }, [dispatch, globalKeys, localKeys]);

    const invokeNamedCallbackIfComboRecognized = React.useCallback(
        (global: boolean, combo: KeyCombo, callbackName: "onKeyDown" | "onKeyUp", e: KeyboardEvent) => {
            const isTextInput = elementIsTextInput(e.target as HTMLElement);
            for (const key of global ? globalKeys : localKeys) {
                const {
                    allowInInput = false,
                    disabled = false,
                    preventDefault = false,
                    stopPropagation = false,
                } = key.config;
                const shouldIgnore = (isTextInput && !allowInInput) || disabled;
                if (!shouldIgnore && comboMatches(key.combo, combo)) {
                    if (preventDefault) {
                        e.preventDefault();
                    }
                    if (stopPropagation) {
                        // set a flag just for unit testing. not meant to be referenced in feature work.
                        (e as any).isPropagationStopped = true;
                        e.stopPropagation();
                    }
                    key.config[callbackName]?.(e);
                }
            }
        },
        [globalKeys, localKeys],
    );

    const handleGlobalKeyDown = React.useCallback(
        (e: KeyboardEvent) => {
            // special case for global keydown: if '?' is pressed, open the hotkeys dialog
            const combo = getKeyCombo(e);
            const isTextInput = elementIsTextInput(e.target as HTMLElement);
            if (!isTextInput && comboMatches(parseKeyCombo(showDialogKeyCombo), combo)) {
                dispatch({ type: "OPEN_DIALOG" });
            } else {
                invokeNamedCallbackIfComboRecognized(true, getKeyCombo(e), "onKeyDown", e);
            }
        },
        [dispatch, invokeNamedCallbackIfComboRecognized, showDialogKeyCombo],
    );
    const handleGlobalKeyUp = React.useCallback(
        (e: KeyboardEvent) => invokeNamedCallbackIfComboRecognized(true, getKeyCombo(e), "onKeyUp", e),
        [invokeNamedCallbackIfComboRecognized],
    );

    const handleLocalKeyDown = React.useCallback(
        (e: React.KeyboardEvent<HTMLElement>) =>
            invokeNamedCallbackIfComboRecognized(false, getKeyCombo(e.nativeEvent), "onKeyDown", e.nativeEvent),
        [invokeNamedCallbackIfComboRecognized],
    );
    const handleLocalKeyUp = React.useCallback(
        (e: React.KeyboardEvent<HTMLElement>) =>
            invokeNamedCallbackIfComboRecognized(false, getKeyCombo(e.nativeEvent), "onKeyUp", e.nativeEvent),
        [invokeNamedCallbackIfComboRecognized],
    );

    React.useEffect(() => {
        // document is guaranteed to be defined inside effects
        document!.addEventListener("keydown", handleGlobalKeyDown);
        document!.addEventListener("keyup", handleGlobalKeyUp);
        return () => {
            document!.removeEventListener("keydown", handleGlobalKeyDown);
            document!.removeEventListener("keyup", handleGlobalKeyUp);
        };
    }, [document, handleGlobalKeyDown, handleGlobalKeyUp]);

    return { handleKeyDown: handleLocalKeyDown, handleKeyUp: handleLocalKeyUp };
}

function getDefaultDocument(): Document | undefined {
    if (typeof window === "undefined") {
        return undefined;
    }
    return window.document;
}

================================================================================

File: src\hooks\overlays\use-overlay-stack.md
--------------------------------------------------------------------------------
@# useOverlayStack

<div class="@ns-callout @ns-intent-warning @ns-icon-warning-sign @ns-callout-has-body-content">
    <h5 class="@ns-heading">Internal API</h5>

This hook is mainly intended to be an internal Blueprint API used by the **Overlay2** component.
Its usage outside of `@blueprintjs/` packages is not fully supported.

</div>

The `useOverlayStack()` hook allows Blueprint components to interact with the global overlay stack
in an application. Compared to the deprecated [**Overlay**](#core/components/overlay) component,
this hook avoids storing global state at the JS module level.

@## Usage

First, make sure [**OverlaysProvider**](#core/context/overlays-provider) is configured correctly at
the root of your React application.

Then, use the hook to interact with the global overlay stack:

```tsx
import { OverlayInstance, OverlayProps, Portal, useOverlayStack, usePrevious } from "@blueprintjs/core";
import * as React from "react";
import { useUID } from "react-uid";

export function Example(props: OverlayProps) {
    const { autoFocus, children, enforceFocus, hasBackdrop, isOpen, usePortal } = props;
    const { openOverlay, closeOverlay } = useOverlayStack();

    const containerElement = React.useRef<HTMLDivElement>(null);

    const bringFocusInsideOverlay = React.useCallback(() => {
        // TODO: implement
    }, []);

    const handleDocumentFocus = React.useCallback((e: FocusEvent) => {
        // TODO: implement
    }, []);

    const id = useUID();
    const instance = React.useMemo<OverlayInstance>(
        () => ({
            bringFocusInsideOverlay,
            containerElement,
            handleDocumentFocus,
            id,
            props: {
                autoFocus,
                enforceFocus,
                hasBackdrop,
                usePortal,
            },
        }),
        [autoFocus, bringFocusInsideOverlay, enforceFocus, handleDocumentFocus, hasBackdrop, id, usePortal],
    );

    const prevIsOpen = usePrevious(isOpen) ?? false;
    React.useEffect(() => {
        if (!prevIsOpen && isOpen) {
            // just opened
            openOverlay(instance);
        }

        if (prevIsOpen && !isOpen) {
            // just closed
            closeOverlay(instance);
        }
    }, [isOpen, openOverlay, closeOverlay, prevIsOpen, instance]);

    // run once on unmount
    React.useEffect(() => {
        return () => {
            if (isOpen) {
                closeOverlay(instance);
            }
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    return usePortal ? <Portal>{children}</Portal> : children;
}
```

================================================================================

File: src\hooks\overlays\useLegacyOverlayStack.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react";
// tslint:disable-next-line no-submodule-imports
import { useSyncExternalStore } from "use-sync-external-store/shim";

import { Classes } from "../../common";
import type { OverlayInstance } from "../../components";

import type { UseOverlayStackReturnValue } from "./useOverlayStack";

const globalStack: OverlayInstance[] = [];
const globalStackListeners: Array<() => void> = [];

/**
 * Modify the global stack in-place and notify all listeners of the updated value.
 *
 * @public for testing
 */
export const modifyGlobalStack = (fn: (stack: OverlayInstance[]) => void) => {
    fn(globalStack);
    globalStackListeners.forEach(listener => listener());
};

const legacyGlobalOverlayStackStore = {
    getSnapshot: () => globalStack,
    subscribe: (listener: () => void) => {
        globalStackListeners.push(listener);
        return () => {
            const index = globalStackListeners.indexOf(listener);
            globalStackListeners.splice(index, 1);
        };
    },
};

/**
 * Legacy implementation of a global overlay stack which maintains state in a global variable.
 * This is used for backwards-compatibility with overlay-based components in Blueprint v5.
 * It will be removed in Blueprint v6 once `<OverlaysProvider>` is required.
 *
 * @see https://github.com/palantir/blueprint/wiki/Overlay2-migration
 */
export function useLegacyOverlayStack(): UseOverlayStackReturnValue {
    const stack = useSyncExternalStore(
        legacyGlobalOverlayStackStore.subscribe,
        legacyGlobalOverlayStackStore.getSnapshot,
        // server snapshot is the same as client snapshot
        legacyGlobalOverlayStackStore.getSnapshot,
    );

    const getLastOpened = React.useCallback(() => stack[stack.length - 1], [stack]);

    const getThisOverlayAndDescendants = React.useCallback(
        (id: string) => {
            const stackIndex = stack.findIndex(o => o.id === id);
            return stack.slice(stackIndex);
        },
        [stack],
    );

    const resetStack = React.useCallback(() => {
        modifyGlobalStack(s => s.splice(0, s.length));
    }, []);

    const openOverlay = React.useCallback((overlay: OverlayInstance) => {
        globalStack.push(overlay);
        if (overlay.props.usePortal && overlay.props.hasBackdrop) {
            // add a class to the body to prevent scrolling of content below the overlay
            document.body.classList.add(Classes.OVERLAY_OPEN);
        }
    }, []);

    const closeOverlay = React.useCallback(
        (id: string) => {
            const otherOverlaysWithBackdrop = stack.filter(
                o => o.props.usePortal && o.props.hasBackdrop && o.id !== id,
            );

            const index = globalStack.findIndex(o => o.id === id);
            if (index > -1) {
                globalStack.splice(index, 1);
            }

            if (otherOverlaysWithBackdrop.length === 0) {
                // remove body class which prevents scrolling of content below overlay
                document.body.classList.remove(Classes.OVERLAY_OPEN);
            }
        },
        [stack],
    );

    return {
        closeOverlay,
        getLastOpened,
        getThisOverlayAndDescendants,
        openOverlay,
        resetStack,
    };
}

================================================================================

File: src\hooks\overlays\useOverlayStack.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react";

import { Classes } from "../../common";
import { OVERLAY2_REQUIRES_OVERLAY_PROVDER } from "../../common/errors";
import { isNodeEnv } from "../../common/utils";
import type { OverlayInstance } from "../../components";
import { OverlaysContext } from "../../context/overlays/overlaysProvider";

import { useLegacyOverlayStack } from "./useLegacyOverlayStack";

export interface UseOverlayStackReturnValue {
    /**
     * Removes an existing overlay off the stack.
     *
     * N.B. This method accepts an id instead of an overlay instance because the latter may be
     * null when an overlay is unmounting, and we may stil have some cleanup to do at that time.
     * Also, this method is not idempotent: if the overlay is not found on the stack, nothing happens.
     *
     * @param id identifier of the overlay to be closed
     */
    closeOverlay: (id: string) => void;

    /**
     * @returns the last opened overlay on the stack
     */
    getLastOpened: () => OverlayInstance | undefined;

    /**
     * @param id current overlay identifier
     * @returns a list of the current overlay and all overlays which are descendants of it.
     */
    getThisOverlayAndDescendants: (id: string) => OverlayInstance[];

    /**
     * Pushes a new overlay onto the stack.
     */
    openOverlay: (overlay: OverlayInstance) => void;

    /**
     * Resets the overlay stack, to be called after all overlays are closed.
     * Warning: this should only be used in unit tests.
     */
    resetStack: () => void;
}

/**
 * React hook to interact with the global overlay stack.
 *
 * @see https://blueprintjs.com/docs/#core/hooks/use-overlay-stack
 */
export function useOverlayStack(): UseOverlayStackReturnValue {
    // get the overlay stack from application-wide React context
    const { stack, hasProvider } = React.useContext(OverlaysContext);
    const legacyOverlayStack = useLegacyOverlayStack();

    const getLastOpened = React.useCallback(() => {
        return stack.current[stack.current.length - 1];
    }, [stack]);

    const getThisOverlayAndDescendants = React.useCallback(
        (id: string) => {
            const index = stack.current.findIndex(o => o.id === id);
            if (index === -1) {
                return [];
            }
            return stack.current.slice(index);
        },
        [stack],
    );

    const resetStack = React.useCallback(() => {
        stack.current = [];
    }, [stack]);

    const openOverlay = React.useCallback(
        (overlay: OverlayInstance) => {
            stack.current.push(overlay);
            if (overlay.props.usePortal && overlay.props.hasBackdrop) {
                // add a class to the body to prevent scrolling of content below the overlay
                document.body.classList.add(Classes.OVERLAY_OPEN);
            }
        },
        [stack],
    );

    const closeOverlay = React.useCallback(
        (id: string) => {
            const otherOverlaysWithBackdrop = stack.current.filter(
                o => o.props.usePortal && o.props.hasBackdrop && o.id !== id,
            );

            const index = stack.current.findIndex(o => o.id === id);
            if (index > -1) {
                stack.current.splice(index, 1);
            }

            if (otherOverlaysWithBackdrop.length === 0) {
                // remove body class which prevents scrolling of content below overlay
                document.body.classList.remove(Classes.OVERLAY_OPEN);
            }
        },
        [stack],
    );

    if (!hasProvider) {
        if (isNodeEnv("development")) {
            console.error(OVERLAY2_REQUIRES_OVERLAY_PROVDER);
        }
        return legacyOverlayStack;
    }

    return {
        closeOverlay,
        getLastOpened,
        getThisOverlayAndDescendants,
        openOverlay,
        resetStack,
    };
}

================================================================================

File: src\legacy\contextMenuLegacy.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview This component is DEPRECATED, and the code is frozen.
 * All changes & bugfixes should be made to ContextMenu2 instead.
 */

/* eslint-disable deprecation/deprecation */

import classNames from "classnames";
import * as React from "react";
import * as ReactDOM from "react-dom";

import { AbstractPureComponent, Classes } from "../common";
import type { OverlayLifecycleProps } from "../components/overlay/overlayProps";
import { Popover } from "../components/popover/popover";

export interface Offset {
    left: number;
    top: number;
}

interface ContextMenuLegacyState {
    isOpen: boolean;
    isDarkTheme: boolean;
    menu?: React.JSX.Element;
    offset?: Offset;
    onClose?: () => void;
}

const TRANSITION_DURATION = 100;

type ContextMenuLegacyProps = OverlayLifecycleProps;

/* istanbul ignore next */
/** @deprecated use ContextMenu */
class ContextMenuLegacy extends AbstractPureComponent<ContextMenuLegacyProps, ContextMenuLegacyState> {
    public state: ContextMenuLegacyState = {
        isDarkTheme: false,
        isOpen: false,
    };

    public render() {
        // prevent right-clicking in a context menu
        const content = <div onContextMenu={this.cancelContextMenu}>{this.state.menu}</div>;
        const popoverClassName = classNames({ [Classes.DARK]: this.state.isDarkTheme });

        // HACKHACK: workaround until we have access to Popper#scheduleUpdate().
        // https://github.com/palantir/blueprint/issues/692
        // Generate key based on offset so a new Popover instance is created
        // when offset changes, to force recomputing position.
        const key = this.state.offset === undefined ? "" : `${this.state.offset.left}x${this.state.offset.top}`;

        // wrap the popover in a positioned div to make sure it is properly
        // offset on the screen.
        return (
            <div className={Classes.CONTEXT_MENU} style={this.state.offset}>
                <Popover
                    {...this.props}
                    backdropProps={{ onContextMenu: this.handleBackdropContextMenu }}
                    content={content}
                    enforceFocus={false}
                    key={key}
                    hasBackdrop={true}
                    isOpen={this.state.isOpen}
                    minimal={true}
                    rootBoundary="viewport"
                    onInteraction={this.handlePopoverInteraction}
                    placement="right-start"
                    popoverClassName={popoverClassName}
                    transitionDuration={TRANSITION_DURATION}
                >
                    <div />
                </Popover>
            </div>
        );
    }

    public show(menu: React.JSX.Element, offset: Offset, onClose?: () => void, isDarkTheme = false) {
        this.setState({ isOpen: true, menu, offset, onClose, isDarkTheme });
    }

    public hide() {
        this.state.onClose?.();
        this.setState({ isOpen: false, onClose: undefined });
    }

    private cancelContextMenu = (e: React.SyntheticEvent<HTMLDivElement>) => e.preventDefault();

    private handleBackdropContextMenu = (e: React.MouseEvent<HTMLDivElement>) => {
        // React function to remove from the event pool, useful when using a event within a callback
        e.persist();
        e.preventDefault();
        // wait for backdrop to disappear so we can find the "real" element at event coordinates.
        // timeout duration is equivalent to transition duration so we know it's animated out.
        this.setTimeout(() => {
            // retrigger context menu event at the element beneath the backdrop.
            // if it has a `contextmenu` event handler then it'll be invoked.
            // if it doesn't, no native menu will show (at least on OSX) :(
            const newTarget = document.elementFromPoint(e.clientX, e.clientY);
            const { view, ...newEventInit } = e;
            newTarget?.dispatchEvent(new MouseEvent("contextmenu", newEventInit));
        }, TRANSITION_DURATION);
    };

    private handlePopoverInteraction = (nextOpenState: boolean) => {
        if (!nextOpenState) {
            // delay the actual hiding till the event queue clears
            // to avoid flicker of opening twice
            this.requestAnimationFrame(() => this.hide());
        }
    };
}

let contextMenuElement: HTMLElement | undefined;
let contextMenu: ContextMenuLegacy | undefined;

/**
 * Show the given menu element at the given offset from the top-left corner of the viewport.
 * The menu will appear below-right of this point and will flip to below-left if there is not enough
 * room onscreen. The optional callback will be invoked when this menu closes.
 *
 * @deprecated use ContextMenu2
 */
export function show(menu: React.JSX.Element, offset: Offset, onClose?: () => void, isDarkTheme?: boolean) {
    if (contextMenuElement === undefined) {
        contextMenuElement = document.createElement("div");
        contextMenuElement.classList.add(Classes.CONTEXT_MENU);
        document.body.appendChild(contextMenuElement);
        contextMenu = ReactDOM.render<ContextMenuLegacyProps>(
            <ContextMenuLegacy onClosed={remove} />,
            contextMenuElement,
        ) as ContextMenuLegacy;
    }

    contextMenu!.show(menu, offset, onClose, isDarkTheme);
}

/** Hide the open context menu. */
export function hide() {
    contextMenu?.hide();
}

/** Return whether a context menu is currently open. */
export function isOpen() {
    return contextMenu != null && contextMenu.state.isOpen;
}

function remove() {
    if (contextMenuElement != null) {
        ReactDOM.unmountComponentAtNode(contextMenuElement);
        contextMenuElement.remove();
        contextMenuElement = undefined;
        contextMenu = undefined;
    }
}

================================================================================

File: src\legacy\contextMenuTargetLegacy.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview This component is DEPRECATED, and the code is frozen.
 * All changes & bugfixes should be made to ContextMenu2 instead.
 */

/* eslint-disable deprecation/deprecation */

import * as React from "react";
import * as ReactDOM from "react-dom";

import { isDarkTheme, isFunction } from "../common/utils";

import { show as showLegacyContextMenu } from "./contextMenuLegacy";
import { type Constructor, getDisplayName } from "./legacyCommon";

export const CONTEXTMENU_WARN_DECORATOR_NO_METHOD = `[Blueprint] @ContextMenuTarget-decorated class should implement renderContextMenu.`;
export const CONTEXTMENU_WARN_DECORATOR_NEEDS_REACT_ELEMENT = `[Blueprint] "@ContextMenuTarget-decorated components must return a single React.JSX.Element or an empty render.`;

export interface ContextMenuTargetLegacyComponent extends React.Component {
    render(): React.ReactElement<any> | null | undefined;
    renderContextMenu: (e: React.MouseEvent<HTMLElement>) => React.JSX.Element | undefined;
    onContextMenuClose?: () => void;
}

/**
 * ContextMenuTarget decorator.
 *
 * @see https://blueprintjs.com/docs/#core/components/context-menu.decorator-usage
 * @deprecated use ContextMenu2
 */
export function ContextMenuTargetLegacy<T extends Constructor<ContextMenuTargetLegacyComponent>>(WrappedComponent: T) {
    if (!isFunction(WrappedComponent.prototype.renderContextMenu)) {
        console.warn(CONTEXTMENU_WARN_DECORATOR_NO_METHOD);
    }

    return class ContextMenuTargetClass extends WrappedComponent {
        public static displayName = `ContextMenuTarget(${getDisplayName(WrappedComponent)})`;

        public render() {
            const element = super.render();

            if (element == null) {
                // always return `element` in case caller is distinguishing between `null` and `undefined`
                return element;
            }

            if (!React.isValidElement<any>(element)) {
                console.warn(CONTEXTMENU_WARN_DECORATOR_NEEDS_REACT_ELEMENT);
                return element;
            }
            const oldOnContextMenu = element.props.onContextMenu as React.MouseEventHandler<HTMLElement>;
            const onContextMenu = (e: React.MouseEvent<HTMLElement>) => {
                // support nested menus (inner menu target would have called preventDefault())
                if (e.defaultPrevented) {
                    return;
                }

                if (isFunction(this.renderContextMenu)) {
                    const menu = this.renderContextMenu(e);
                    if (menu != null) {
                        // HACKHACK: see https://github.com/palantir/blueprint/issues/3979
                        /* eslint-disable-next-line react/no-find-dom-node */
                        const darkTheme = isDarkTheme(ReactDOM.findDOMNode(this));
                        e.preventDefault();
                        showLegacyContextMenu(
                            menu,
                            { left: e.clientX, top: e.clientY },
                            this.onContextMenuClose,
                            darkTheme,
                        );
                    }
                }

                oldOnContextMenu?.(e);
            };

            return React.cloneElement(element, { onContextMenu });
        }
    };
}

================================================================================

File: src\legacy\hotkeys-legacy.md
--------------------------------------------------------------------------------
---
tag: deprecated
---

@# Hotkeys (legacy)

<div class="@ns-callout @ns-intent-danger @ns-icon-error @ns-callout-has-body-content">
    <h5 class="@ns-heading">

Deprecated: use [useHotkeys](#core/hooks/use-hotkeys)

</h5>

This API is **deprecated since @blueprintjs/core v3.39.0** in favor of the new
[`useHotkeys` hook](#core/hooks/use-hotkeys) and
[**HotkeysTarget2** component](#core/components/hotkeys-target2). You should migrate to one of
these new APIs, as they will become the standard in future major version of Blueprint.

</div>

Hotkeys enable you to create interactions based on user keyboard events.

To add hotkeys to your React component, use the `@HotkeysTarget` class decorator
and add a `renderHotkeys()` method. The decorator will call `renderHotkeys()`
and attach the appropriate key listeners.

@reactExample HotkeyPiano

@## Usage

1. Add the `@HotkeysTarget` class decorator to your react component.
1. Implement the `renderHotkeys()` method.
1. Define your `<Hotkey>`s inside a `<Hotkeys>` element.

```tsx
import { Hotkey, Hotkeys, HotkeysTarget } from "@blueprintjs/core";
import * as React from "react";

@HotkeysTarget
export class MyComponent extends React.Component {
    public render() {
        return <div>Custom content</div>;
    }

    public renderHotkeys() {
        return (
            <Hotkeys>
                <Hotkey
                    global={true}
                    combo="shift + a"
                    label="Be awesome all the time"
                    onKeyDown={() => console.log("Awesome!")}
                />
                <Hotkey
                    group="Fancy shortcuts"
                    combo="shift + f"
                    label="Be fancy only when focused"
                    onKeyDown={() => console.log("So fancy!")}
                />
            </Hotkeys>
        );
    }
}
```

<div class="@ns-callout @ns-intent-primary @ns-icon-info-sign">

Your decorated component must return a single DOM element in its `render()` method,
not a custom React component. This constraint allows `HotkeysTarget` to inject
event handlers without creating an extra wrapper element.

</div>

@### Decorator

The `@HotkeysTarget` decorator allows you to easily add global and local
hotkeys to any React component. Add the decorator to the top of the class and
make sure to implement the `renderHotkeys` method.

@interface IHotkeysTarget

@### Props

Wrap your `Hotkey`s in the `Hotkeys` element. For example:

```tsx
<Hotkeys>
    <Hotkey label="Quit" combo="ctrl+q" global onKeyDown={handleQuit} />
    <Hotkey label="Save" combo="ctrl+s" group="File" onKeyDown={handleSave} />
</Hotkeys>
```

@interface IHotkeysProps

@interface IHotkeyProps

@## Scope

`Hotkey`s can have either local or global scope. Local hotkeys will only be
triggered when the target is focused, while global hotkeys can be triggered no
matter which element is focused.

Additionally, any keyboard input that occurs inside a text input (such as a
`<textarea>`, `<input>`, or `<div contenteditable>`) is ignored.

@## Dialog

If you define hotkeys for your page, you'll want to display the hotkeys in a
nice format for the user. If you register any global or local hotkeys, we
automatically attach a hotkey `?`, which will display the hotkeys dialog.

The dialog will always include all available global hotkeys, and if you are
focused on an element that has any hotkeys, those will be shown as well.

If you would like to change the style of the dialog (for example, to apply the
dark theme class), call the `setHotkeysDialogProps` function with `IDialogProps`.

================================================================================

File: src\legacy\hotkeysDialogLegacy.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview This component is DEPRECATED, and the code is frozen.
 * All changes & bugfixes should be made to HotkeysDialog2 instead.
 */

/* eslint-disable deprecation/deprecation */

import classNames from "classnames";
import * as React from "react";
import * as ReactDOM from "react-dom";

import { Classes } from "../common";
import { Dialog, DialogBody, type DialogProps, Hotkey, type HotkeyProps, Hotkeys } from "../components";

interface HotkeysDialogProps extends DialogProps {
    /**
     * This string displayed as the group name in the hotkeys dialog for all
     * global hotkeys.
     */
    globalHotkeysGroup?: string;
}

/**
 * The delay before showing or hiding the dialog. Should be long enough to
 * allow all registered hotkey listeners to execute first.
 */
const DELAY_IN_MS = 10;

/** @deprecated use HotkeysDialog2 */
class HotkeysDialogLegacy {
    public componentProps = {
        globalHotkeysGroup: "Global hotkeys",
    } as HotkeysDialogProps;

    private container: HTMLElement | null = null;

    private hotkeysQueue = [] as HotkeyProps[][];

    private isDialogShowing = false;

    private showTimeoutToken?: number;

    private hideTimeoutToken?: number;

    public render() {
        if (this.container == null) {
            this.container = this.getContainer();
        }
        ReactDOM.render(this.renderComponent(), this.container);
    }

    public unmount() {
        if (this.container != null) {
            ReactDOM.unmountComponentAtNode(this.container);
            this.container.remove();
            this.container = null;
        }
    }

    /**
     * Because hotkeys can be registered globally and locally and because
     * event ordering cannot be guaranteed, we use this debouncing method to
     * allow all hotkey listeners to fire and add their hotkeys to the dialog.
     *
     * 10msec after the last listener adds their hotkeys, we render the dialog
     * and clear the queue.
     */
    public enqueueHotkeysForDisplay(hotkeys: HotkeyProps[]) {
        this.hotkeysQueue.push(hotkeys);

        // reset timeout for debounce
        window.clearTimeout(this.showTimeoutToken);
        this.showTimeoutToken = window.setTimeout(this.show, DELAY_IN_MS);
    }

    public hideAfterDelay() {
        window.clearTimeout(this.hideTimeoutToken);
        this.hideTimeoutToken = window.setTimeout(this.hide, DELAY_IN_MS);
    }

    public show = () => {
        this.isDialogShowing = true;
        this.render();
    };

    public hide = () => {
        this.isDialogShowing = false;
        this.render();
    };

    public isShowing() {
        return this.isDialogShowing;
    }

    private getContainer() {
        if (this.container == null) {
            this.container = document.createElement("div");
            this.container.classList.add(Classes.PORTAL);
            document.body.appendChild(this.container);
        }
        return this.container;
    }

    private renderComponent() {
        return (
            <Dialog
                {...this.componentProps}
                className={classNames(Classes.HOTKEY_DIALOG, this.componentProps.className)}
                isOpen={this.isDialogShowing}
                onClose={this.hide}
            >
                <DialogBody>{this.renderHotkeys()}</DialogBody>
            </Dialog>
        );
    }

    private renderHotkeys() {
        const hotkeys = this.emptyHotkeyQueue();
        const elements = hotkeys.map((hotkey, index) => {
            const group =
                hotkey.global === true && hotkey.group == null ? this.componentProps.globalHotkeysGroup : hotkey.group;

            return <Hotkey key={index} {...hotkey} group={group} />;
        });

        return <Hotkeys>{elements}</Hotkeys>;
    }

    private emptyHotkeyQueue() {
        // flatten then empty the hotkeys queue
        const hotkeys = this.hotkeysQueue.reduce((arr, queued) => arr.concat(queued), []);
        this.hotkeysQueue.length = 0;
        return hotkeys;
    }
}

// singleton instance
const HOTKEYS_DIALOG = new HotkeysDialogLegacy();

/** @deprecated use HotkeysProvider */
export function isHotkeysDialogShowing() {
    return HOTKEYS_DIALOG.isShowing();
}

/** @deprecated use HotkeysProvider */
export function setHotkeysDialogProps(props: Partial<HotkeysDialogProps>) {
    for (const key in props) {
        if (props.hasOwnProperty(key)) {
            (HOTKEYS_DIALOG.componentProps as any)[key] = (props as any)[key];
        }
    }
}

/** @deprecated use HotkeysProvider */
export function showHotkeysDialog(hotkeys: HotkeyProps[]) {
    HOTKEYS_DIALOG.enqueueHotkeysForDisplay(hotkeys);
}

/** @deprecated use HotkeysProvider */
export function hideHotkeysDialog() {
    HOTKEYS_DIALOG.hide();
}

/**
 * Use this function instead of `hideHotkeysDialog` if you need to ensure that all hotkey listeners
 * have time to execute with the dialog in a consistent open state. This can avoid flickering the
 * dialog between open and closed states as successive listeners fire.
 *
 * @deprecated use HotkeysProvider
 */
export function hideHotkeysDialogAfterDelay() {
    HOTKEYS_DIALOG.hideAfterDelay();
}

================================================================================

File: src\legacy\hotkeysEvents.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview This component is DEPRECATED, and the code is frozen.
 * All changes & bugfixes should be made to HotkeysDialog2 instead.
 */

/* eslint-disable deprecation/deprecation */

import { Children, type ReactNode } from "react";

import { isElementOfType } from "../common/utils";
import { Hotkey, type HotkeyProps, type HotkeysProps } from "../components/hotkeys";
import { comboMatches, getKeyCombo, type KeyCombo, parseKeyCombo } from "../components/hotkeys/hotkeyParser";

import { hideHotkeysDialogAfterDelay, isHotkeysDialogShowing, showHotkeysDialog } from "./hotkeysDialogLegacy";

const SHOW_DIALOG_KEY = "?";

export enum HotkeyScope {
    LOCAL = "local",
    GLOBAL = "global",
}

export interface IHotkeyAction {
    combo: KeyCombo;
    props: HotkeyProps;
}

export class HotkeysEvents {
    private actions = [] as IHotkeyAction[];

    public constructor(private scope: HotkeyScope) {}

    public count() {
        return this.actions.length;
    }

    public clear() {
        this.actions = [];
    }

    public setHotkeys(props: HotkeysProps & { children?: ReactNode }) {
        const actions = [] as IHotkeyAction[];
        Children.forEach(props.children, (child: ReactNode) => {
            if (isElementOfType(child, Hotkey) && this.isScope(child.props)) {
                actions.push({
                    combo: parseKeyCombo(child.props.combo),
                    props: child.props,
                });
            }
        });
        this.actions = actions;
    }

    public handleKeyDown = (e: KeyboardEvent) => {
        const combo = getKeyCombo(e);
        const isTextInput = this.isTextInput(e);

        if (!isTextInput && comboMatches(parseKeyCombo(SHOW_DIALOG_KEY), combo)) {
            if (isHotkeysDialogShowing()) {
                hideHotkeysDialogAfterDelay();
            } else {
                showHotkeysDialog(this.actions.map(action => action.props));
            }
            return;
        } else if (isHotkeysDialogShowing()) {
            return;
        }

        this.invokeNamedCallbackIfComboRecognized(combo, "onKeyDown", e);
    };

    public handleKeyUp = (e: KeyboardEvent) => {
        if (isHotkeysDialogShowing()) {
            return;
        }
        this.invokeNamedCallbackIfComboRecognized(getKeyCombo(e), "onKeyUp", e);
    };

    private invokeNamedCallbackIfComboRecognized(
        combo: KeyCombo,
        callbackName: "onKeyDown" | "onKeyUp",
        e: KeyboardEvent,
    ) {
        const isTextInput = this.isTextInput(e);
        for (const action of this.actions) {
            const shouldIgnore = (isTextInput && !action.props.allowInInput) || action.props.disabled;
            if (!shouldIgnore && comboMatches(action.combo, combo)) {
                if (action.props.preventDefault) {
                    e.preventDefault();
                }
                if (action.props.stopPropagation) {
                    // set a flag just for unit testing. not meant to be referenced in feature work.
                    (e as any).isPropagationStopped = true;
                    e.stopPropagation();
                }
                action.props[callbackName]?.(e);
            }
        }
    }

    private isScope(props: HotkeyProps) {
        return (props.global ? HotkeyScope.GLOBAL : HotkeyScope.LOCAL) === this.scope;
    }

    private isTextInput(e: KeyboardEvent) {
        const elem = e.target as HTMLElement;
        // we check these cases for unit testing, but this should not happen
        // during normal operation
        if (elem == null || elem.closest == null) {
            return false;
        }

        const editable = elem.closest("input, textarea, [contenteditable=true]");

        if (editable == null) {
            return false;
        }

        // don't let checkboxes, switches, and radio buttons prevent hotkey behavior
        if (editable.tagName.toLowerCase() === "input") {
            const inputType = (editable as HTMLInputElement).type;
            if (inputType === "checkbox" || inputType === "radio") {
                return false;
            }
        }

        // don't let read-only fields prevent hotkey behavior
        if ((editable as HTMLInputElement).readOnly) {
            return false;
        }

        return true;
    }
}

================================================================================

File: src\legacy\hotkeysTargetLegacy.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview This component is DEPRECATED, and the code is frozen.
 * All changes & bugfixes should be made to HotkeysTarget2 instead.
 */

/* eslint-disable deprecation/deprecation */

import * as React from "react";

import { isFunction } from "../common/utils";
import type { HotkeysProps } from "../components/hotkeys";

import { HotkeyScope, HotkeysEvents } from "./hotkeysEvents";
import { type Constructor, getDisplayName } from "./legacyCommon";

const HOTKEYS_WARN_DECORATOR_NO_METHOD = `[Blueprint] @HotkeysTargetLegacy-decorated class should implement renderHotkeys.`;
const HOTKEYS_WARN_DECORATOR_NEEDS_REACT_ELEMENT = `[Blueprint] "@HotkeysTargetLegacy-decorated components must return a single React.JSX.Element or an empty render.`;

export interface HotkeysTargetLegacyComponent extends React.Component {
    /** Components decorated with the `@HotkeysTargetLegacy` decorator must implement React's component `render` function. */
    render(): React.ReactElement<any> | null | undefined;

    /**
     * Components decorated with the `@HotkeysTargetLegacy` decorator must implement
     * this method, and it must return a `Hotkeys` React element.
     */
    renderHotkeys: () => React.ReactElement<HotkeysProps>;
}

/** @deprecated use `useHotkeys` hook or `<HotkeysTarget2>` component */
export function HotkeysTargetLegacy<T extends Constructor<HotkeysTargetLegacyComponent>>(WrappedComponent: T) {
    if (!isFunction(WrappedComponent.prototype.renderHotkeys)) {
        console.warn(HOTKEYS_WARN_DECORATOR_NO_METHOD);
    }

    return class HotkeysTargetClass extends WrappedComponent {
        public static displayName = `HotkeysTarget(${getDisplayName(WrappedComponent)})`;

        /** @internal */
        public globalHotkeysEvents: HotkeysEvents = new HotkeysEvents(HotkeyScope.GLOBAL);

        /** @internal */
        public localHotkeysEvents: HotkeysEvents = new HotkeysEvents(HotkeyScope.LOCAL);

        public componentDidMount() {
            if (super.componentDidMount != null) {
                super.componentDidMount();
            }

            // attach global key event listeners
            document.addEventListener("keydown", this.globalHotkeysEvents.handleKeyDown);
            document.addEventListener("keyup", this.globalHotkeysEvents.handleKeyUp);
        }

        public componentWillUnmount() {
            super.componentWillUnmount?.();
            document.removeEventListener("keydown", this.globalHotkeysEvents.handleKeyDown);
            document.removeEventListener("keyup", this.globalHotkeysEvents.handleKeyUp);

            this.globalHotkeysEvents.clear();
            this.localHotkeysEvents.clear();
        }

        public render() {
            const element = super.render() as React.JSX.Element;

            if (element == null) {
                // always return `element` in case caller is distinguishing between `null` and `undefined`
                return element;
            }

            if (!React.isValidElement<any>(element)) {
                console.warn(HOTKEYS_WARN_DECORATOR_NEEDS_REACT_ELEMENT);
                return element;
            }

            if (isFunction(this.renderHotkeys)) {
                const hotkeys = this.renderHotkeys();
                if (this.localHotkeysEvents) {
                    this.localHotkeysEvents.setHotkeys(hotkeys.props);
                }
                if (this.globalHotkeysEvents) {
                    this.globalHotkeysEvents.setHotkeys(hotkeys.props);
                }

                if (this.localHotkeysEvents.count() > 0) {
                    const tabIndex = hotkeys.props.tabIndex === undefined ? 0 : hotkeys.props.tabIndex;

                    const { onKeyDown: existingKeyDown, onKeyUp: existingKeyUp } = element.props;

                    const handleKeyDownWrapper = (e: React.KeyboardEvent<HTMLElement>) => {
                        this.localHotkeysEvents.handleKeyDown(e.nativeEvent as KeyboardEvent);
                        existingKeyDown?.(e);
                    };

                    const handleKeyUpWrapper = (e: React.KeyboardEvent<HTMLElement>) => {
                        this.localHotkeysEvents.handleKeyUp(e.nativeEvent as KeyboardEvent);
                        existingKeyUp?.(e);
                    };
                    return React.cloneElement(element, {
                        onKeyDown: handleKeyDownWrapper,
                        onKeyUp: handleKeyUpWrapper,
                        tabIndex,
                    });
                }
            }
            return element;
        }
    };
}

================================================================================

File: src\legacy\legacy.md
--------------------------------------------------------------------------------
@# Legacy APIs

<!-- Exact ordering of items in the navbar: -->

@page hotkeys-legacy

================================================================================

File: src\legacy\legacyCommon.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Represents anything that has a `name` property such as Functions.
 */
export interface Named {
    name?: string;
}

/**
 * Generic interface defining constructor types, such as classes. This is used to type the class
 * itself in meta-programming situations such as decorators.
 */
export type Constructor<T> = new (...args: any[]) => T;

export function getDisplayName(ComponentClass: React.ComponentType | Named) {
    return (ComponentClass as React.ComponentType).displayName || (ComponentClass as Named).name || "Unknown";
}

================================================================================

File: test\index.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import "../lib/css/blueprint.css";

import "@blueprintjs/test-commons/bootstrap";

// common
import "./common/propsTests";
import "./common/utils/compareUtilsTests";
import "./common/utilsTests";

// components
import "./alert/alertTests";
import "./breadcrumbs/breadcrumbTests";
import "./breadcrumbs/breadcrumbsTests";
import "./buttons/buttonTests";
import "./callout/calloutTests";
import "./card-list/cardListTests";
import "./card/cardTests";
import "./collapse/collapseTests";
import "./context-menu/contextMenuSingletonTests";
import "./context-menu/contextMenuTests";
import "./controls/controlsTests";
import "./controls/inputGroupTests";
import "./control-card/controlCardTests";
import "./controls/numericInputTests";
import "./controls/radioGroupTests";
import "./dialog/dialogTests";
import "./drawer/drawerTests";
import "./editable-text/editableTextTests";
import "./entity-title/entityTitleTests";
import "./forms/asyncControllableInputTests";
import "./forms/fileInputTests";
import "./forms/formGroupTests";
import "./forms/textAreaTests";
import "./hotkeys/hotkeyTests";
import "./hotkeys/hotkeysParserTests";
import "./hotkeys/keyComboTagTests";
import "./html-select/htmlSelectTests";
import "./html/htmlTests";
import "./icon/iconTests";
import "./menu/menuItemTests";
import "./menu/menuTests";
import "./multistep-dialog/multistepDialogTests";
import "./non-ideal-state/nonIdealStateTests";
import "./overflow-list/overflowListTests";
import "./overlay/overlayTests";
import "./overlay2/overlay2Tests";
import "./panel-stack/panelStackTests";
import "./panel-stack2/panelStack2Tests";
import "./popover/popoverTests";
import "./popover/popperUtilTests";
import "./portal/portalTests";
import "./progress/progressBarTests";
import "./resize-sensor/resizeSensorTests";
import "./section/sectionTests";
import "./segmented-control/segmentedControlTests";
import "./slider/handleTests";
import "./slider/multiSliderTests";
import "./slider/rangeSliderTests";
import "./slider/sliderTests";
import "./spinner/spinnerTests";
import "./tabs/tabsTests";
import "./tag-input/tagInputTests";
import "./tag/compoundTagTests";
import "./tag/tagTests";
import "./text/textTests";
import "./toast/overlayToasterTests";
import "./toast/toastTests";
import "./toast/toast2Tests";
import "./toast/toasterTests";
import "./tooltip/tooltipTests";
import "./tree/treeTests";

// hooks
import "./hooks/useHotkeysTests";
import "./hooks/useOverlayStackTests";

================================================================================

File: test\isotest.mjs
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// @ts-check

import "@blueprintjs/test-commons/bootstrap";
import React from "react";

import { generateIsomorphicTests } from "@blueprintjs/test-commons";

import Core from "../lib/cjs/index.js";

const requiredChild = React.createElement("button");
const EXAMPLE_HOTKEY_CONFIG = { combo: "mod+s", global: true, label: "save" };

describe("@blueprintjs/core isomorphic rendering", () => {
    generateIsomorphicTests(
        Core,
        {
            Alert: {
                props: { isOpen: true, lazy: false, usePortal: false },
            },
            BlueprintProvider: {
                className: false,
            },
            Breadcrumbs: {
                props: { items: [] },
            },
            ContextMenu: {
                props: { children: React.createElement("div"), content: React.createElement("div") },
            },
            Dialog: {
                props: { isOpen: true, lazy: false, usePortal: false },
            },
            Drawer: {
                props: { isOpen: true, lazy: false, usePortal: false },
            },
            Hotkey: {
                props: EXAMPLE_HOTKEY_CONFIG,
            },
            Hotkeys: {
                children: React.createElement(Core.Hotkey, EXAMPLE_HOTKEY_CONFIG),
            },
            HotkeysDialog2: {
                props: {
                    hotkeys: [EXAMPLE_HOTKEY_CONFIG],
                    isOpen: true,
                    lazy: false,
                    usePortal: false,
                },
            },
            HotkeysProvider: {
                className: false,
            },
            HotkeysTarget2: {
                props: {
                    hotkeys: [EXAMPLE_HOTKEY_CONFIG],
                },
                children: requiredChild,
                className: false,
            },
            Icon: {
                props: { icon: "build" },
            },
            MultistepDialog: {
                props: { isOpen: true, lazy: false, usePortal: false },
                children: React.createElement(Core.DialogStep, {
                    key: 1,
                    id: 1,
                    title: "Step one",
                    panel: React.createElement("div"),
                }),
            },
            KeyComboTag: {
                props: { combo: "?" },
            },
            OverflowList: {
                props: { items: [], overflowRenderer: () => null, visibleItemRenderer: () => null },
            },
            Overlay: {
                props: { lazy: false, usePortal: false },
            },
            Overlay2: {
                props: { lazy: false, usePortal: false },
            },
            OverlaysProvider: {
                className: false,
            },
            OverlayToaster: {
                props: { usePortal: false },
                children: React.createElement(Core.Toast2, { message: "Toast" }),
            },
            PanelStack: {
                props: {
                    initialPanel: { component: () => null, props: {}, title: "" },
                },
                children: "",
            },
            PanelStack2: {
                props: {
                    initialPanel: { renderPanel: () => null, props: {}, title: "" },
                },
                children: "",
            },
            Portal: {
                className: false, // only renders in browser (`document`)
            },
            Popover: {
                children: requiredChild,
            },
            PortalProvider: {
                className: false,
            },
            ResizeSensor: {
                children: requiredChild,
                className: false,
            },
            Tabs: {
                children: React.createElement(Core.Tab, { key: 1, id: 1, title: "Tab one" }),
            },
            TabsExpander: {
                className: false,
            },
            TagInput: {
                props: { values: ["foo", "bar", "baz"] },
            },
            Tooltip: {
                props: { content: React.createElement("h1", {}, "content") },
                children: requiredChild,
            },
        },
        {
            excludedSymbols: [
                "AbstractComponent",
                "AbstractComponent2",
                "AbstractPureComponent",
                "AbstractPureComponent2",
                "ContextMenuTargetLegacy",
                "Expander",
                "HotkeysTarget",
            ],
        },
    );
});

================================================================================

File: test\tsconfig.json
--------------------------------------------------------------------------------
{
    "extends": "../src/tsconfig",
    "compilerOptions": {
        "declaration": false,
        "downlevelIteration": true,
        "lib": ["dom", "dom.iterable", "es5", "es2015.collection", "es2015.iterable", "es2015.promise"],
        "noEmit": true,
    },
}

================================================================================

File: test\utils.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { ReactWrapper } from "enzyme";

import { Portal } from "../src";

export function findInPortal<P>(overlay: ReactWrapper<P>, selector: string) {
    // React 16: createPortal preserves React tree so simple find works.
    const element = overlay.find(Portal).find(selector);
    if (element.exists()) {
        return element;
    }

    // React 15: unstable_renderSubtree does not preserve tree so we must create new wrapper.
    const portal = overlay.find(Portal).instance();
    const portalChildren = new ReactWrapper(portal.props.children as React.JSX.Element[]);
    if (portalChildren.is(selector)) {
        return portalChildren;
    }
    return portalChildren.find(selector);
}

export async function sleep(timeout?: number) {
    return new Promise(resolve => window.setTimeout(resolve, timeout));
}

================================================================================

File: test\alert\alertTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, shallow, type ShallowWrapper } from "enzyme";
import * as React from "react";
import { type SinonStub, spy, stub } from "sinon";

import { WarningSign } from "@blueprintjs/icons";

import { Alert, type AlertProps, Button, type ButtonProps, Classes, Icon, Intent } from "../../src";
import * as Errors from "../../src/common/errors";
import { findInPortal } from "../utils";

describe("<Alert>", () => {
    let testsContainerElement: HTMLElement | undefined;

    beforeEach(() => {
        testsContainerElement = document.createElement("div");
        document.body.appendChild(testsContainerElement);
    });

    afterEach(() => {
        testsContainerElement?.remove();
    });

    it("renders its content correctly", () => {
        const noop = () => true;
        const wrapper = shallow(
            <Alert
                className="test-class"
                isOpen={true}
                confirmButtonText="Delete"
                cancelButtonText="Cancel"
                onClose={noop}
            >
                <p>Are you sure you want to delete this file?</p>
                <p>There is no going back.</p>
            </Alert>,
        );

        assert.lengthOf(wrapper.find(`.${Classes.ALERT}.test-class`), 1);
        assert.lengthOf(wrapper.find(`.${Classes.ALERT_BODY}`), 1);
        assert.lengthOf(wrapper.find(`.${Classes.ALERT_CONTENTS}`), 1);
        assert.lengthOf(wrapper.find(`.${Classes.ALERT_FOOTER}`), 1);
    });

    it("renders contents to specified container correctly", () => {
        const container = document.createElement("div");
        document.body.appendChild(container);
        mount(
            <Alert isOpen={true} portalContainer={container}>
                <p>Are you sure you want to delete this file?</p>
                <p>There is no going back.</p>
            </Alert>,
            { attachTo: testsContainerElement },
        );
        assert.lengthOf(container.getElementsByClassName(Classes.ALERT), 1);
        document.body.removeChild(container);
    });

    it("renders the icon correctly", () => {
        const wrapper = shallow(
            <Alert icon={<WarningSign />} isOpen={true} confirmButtonText="Delete">
                <p>Are you sure you want to delete this file?</p>
                <p>There is no going back.</p>
            </Alert>,
        );

        assert.lengthOf(wrapper.find(Icon), 1);
    });

    it("supports overlay lifecycle props", () => {
        const onOpening = spy();
        const wrapper = mount(
            <Alert isOpen={true} onOpening={onOpening}>
                Alert
                <p>Are you sure you want to delete this file?</p>
                <p>There is no going back.</p>
            </Alert>,
            { attachTo: testsContainerElement },
        );
        assert.isTrue(onOpening.calledOnce);
        wrapper.unmount();
    });

    describe("confirm button", () => {
        const onConfirm = spy();
        const onClose = spy();
        let wrapper: ShallowWrapper<AlertProps, any>;

        beforeEach(() => {
            onConfirm.resetHistory();
            onClose.resetHistory();
            wrapper = shallow(
                <Alert
                    icon={<WarningSign />}
                    intent={Intent.PRIMARY}
                    isOpen={true}
                    confirmButtonText="Delete"
                    onConfirm={onConfirm}
                    onClose={onClose}
                >
                    <p>Are you sure you want to delete this file?</p>
                    <p>There is no going back.</p>
                </Alert>,
            );
        });

        afterEach(() => wrapper.unmount());

        it("text is confirmButtonText", () => {
            assert.equal(wrapper.find(Button).prop("text"), "Delete");
        });

        it("intent inherited from prop", () => {
            assert.equal(wrapper.find(Button).prop("intent"), Intent.PRIMARY);
        });

        it("onConfirm and onClose triggered on click", () => {
            wrapper.find(Button).simulate("click");
            assert.isTrue(onConfirm.calledOnce);
            assert.isTrue(onClose.calledOnce);
            assert.strictEqual(onClose.args[0][0], true);
        });
    });

    describe("cancel button", () => {
        const onCancel = spy();
        const onClose = spy();
        let wrapper: ShallowWrapper<AlertProps, any>;
        let cancelButton: ShallowWrapper<ButtonProps, any>;

        beforeEach(() => {
            onCancel.resetHistory();
            onClose.resetHistory();
            wrapper = shallow(
                <Alert
                    icon={<WarningSign />}
                    intent={Intent.PRIMARY}
                    isOpen={true}
                    cancelButtonText="Cancel"
                    confirmButtonText="Delete"
                    onCancel={onCancel}
                    onClose={onClose}
                >
                    <p>Are you sure you want to delete this file?</p>
                    <p>There is no going back.</p>
                </Alert>,
            );
            cancelButton = wrapper.find(Button).last();
        });

        afterEach(() => wrapper.unmount());

        it("text is cancelButtonText", () => {
            assert.equal(cancelButton.prop("text"), "Cancel");
        });

        it("intent is undefined", () => {
            assert.isUndefined(cancelButton.prop("intent"));
        });

        it("onCancel and onClose triggered on click", () => {
            cancelButton.simulate("click");
            assert.isTrue(onCancel.calledOnce);
            assert.isTrue(onClose.calledOnce);
            assert.strictEqual(onClose.args[0][0], false);
        });

        it("canEscapeKeyCancel enables escape key", () => {
            const alert = mount<AlertProps>(
                <Alert isOpen={true} cancelButtonText="Cancel" confirmButtonText="Delete" onCancel={onCancel}>
                    <p>Are you sure you want to delete this file?</p>
                    <p>There is no going back.</p>
                </Alert>,
                { attachTo: testsContainerElement },
            );
            const overlay = findInPortal(alert, "." + Classes.OVERLAY).first();

            overlay.simulate("keydown", { key: "Escape" });
            assert.isTrue(onCancel.notCalled);

            alert.setProps({ canEscapeKeyCancel: true });
            overlay.simulate("keydown", { key: "Escape" });
            assert.isTrue(onCancel.calledOnce);

            alert.unmount();
        });

        it("canOutsideClickCancel enables outside click", () => {
            const alert = mount<AlertProps>(
                <Alert isOpen={true} cancelButtonText="Cancel" confirmButtonText="Delete" onCancel={onCancel}>
                    <p>Are you sure you want to delete this file?</p>
                    <p>There is no going back.</p>
                </Alert>,
                { attachTo: testsContainerElement },
            );
            const backdrop = findInPortal(alert, "." + Classes.OVERLAY_BACKDROP).hostNodes();

            backdrop.simulate("mousedown");
            assert.isTrue(onCancel.notCalled);

            alert.setProps({ canOutsideClickCancel: true });
            backdrop.simulate("mousedown");
            assert.isTrue(onCancel.calledOnce);

            alert.unmount();
        });
    });

    describe("load state", () => {
        let wrapper: ShallowWrapper<AlertProps, any>;
        let findCancelButton: () => ShallowWrapper<ButtonProps, any>;
        let findSubmitButton: () => ShallowWrapper<ButtonProps, any>;

        beforeEach(() => {
            wrapper = shallow(
                <Alert
                    icon={<WarningSign />}
                    intent={Intent.PRIMARY}
                    isOpen={true}
                    loading={true}
                    cancelButtonText="Cancel"
                    confirmButtonText="Delete"
                >
                    <p>Are you sure you want to delete this file?</p>
                    <p>There is no going back.</p>
                </Alert>,
            );
            findSubmitButton = () => wrapper.find(Button).first();
            findCancelButton = () => wrapper.find(Button).last();
        });

        it("Properly displays buttons when set to loading", () => {
            assert.isTrue(findCancelButton().prop("disabled"));
            assert.isTrue(findSubmitButton().prop("loading"));
            wrapper.setProps({ loading: false });
            assert.isFalse(findCancelButton().prop("disabled"));
            assert.isFalse(findSubmitButton().prop("loading"));
        });
    });

    describe("warnings", () => {
        let warnSpy: SinonStub;
        before(() => (warnSpy = stub(console, "warn")));
        afterEach(() => warnSpy.resetHistory());
        after(() => warnSpy.restore());

        it("cancelButtonText without cancel handler", () => {
            testWarn(<Alert cancelButtonText="cancel" isOpen={false} />, Errors.ALERT_WARN_CANCEL_PROPS);
        });

        it("canEscapeKeyCancel without cancel handler", () => {
            testWarn(<Alert canEscapeKeyCancel={true} isOpen={false} />, Errors.ALERT_WARN_CANCEL_ESCAPE_KEY);
        });

        it("canOutsideClickCancel without cancel handler", () => {
            testWarn(<Alert canOutsideClickCancel={true} isOpen={false} />, Errors.ALERT_WARN_CANCEL_OUTSIDE_CLICK);
        });

        function testWarn(alert: React.JSX.Element, warning: string) {
            // one warning
            const wrapper = shallow(alert);
            assert.strictEqual(warnSpy.callCount, 1);
            assert.isTrue(warnSpy.calledWithExactly(warning));
            // no more warnings
            wrapper
                .setProps({ onClose: () => true })
                .setProps({ cancelButtonText: "cancel", onCancel: () => true, onClose: undefined });
            assert.strictEqual(warnSpy.callCount, 1);
        }
    });
});

================================================================================

File: test\breadcrumbs\breadcrumbsTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount } from "enzyme";
import * as React from "react";
import sinon from "sinon";

import { Classes } from "../../src/common";
import { Boundary } from "../../src/common/boundary";
import { Breadcrumb, type BreadcrumbProps } from "../../src/components/breadcrumbs/breadcrumb";
import { Breadcrumbs } from "../../src/components/breadcrumbs/breadcrumbs";
import { MenuItem } from "../../src/components/menu/menuItem";
import { OverflowList, type OverflowListProps } from "../../src/components/overflow-list/overflowList";

const ITEMS: BreadcrumbProps[] = [{ text: "1" }, { text: "2" }, { text: "3" }];

describe("Breadcrumbs", () => {
    let containerElement: HTMLElement | undefined;

    beforeEach(() => {
        containerElement = document.createElement("div");
        document.body.appendChild(containerElement);
    });
    afterEach(() => {
        containerElement?.remove();
    });

    it("passes through props to the OverflowList", () => {
        const wrapper = mount(
            <Breadcrumbs
                className="breadcrumbs-class"
                collapseFrom={Boundary.END}
                items={[]}
                minVisibleItems={7}
                overflowListProps={{ className: "overflow-list-class", tagName: "article" }}
            />,
            { attachTo: containerElement },
        );
        const overflowListProps = wrapper.find<OverflowListProps<BreadcrumbProps>>(OverflowList).props();
        assert.equal(overflowListProps.className, `${Classes.BREADCRUMBS} overflow-list-class breadcrumbs-class`);
        assert.equal(overflowListProps.collapseFrom, Boundary.END);
        assert.equal(overflowListProps.minVisibleItems, 7);
        assert.equal(overflowListProps.tagName, "article");
    });

    it("makes the last breadcrumb current", () => {
        const wrapper = mount(<Breadcrumbs items={ITEMS} minVisibleItems={ITEMS.length} />, {
            attachTo: containerElement,
        });
        const breadcrumbs = wrapper.find(Breadcrumb);
        assert.lengthOf(breadcrumbs, ITEMS.length);
        assert.isFalse(breadcrumbs.get(0).props.current);
        assert.isTrue(breadcrumbs.get(ITEMS.length - 1).props.current);
    });

    it("renders overflow/collapsed indicator when items don't fit", () => {
        const wrapper = mount(
            // 70px is just enough to show one item
            <div style={{ width: 70 }}>
                <Breadcrumbs items={ITEMS} />
            </div>,
            { attachTo: containerElement },
        );
        assert.lengthOf(wrapper.find(`.${Classes.BREADCRUMBS_COLLAPSED}`), 1);
    });

    it("renders the correct overflow menu items", () => {
        const wrapper = mount(
            // 70px is just enough to show one item
            <div style={{ width: 70 }}>
                <Breadcrumbs items={ITEMS} popoverProps={{ isOpen: true, usePortal: false }} />
            </div>,
            { attachTo: containerElement },
        );
        const menuItems = wrapper.find(MenuItem);
        assert.lengthOf(menuItems, ITEMS.length - 1);
        assert.equal(menuItems.get(0).props.text, "2");
        assert.equal(menuItems.get(1).props.text, "1");
    });

    it("renders the correct overflow menu items when collapsing from END", () => {
        const wrapper = mount(
            // 70px is just enough to show one item
            <div style={{ width: 70 }}>
                <Breadcrumbs
                    collapseFrom={Boundary.END}
                    items={ITEMS}
                    popoverProps={{ isOpen: true, usePortal: false }}
                />
            </div>,
            { attachTo: containerElement },
        );
        const menuItems = wrapper.find(MenuItem);
        assert.lengthOf(menuItems, ITEMS.length - 1);
        assert.equal(menuItems.get(0).props.text, "2");
        assert.equal(menuItems.get(1).props.text, "3");
    });

    it("disables menu item when it is not clickable", () => {
        const wrapper = mount(
            // 10px is too small to show any items
            <div style={{ width: 10 }}>
                <Breadcrumbs items={ITEMS} popoverProps={{ isOpen: true, usePortal: false }} />
            </div>,
            { attachTo: containerElement },
        );
        const menuItems = wrapper.find(MenuItem);
        assert.lengthOf(menuItems, ITEMS.length);
        assert.isTrue(menuItems.get(0).props.disabled);
    });

    it("calls currentBreadcrumbRenderer (only) for the current breadcrumb", () => {
        const spy = sinon.spy();
        mount(<Breadcrumbs currentBreadcrumbRenderer={spy} items={ITEMS} minVisibleItems={ITEMS.length} />, {
            attachTo: containerElement,
        });
        assert.isTrue(spy.calledOnce);
        assert.isTrue(spy.calledWith(ITEMS[ITEMS.length - 1]));
    });

    it("does not call breadcrumbRenderer for the current breadcrumb when there is a currentBreadcrumbRenderer", () => {
        const spy = sinon.spy();
        mount(
            <Breadcrumbs
                breadcrumbRenderer={spy}
                currentBreadcrumbRenderer={() => <div />}
                items={ITEMS}
                minVisibleItems={ITEMS.length}
            />,
            { attachTo: containerElement },
        );
        assert.equal(spy.callCount, ITEMS.length - 1);
        assert.isTrue(spy.neverCalledWith(ITEMS[ITEMS.length - 1]));
    });

    it("calls breadcrumbRenderer", () => {
        const spy = sinon.spy();
        mount(<Breadcrumbs breadcrumbRenderer={spy} items={ITEMS} minVisibleItems={ITEMS.length} />, {
            attachTo: containerElement,
        });
        assert.equal(spy.callCount, ITEMS.length);
    });
});

================================================================================

File: test\breadcrumbs\breadcrumbTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, shallow } from "enzyme";
import * as React from "react";
import { spy } from "sinon";

import { FolderClose } from "@blueprintjs/icons";

import { Breadcrumb, Classes, Icon } from "../../src";

describe("Breadcrumb", () => {
    it("renders its contents", () => {
        const wrapper = shallow(<Breadcrumb className="foo" text="Hello" />);
        assert.isTrue(wrapper.hasClass(Classes.BREADCRUMB));
        assert.isTrue(wrapper.hasClass("foo"));
        assert.strictEqual(wrapper.text(), "Hello");
    });

    it("clicking triggers onClick", () => {
        const onClick = spy();
        shallow(<Breadcrumb onClick={onClick} text="Hello" />).simulate("click");
        assert.isTrue(onClick.calledOnce, "onClick not called once");
    });

    it("clicking disabled does not trigger onClick", () => {
        const onClick = spy();
        shallow(<Breadcrumb disabled={true} onClick={onClick} text="Hello" />).simulate("click");
        assert.isTrue(onClick.notCalled, "onClick called");
    });

    it("renders an a tag if it's clickable", () => {
        assert.lengthOf(shallow(<Breadcrumb href="test" />).find("a"), 1);
        assert.lengthOf(shallow(<Breadcrumb href="test" />).find("span"), 0);
    });

    it("renders a span tag if it's not clickable", () => {
        assert.lengthOf(shallow(<Breadcrumb />).find("a"), 0);
        assert.lengthOf(shallow(<Breadcrumb />).find("span"), 1);
    });

    it("renders an icon if one is provided", () => {
        assert.lengthOf(mount(<Breadcrumb />).find(Icon), 0);
        assert.lengthOf(mount(<Breadcrumb icon={<FolderClose />} />).find(FolderClose), 1);
    });
});

================================================================================

File: test\buttons\abstractButtonTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { shallow } from "enzyme";
import * as React from "react";

import { Alignment, AnchorButton, Button } from "../../src";

describe("ButtonProps", () => {
    describe("(omitting 'ref' prop) should be assignable to", () => {
        const buttonProps = {
            active: true,
            alignText: Alignment.LEFT,
            fill: true,
            onClick: (_event: React.MouseEvent<HTMLElement>) => {
                /* no-op */
            },
            outlined: true,
        };

        it("<Button> component", () => {
            shallow(<Button {...buttonProps} />);
        });

        it("<AnchorButton> component", () => {
            shallow(<AnchorButton {...buttonProps} />);
        });
    });
});

================================================================================

File: test\buttons\buttonTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount } from "enzyme";
import * as React from "react";
import { spy } from "sinon";

import { AnchorButton, Button, type ButtonProps, Classes, Icon, Spinner } from "../../src";

describe("Buttons:", () => {
    buttonTestSuite(Button, "button");
    buttonTestSuite(AnchorButton, "a");
});

function buttonTestSuite(component: React.FC<any>, tagName: string) {
    describe(`<${component.displayName!.split(".")[1]}>`, () => {
        let containerElement: HTMLElement | undefined;

        beforeEach(() => {
            containerElement = document.createElement("div");
            document.body.appendChild(containerElement);
        });
        afterEach(() => {
            containerElement?.remove();
        });

        it("renders its contents", () => {
            const wrapper = button({ className: "foo" });
            const el = wrapper.find(tagName);
            assert.isTrue(el.exists());
            assert.isTrue(el.hasClass(Classes.BUTTON));
            assert.isTrue(el.hasClass("foo"));
        });

        it('icon="style" renders Icon as first child', () => {
            const wrapper = button({ icon: "style" });
            const firstChild = wrapper.find(Icon).at(0);
            assert.strictEqual(firstChild.prop("icon"), "style");
        });

        it("renders the button text prop", () => {
            const wrapper = button({ text: "some text" }, true);
            assert.equal(wrapper.text(), "some text");
        });

        it("renders the button text prop", () => {
            const wrapper = mount(<Button data-test-foo="bar" />);
            assert.isTrue(wrapper.find('[data-test-foo="bar"]').exists());
        });

        it("wraps string children in spans", () => {
            // so text can be hidden when loading
            const wrapper = button({}, "raw string", <em>not a string</em>);
            assert.equal(wrapper.find("span").length, 1, "span not found");
            assert.equal(wrapper.find("em").length, 1, "em not found");
        });

        it("renders span if text={0}", () => {
            const wrapper = button({ text: 0 }, true);
            assert.equal(wrapper.text(), "0");
        });

        it('doesn\'t render a text span if children=""', () => {
            const wrapper = button({}, "");
            assert.equal(wrapper.find("span").length, 0);
        });

        it('doesn\'t render a text span if text=""', () => {
            const wrapper = button({ text: "" });
            assert.equal(wrapper.find("span").length, 0);
        });

        it("accepts textClassName prop", () => {
            const wrapper = button({ text: "text", textClassName: "text-class" });
            assert.isTrue(wrapper.find(".text-class").exists());
        });

        it("renders a loading spinner when the loading prop is true", () => {
            const wrapper = button({ loading: true });
            assert.lengthOf(wrapper.find(Spinner), 1);
        });

        it("button is disabled when the loading prop is true", () => {
            const wrapper = button({ loading: true });
            assert.isTrue(wrapper.find(tagName).hasClass(Classes.DISABLED));
        });

        // This tests some subtle (potentialy unexpected) behavior, but it was an API decision we
        // made a long time ago which we rely on and should not break.
        // See https://github.com/palantir/blueprint/issues/3819#issuecomment-1189478596
        it("button is disabled when the loading prop is true, even if disabled={false}", () => {
            const wrapper = button({ disabled: false, loading: true });
            assert.isTrue(wrapper.find(tagName).hasClass(Classes.DISABLED));
        });

        it("clicking button triggers onClick prop", () => {
            const onClick = spy();
            button({ onClick }).simulate("click");
            assert.equal(onClick.callCount, 1);
        });

        it("clicking disabled button does not trigger onClick prop", () => {
            const onClick = spy();
            // full DOM mount so `button` element will ignore click
            button({ disabled: true, onClick }, true).simulate("click");
            assert.equal(onClick.callCount, 0);
        });

        it("pressing enter triggers onKeyDown props with any modifier flags", () => {
            checkKeyEventCallbackInvoked("onKeyDown", "keydown", "Enter");
        });

        it("pressing space triggers onKeyDown props with any modifier flags", () => {
            checkKeyEventCallbackInvoked("onKeyDown", "keydown", " ");
        });

        it("calls onClick when enter key released", () => {
            checkClickTriggeredOnKeyUp({ key: "Enter" });
        });

        it("calls onClick when space key released", () => {
            checkClickTriggeredOnKeyUp({ key: " " });
        });

        it("attaches ref with createRef", () => {
            const ref = React.createRef<HTMLButtonElement>();
            const wrapper = button({ ref });
            wrapper.update();
            assert.isTrue(
                ref.current instanceof (tagName === "button" ? HTMLButtonElement : HTMLAnchorElement),
                `ref.current should be a(n) ${tagName} element`,
            );
        });

        it("attaches ref with useRef", () => {
            let buttonRef: React.RefObject<any> | undefined;
            const Component = component;

            const Test = () => {
                buttonRef = React.useRef<any>(null);

                return <Component ref={buttonRef} />;
            };

            const wrapper = mount(<Test />);
            wrapper.update();

            assert.isTrue(
                buttonRef?.current instanceof (tagName === "button" ? HTMLButtonElement : HTMLAnchorElement),
                `ref.current should be a(n) ${tagName} element`,
            );
        });

        function button(props: ButtonProps, ...children: React.ReactNode[]) {
            const element = React.createElement(component, props, ...children);
            return mount(element, { attachTo: containerElement });
        }

        function checkClickTriggeredOnKeyUp(keyEventProps: Partial<React.KeyboardEvent<any>>) {
            // we need to listen for real DOM events here, since the implementation of this feature uses
            // HTMLElement#click() - see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click
            const onContainerClick = spy();
            containerElement?.addEventListener("click", onContainerClick);
            const wrapper = button({ text: "Test" });

            wrapper.find(`.${Classes.BUTTON}`).hostNodes().simulate("keyup", keyEventProps);
            assert.isTrue(onContainerClick.calledOnce, "Expected a click event to bubble up to container element");
        }

        function checkKeyEventCallbackInvoked(callbackPropName: string, eventName: string, key: string) {
            const callback = spy();

            // ButtonProps doesn't include onKeyDown or onKeyUp in its
            // definition, even though Buttons support those props. Casting as
            // `any` gets around that for the purpose of these tests.
            const wrapper = button({ [callbackPropName]: callback } as any);
            const eventProps = { key, shiftKey: true, metaKey: true };
            wrapper.simulate(eventName, eventProps);

            // check that the callback was invoked with modifier key flags included
            assert.equal(callback.callCount, 1);
            assert.equal(callback.firstCall.args[0].shiftKey, true);
            assert.equal(callback.firstCall.args[0].metaKey, true);
        }
    });
}

================================================================================

File: test\callout\calloutTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount } from "enzyme";
import * as React from "react";

import { IconNames } from "@blueprintjs/icons";

import { Callout, Classes, H5, Intent } from "../../src";

describe("<Callout>", () => {
    let containerElement: HTMLElement | undefined;

    beforeEach(() => {
        containerElement = document.createElement("div");
        document.body.appendChild(containerElement);
    });
    afterEach(() => {
        containerElement?.remove();
    });

    it("supports className", () => {
        const wrapper = mount(<Callout className="foo" />, { attachTo: containerElement });
        assert.isFalse(wrapper.find(H5).exists(), "expected no H5");
        assert.isTrue(wrapper.find(`.${Classes.CALLOUT}`).hostNodes().exists());
        assert.isTrue(wrapper.find(`.foo`).hostNodes().exists());
    });

    it("supports icon", () => {
        const wrapper = mount(<Callout icon={IconNames.GRAPH} />, { attachTo: containerElement });
        assert.isTrue(wrapper.find(`[data-icon="${IconNames.GRAPH}"]`).exists());
    });

    it("supports intent", () => {
        const wrapper = mount(<Callout intent={Intent.DANGER} />, { attachTo: containerElement });
        assert.isTrue(wrapper.find(`.${Classes.INTENT_DANGER}`).hostNodes().exists());
    });

    it("intent='primary' renders the associated default icon", () => {
        const wrapper = mount(<Callout intent={Intent.PRIMARY} />, { attachTo: containerElement });
        assert.isTrue(wrapper.find(`[data-icon="${IconNames.INFO_SIGN}"]`).exists());
    });

    it("icon=null removes intent icon", () => {
        const wrapper = mount(<Callout icon={null} intent={Intent.PRIMARY} />, { attachTo: containerElement });
        assert.isFalse(wrapper.find(`[data-icon]`).exists());
    });

    it("renders optional title element", () => {
        const wrapper = mount(<Callout title="title" />, { attachTo: containerElement });
        assert.isTrue(wrapper.find(`.${Classes.HEADING}`).exists());
        // NOTE: JSX cannot be passed through `title` prop due to conflict with HTML props
        // @ts-expect-error
        mount(<Callout title={<em>typings fail</em>} />);
    });
});

================================================================================

File: test\card\cardTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, shallow } from "enzyme";
import * as React from "react";
import sinon from "sinon";

import { Card, Classes, H4 } from "../../src";

describe("<Card>", () => {
    it("supports elevation, interactive, and className props", () => {
        const wrapper = shallow(<Card elevation={3} interactive={true} className={Classes.TEXT_MUTED} />);

        assert.isTrue(wrapper.hasClass(Classes.CARD), Classes.CARD);
        assert.isTrue(wrapper.hasClass(Classes.ELEVATION_3), Classes.ELEVATION_3);
        assert.isTrue(wrapper.hasClass(Classes.INTERACTIVE), Classes.INTERACTIVE);
        assert.isTrue(wrapper.hasClass(Classes.TEXT_MUTED), Classes.TEXT_MUTED);
    });

    it("renders children", () => {
        const wrapper = shallow(
            <Card>
                <H4>Card content</H4>
            </Card>,
        );
        assert.isTrue(wrapper.find(H4).exists());
    });

    it("calls onClick when card is clicked", () => {
        const onClick = sinon.spy();
        shallow(<Card onClick={onClick} />).simulate("click");
        assert.isTrue(onClick.calledOnce);
    });

    it("supports HTML props", () => {
        const onChange = sinon.spy();
        const card = shallow(<Card onChange={onChange} title="foo" tabIndex={4000} />).find("div");
        assert.strictEqual(card.prop("onChange"), onChange);
        assert.strictEqual(card.prop("title"), "foo");
    });

    it("supports ref prop", () => {
        const elementRef = React.createRef<HTMLDivElement>();
        mount(<Card ref={elementRef} />);
        assert.isDefined(elementRef.current);
    });
});

================================================================================

File: test\card-list\cardListTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount } from "enzyme";
import * as React from "react";

import { Card, CardList, Classes } from "../../src";

describe("<CardList>", () => {
    it("supports className prop", () => {
        const TEST_CLASS = "test-class";
        const wrapper = mount(
            <CardList className={TEST_CLASS}>
                <Card>first</Card>
                <Card>second</Card>
            </CardList>,
        );

        assert.isTrue(wrapper.find(`.${Classes.CARD_LIST}`).hostNodes().hasClass(TEST_CLASS), TEST_CLASS);
    });

    it("supports HTML props", () => {
        const cardList = mount(<CardList title="foo" />).find("div");
        assert.strictEqual(cardList.prop("title"), "foo");
    });

    it("supports ref prop", () => {
        const elementRef = React.createRef<HTMLDivElement>();
        mount(<CardList ref={elementRef} />);
        assert.isDefined(elementRef.current);
    });
});

================================================================================

File: test\collapse\collapseTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, shallow } from "enzyme";
import * as React from "react";

import { Classes, MenuItem } from "../../src";
import { AnimationStates, Collapse } from "../../src/components/collapse/collapse";

describe("<Collapse>", () => {
    it("has the correct className", () => {
        const collapse = shallow(<Collapse />);
        assert.isTrue(collapse.hasClass(Classes.COLLAPSE));
    });

    it("is closed", () => {
        const collapse = mount(<Collapse isOpen={false}>Body</Collapse>);
        assert.strictEqual(collapse.state("height"), "0px");
    });

    it("is open", () => {
        const collapse = mount(<Collapse isOpen={true}>Body</Collapse>);
        assert.strictEqual(collapse.state("height"), "auto");
    });

    it("is opening", () => {
        const collapse = mount(<Collapse isOpen={false}>Body</Collapse>);
        collapse.setProps({ isOpen: true });
        assert.strictEqual(collapse.state("animationState"), AnimationStates.OPENING);
    });

    it("supports custom intrinsic element", () => {
        assert.isTrue(shallow(<Collapse component="article" />).is("article"));
    });

    it("supports custom Component", () => {
        assert.isTrue(shallow(<Collapse component={MenuItem} />).is(MenuItem));
    });

    it("unmounts children by default", () => {
        const collapse = mount(
            <Collapse isOpen={false}>
                <div className="removed-child" />
            </Collapse>,
        );
        assert.lengthOf(collapse.find(".removed-child"), 0);
    });

    it("keepChildrenMounted keeps child mounted", () => {
        const collapse = mount(
            <Collapse isOpen={false} keepChildrenMounted={true}>
                <div className="hidden-child" />
            </Collapse>,
        );
        assert.lengthOf(collapse.find(".hidden-child"), 1);
    });
});

================================================================================

File: test\common\propsTests.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";

import { removeNonHTMLProps } from "../../src/common/props";

describe("Props", () => {
    describe("removeNonHTMLProps", () => {
        let props: { [key: string]: boolean };

        beforeEach(() => {
            props = {
                apple: true,
                banana: true,
                cat: true,
                containerRef: true,
                icon: true,
                intent: true,
                round: true,
                text: true,
            };
        });

        it("removes only from curated denylist when supplied 1 argument", () => {
            assert.deepEqual(removeNonHTMLProps(props), {
                apple: true,
                banana: true,
                cat: true,
            });
        });

        it("removes only from the supplied array when supplied 2 arguments", () => {
            assert.deepEqual(removeNonHTMLProps(props, ["apple", "banana"]), {
                cat: true,
                containerRef: true,
                icon: true,
                intent: true,
                round: true,
                text: true,
            });
        });

        it("removes from the curated denylist and the supplied array when shouldMerge=true", () => {
            assert.deepEqual(removeNonHTMLProps(props, ["apple", "banana"], true), { cat: true });
        });
    });
});

================================================================================

File: test\common\utilsTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import * as React from "react";
import { type SinonSpy, spy } from "sinon";

import * as Utils from "../../src/common/utils";

describe("Utils", () => {
    it("isFunction", () => {
        assert.isTrue(Utils.isFunction(() => 3));
        assert.isFalse(Utils.isFunction(undefined));
    });

    it("isReactNodeEmpty", () => {
        // empty nodes
        assert.isTrue(Utils.isReactNodeEmpty(undefined), "undefined");
        assert.isTrue(Utils.isReactNodeEmpty(null), "null");
        assert.isTrue(Utils.isReactNodeEmpty(""), '""');
        assert.isTrue(Utils.isReactNodeEmpty([]), "[]");
        assert.isTrue(Utils.isReactNodeEmpty([undefined, null, false, ""]), "array");
        // not empty nodes
        assert.isFalse(Utils.isReactNodeEmpty(0), "0");
        assert.isFalse(Utils.isReactNodeEmpty("text"), "text");
        assert.isFalse(Utils.isReactNodeEmpty(<div />), "<div />");
        assert.isFalse(Utils.isReactNodeEmpty([null, <div key="div" />]), "array");
    });

    it("elementIsOrContains", () => {
        const child = document.createElement("span");
        const parent = document.createElement("div");
        const grandparent = document.createElement("div");

        parent.appendChild(child);
        grandparent.appendChild(parent);

        assert.isTrue(Utils.elementIsOrContains(child, child));
        assert.isTrue(Utils.elementIsOrContains(parent, child));
        assert.isTrue(Utils.elementIsOrContains(grandparent, parent));
        assert.isTrue(Utils.elementIsOrContains(grandparent, child));

        assert.isFalse(Utils.elementIsOrContains(child, parent));
        assert.isFalse(Utils.elementIsOrContains(parent, grandparent));
    });

    it("arrayLengthCompare", () => {
        assert.isAbove(Utils.arrayLengthCompare([1, 2], []), 0);
        assert.strictEqual(Utils.arrayLengthCompare([1, 2], [1, 2]), 0);
        assert.isBelow(Utils.arrayLengthCompare([], [1, 2]), 0);

        assert.isAbove(Utils.arrayLengthCompare([1]), 0);
        assert.strictEqual(Utils.arrayLengthCompare(), 0);
        assert.isBelow(Utils.arrayLengthCompare(undefined, [1]), 0);
    });

    it("approxEqual", () => {
        const DEFAULT_EPSILON = 0.00001;
        assert.isTrue(Utils.approxEqual(0, DEFAULT_EPSILON));
        assert.isTrue(Utils.approxEqual(-1 * DEFAULT_EPSILON, -2 * DEFAULT_EPSILON));
        assert.isFalse(Utils.approxEqual(10, 10 + DEFAULT_EPSILON + DEFAULT_EPSILON / 10));
        assert.isFalse(Utils.approxEqual(10, 10 - DEFAULT_EPSILON - DEFAULT_EPSILON / 10));
    });

    it("clamp", () => {
        assert.strictEqual(Utils.clamp(10, 0, 20), 10, "value between min/max");
        assert.strictEqual(Utils.clamp(0, 10, 20), 10, "value below min");
        assert.strictEqual(Utils.clamp(40, 0, 20), 20, "value above max");
        assert.throws(() => Utils.clamp(0, 20, 10), /less than/);
    });

    it("countDecimalPlaces", () => {
        assert.equal(Utils.countDecimalPlaces(1), 0);
        assert.equal(Utils.countDecimalPlaces(0.11), 2);
        assert.equal(Utils.countDecimalPlaces(-1.1111111111), 10);
        assert.equal(Utils.countDecimalPlaces(1e-10), 10);
        assert.equal(Utils.countDecimalPlaces(NaN), 0);
    });

    it("uniqueId", () => {
        const ns = "testNamespace";
        const otherNs = "otherNamespace";
        assert.equal(Utils.uniqueId(ns), `${ns}-0`);
        assert.equal(Utils.uniqueId(ns), `${ns}-1`);
        assert.equal(Utils.uniqueId(ns), `${ns}-2`);
        assert.equal(Utils.uniqueId(otherNs), `${otherNs}-0`);
    });

    // TODO: not sure how to test this. perhaps with the help of https://github.com/alexreardon/raf-stub?
    it.skip("throttleEvent");

    describe("ensureElement", () => {
        it("handles undefined/null", () => {
            assert.isUndefined(Utils.ensureElement(undefined));
            assert.isUndefined(Utils.ensureElement(null));
        });

        it("wraps strings & numbers", () => {
            assert.strictEqual(Utils.ensureElement("foo")?.type, "span");
            assert.strictEqual(Utils.ensureElement(1234)?.type, "span");
        });

        it("returns undefined for whitespace strings", () => {
            assert.isUndefined(Utils.ensureElement("   "));
        });

        it("passes through JSX elements", () => {
            const el = <div>my element</div>;
            assert.strictEqual(Utils.ensureElement(el), el);
        });

        // React 16 only
        if (React.Fragment !== undefined) {
            it("wraps JSX fragments in element", () => {
                const el = Utils.ensureElement(
                    <>
                        one <em>two</em> three
                    </>,
                );
                assert.strictEqual(el?.type, "span");
            });
        }
    });

    describe("throttleReactEventCallback", () => {
        let callback: SinonSpy;
        let fakeEvent: any; // cast as `any` to avoid having to set every required property on the event
        let throttledCallback: (event2: React.SyntheticEvent<any>, ...otherArgs2: any[]) => void;

        beforeEach(() => {
            callback = spy();
            fakeEvent = { persist: spy(), preventDefault: spy() };
        });

        afterEach(() => {
            fakeEvent = undefined;
        });

        it("invokes event.persist() to prevent React from pooling before we can reference the event in rAF", () => {
            throttledCallback = Utils.throttleReactEventCallback(callback);
            throttledCallback(fakeEvent as any);
            assert.isTrue(fakeEvent.persist.calledOnce);
        });

        it("can preventDefault", () => {
            throttledCallback = Utils.throttleReactEventCallback(callback, {
                preventDefault: true,
            });
            throttledCallback(fakeEvent as any);
            assert.isTrue(fakeEvent.preventDefault.calledOnce);
        });

        // TODO: how to test this properly? perhaps with the help of https://github.com/alexreardon/raf-stub?
        it.skip("properly throttles callback using requestAnimationFrame");
    });
});

================================================================================

File: test\common\utils\compareUtilsTests.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable max-classes-per-file */

import { expect } from "chai";

import type { KeyAllowlist, KeyDenylist } from "../../../src/common/utils";
import * as CompareUtils from "../../../src/common/utils/compareUtils";

describe("CompareUtils", () => {
    describe("arraysEqual", () => {
        describe("no compare function provided", () => {
            describe("should return true if the arrays are shallowly equal", () => {
                runTest(true, undefined, undefined);
                runTest(true, undefined, null);
                runTest(true, [3, "1", true], [3, "1", true]);
            });

            describe("should return false if the arrays are not shallowly equal", () => {
                runTest(false, null, [3]);
                runTest(false, [3, 1, 2], [3, 1]);
                runTest(false, [{ x: 1 }], [{ x: 1 }]);
            });
        });

        describe("compare function provided", () => {
            const COMPARE_FN = (a: any, b: any) => a.x === b.x;

            describe("should return true if the arrays are equal using a custom compare function", () => {
                runTest(true, undefined, undefined, COMPARE_FN);
                runTest(true, undefined, null, COMPARE_FN);
                runTest(true, [{ x: 1 }, { x: 2 }], [{ x: 1 }, { x: 2 }], COMPARE_FN);
            });

            describe("should return false if the arrays are not equal using custom compare function", () => {
                runTest(false, null, [], COMPARE_FN);
                runTest(false, [{ x: 1 }, {}], [{ x: 1 }, { x: 2 }], COMPARE_FN);
            });
        });

        function runTest(expectedResult: boolean, a: any, b: any, compareFn?: (a: any, b: any) => boolean) {
            it(getCompareTestDescription(a, b), () => {
                expect(CompareUtils.arraysEqual(a, b, compareFn)).to.equal(expectedResult);
            });
        }
    });

    describe("shallowCompareKeys", () => {
        describe("with `keys` defined as whitelist", () => {
            describe("returns true if only the specified values are shallowly equal", () => {
                runTest(true, { a: 1 }, { a: 1 }, wl(["a", "b", "c", "d"]));
                runTest(true, { a: 1, b: [1, 2, 3], c: "3" }, { b: [1, 2, 3], a: 1, c: "3" }, wl(["a", "c"]));
                runTest(true, { a: 1, b: "2", c: { a: 1 } }, { a: 1, b: "2", c: { a: 1 } }, wl(["a", "b"]));
            });

            describe("returns false if any specified values are not shallowly equal", () => {
                runTest(false, { a: [1, "2", true] }, { a: [1, "2", true] }, wl(["a"]));
                runTest(false, { a: 1, b: "2", c: { a: 1 } }, { a: 1, b: "2", c: { a: 1 } }, wl(["a", "b", "c"]));
                runTest(false, { a: 1, c: { a: 1 } }, { a: 1, b: "2" }, wl(["a", "b"]));
            });

            describe("edge cases that return true", () => {
                runTest(true, undefined, null, wl([]));
                runTest(true, undefined, undefined, wl(["a"]));
                runTest(true, null, null, wl(["a"]));
                runTest(true, {}, {}, wl(["a"]));
            });

            describe("edge cases that return false", () => {
                runTest(false, {}, undefined, wl([]));
                runTest(false, {}, [], wl([]));
                runTest(false, [], [], wl([]));
            });

            function runTest(expectedResult: boolean, a: any, b: any, keys: KeyDenylist<Keys> | KeyAllowlist<Keys>) {
                it(getCompareTestDescription(a, b), () => {
                    expect(CompareUtils.shallowCompareKeys(a, b, keys)).to.equal(expectedResult);
                });
            }
        });

        describe("with `keys` defined as denylist", () => {
            describe("returns true if only the specified values are shallowly equal", () => {
                runTest(true, { a: 1 }, { a: 1 }, bl(["b", "c", "d"]));
                runTest(true, { a: 1, b: [1, 2, 3], c: "3" }, { b: [1, 2, 3], a: 1, c: "3" }, bl(["b"]));
                runTest(true, { a: 1, b: "2", c: { a: 1 } }, { a: 1, b: "2", c: { a: 1 } }, bl(["c"]));
            });

            describe("returns false if any specified values are not shallowly equal", () => {
                runTest(false, { a: [1, "2", true] }, { a: [1, "2", true] }, bl(["b, c"]));
                runTest(false, { a: 1, b: "2", c: { a: 1 } }, { a: 1, b: "2", c: { a: 1 } }, bl(["a", "b", "d"]));
                runTest(false, { a: 1, c: { a: 1 } }, { a: 1, b: "2" }, bl(["c"]));
            });

            describe("edge cases that return true", () => {
                runTest(true, undefined, null, bl([]));
                runTest(true, undefined, undefined, bl(["a"]));
                runTest(true, null, null, bl(["a"]));
                runTest(true, {}, {}, bl(["a"]));
            });

            describe("edge cases that return false", () => {
                runTest(false, {}, undefined, bl([]));
                runTest(false, {}, [], bl([]));
                runTest(false, [], [], bl([]));
            });

            function runTest(expectedResult: boolean, a: any, b: any, keys: KeyDenylist<Keys> | KeyAllowlist<Keys>) {
                it(getCompareTestDescription(a, b), () => {
                    expect(CompareUtils.shallowCompareKeys(a, b, keys)).to.equal(expectedResult);
                });
            }
        });

        describe("with `keys` not defined", () => {
            describe("returns true if values are shallowly equal", () => {
                runTest(true, { a: 1, b: "2", c: true }, { a: 1, b: "2", c: true });
                runTest(true, undefined, undefined);
                runTest(true, null, undefined);
            });

            describe("returns false if values are not shallowly equal", () => {
                runTest(false, undefined, {});
                runTest(false, null, {});
                runTest(false, {}, []);
                runTest(false, { a: 1, b: "2", c: { a: 1 } }, { a: 1, b: "2", c: { a: 1 } });
            });

            describe("returns false if keys are different", () => {
                runTest(false, {}, { a: 1 });
                runTest(false, { a: 1, b: "2" }, { b: "2" });
                runTest(false, { a: 1, b: "2", c: true }, { b: "2", c: true, d: 3 });
            });

            describe("returns true if same deeply-comparable instance is reused in both objects", () => {
                const deeplyComparableThing1 = { a: 1 };
                const deeplyComparableThing2 = [1, "2", true];
                runTest(true, { a: 1, b: deeplyComparableThing1 }, { a: 1, b: deeplyComparableThing1 });
                runTest(true, { a: 1, b: deeplyComparableThing2 }, { a: 1, b: deeplyComparableThing2 });
            });

            function runTest(expectedResult: boolean, a: any, b: any) {
                it(getCompareTestDescription(a, b), () => {
                    expect(CompareUtils.shallowCompareKeys(a, b)).to.equal(expectedResult);
                });
            }
        });
    });

    describe("deepCompareKeys", () => {
        class DVD {
            public constructor() {
                /* Empty */
            }
        }

        class VHSTape {
            public constructor() {
                /* Empty */
            }
        }

        describe("with `keys` defined", () => {
            describe("returns true if only the specified values are deeply equal", () => {
                const customInstance1 = new DVD();
                const customInstance2 = new DVD();

                runTest(true, { a: 1 }, { a: 1 }, ["a", "b", "c", "d"]);
                runTest(true, { a: customInstance1 }, { a: customInstance2 }, ["a"]);
                runTest(true, { a: 1, b: [1, 2, 3], c: "3" }, { b: [1, 2, 3], a: 1, c: "3" }, ["b", "c"]);
                runTest(true, { a: 1, b: "2", c: { a: 1 } }, { a: 1, b: "2", c: { a: 1 } }, ["b", "c"]);
            });

            describe("returns false if any specified values are not deeply equal", () => {
                const customInstance1 = new DVD();
                const customInstance2 = new VHSTape();

                runTest(false, { a: [1, "2", true] }, { a: [1, "2", false] }, ["a"]);
                runTest(false, { a: customInstance1 }, { a: customInstance2 }, ["a"]);
                runTest(false, { a: 1, b: "2", c: { a: 1 } }, { a: 1, b: "2", c: { a: 2 } }, ["a", "b", "c"]);
            });

            describe("edge cases that return true", () => {
                runTest(true, undefined, null, []);
                runTest(true, undefined, undefined, ["a"]);
                runTest(true, null, null, ["a"]);
                runTest(true, {}, {}, ["a"]);
            });

            describe("edge cases that return false", () => {
                runTest(false, {}, undefined, []);
                runTest(false, {}, [], []);
            });

            function runTest(expectedResult: boolean, a: any, b: any, keys: string[]) {
                it(getCompareTestDescription(a, b), () => {
                    expect(CompareUtils.deepCompareKeys(a, b, keys)).to.equal(expectedResult);
                });
            }
        });

        describe("with `keys` not defined", () => {
            describe("returns true if values are deeply equal", () => {
                const customInstance1 = new DVD();
                const customInstance2 = new DVD();

                runTest(true, { a: 1, b: "2", c: true }, { a: 1, b: "2", c: true });
                runTest(true, { a: 1, b: "2", c: { a: 1, b: "2" } }, { a: 1, b: "2", c: { a: 1, b: "2" } });
                runTest(true, [1, "2", true], [1, "2", true]);
                runTest(true, 1, 1);
                runTest(true, customInstance1, customInstance2);
                runTest(true, "2", "2");
                runTest(true, undefined, undefined);
                runTest(true, null, undefined);
            });

            describe("returns false if values are not deeply equal", () => {
                const customInstance1 = new DVD();
                const customInstance2 = new VHSTape();

                runTest(false, undefined, {});
                runTest(false, null, {});
                runTest(false, {}, []);
                runTest(false, { a: 1, b: "2", c: { a: 1 } }, { a: 1, b: "2", c: { a: "1" } });
                runTest(false, customInstance1, customInstance2);
            });

            describe("returns false if keys are different", () => {
                runTest(false, {}, { a: 1 });
                runTest(false, { a: 1, b: "2" }, { b: "2" });
                runTest(false, { a: 1, b: "2", c: true }, { b: "2", c: true, d: 3 });
            });

            describe("returns true if same deeply-comparable instance is reused in both objects", () => {
                const deeplyComparableThing1 = { a: 1 };
                const deeplyComparableThing2 = [1, "2", true];
                runTest(true, { a: 1, b: deeplyComparableThing1 }, { a: 1, b: deeplyComparableThing1 });
                runTest(true, { a: 1, b: deeplyComparableThing2 }, { a: 1, b: deeplyComparableThing2 });
            });

            function runTest(expectedResult: boolean, a: any, b: any) {
                it(getCompareTestDescription(a, b), () => {
                    expect(CompareUtils.deepCompareKeys(a, b)).to.equal(expectedResult);
                });
            }
        });
    });

    describe("getDeepUnequalKeyValues", () => {
        describe("with `keys` defined", () => {
            describe("returns empty array if only the specified values are deeply equal", () => {
                runTest([], { a: 1, b: [1, 2, 3], c: "3" }, { b: [1, 2, 3], a: 1, c: "3" }, ["b", "c"]);
            });

            describe("returns unequal key/values if any specified values are not deeply equal", () => {
                runTest(
                    [
                        { key: "a", valueA: 2, valueB: 1 },
                        { key: "b", valueA: [2, 3, 4], valueB: [1, 2, 3] },
                    ],
                    { a: 2, b: [2, 3, 4], c: "3" },
                    { b: [1, 2, 3], a: 1, c: "3" },
                    ["a", "b"],
                );
            });
        });

        describe("with `keys` not defined", () => {
            describe("returns empty arrau if values are deeply equal", () => {
                runTest([], { a: 1, b: "2", c: { a: 1, b: "2" } }, { a: 1, b: "2", c: { a: 1, b: "2" } });
            });

            describe("returns unequal key/values if values are not deeply equal", () => {
                runTest(
                    [{ key: "a", valueA: [1, "2", true], valueB: [1, "2", false] }],
                    { a: [1, "2", true] },
                    { a: [1, "2", false] },
                );
            });
        });

        function runTest(expectedResult: any[], a: any, b: any, keys?: string[]) {
            it(getCompareTestDescription(a, b, keys), () => {
                expect(CompareUtils.getDeepUnequalKeyValues(a, b, keys)).to.deep.equal(expectedResult);
            });
        }
    });
});

function getCompareTestDescription(a?: any, b?: any, keys?: any) {
    const baseResult = `${JSON.stringify(a)} and ${JSON.stringify(b)}`;
    return keys != null ? baseResult + ` (keys: ${JSON.stringify(keys)})` : baseResult;
}

interface Keys {
    a?: any;
    b?: any;
    c?: any;
    d?: any;
}

/**
 * A compactly named function for converting a string array to a key denylist.
 */
function bl(keys: string[]): KeyDenylist<Keys> {
    return { exclude: keys as Array<keyof Keys> };
}

/**
 * A compactly named function for converting a string array to a key whitelist.
 */
function wl(keys: string[]): KeyAllowlist<Keys> {
    return { include: keys as Array<keyof Keys> };
}

================================================================================

File: test\context-menu\contextMenuSingletonTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import * as React from "react";

import { dispatchMouseEvent } from "@blueprintjs/test-commons";

import { Classes, hideContextMenu, Menu, MenuItem, showContextMenu, Utils } from "../../src";

// use a unique ID to avoid collisons with other tests
const MENU_CLASSNAME = Utils.uniqueId("test-menu");
const MENU = (
    <Menu className={MENU_CLASSNAME}>
        <MenuItem icon="align-left" text="Align Left" />
        <MenuItem icon="align-center" text="Align Center" />
        <MenuItem icon="align-right" text="Align Right" />
    </Menu>
);
const DEFAULT_CONTEXT_MENU_POPOVER_PROPS = {
    content: MENU,
    targetOffset: {
        left: 10,
        top: 10,
    },
    transitionDuration: 0,
};

function assertMenuState(isOpen = true) {
    const ctxMenuElement = document.querySelectorAll<HTMLElement>(`.${MENU_CLASSNAME}`);
    if (isOpen) {
        assert.isTrue(ctxMenuElement.length === 1, "Expected menu to be rendered on the page");
        assert.isNotNull(ctxMenuElement[0].closest(`.${Classes.OVERLAY_OPEN}`), "Expected overlay to be open");
    } else {
        if (ctxMenuElement.length > 0) {
            assert.isNull(ctxMenuElement[0].closest(`.${Classes.OVERLAY_OPEN}`), "Expected overlay to be closed");
        }
    }
}

function dismissContextMenu() {
    const backdrop = document.querySelector<HTMLElement>(`.${Classes.CONTEXT_MENU_BACKDROP}`);
    if (backdrop != null) {
        dispatchMouseEvent(backdrop, "mousedown");
    }
}

describe("showContextMenu() + hideContextMenu()", () => {
    let containerElement: HTMLElement | undefined;

    before(() => {
        // create an element on the page with non-zero dimensions so that we can trigger a context menu above it
        containerElement = document.createElement("div");
        containerElement.setAttribute("style", "width: 100px; height: 100px;");
        document.body.appendChild(containerElement);
    });

    beforeEach(() => {
        assertMenuState(false);
    });

    after(() => {
        containerElement?.remove();
    });

    it("shows a menu with the imperative API", done => {
        showContextMenu({
            ...DEFAULT_CONTEXT_MENU_POPOVER_PROPS,
            onOpened: () =>
                // defer assertions until the next animation frame; otherwise, this might throw an error
                // inside the <TransitionGroup>, which may throw off test debugging
                requestAnimationFrame(() => {
                    assertMenuState(true);
                    // important: close menu for the next test
                    dismissContextMenu();
                    done();
                }),
        });
    });

    describe("hides a menu", () => {
        it("by clicking on the backdrop (when onClose prop is defined)", done => {
            const handleClose = () =>
                requestAnimationFrame(() => {
                    assertMenuState(false);
                    done();
                });

            showContextMenu({
                ...DEFAULT_CONTEXT_MENU_POPOVER_PROPS,
                onClose: handleClose,
                onOpened: () =>
                    requestAnimationFrame(() => {
                        dismissContextMenu();
                    }),
            });
        });

        it("via hideContextMenu()", done => {
            showContextMenu({
                ...DEFAULT_CONTEXT_MENU_POPOVER_PROPS,
                onOpened: () =>
                    // defer assertions until the next animation frame
                    requestAnimationFrame(() => {
                        hideContextMenu();
                        assertMenuState(false);
                        done();
                    }),
            });
        });
    });
});

================================================================================

File: test\context-menu\contextMenuTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import classNames from "classnames";
import { mount, type ReactWrapper } from "enzyme";
import * as React from "react";
import * as ReactDOM from "react-dom";
import { spy } from "sinon";

import {
    Classes,
    ContextMenu,
    type ContextMenuContentProps,
    type ContextMenuProps,
    Drawer,
    Menu,
    MenuItem,
    Popover,
    PopoverInteractionKind,
    Tooltip,
    type TooltipProps,
    Utils,
} from "../../src";

// use a unique ID to avoid collisons with other tests
const MENU_CLASSNAME = Utils.uniqueId("test-menu");
const MENU = (
    <Menu className={MENU_CLASSNAME}>
        <MenuItem icon="align-left" text="Align Left" />
        <MenuItem icon="align-center" text="Align Center" />
        <MenuItem icon="align-right" text="Align Right" />
    </Menu>
);
const TARGET_CLASSNAME = "test-target";
const TOOLTIP_SELECTOR = `.${Classes.TOOLTIP}`;
const COMMON_TOOLTIP_PROPS: Partial<TooltipProps> = {
    hoverCloseDelay: 0,
    hoverOpenDelay: 0,
    usePortal: false,
};

describe("ContextMenu", () => {
    let containerElement: HTMLElement | undefined;

    beforeEach(() => {
        containerElement = document.createElement("div");
        document.body.appendChild(containerElement);
    });
    afterEach(() => {
        ReactDOM.unmountComponentAtNode(containerElement!);
        containerElement!.remove();
    });

    describe("basic usage", () => {
        it("renders children and Popover", () => {
            const ctxMenu = mountTestMenu();
            assert.isTrue(ctxMenu.find(`.${TARGET_CLASSNAME}`).exists());
            assert.isTrue(ctxMenu.find(Popover).exists());
        });

        it("opens popover on right click", () => {
            const ctxMenu = mountTestMenu();
            openCtxMenu(ctxMenu);
            assert.isTrue(ctxMenu.find(Popover).prop("isOpen"));
        });

        it("renders custom HTML tag if specified", () => {
            const ctxMenu = mountTestMenu({ tagName: "span" });
            assert.isTrue(ctxMenu.find(`span.${Classes.CONTEXT_MENU}`).exists());
        });

        it("supports custom refs", () => {
            const ref = React.createRef<HTMLElement>();
            mountTestMenu({ className: "test-container", ref });
            assert.isDefined(ref.current);
            assert.isTrue(ref.current?.classList.contains("test-container"));
        });

        it("closes popover on ESC key press", () => {
            const ctxMenu = mountTestMenu();
            openCtxMenu(ctxMenu);
            ctxMenu
                .find(`.${Classes.OVERLAY_OPEN}`)
                .hostNodes()
                .simulate("keydown", {
                    key: "Escape",
                    nativeEvent: new KeyboardEvent("keydown"),
                });
            assert.isFalse(ctxMenu.find(Popover).prop("isOpen"));
        });

        it("clicks inside popover don't propagate to context menu wrapper", () => {
            const itemClickSpy = spy();
            const wrapperClickSpy = spy();
            const ctxMenu = mountTestMenu({
                content: (
                    <Menu>
                        <MenuItem data-testid="item" text="item" onClick={itemClickSpy} />
                    </Menu>
                ),
                onClick: wrapperClickSpy,
            });
            openCtxMenu(ctxMenu);
            ctxMenu.find("[data-testid='item']").hostNodes().simulate("click");
            assert.isTrue(itemClickSpy.calledOnce, "menu item click handler should be called once");
            assert.isFalse(wrapperClickSpy.called, "ctx menu wrapper click handler should not be called");
        });

        it("allows overrding some Popover props", () => {
            const placement = "top";
            const popoverClassName = "test-popover-class";
            const ctxMenu = mountTestMenu({ popoverProps: { placement, popoverClassName } });
            openCtxMenu(ctxMenu);
            const popoverWithTopPlacement = document.querySelector(
                `.${popoverClassName}.${Classes.POPOVER_CONTENT_PLACEMENT}-${placement}`,
            );
            assert.exists(
                popoverWithTopPlacement,
                `popover element with custom class '${popoverClassName}' and '${placement}' placement should exist`,
            );
        });

        function mountTestMenu(props: Partial<ContextMenuProps> = {}) {
            return mount(
                <ContextMenu content={MENU} popoverProps={{ transitionDuration: 0 }} {...props}>
                    <div className={TARGET_CLASSNAME} />
                </ContextMenu>,
                { attachTo: containerElement },
            );
        }
    });

    describe("advanced usage (child render function API)", () => {
        it("renders children and Popover", () => {
            const ctxMenu = mountTestMenu();
            assert.isTrue(ctxMenu.find(`.${TARGET_CLASSNAME}`).exists());
            assert.isTrue(ctxMenu.find(Popover).exists());
        });

        it("opens popover on right click", () => {
            const ctxMenu = mountTestMenu();
            openCtxMenu(ctxMenu);
            assert.isTrue(ctxMenu.find(Popover).prop("isOpen"));
        });

        it("handles context menu event, even if content is undefined", () => {
            const ctxMenu = mountTestMenu({ content: undefined });
            let clickedInfo = ctxMenu.find("[data-testid='content-clicked-info']");
            assert.strictEqual(clickedInfo.text().trim(), renderClickedInfo(undefined));
            openCtxMenu(ctxMenu);
            clickedInfo = ctxMenu.find("[data-testid='content-clicked-info']");
            assert.strictEqual(clickedInfo.text().trim(), renderClickedInfo({ left: 10, top: 10 }));
        });

        it("does not handle context menu event when disabled={true}", () => {
            const ctxMenu = mountTestMenu({ disabled: true });
            let clickedInfo = ctxMenu.find("[data-testid='content-clicked-info']");
            assert.strictEqual(clickedInfo.text().trim(), renderClickedInfo(undefined));
            openCtxMenu(ctxMenu);
            clickedInfo = ctxMenu.find("[data-testid='content-clicked-info']");
            assert.strictEqual(clickedInfo.text().trim(), renderClickedInfo(undefined));
        });

        function mountTestMenu(props?: Partial<ContextMenuProps>) {
            return mount(
                <ContextMenu content={MENU} popoverProps={{ transitionDuration: 0 }} {...props}>
                    {ctxMenuProps => (
                        <div
                            className={classNames(ctxMenuProps.className, TARGET_CLASSNAME)}
                            onContextMenu={ctxMenuProps.onContextMenu}
                        >
                            {ctxMenuProps.popover}
                            <span data-testid="content-clicked-info">
                                {renderClickedInfo(ctxMenuProps.contentProps.targetOffset)}
                            </span>
                        </div>
                    )}
                </ContextMenu>,
                { attachTo: containerElement },
            );
        }
    });

    describe("advanced usage (content render function API)", () => {
        const ALT_CONTENT_WRAPPER = "alternative-content-wrapper";

        it("renders children and menu content, prevents default context menu handler", done => {
            const onContextMenu = (e: React.MouseEvent) => {
                assert.isTrue(e.defaultPrevented);
                done();
            };
            const wrapper = mountTestMenu({ onContextMenu });
            assert.isTrue(wrapper.find(`.${TARGET_CLASSNAME}`).exists());
            openCtxMenu(wrapper);
            assert.isTrue(wrapper.find(`.${MENU_CLASSNAME}`).exists());
            closeCtxMenu(wrapper);
        });

        it("triggers native context menu if content function returns undefined", done => {
            const onContextMenu = (e: React.MouseEvent) => {
                assert.isFalse(e.defaultPrevented);
                done();
            };
            const wrapper = mountTestMenu({
                content: () => undefined,
                onContextMenu,
            });
            openCtxMenu(wrapper);
            closeCtxMenu(wrapper);
        });

        it("updates menu if content prop value changes", () => {
            const ctxMenu = mountTestMenu();
            openCtxMenu(ctxMenu);
            assert.isTrue(ctxMenu.find(`.${MENU_CLASSNAME}`).exists());
            assert.isFalse(ctxMenu.find(`.${ALT_CONTENT_WRAPPER}`).exists());
            ctxMenu.setProps({ content: renderAlternativeContent });
            assert.isTrue(ctxMenu.find(`.${ALT_CONTENT_WRAPPER}`).exists());
        });

        it("updates menu if content render function return value changes", () => {
            const testMenu = mount(<TestMenuWithChangingContent useAltContent={false} />, {
                attachTo: containerElement,
            });
            openCtxMenu(testMenu);
            assert.isTrue(testMenu.find(`.${MENU_CLASSNAME}`).exists());
            assert.isFalse(testMenu.find(`.${ALT_CONTENT_WRAPPER}`).exists());
            testMenu.setProps({ useAltContent: true });
            assert.isTrue(testMenu.find(`.${ALT_CONTENT_WRAPPER}`).exists());
        });

        function renderContent({ mouseEvent, targetOffset }: ContextMenuContentProps) {
            if (mouseEvent === undefined || targetOffset === undefined) {
                return undefined;
            }
            return MENU;
        }

        function renderAlternativeContent() {
            return <div className={ALT_CONTENT_WRAPPER}>{MENU}</div>;
        }

        function mountTestMenu(props?: Partial<ContextMenuProps>) {
            return mount(
                <ContextMenu content={renderContent} popoverProps={{ transitionDuration: 0 }} {...props}>
                    <div className={TARGET_CLASSNAME} />
                </ContextMenu>,
                { attachTo: containerElement },
            );
        }

        function TestMenuWithChangingContent({ useAltContent } = { useAltContent: false }) {
            const content = React.useCallback(
                (contentProps: ContextMenuContentProps) =>
                    useAltContent ? renderAlternativeContent() : renderContent(contentProps),
                [useAltContent],
            );
            return (
                <ContextMenu content={content} popoverProps={{ transitionDuration: 0 }}>
                    <div className={TARGET_CLASSNAME} />
                </ContextMenu>
            );
        }
    });

    describe("theming", () => {
        it("detects dark theme", () => {
            const wrapper = mount(
                <div className={Classes.DARK}>
                    <ContextMenu content={MENU} popoverProps={{ transitionDuration: 0 }}>
                        <div className={TARGET_CLASSNAME} />
                    </ContextMenu>
                </div>,
            );

            openCtxMenu(wrapper);
            const ctxMenuPopover = wrapper.find(`.${Classes.CONTEXT_MENU_POPOVER}`).hostNodes();
            assert.isTrue(
                ctxMenuPopover.hasClass(Classes.DARK),
                "ContextMenu popover should be open WITH dark theme applied",
            );
            closeCtxMenu(wrapper);
        });

        it("detects theme change (dark -> light)", () => {
            const wrapper = mount(
                <div className={Classes.DARK}>
                    <ContextMenu content={MENU} popoverProps={{ transitionDuration: 0 }}>
                        <div className={TARGET_CLASSNAME} />
                    </ContextMenu>
                </div>,
            );

            wrapper.setProps({ className: undefined });
            openCtxMenu(wrapper);
            const ctxMenuPopover = wrapper.find(`.${Classes.CONTEXT_MENU_POPOVER}`).hostNodes();
            assert.isFalse(
                ctxMenuPopover.hasClass(Classes.DARK),
                "ContextMenu popover should be open WITHOUT dark theme applied",
            );
            closeCtxMenu(wrapper);
        });
    });

    describe("interacting with other components", () => {
        describe("with one level of nesting", () => {
            it("closes parent Tooltip", () => {
                const wrapper = mount(
                    <Tooltip content="hello" {...COMMON_TOOLTIP_PROPS}>
                        <ContextMenu content={MENU} popoverProps={{ transitionDuration: 0 }}>
                            <div className={TARGET_CLASSNAME} />
                        </ContextMenu>
                    </Tooltip>,
                );

                openTooltip(wrapper);
                openCtxMenu(wrapper);
                assert.isTrue(
                    wrapper.find(ContextMenu).find(Popover).prop("isOpen"),
                    "ContextMenu popover should be open",
                );
                assertTooltipClosed(wrapper);
                closeCtxMenu(wrapper);
            });

            it("closes child Tooltip", () => {
                const wrapper = mount(
                    <ContextMenu content={MENU} popoverProps={{ transitionDuration: 0 }}>
                        <Tooltip content="hello" {...COMMON_TOOLTIP_PROPS}>
                            <div className={TARGET_CLASSNAME} />
                        </Tooltip>
                    </ContextMenu>,
                );

                openTooltip(wrapper);
                openCtxMenu(wrapper);
                assert.isTrue(
                    wrapper.find(ContextMenu).find(Popover).first().prop("isOpen"),
                    "ContextMenu popover should be open",
                );
                // this assertion is difficult to unit test, but we know that the tooltip closes in manual testing,
                // see https://github.com/palantir/blueprint/pull/4744
                // assertTooltipClosed(wrapper);
                closeCtxMenu(wrapper);
            });

            function assertTooltipClosed(wrapper: ReactWrapper) {
                assert.isFalse(
                    wrapper
                        .find(Popover)
                        .find({ interactionKind: PopoverInteractionKind.HOVER_TARGET_ONLY })
                        .state("isOpen"),
                    "Tooltip should be closed",
                );
            }
        });

        describe("with multiple layers of Tooltip nesting", () => {
            const OUTER_TARGET_CLASSNAME = "outer-target";

            describe("ContextMenu > Tooltip > ContextMenu", () => {
                it("closes tooltip when inner menu opens", () => {
                    const wrapper = mountTestCase();
                    openTooltip(wrapper);
                    assert.lengthOf(wrapper.find(TOOLTIP_SELECTOR), 1, "tooltip should be open");
                    openCtxMenu(wrapper);
                    assertTooltipClosed(wrapper);
                    const ctxMenuPopover = wrapper.find(`.${Classes.CONTEXT_MENU_POPOVER}`).hostNodes();
                    assert.isTrue(ctxMenuPopover.exists(), "ContextMenu popover should be open");
                    assert.isTrue(ctxMenuPopover.text().includes("first"), "inner ContextMenu should be open");
                    closeCtxMenu(wrapper);
                });

                it("closes tooltip when outer menu opens", () => {
                    const wrapper = mountTestCase();
                    openTooltip(wrapper, OUTER_TARGET_CLASSNAME);
                    assert.lengthOf(wrapper.find(TOOLTIP_SELECTOR), 1, "tooltip should be open");
                    openCtxMenu(wrapper, OUTER_TARGET_CLASSNAME);
                    // this assertion is difficult to test, but we know that the tooltip eventually does close in manual testing
                    // assertTooltipClosed(wrapper);
                    const ctxMenuPopover = wrapper.find(`.${Classes.CONTEXT_MENU_POPOVER}`).hostNodes();
                    assert.isTrue(ctxMenuPopover.exists(), "ContextMenu popover should be open");
                    assert.isTrue(ctxMenuPopover.text().includes("Align"), "outer ContextMenu should be open");
                    closeCtxMenu(wrapper);
                });

                function mountTestCase() {
                    /**
                     * Renders a component tree that looks like this:
                     *
                     *  ––––––––––––––––––––––––––––––––––––––
                     * |   outer ctx menu                     |
                     * |   ––––––––––––––––––––––––––––––––   |
                     * |  |   tooltip target               |  |
                     * |  |   ––––––––––––––––––––––––––   |  |
                     * |  |  | inner ctx menu w/ target |  |  |
                     * |  |  |                          |  |  |
                     * |  |   ––––––––––––––––––––––––––   |  |
                     * |   ––––––––––––––––––––––––––––––––   |
                     *  ––––––––––––––––––––––––––––––––––––––
                     *
                     * It is possible to click on just the outer ctx menu, hover on just the tooltip target
                     * (and not the inner target), and to click on the inner target.
                     */
                    return mount(
                        <ContextMenu
                            content={MENU}
                            popoverProps={{ transitionDuration: 0 }}
                            style={{ width: 100, height: 100, padding: 20, background: "red" }}
                        >
                            <Tooltip content="hello" {...COMMON_TOOLTIP_PROPS}>
                                <div className={OUTER_TARGET_CLASSNAME} style={{ padding: 20, background: "green" }}>
                                    <ContextMenu
                                        content={
                                            <Menu>
                                                <MenuItem text="first" />
                                                <MenuItem text="second" />
                                                <MenuItem text="third" />
                                            </Menu>
                                        }
                                        popoverProps={{ transitionDuration: 0 }}
                                    >
                                        <div
                                            className={TARGET_CLASSNAME}
                                            style={{ width: 20, height: 20, background: "blue" }}
                                        />
                                    </ContextMenu>
                                </div>
                            </Tooltip>
                        </ContextMenu>,
                    );
                }

                function assertTooltipClosed(wrapper: ReactWrapper) {
                    assert.isFalse(
                        wrapper
                            .find(Popover)
                            .find({ interactionKind: PopoverInteractionKind.HOVER_TARGET_ONLY })
                            .state("isOpen"),
                        "Tooltip should be closed",
                    );
                }
            });

            describe("Tooltip > ContextMenu > Tooltip", () => {
                const OUTER_TOOLTIP_CONTENT = "hello";
                const INNER_TOOLTIP_CONTENT = "goodbye";
                const CTX_MENU_CLASSNAME = "test-ctx-menu";

                it("closes inner tooltip when menu opens (after hovering inner target)", () => {
                    const wrapper = mountTestCase();
                    wrapper.find(`.${OUTER_TARGET_CLASSNAME}`).simulate("mouseenter");
                    openTooltip(wrapper);
                    assert.lengthOf(wrapper.find(`.${Classes.TOOLTIP}`), 1, "tooltip should be open");
                    openCtxMenu(wrapper);
                    // this assertion is difficult to test, but we know that the tooltip eventually does close in manual testing
                    assert.isFalse(
                        wrapper
                            .find(Popover)
                            .find({ interactionKind: PopoverInteractionKind.HOVER_TARGET_ONLY })
                            .first()
                            .state("isOpen"),
                        "Tooltip should be closed",
                    );
                    const ctxMenuPopover = wrapper.find(`.${Classes.CONTEXT_MENU_POPOVER}`).hostNodes();
                    assert.isTrue(ctxMenuPopover.exists(), "ContextMenu popover should be open");
                    closeCtxMenu(wrapper);
                    wrapper.find(`.${OUTER_TARGET_CLASSNAME}`).simulate("mouseleave");
                });

                it("closes outer tooltip when menu opens (after hovering ctx menu target)", () => {
                    const wrapper = mountTestCase();
                    openTooltip(wrapper, CTX_MENU_CLASSNAME);
                    assert.lengthOf(wrapper.find(`.${Classes.TOOLTIP}`), 1, "tooltip should be open");
                    openCtxMenu(wrapper, CTX_MENU_CLASSNAME);
                    // this assertion is difficult to test, but we know that the tooltip eventually does close in manual testing
                    // assert.isFalse(
                    //     wrapper
                    //         .find(Popover)
                    //         .find({ interactionKind: PopoverInteractionKind.HOVER_TARGET_ONLY })
                    //         .last()
                    //         .state("isOpen"),
                    //     "Tooltip should be closed",
                    // );
                    const ctxMenuPopover = wrapper.find(`.${Classes.CONTEXT_MENU_POPOVER}`).hostNodes();
                    assert.isTrue(ctxMenuPopover.exists(), "ContextMenu popover should be open");
                    assert.isTrue(ctxMenuPopover.text().includes("Align"), "outer ContextMenu should be open");
                    closeCtxMenu(wrapper);
                    wrapper.find(`.${OUTER_TARGET_CLASSNAME}`).simulate("mouseleave");
                });

                function mountTestCase() {
                    /**
                     * Renders a component tree that looks like this:
                     *
                     *  ––––––––––––––––––––––––––––––––––––––
                     * |  outer tooltip                       |
                     * |   ––––––––––––––––––––––––––––––––   |
                     * |  |  ctx menu target               |  |
                     * |  |   ––––––––––––––––––––––––––   |  |
                     * |  |  | inner tooltip w/ target  |  |  |
                     * |  |  |                          |  |  |
                     * |  |   ––––––––––––––––––––––––––   |  |
                     * |   ––––––––––––––––––––––––––––––––   |
                     *  ––––––––––––––––––––––––––––––––––––––
                     *
                     * It is possible to hover on just the outer tooltip area, click on just the ctx menu target
                     * (and not trigger the inner tooltip), and to click/hover on the inner target.
                     */
                    return mount(
                        <Tooltip content={OUTER_TOOLTIP_CONTENT} {...COMMON_TOOLTIP_PROPS}>
                            <div
                                className={OUTER_TARGET_CLASSNAME}
                                style={{ width: 100, height: 100, padding: 20, background: "green" }}
                            >
                                <ContextMenu
                                    className={CTX_MENU_CLASSNAME}
                                    content={MENU}
                                    popoverProps={{ transitionDuration: 0 }}
                                    style={{ padding: 20, background: "red" }}
                                >
                                    <Tooltip content={INNER_TOOLTIP_CONTENT} {...COMMON_TOOLTIP_PROPS}>
                                        <div
                                            className={TARGET_CLASSNAME}
                                            style={{ width: 20, height: 20, background: "blue" }}
                                        />
                                    </Tooltip>
                                </ContextMenu>
                            </div>
                        </Tooltip>,
                    );
                }
            });
        });

        describe("with Drawer as parent content", () => {
            it("positions correctly", () => {
                const POPOVER_CLASSNAME = "test-positions-popover";
                const wrapper = mount(
                    <Drawer isOpen={true} position="right" transitionDuration={0}>
                        <ContextMenu
                            content={MENU}
                            className="test-ctx-menu"
                            popoverProps={{ transitionDuration: 0, popoverClassName: POPOVER_CLASSNAME }}
                            style={{ padding: 20, background: "red" }}
                        >
                            <div className={TARGET_CLASSNAME} style={{ width: 20, height: 20, background: "blue" }} />
                        </ContextMenu>
                    </Drawer>,
                    { attachTo: containerElement },
                );
                const target = wrapper.find(`.${TARGET_CLASSNAME}`).hostNodes();
                assert.isTrue(target.exists(), "target should exist");
                const nonExistentPopover = wrapper.find(`.${POPOVER_CLASSNAME}`).hostNodes();
                assert.isFalse(
                    nonExistentPopover.exists(),
                    "ContextMenu popover should not be open before triggering contextmenu event",
                );

                const targetRect = target.getDOMNode().getBoundingClientRect();
                // right click on the target
                const simulateArgs = {
                    clientX: targetRect.left + targetRect.width / 2,
                    clientY: targetRect.top + targetRect.height / 2,
                    x: targetRect.left + targetRect.width / 2,
                    y: targetRect.top + targetRect.height / 2,
                };
                target.simulate("contextmenu", simulateArgs);
                const popover = wrapper.find(`.${POPOVER_CLASSNAME}`).hostNodes();
                assert.isTrue(popover.exists(), "ContextMenu popover should be open");
            });
        });

        function openTooltip(wrapper: ReactWrapper, targetClassName = TARGET_CLASSNAME) {
            const target = wrapper.find(`.${targetClassName}`);
            if (!target.exists()) {
                assert.fail("tooltip target not found in mounted test case");
            }
            target.hostNodes().closest(`.${Classes.POPOVER_TARGET}`).simulate("mouseenter");
        }
    });

    function openCtxMenu(ctxMenu: ReactWrapper, targetClassName = TARGET_CLASSNAME) {
        const target = ctxMenu.find(`.${targetClassName}`);
        if (!target.exists()) {
            assert.fail("Context menu target not found in mounted test case");
        }
        const { clientLeft, clientTop } = target.hostNodes().getDOMNode();
        target
            .hostNodes()
            .simulate("contextmenu", { defaultPrevented: false, clientX: clientLeft + 10, clientY: clientTop + 10 })
            .update();
    }

    function closeCtxMenu(wrapper: ReactWrapper) {
        const backdrop = wrapper.find(`.${Classes.CONTEXT_MENU_BACKDROP}`);
        if (backdrop.exists()) {
            backdrop.simulate("mousedown");
            wrapper.update();
        }
    }

    function renderClickedInfo(targetOffset: ContextMenuContentProps["targetOffset"]) {
        return targetOffset === undefined ? "" : `Clicked at (${targetOffset.left}, ${targetOffset.top})`;
    }
});

================================================================================

File: test\control-card\controlCardTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { type EnzymePropSelector, mount, type ReactWrapper } from "enzyme";
import * as React from "react";
import { type SinonSpy, spy } from "sinon";

import { CheckboxCard, Classes, RadioCard, RadioGroup, SwitchCard } from "../../src";

describe("ControlCard", () => {
    let testsContainerElement: HTMLElement | undefined;

    beforeEach(() => {
        testsContainerElement = document.createElement("div");
        document.body.appendChild(testsContainerElement);
    });

    afterEach(() => {
        testsContainerElement?.remove();
    });

    describe("SwitchCard", () => {
        const handleControlChangeSpy = spy() as SinonSpy<[React.FormEvent<HTMLInputElement>], void>;

        beforeEach(() => {
            handleControlChangeSpy.resetHistory();
        });

        it("clicking on label element toggles switch state", () => {
            const wrapper = mount(<SwitchCard defaultChecked={false} onChange={handleControlChangeSpy} />, {
                attachTo: testsContainerElement,
            });
            wrapper.find("input").simulate("change");
            assert.isTrue(handleControlChangeSpy.calledOnce, "expected onChange to be called");
        });
    });

    describe("CheckboxCard", () => {
        it("is left-aligned by default", () => {
            const wrapper = mount(<CheckboxCard />, { attachTo: testsContainerElement });
            assert.isTrue(
                wrapper.find(`.${Classes.CONTROL}.${Classes.ALIGN_LEFT}`).exists(),
                "expected left alignment",
            );
        });
    });

    describe("RadioCard", () => {
        it("works like a Radio component inside a RadioGroup", () => {
            const changeSpy = spy();
            const group = mount(
                <RadioGroup onChange={changeSpy}>
                    <RadioCard value="one" label="One" />
                    <RadioCard value="two" label="Two" />
                </RadioGroup>,
            );
            findInput(group, { value: "one" }).simulate("change");
            findInput(group, { value: "two" }).simulate("change");
            assert.equal(changeSpy.callCount, 2);
        });
    });

    function findInput(wrapper: ReactWrapper<any, any>, props: EnzymePropSelector) {
        return wrapper.find("input").filter(props);
    }
});

================================================================================

File: test\controls\controlsTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount } from "enzyme";
import * as React from "react";

import { Classes } from "../../src";
import type { ControlProps } from "../../src/components/forms/controlProps";
import { Checkbox, Radio, Switch } from "../../src/components/forms/controls";

type ControlType = typeof Checkbox | typeof Radio | typeof Switch;

describe("Controls:", () => {
    controlsTests(Checkbox, "checkbox", Classes.CHECKBOX, () => {
        describe("indeterminate", () => {
            const inputRef = React.createRef<HTMLInputElement>();

            it("prop sets element state", () => {
                mount(<Checkbox indeterminate={true} inputRef={inputRef} />);
                assert.isTrue(inputRef.current?.indeterminate);
            });

            it("default prop sets element state", () => {
                mount(<Checkbox defaultIndeterminate={true} inputRef={inputRef} />);
                assert.isTrue(inputRef.current?.indeterminate);
            });
        });
    });

    controlsTests(Switch, "checkbox", Classes.SWITCH, () => {
        describe("internal text", () => {
            it("renders both innerLabels when both defined", () => {
                const switchWithText = mount(<Switch innerLabelChecked="checked" innerLabel="unchecked" />);
                const innerTextNodes = switchWithText.find(`.${Classes.SWITCH_INNER_TEXT}`);
                const checkedTest = innerTextNodes.first().text();
                const uncheckedText = innerTextNodes.last().text();
                assert.lengthOf(innerTextNodes, 2);
                assert.equal(checkedTest.trim(), "checked");
                assert.equal(uncheckedText.trim(), "unchecked");
            });
            it("does not render innerLabel components when neither defined", () => {
                const switchWithoutText = mount(<Switch />);
                const innerTextNodes = switchWithoutText.find(`.${Classes.SWITCH_INNER_TEXT}`);
                assert.lengthOf(innerTextNodes, 0);
            });
            it("renders innerLabel when innerLabelChecked is undefined", () => {
                const switchWithText = mount(<Switch innerLabel="onlyInnerLabel" />);
                const innerTextNodes = switchWithText.find(`.${Classes.SWITCH_INNER_TEXT}`);
                const checkedText = innerTextNodes.last().text();
                const uncheckedText = innerTextNodes.first().text();
                assert.equal(checkedText.trim(), "onlyInnerLabel");
                assert.equal(checkedText.trim(), uncheckedText.trim());
            });
            it("renders innerLabelChecked only when checked", () => {
                const switchWithText = mount(<Switch innerLabelChecked="onlyChecked" />);
                const innerTextNodes = switchWithText.find(`.${Classes.SWITCH_INNER_TEXT}`);
                const checked = innerTextNodes.first().text();
                const uncheckedText = innerTextNodes.last().text();
                assert.equal(checked.trim(), "onlyChecked");
                assert.equal(uncheckedText.trim(), "");
            });
        });
    });

    controlsTests(Radio, "radio", Classes.RADIO);

    function controlsTests(classType: ControlType, propType: string, className: string, moreTests?: () => void) {
        describe(`<${classType.displayName!.split(".")[1]}>`, () => {
            it(`renders .${Classes.CONTROL}.${className}`, () => {
                const control = mountControl();
                assert.isTrue(control.find(`.${Classes.CONTROL}`).hasClass(className));
            });

            it(`renders input[type=${propType}]`, () => {
                // ensure that `type` prop always comes out as expected, regardless of given value
                const control = mountControl({ type: "failure" });
                assert.equal(control.find("input").prop("type"), propType);
            });

            it("supports JSX children", () => {
                const control = mountControl({}, <span className="jsx-child" key="jsx" />, "Label Text");
                assert.lengthOf(control.find(".jsx-child"), 1);
                assert.equal(control.text().trim(), "Label Text");
            });

            it("supports JSX labelElement", () => {
                // uncommenting this line should present a tsc error on label prop:
                // <Checkbox label={<strong>boom</strong>} />;

                const control = mountControl({ labelElement: <strong>boom</strong> });
                assert.lengthOf(control.find("strong"), 1);
                assert.equal(control.text().trim(), "boom");
            });

            if (moreTests != null) {
                moreTests();
            }
        });

        function mountControl(props?: ControlProps, ...children: React.ReactNode[]) {
            return mount(React.createElement(classType, props, children));
        }
    }
});

================================================================================

File: test\controls\inputGroupTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount } from "enzyme";
import * as React from "react";
import { spy } from "sinon";

import { Classes, Icon, InputGroup } from "../../src";

describe("<InputGroup>", () => {
    it("renders left icon before input", () => {
        const input = mount(<InputGroup leftIcon="star" />).children();
        assert.isTrue(input.childAt(0).is(Icon));
        assert.isTrue(input.childAt(1).hasClass(Classes.INPUT));
    });

    it("supports custom props", () => {
        const input = mount(<InputGroup leftIcon="star" style={{ background: "yellow" }} tabIndex={4} />);
        const inputElement = input.find("input").getDOMNode() as HTMLElement;
        assert.equal(inputElement.style.background, "yellow");
        assert.equal(inputElement.tabIndex, 4);
    });

    it(`renders right element inside .${Classes.INPUT_ACTION} after input`, () => {
        const action = mount(<InputGroup rightElement={<address />} />)
            .children()
            .childAt(1);
        assert.isTrue(action.hasClass(Classes.INPUT_ACTION));
        assert.lengthOf(action.find("address"), 1);
    });

    it("works like a text input", () => {
        const changeSpy = spy();
        const input = mount(<InputGroup value="value" onChange={changeSpy} />).find("input");
        assert.strictEqual(input.prop("type"), "text");
        assert.strictEqual(input.prop("value"), "value");

        input.simulate("change");
        assert.isTrue(changeSpy.calledOnce, "onChange not called");
    });

    it("supports custom type attribute", () => {
        const group = mount(<InputGroup type="email" />);
        assert.strictEqual(group.find("input").prop("type"), "email");

        group.setProps({ type: "password" });
        assert.strictEqual(group.find("input").prop("type"), "password");
    });

    it("supports inputRef", () => {
        let input: HTMLInputElement | null = null;
        mount(<InputGroup inputRef={ref => (input = ref)} />);
        assert.instanceOf(input, HTMLInputElement);
    });

    // this test was added to validate a regression introduced by AsyncControllableInput,
    // see https://github.com/palantir/blueprint/issues/4375
    it("accepts controlled update truncating the input value", () => {
        class TestComponent extends React.PureComponent<
            { initialValue: string; transformInput: (value: string) => string },
            { value: string }
        > {
            public state = { value: this.props.initialValue };

            public render() {
                return <InputGroup type="text" value={this.state.value} onChange={this.handleChange} />;
            }

            private handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
                this.setState({
                    value: this.props.transformInput(e.target.value),
                });
            };
        }

        const wrapper = mount(
            <TestComponent initialValue="abc" transformInput={(value: string) => value.substring(0, 3)} />,
        );

        let input = wrapper.find("input");
        assert.strictEqual(input.prop("value"), "abc");

        input.simulate("change", { target: { value: "abcd" } });
        input = wrapper.find("input");
        // value should not change because our change handler prevents it from being longer than characters
        assert.strictEqual(input.prop("value"), "abc");
    });

    it("supports the onValueChange callback", () => {
        const initialValue = "value";
        const newValue = "new-value";
        const handleValueChange = spy();
        const inputGroup = mount(<InputGroup value={initialValue} onValueChange={handleValueChange} />);
        assert.strictEqual(inputGroup.find("input").prop("value"), initialValue);

        inputGroup
            .find("input")
            .simulate("change", { currentTarget: { value: newValue }, target: { value: newValue } });
        assert.isTrue(handleValueChange.calledOnce, "onValueChange not called");
        assert.isTrue(handleValueChange.calledWithMatch(newValue), `onValueChange not called with '${newValue}'`);
    });
});

================================================================================

File: test\controls\numericInputTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert, expect } from "chai";
import {
    type MountRendererProps,
    type ReactWrapper,
    type ShallowRendererProps,
    mount as untypedMount,
    shallow as untypedShallow,
} from "enzyme";
import * as React from "react";
import { type SinonStub, spy, stub } from "sinon";

import { dispatchMouseEvent } from "@blueprintjs/test-commons";

import {
    Button,
    ButtonGroup,
    ControlGroup,
    type HTMLInputProps,
    Icon,
    InputGroup,
    NumericInput,
    type NumericInputProps,
    Position,
} from "../../src";
import * as Errors from "../../src/common/errors";

/**
 * @see https://github.com/DefinitelyTyped/DefinitelyTyped/issues/26979#issuecomment-465304376
 */
const mount = (el: React.ReactElement<NumericInputProps>, options?: MountRendererProps) =>
    untypedMount<NumericInput>(el, options);
const shallow = (el: React.ReactElement<NumericInputProps>, options?: ShallowRendererProps) =>
    untypedShallow<NumericInput>(el, options);

describe("<NumericInput>", () => {
    describe("Defaults", () => {
        it("renders the buttons on the right by default", () => {
            // this ordering is trivial to test with shallow renderer
            // (no DOM elements getting in the way)
            const component = untypedShallow(<NumericInput />);
            const rightGroup = component.children().last();
            expect(rightGroup.is(ButtonGroup)).to.be.true;
        });

        it("has a stepSize of 1 by default", () => {
            const component = mount(<NumericInput />);
            const stepSize = component.props().stepSize;
            expect(stepSize).to.equal(1);
        });

        it("has a minorStepSize of 0.1 by default", () => {
            const component = mount(<NumericInput />);
            const minorStepSize = component.props().minorStepSize;
            expect(minorStepSize).to.equal(0.1);
        });

        it("has a majorStepSize of 10 by default", () => {
            const component = mount(<NumericInput />);
            const majorStepSize = component.props().majorStepSize;
            expect(majorStepSize).to.equal(10);
        });

        it("has a value of '' by default", () => {
            const component = mount(<NumericInput />);
            const value = component.state().value;
            expect(value).to.equal("");
        });

        it("increments the value from 0 if the field is empty", () => {
            const component = mount(<NumericInput />);

            const incrementButton = component.find(Button).first();
            incrementButton.simulate("mousedown");

            const value = component.state().value;
            expect(value).to.equal("1");
        });

        it("accepts defaultValue prop", () => {
            const component = mount(<NumericInput defaultValue={2} />);
            const value = component.state().value;
            expect(value).to.equal("2");
        });
    });

    describe("Button position", () => {
        it("renders the buttons on the right when buttonPosition == Position.RIGHT", () => {
            const buttons = shallow(<NumericInput buttonPosition={Position.RIGHT} />)
                .children()
                .last();
            expect(buttons.is(ButtonGroup)).to.be.true;
        });

        it("renders the buttons on the left when buttonPosition == Position.LEFT", () => {
            const buttons = shallow(<NumericInput buttonPosition={Position.LEFT} />)
                .children()
                .first();
            expect(buttons.is(ButtonGroup)).to.be.true;
        });

        it('does not render the buttons when buttonPosition == "none"', () => {
            const component = shallow(<NumericInput buttonPosition="none" />);
            expect(component.find(ButtonGroup).exists()).to.be.false;
        });

        it(`always renders the children in a ControlGroup`, () => {
            // if the input is put into a control group by itself, it'll have squared border radii
            // on the left, which we don't want.
            const component = shallow(<NumericInput />);
            expect(component.find(ControlGroup).exists()).to.be.true;
            component.setProps({ buttonPosition: "none" });
            expect(component.find(ControlGroup).exists()).to.be.true;
        });
    });

    describe("Basic functionality", () => {
        it("works like a text input", () => {
            const component = mount(<NumericInput />);

            component.find("input").simulate("change", { target: { value: "11" } });
            expect(component.state().value).to.equal("11");
        });

        it("allows entry of non-numeric characters", () => {
            const component = mount(<NumericInput />);

            component.find("input").simulate("change", { target: { value: "3 + a" } });

            const value = component.state().value;
            const expectedValue = "3 + a";
            expect(value).to.equal(expectedValue);
        });

        it("provides numeric value to onValueChange as a number and a string", () => {
            const onValueChangeSpy = spy();
            const component = mount(<NumericInput onValueChange={onValueChangeSpy} />);
            const nextValue = "1";

            component.find("input").simulate("change", { target: { value: nextValue } });

            expect(onValueChangeSpy.calledOnce).to.be.true;
            expect(onValueChangeSpy.calledWith(+nextValue, nextValue)).to.be.true;
        });

        it("provides non-numeric value to onValueChange as NaN and a string", () => {
            const onValueChangeSpy = spy();
            const component = mount(<NumericInput onValueChange={onValueChangeSpy} />);
            const invalidValue = "non-numeric-value";

            component.find("input").simulate("change", { target: { value: invalidValue } });

            expect(onValueChangeSpy.calledOnce).to.be.true;
            expect(onValueChangeSpy.calledWith(NaN, invalidValue)).to.be.true;
        });

        it("accepts a numeric value", () => {
            const component = mount(<NumericInput value={10} />);
            const value = component.state().value;
            expect(value).to.equal("10");
        });

        it("accepts a string value", () => {
            const component = mount(<NumericInput value={"10"} />);
            const value = component.state().value;
            expect(value).to.equal("10");
        });

        it("fires onValueChange with the number value, string value, and input element when the value changes", () => {
            const onValueChangeSpy = spy();
            const component = mount(<NumericInput onValueChange={onValueChangeSpy} />);

            const incrementButton = component.find(Button).first();
            incrementButton.simulate("mousedown");
            dispatchMouseEvent(document, "mouseup");

            const inputElement = component.find("input").first().getDOMNode();
            expect(onValueChangeSpy.calledOnceWithExactly(1, "1", inputElement)).to.be.true;
        });

        it("fires onButtonClick with the number value and the string value when either button is pressed", () => {
            const onButtonClickSpy = spy();
            const component = mount(<NumericInput onButtonClick={onButtonClickSpy} />);

            const incrementButton = component.find(Button).first();
            const decrementButton = component.find(Button).last();

            // incrementing from 0
            incrementButton.simulate("mousedown");
            dispatchMouseEvent(document, "mouseup");

            expect(onButtonClickSpy.calledOnce).to.be.true;
            expect(onButtonClickSpy.firstCall.args).to.deep.equal([1, "1"]);
            onButtonClickSpy.resetHistory();

            // decrementing from 1 now
            decrementButton.simulate("mousedown");
            expect(onButtonClickSpy.calledOnce).to.be.true;
            expect(onButtonClickSpy.firstCall.args).to.deep.equal([0, "0"]);
        });
    });

    describe("Selection", () => {
        const VALUE = "12345678";

        describe("selectAllOnFocus", () => {
            it("if false (the default), does not select any text on focus", () => {
                const containerElement = document.createElement("div");
                mount(<NumericInput value="12345678" />, { attachTo: containerElement });

                const input = containerElement.querySelector("input")!;
                input.focus();

                expect(input.selectionStart).to.equal(input.selectionEnd);
            });

            it("if true, selects all text on focus", () => {
                const attachTo = document.createElement("div");
                const input = mount(<NumericInput value={VALUE} selectAllOnFocus={true} />, {
                    attachTo,
                }).find("input");
                input.simulate("focus");
                const { selectionStart, selectionEnd } = input.getDOMNode<HTMLInputElement>();
                expect(selectionStart).to.equal(0);
                expect(selectionEnd).to.equal(VALUE.length);
            });
        });

        describe("selectAllOnIncrement", () => {
            const INCREMENT_KEYSTROKE = { key: "ArrowUp" };

            it("if false (the default), does not select any text on increment", () => {
                const attachTo = document.createElement("div");
                const component = mount(<NumericInput value="12345678" />, { attachTo });

                const wrappedInput = component.find(InputGroup).find("input");
                wrappedInput.simulate("keyDown", INCREMENT_KEYSTROKE);

                const input = attachTo.querySelector<HTMLInputElement>("input")!;
                expect(input.selectionStart).to.equal(input.selectionEnd);
            });

            it("if true, selects all text on increment", () => {
                const attachTo = document.createElement("div");
                const component = mount(<NumericInput value={VALUE} selectAllOnIncrement={true} />, { attachTo });

                const wrappedInput = component.find(InputGroup).find("input");
                wrappedInput.simulate("keyDown", INCREMENT_KEYSTROKE);

                const input = attachTo.querySelector<HTMLInputElement>("input")!;
                expect(input.selectionStart).to.equal(0);
                expect(input.selectionEnd).to.equal(VALUE.length);
            });
        });
    });

    describe("Keyboard text entry in input field", () => {
        const LESS_COMMON_SYMBOLS = stringToCharArray("åß∂ƒ©©˙∆˚≈ç√∫˜µ≤∑´®†¥¨ˆ≤≥");

        const NON_CHARACTER_KEYS = [
            "Alt",
            "ArrowDown",
            "ArrowLeft",
            "ArrowRight",
            "ArrowUp",
            "Backspace",
            "CapsLock",
            "Control",
            "Enter",
            "Escape",
            "F1",
            "F2",
            "F3",
            "F4",
            "F5",
            "F6",
            "F7",
            "F8",
            "F9",
            "F10",
            "F11",
            "F12",
            "Meta",
            "Shift",
            "Tab",
        ];

        const NON_NUMERIC_LOWERCASE_LETTERS = stringToCharArray("abcdfghijklmnopqrstuvwxyz");
        const NON_NUMERIC_UPPERCASE_LETTERS = stringToCharArray("ABCDFGHIJKLMNOPQRSTUVWXYZ");
        const NON_NUMERIC_SYMBOLS_WITHOUT_SHIFT = stringToCharArray("`=[]\\;',/");
        const NON_NUMERIC_SYMBOLS_WITH_SHIFT = stringToCharArray('~!@#$%^&*()_{}|:"<>?');

        const NUMERIC_DIGITS = stringToCharArray("0123456789"); // could be typed from the keyboard or numpad
        const NUMERIC_LOWERCASE_LETTERS = stringToCharArray("e");
        const NUMERIC_UPPERCASE_LETTERS = stringToCharArray("E");
        const NUMERIC_SYMBOLS_WITHOUT_SHIFT = stringToCharArray(".-");
        const NUMERIC_SYMBOLS_WITH_SHIFT = stringToCharArray("+");

        const SAMPLE_CHARS_TO_ALLOW_WITH_ALT_CTRL_META_WITHOUT_SHIFT = stringToCharArray("a[;,/=");
        const SAMPLE_CHARS_TO_ALLOW_WITH_ALT_CTRL_META_WITH_SHIFT = stringToCharArray("A{:<?_!");

        const SPACE_CHAR = " ";

        describe("if allowNumericCharactersOnly = true", () => {
            it("disables keystroke for all letters except 'e' and 'E'", () => {
                runTextInputSuite(NON_NUMERIC_LOWERCASE_LETTERS, true);
                runTextInputSuite(NON_NUMERIC_UPPERCASE_LETTERS, true, { shiftKey: true });
                runTextInputSuite(NUMERIC_LOWERCASE_LETTERS, false);
                runTextInputSuite(NUMERIC_UPPERCASE_LETTERS, false, { shiftKey: true });
            });

            it("disables keystroke for all common English symbols except '.', '-', and '+'", () => {
                // these are typed without the shift key
                runTextInputSuite(NON_NUMERIC_SYMBOLS_WITHOUT_SHIFT, true);
                runTextInputSuite(NUMERIC_SYMBOLS_WITHOUT_SHIFT, false);

                // these are typed with the shift key
                runTextInputSuite(NON_NUMERIC_SYMBOLS_WITH_SHIFT, true, { shiftKey: true });
                runTextInputSuite(NUMERIC_SYMBOLS_WITH_SHIFT, false, { shiftKey: true });
            });

            it("disables keystroke for less common symbols typed with OPTION-key modifier on Mac", () => {
                runTextInputSuite(LESS_COMMON_SYMBOLS, true);
            });

            it("disables keystroke for the spacebar", () => {
                runTextInputSuite([SPACE_CHAR], true);
            });

            it("allows keystroke for keys that don't print a character (Arrow keys, Backspace, Enter, etc.)", () => {
                runTextInputSuite(NON_CHARACTER_KEYS, false);
            });

            it("allows keystroke for numeric digits (0-9)", () => {
                runTextInputSuite(NUMERIC_DIGITS, false);
            });

            it("allows keystroke for any key combination involving the CTRL, ALT, or META keys", () => {
                const charsWithoutShift = SAMPLE_CHARS_TO_ALLOW_WITH_ALT_CTRL_META_WITHOUT_SHIFT;
                runTextInputSuite(charsWithoutShift, false, { altKey: true });
                runTextInputSuite(charsWithoutShift, false, { ctrlKey: true });
                runTextInputSuite(charsWithoutShift, false, { metaKey: true });

                const charsWithShift = SAMPLE_CHARS_TO_ALLOW_WITH_ALT_CTRL_META_WITH_SHIFT;
                runTextInputSuite(charsWithShift, false, { shiftKey: true, altKey: true });
                runTextInputSuite(charsWithShift, false, { shiftKey: true, ctrlKey: true });
                runTextInputSuite(charsWithShift, false, { shiftKey: true, metaKey: true });
            });

            it("allows malformed number inputs as long as all the characters are legal", () => {
                const VALUE = "+++---eeeEEE123...456---+++";

                const component = mount(<NumericInput />);
                const inputField = component.find("input");

                inputField.simulate("change", { target: { value: VALUE } });
                expect(component.state().value).to.equal(VALUE);
            });

            it("omits non-floating-point numeric characters from pasted text", () => {
                const VALUE = "a1a.a2aeaEa+a-a";
                const SANITIZED_VALUE = "1.2eE+-";

                const component = mount(<NumericInput />);
                const inputField = component.find("input");

                inputField.simulate("paste");
                inputField.simulate("change", { target: { value: VALUE } });

                expect(component.state().value).to.equal(SANITIZED_VALUE);
            });
        });

        describe("if allowNumericCharactersOnly = false", () => {
            // Scope-wide flag for setting allowNumericCharactersOnly = false
            const PROP_FLAG: boolean = false;

            // Scope-wide flag for the expected test result.
            const EXPECT_DEFAULT_PREVENTED: boolean = false;

            it("allows keystroke for all English letters", () => {
                const lowercaseLetters = NON_NUMERIC_LOWERCASE_LETTERS.concat(NUMERIC_LOWERCASE_LETTERS);
                const uppercaseLetters = NON_NUMERIC_UPPERCASE_LETTERS.concat(NUMERIC_UPPERCASE_LETTERS);
                runTextInputSuite(lowercaseLetters, EXPECT_DEFAULT_PREVENTED, {}, PROP_FLAG);
                runTextInputSuite(uppercaseLetters, EXPECT_DEFAULT_PREVENTED, { shiftKey: true }, PROP_FLAG);
            });

            it("allows keystroke for all common English symbols", () => {
                const symbolsWithoutShift = NON_NUMERIC_SYMBOLS_WITHOUT_SHIFT.concat(NUMERIC_SYMBOLS_WITHOUT_SHIFT);
                const symbolsWithShift = NON_NUMERIC_SYMBOLS_WITH_SHIFT.concat(NUMERIC_SYMBOLS_WITH_SHIFT);
                runTextInputSuite(symbolsWithoutShift, EXPECT_DEFAULT_PREVENTED, {}, PROP_FLAG);
                runTextInputSuite(symbolsWithShift, EXPECT_DEFAULT_PREVENTED, { shiftKey: true }, PROP_FLAG);
            });

            it("allows keystroke for less common symbols typed with OPTION-key modifier on Mac", () => {
                runTextInputSuite(LESS_COMMON_SYMBOLS, EXPECT_DEFAULT_PREVENTED, {}, PROP_FLAG);
            });

            it("allows keystroke for the space character", () => {
                runTextInputSuite([SPACE_CHAR], EXPECT_DEFAULT_PREVENTED, {}, PROP_FLAG);
            });

            it("allows keystroke for keys that don't print a character (Arrow keys, Backspace, Enter, etc.)", () => {
                runTextInputSuite(NON_CHARACTER_KEYS, EXPECT_DEFAULT_PREVENTED, {}, PROP_FLAG);
            });

            it("allows keystroke for numeric digits (0-9)", () => {
                runTextInputSuite(NUMERIC_DIGITS, EXPECT_DEFAULT_PREVENTED);
            });

            it("allows keystroke for any key combination involving the CTRL, ALT, or META keys", () => {
                const charsWithoutShift = SAMPLE_CHARS_TO_ALLOW_WITH_ALT_CTRL_META_WITHOUT_SHIFT;
                runTextInputSuite(charsWithoutShift, EXPECT_DEFAULT_PREVENTED, { altKey: true });
                runTextInputSuite(charsWithoutShift, EXPECT_DEFAULT_PREVENTED, { ctrlKey: true });
                runTextInputSuite(charsWithoutShift, EXPECT_DEFAULT_PREVENTED, { metaKey: true });

                const charsWithShift = SAMPLE_CHARS_TO_ALLOW_WITH_ALT_CTRL_META_WITH_SHIFT;
                runTextInputSuite(charsWithShift, EXPECT_DEFAULT_PREVENTED, {
                    altKey: true,
                    shiftKey: true,
                });
                runTextInputSuite(charsWithShift, EXPECT_DEFAULT_PREVENTED, {
                    ctrlKey: true,
                    shiftKey: true,
                });
                runTextInputSuite(charsWithShift, EXPECT_DEFAULT_PREVENTED, {
                    metaKey: true,
                    shiftKey: true,
                });
            });
        });
    });

    describe("Keyboard interactions in input field", () => {
        const simulateIncrement = (component: ReactWrapper<any>, mockEvent?: MockEvent) => {
            const inputField = component.find(InputGroup).find("input");
            inputField.simulate("keydown", { ...mockEvent, key: "ArrowUp" });
        };

        const simulateDecrement = (component: ReactWrapper<any>, mockEvent?: MockEvent) => {
            const inputField = component.find(InputGroup).find("input");
            inputField.simulate("keydown", { ...mockEvent, key: "ArrowDown" });
        };

        runInteractionSuite("Press '↑'", "Press '↓'", simulateIncrement, simulateDecrement);
    });

    // Enable these tests once we have a solution for testing Button onKeyUp callbacks (see PR #561)
    describe("Keyboard interactions on buttons (with Space key)", () => {
        const simulateIncrement = (component: ReactWrapper<any>, mockEvent: MockEvent = {}) => {
            const incrementButton = component.find(Button).first();
            incrementButton.simulate("keydown", { ...mockEvent, key: " " });
        };

        const simulateDecrement = (component: ReactWrapper<any>, mockEvent: MockEvent = {}) => {
            const decrementButton = component.find(Button).last();
            decrementButton.simulate("keydown", { ...mockEvent, key: " " });
        };

        runInteractionSuite("Press 'SPACE'", "Press 'SPACE'", simulateIncrement, simulateDecrement);
    });

    describe("Keyboard interactions on buttons (with Enter key)", () => {
        const simulateIncrement = (component: ReactWrapper<any>, mockEvent?: MockEvent) => {
            const incrementButton = component.find(Button).first();
            const event = { ...mockEvent, key: "Enter" };
            incrementButton.simulate("keydown", event);
            incrementButton.simulate("keyup", event);
        };

        const simulateDecrement = (component: ReactWrapper<any>, mockEvent?: MockEvent) => {
            const decrementButton = component.find(Button).last();
            const event = { ...mockEvent, key: "Enter" };
            decrementButton.simulate("keydown", event);
            decrementButton.simulate("keyup", event);
        };

        runInteractionSuite("Press 'ENTER'", "Press 'ENTER'", simulateIncrement, simulateDecrement);
    });

    describe("Mouse interactions", () => {
        const simulateIncrement = (component: ReactWrapper<any>, mockEvent?: MockEvent) => {
            const incrementButton = component.find(Button).first();
            incrementButton.simulate("mousedown", mockEvent);
        };

        const simulateDecrement = (component: ReactWrapper<any>, mockEvent?: MockEvent) => {
            const decrementButton = component.find(Button).last();
            decrementButton.simulate("mousedown", mockEvent);
        };

        runInteractionSuite("Click '+'", "Click '-'", simulateIncrement, simulateDecrement);
    });

    describe("Value bounds", () => {
        describe("if no bounds are defined", () => {
            it("enforces no minimum bound", () => {
                const component = mount(<NumericInput />);

                const decrementButton = component.find(Button).last();
                decrementButton.simulate("mousedown", { shiftKey: true });
                decrementButton.simulate("mousedown", { shiftKey: true });

                const newValue = component.state().value;
                expect(newValue).to.equal("-20");
            });

            it("enforces no maximum bound", () => {
                const component = mount(<NumericInput />);

                const incrementButton = component.find(Button).first();
                incrementButton.simulate("mousedown", { shiftKey: true });
                incrementButton.simulate("mousedown", { shiftKey: true });

                const newValue = component.state().value;
                expect(newValue).to.equal("20");
            });

            it("clamps an out-of-bounds value to the new `min` if the component props change", () => {
                const component = mount(<NumericInput value={0} />);

                const value = component.state().value;
                expect(value).to.equal("0");

                component.setProps({ min: 10 });

                // the old value was below the min, so the component should have raised the value
                // to meet the new minimum bound.
                const newValue = component.state().value;
                expect(newValue).to.equal("10");
            });

            it("clamps an out-of-bounds value to the new `max` if the component props change", () => {
                const component = mount(<NumericInput value={0} />);

                const value = component.state().value;
                expect(value).to.equal("0");

                component.setProps({ max: -10 });

                // the old value was above the max, so the component should have raised the value
                // to meet the new maximum bound.
                const newValue = component.state().value;
                expect(newValue).to.equal("-10");
            });
        });

        describe("if `min` is defined", () => {
            it("decrements the value as usual if it is above the minimum", () => {
                const MIN_VALUE = 0;
                const component = mount(<NumericInput min={MIN_VALUE} />);

                // try to decrement by 1
                const decrementButton = component.find(Button).last();
                decrementButton.simulate("mousedown");

                const newValue = component.state().value;
                expect(newValue).to.equal("0");
            });

            it("clamps the value to the minimum bound when decrementing by 'stepSize'", () => {
                const MIN_VALUE = -0.5;
                const component = mount(<NumericInput min={MIN_VALUE} />);

                // try to decrement by 1
                const decrementButton = component.find(Button).last();
                decrementButton.simulate("mousedown");

                const newValue = component.state().value;
                expect(newValue).to.equal(MIN_VALUE.toString());
            });

            it("clamps the value to the minimum bound when decrementing by 'minorStepSize'", () => {
                const MIN_VALUE = -0.05;
                const component = mount(<NumericInput min={MIN_VALUE} />);

                // try to decrement by 0.1
                const decrementButton = component.find(Button).last();
                decrementButton.simulate("mousedown", { altKey: true });

                const newValue = component.state().value;
                expect(newValue).to.equal(MIN_VALUE.toString());
            });

            it("clamps the value to the minimum bound when decrementing by 'majorStepSize'", () => {
                const MIN_VALUE = -5;
                const component = mount(<NumericInput min={MIN_VALUE} />);

                // try to decrement by 10
                const decrementButton = component.find(Button).last();
                decrementButton.simulate("mousedown", { shiftKey: true });

                const newValue = component.state().value;
                expect(newValue).to.equal(MIN_VALUE.toString());
            });

            it("fires onValueChange with clamped value if nextProps.min > value ", () => {
                const onValueChangeSpy = spy();
                const component = mount(<NumericInput value={-10} onValueChange={onValueChangeSpy} />);

                component.setProps({ min: 0 });

                const newValue = component.state().value;
                expect(newValue).to.equal("0");

                const inputElement = component.find("input").first().getDOMNode();
                expect(onValueChangeSpy.calledOnceWithExactly(0, "0", inputElement)).to.be.true;
            });

            it("does not fire onValueChange if nextProps.min < value", () => {
                const onValueChangeSpy = spy();
                const component = mount(<NumericInput value={-10} onValueChange={onValueChangeSpy} />);

                component.setProps({ min: -20 });

                const newValue = component.state().value;
                expect(newValue).to.equal("-10");
                expect(onValueChangeSpy.called).to.be.false;
            });
        });

        describe("if `max` is defined", () => {
            it("increments the value as usual if it is above the minimum", () => {
                const MAX_VALUE = 0;
                const component = mount(<NumericInput max={MAX_VALUE} />);

                // try to increment by 1
                const incrementButton = component.find(Button).first();
                incrementButton.simulate("mousedown");

                const newValue = component.state().value;
                expect(newValue).to.equal("0");
            });

            it("clamps the value to the maximum bound when incrementing by 'stepSize'", () => {
                const MAX_VALUE = 0.5;
                const component = mount(<NumericInput max={MAX_VALUE} />);

                // try to increment in by 1
                const incrementButton = component.find(Button).first();
                incrementButton.simulate("mousedown");

                const newValue = component.state().value;
                expect(newValue).to.equal(MAX_VALUE.toString());
            });

            it("clamps the value to the maximum bound when incrementing by 'minorStepSize'", () => {
                const MAX_VALUE = 0.05;
                const component = mount(<NumericInput max={MAX_VALUE} />);

                // try to increment by 0.1
                const incrementButton = component.find(Button).first();
                incrementButton.simulate("mousedown", { altKey: true });

                const newValue = component.state().value;
                expect(newValue).to.equal(MAX_VALUE.toString());
            });

            it("clamps the value to the maximum bound when incrementing by 'majorStepSize'", () => {
                const MAX_VALUE = 5;
                const component = mount(<NumericInput max={MAX_VALUE} />);

                // try to increment by 10
                const incrementButton = component.find(Button).first();
                incrementButton.simulate("mousedown", { shiftKey: true });

                const newValue = component.state().value;
                expect(newValue).to.equal(MAX_VALUE.toString());
            });

            it("fires onValueChange with clamped value if nextProps.max < value ", () => {
                const onValueChangeSpy = spy();
                const component = mount(<NumericInput value={10} onValueChange={onValueChangeSpy} />);

                component.setProps({ max: 0 });

                const newValue = component.state().value;
                expect(newValue).to.equal("0");

                const inputElement = component.find("input").first().getDOMNode();
                expect(onValueChangeSpy.calledOnceWithExactly(0, "0", inputElement)).to.be.true;
            });

            it("does not fire onValueChange if nextProps.max > value", () => {
                const onValueChangeSpy = spy();
                const component = mount(<NumericInput value={10} onValueChange={onValueChangeSpy} />);

                component.setProps({ max: 20 });

                const newValue = component.state().value;
                expect(newValue).to.equal("10");
                expect(onValueChangeSpy.called).to.be.false;
            });
        });

        describe("if min === max", () => {
            it("never changes value", () => {
                const onValueChangeSpy = spy();
                const component = mount(<NumericInput min={2} max={2} onValueChange={onValueChangeSpy} />);
                // repeated interactions, no change in state
                component
                    .find(Button)
                    .first()
                    .simulate("mousedown")
                    .simulate("mousedown")
                    .simulate("mousedown")
                    .simulate("mousedown")
                    .simulate("mousedown");
                expect(component.state().value).to.equal("2");

                const inputElement = component.find("input").first().getDOMNode();
                expect(onValueChangeSpy.calledOnceWithExactly(2, "2", inputElement)).to.be.true;
            });
        });

        describe("clampValueOnBlur", () => {
            it("does not clamp or invoke onValueChange on blur if clampValueOnBlur=false", () => {
                // should be false by default
                const VALUE = "-5";
                const onValueChange = spy();
                const component = mount(<NumericInput clampValueOnBlur={false} onValueChange={onValueChange} />);
                const inputField = component.find("input");

                inputField.simulate("change", { target: { value: VALUE } });
                inputField.simulate("blur");

                expect(component.state().value).to.equal(VALUE);
                expect(onValueChange.calledOnce).to.be.true;
            });

            it("clamps an out-of-bounds value to min", () => {
                const MIN = 0;
                const component = mount(<NumericInput clampValueOnBlur={true} min={MIN} />);
                const inputField = component.find("input");

                inputField.simulate("change", { target: { value: "-5" } });
                inputField.simulate("blur", { target: { value: "-5" } });
                expect(component.state().value).to.equal(MIN.toString());
            });

            it("clamps an out-of-bounds value to max", () => {
                const MAX = 0;
                const component = mount(<NumericInput clampValueOnBlur={true} max={MAX} />);
                const inputField = component.find("input");

                inputField.simulate("change", { target: { value: "5" } });
                inputField.simulate("blur", { target: { value: "5" } });
                expect(component.state().value).to.equal(MAX.toString());
            });

            it("invokes onValueChange when out-of-bounds value clamped on blur", () => {
                const onValueChange = spy();
                const MIN = 0;
                const component = mount(
                    <NumericInput clampValueOnBlur={true} min={MIN} onValueChange={onValueChange} />,
                );
                const inputField = component.find("input");

                inputField.simulate("change", { target: { value: "-5" } });
                inputField.simulate("blur", { target: { value: "-5" } });

                const args = onValueChange.getCall(1).args;
                expect(onValueChange.calledTwice).to.be.true;
                expect(args[0]).to.equal(MIN);
                expect(args[1]).to.equal(MIN.toString());
            });
        });
    });

    // Note: we don't call mount() here since React 16 throws before we can even validate the errors thrown
    // in component constructors
    describe("Validation", () => {
        let consoleError: SinonStub;

        before(() => (consoleError = stub(console, "error")));
        afterEach(() => consoleError.resetHistory());
        after(() => consoleError.restore());

        it("logs an error if min >= max", () => {
            mount(<NumericInput min={2} max={1} />);
            expect(consoleError.calledWith(Errors.NUMERIC_INPUT_MIN_MAX)).to.be.true;
        });

        it("logs an error if stepSize <= 0", () => {
            mount(<NumericInput stepSize={-1} />);
            expect(consoleError.calledWith(Errors.NUMERIC_INPUT_STEP_SIZE_NON_POSITIVE)).to.be.true;
        });

        it("logs an error if minorStepSize <= 0", () => {
            mount(<NumericInput minorStepSize={-0.1} />);
            expect(consoleError.calledWith(Errors.NUMERIC_INPUT_MINOR_STEP_SIZE_NON_POSITIVE)).to.be.true;
        });

        it("logs an error if majorStepSize <= 0", () => {
            mount(<NumericInput majorStepSize={-0.1} />);
            expect(consoleError.calledWith(Errors.NUMERIC_INPUT_MAJOR_STEP_SIZE_NON_POSITIVE)).to.be.true;
        });

        it("logs an error if majorStepSize <= stepSize", () => {
            mount(<NumericInput majorStepSize={0.5} />);
            expect(consoleError.calledWith(Errors.NUMERIC_INPUT_MAJOR_STEP_SIZE_BOUND)).to.be.true;
        });

        it("logs an error if stepSize <= minorStepSize", () => {
            mount(<NumericInput minorStepSize={2} />);
            expect(consoleError.calledWith(Errors.NUMERIC_INPUT_MINOR_STEP_SIZE_BOUND)).to.be.true;
        });

        it("clears the field if the value is invalid when incrementing", () => {
            const component = mount(<ControlledNumericInput value={"<invalid>"} />);

            const value = component.find(NumericInput).state().value;
            expect(value).to.equal("<invalid>");

            const incrementButton = component.find(Button).first();
            incrementButton.simulate("mousedown");

            const newValue = component.state().value;
            expect(newValue).to.equal("");
        });

        it("clears the field if the value is invalid when decrementing", () => {
            const component = mount(<ControlledNumericInput value={"<invalid>"} />);

            const value = component.find(NumericInput).state().value;
            expect(value).to.equal("<invalid>");

            const decrementButton = component.find(Button).last();
            decrementButton.simulate("mousedown");

            const newValue = component.state().value;
            expect(newValue).to.equal("");
        });
    });

    describe("Controlled mode", () => {
        it("value prop updates do not trigger onValueChange", () => {
            const onValueChangeSpy = spy();
            const component = mount(<NumericInput min={0} value={0} max={1} onValueChange={onValueChangeSpy} />);
            component.setProps({ value: 1 });
            expect(onValueChangeSpy.notCalled).to.be.true;
        });

        it("state.value only changes with prop change", () => {
            const initialValue = 10;
            const onValueChangeSpy = spy();
            const component = mount(<NumericInput value={initialValue} onValueChange={onValueChangeSpy} />);

            const incrementButton = component.find(Button).first();
            incrementButton.simulate("mousedown");
            dispatchMouseEvent(document, "mouseup");

            let inputElement = component.find("input");
            expect(inputElement.props().value).to.equal("10");
            expect(onValueChangeSpy.calledOnceWithExactly(11, "11", inputElement.getDOMNode()));

            component.setProps({ value: 11 }).update();
            inputElement = component.find("input");
            expect(inputElement.props().value).to.equal("11");
        });

        it("accepts successive value changes containing non-numeric characters", () => {
            const onValueChangeSpy = spy();
            const component = mount(<NumericInput onValueChange={onValueChangeSpy} />);
            component.setProps({ value: "1" });
            expect(component.state().value).to.equal("1");
            component.setProps({ value: "1 +" });
            expect(component.state().value).to.equal("1 +");
            component.setProps({ value: "1 + 1" });
            expect(component.state().value).to.equal("1 + 1");
        });
    });

    describe("Localization", () => {
        it("accepts the number in a different locale", () => {
            const onValueChangeSpy = spy();
            const component = mount(<NumericInput onValueChange={onValueChangeSpy} locale={"de-DE"} />);
            const nextValue = "99,99";
            const nextValueNumber = 99.99;

            component.find("input").simulate("change", { target: { value: nextValue } });

            expect(onValueChangeSpy.calledOnce).to.be.true;
            expect(onValueChangeSpy.calledWith(nextValueNumber, nextValue)).to.be.true;
        });

        it("accepts the number in a different locale [Arabic - Bahrain (ar-BH)]", () => {
            const onValueChangeSpy = spy();
            const component = mount(<NumericInput onValueChange={onValueChangeSpy} locale={"ar-BH"} />);
            const nextValue = "٩٫٩٩";
            const nextValueNumber = 9.99;

            component.find("input").simulate("change", { target: { value: nextValue } });

            expect(onValueChangeSpy.calledOnce).to.be.true;
            expect(onValueChangeSpy.calledWith(nextValueNumber, nextValue)).to.be.true;
        });

        it("changing the locale it changes the value (en-US to it-IT)", () => {
            const onValueChangeSpy = spy();
            const component = mount(<NumericInput onValueChange={onValueChangeSpy} />);
            const nextValue = "99.99";
            const formattedValue = "99,99";

            component.find("input").simulate("change", { target: { value: nextValue } });
            expect(onValueChangeSpy.lastCall.calledWith(+nextValue, nextValue)).to.be.true;

            component.setProps({ locale: "it-IT" });

            expect(onValueChangeSpy.lastCall.calledWith(+nextValue, formattedValue)).to.be.true;
        });

        it("changing the locale it changes the value (it-IT to undefined)", () => {
            const onValueChangeSpy = spy();
            const component = mount(<NumericInput onValueChange={onValueChangeSpy} locale={"it-IT"} />);
            const nextValue = "99,99";
            const usValue = "99.99";

            component.find("input").simulate("change", { target: { value: nextValue } });
            expect(onValueChangeSpy.lastCall.calledWith(+usValue, nextValue)).to.be.true;

            component.setProps({ locale: undefined });

            expect(onValueChangeSpy.lastCall.calledWith(+usValue, usValue)).to.be.true;
        });

        it("doesn't accept the number in a different format", () => {
            const onValueChangeSpy = spy();
            const component = mount(<NumericInput onValueChange={onValueChangeSpy} />);
            const invalidValue = "77,99";

            component.find("input").simulate("change", { target: { value: invalidValue } });

            expect(onValueChangeSpy.calledOnce).to.be.true;
            expect(onValueChangeSpy.calledWith(NaN, invalidValue)).to.be.true;
        });

        it("increments the number with the specified locale", () => {
            const onValueChangeSpy = spy();
            const component = mount(<NumericInput onValueChange={onValueChangeSpy} locale={"de-DE"} />);
            const nextValue = "7,9";
            const nextValueNumber = 7.9;
            const valueAfterDecrement = "8,9";
            const valueNumberAfterDecrement = 8.9;

            component.find("input").simulate("change", { target: { value: nextValue } });

            expect(onValueChangeSpy.calledWith(nextValueNumber, nextValue)).to.be.true;

            const incrementButton = component.find(Button).first();
            incrementButton.simulate("mousedown");
            dispatchMouseEvent(document, "mouseup");

            expect(onValueChangeSpy.calledWith(valueNumberAfterDecrement, valueAfterDecrement)).to.be.true;
        });

        it("decrements the number with the specified locale", () => {
            const onValueChangeSpy = spy();
            const component = mount(<NumericInput onValueChange={onValueChangeSpy} locale={"de-DE"} />);
            const nextValue = "7,9";
            const nextValueNumber = 7.9;
            const valueAfterDecrement = "6,9";
            const valueNumberAfterDecrement = 6.9;

            component
                .find("input")
                .first()
                .simulate("change", { target: { value: nextValue } });

            expect(onValueChangeSpy.calledWith(nextValueNumber, nextValue)).to.be.true;

            const decrementButton = component.find(Button).last();
            decrementButton.simulate("mousedown");
            dispatchMouseEvent(document, "mouseup");

            expect(onValueChangeSpy.calledWith(valueNumberAfterDecrement, valueAfterDecrement)).to.be.true;
        });
    });

    describe("Other", () => {
        it("disables the increment button when the value is greater than or equal to max", () => {
            const component = mount(<NumericInput value={100} max={100} />);

            const decrementButton = component.find(Button).last();
            const incrementButton = component.find(Button).first();

            expect(decrementButton.props().disabled).to.be.false;
            expect(incrementButton.props().disabled).to.be.true;
        });

        it("disables the decrement button when the value is less than or equal to min", () => {
            const component = mount(<NumericInput value={-10} min={-10} />);

            const decrementButton = component.find(Button).last();
            const incrementButton = component.find(Button).first();

            expect(decrementButton.props().disabled).to.be.true;
            expect(incrementButton.props().disabled).to.be.false;
        });

        it("disables the input field and buttons when disabled is true", () => {
            const component = mount(<NumericInput disabled={true} />);

            const inputGroup = component.find(InputGroup);
            const decrementButton = component.find(Button).last();
            const incrementButton = component.find(Button).first();

            expect(inputGroup.props().disabled).to.be.true;
            expect(decrementButton.props().disabled).to.be.true;
            expect(incrementButton.props().disabled).to.be.true;
        });

        it("disables the buttons and sets the input field to read-only when readOnly is true", () => {
            const component = mount(<NumericInput readOnly={true} />);

            const inputGroup = component.find(InputGroup);
            const decrementButton = component.find(Button).last();
            const incrementButton = component.find(Button).first();

            expect(inputGroup.props().readOnly).to.be.true;
            expect(decrementButton.props().disabled).to.be.true;
            expect(incrementButton.props().disabled).to.be.true;
        });

        it("shows a left icon if provided", () => {
            const component = mount(<NumericInput leftIcon="variable" />);
            const icon = component.find(InputGroup).find(Icon);
            expect(icon.prop("icon")).to.equal("variable");
        });

        it("shows a left element if provided", () => {
            const component = mount(<NumericInput leftElement={<Button minimal={true} icon="variable" />} />);
            const button = component.find(InputGroup).find(Button);
            expect(button.prop("icon")).to.equal("variable");
            expect(button.prop("minimal")).to.equal(true);
        });

        it("shows only a left element if both a left element and a left icon are provided", () => {
            const component = mount(
                <NumericInput leftIcon="variable" leftElement={<Button minimal={true} icon="variable" />} />,
            );
            const button = component.find(InputGroup).find(Button);
            expect(button.prop("icon")).to.equal("variable");
            expect(button.prop("minimal")).to.equal(true);
            const icon = component.find(InputGroup).find(Icon);
            expect(icon).to.be.empty;
        });

        it("shows placeholder text if provided", () => {
            const component = mount(<NumericInput placeholder={"Enter a number..."} />);

            const inputField = component.find("input");
            const placeholderText = inputField.props().placeholder;

            expect(placeholderText).to.equal("Enter a number...");
        });

        it("shows right element if provided", () => {
            const component = mount(<NumericInput rightElement={<Button />} />);
            expect(component.find(InputGroup).find(Button)).to.exist;
        });

        it("passed decimal value should be rounded by stepSize", () => {
            const component = mount(<NumericInput value={9.001} min={0} />);
            expect(component.find("input").prop("value")).to.equal("9");
        });

        it("passed decimal value should be rounded by minorStepSize", () => {
            const component = mount(<NumericInput value={"9.01"} min={0} minorStepSize={0.01} />);
            expect(component.find("input").prop("value")).to.equal("9.01");
        });

        it("changes max precision of displayed value to that of the smallest step size defined", () => {
            const component = mount(<NumericInput majorStepSize={1} stepSize={0.1} minorStepSize={0.001} />);
            const incrementButton = component.find(Button).first();

            incrementButton.simulate("mousedown");
            expect(component.find("input").prop("value")).to.equal("0.1");

            incrementButton.simulate("mousedown", { altKey: true });
            expect(component.find("input").prop("value")).to.equal("0.101");

            incrementButton.simulate("mousedown", { shiftKey: true });
            expect(component.find("input").prop("value")).to.equal("1.101");

            // one significant digit too many
            setNextValue(component, "1.0001");
            incrementButton.simulate("mousedown", { altKey: true });
            expect(component.find("input").prop("value")).to.equal("1.001");
        });

        it("handle big decimal numbers", () => {
            const onValueChangeSpy = spy();
            const component = mount(
                <NumericInput
                    onValueChange={onValueChangeSpy}
                    value={0}
                    stepSize={0.000000000000000001}
                    minorStepSize={0.000000000000000001}
                />,
            );
            const input = component.find("input");
            input.simulate("keydown", { key: "ArrowUp" });
            assert.isTrue(onValueChangeSpy.calledWith(0.000000000000000001));
        });

        it("changes max precision appropriately when the min/max stepSize props change", () => {
            const onValueChangeSpy = spy();
            const component = mount(
                <NumericInput
                    majorStepSize={1}
                    stepSize={0.1}
                    minorStepSize={0.001}
                    value="0.0001"
                    onValueChange={onValueChangeSpy}
                />,
            );

            // excess digits should truncate to max precision
            let incrementButton = component.find(Button).first();
            incrementButton.simulate("mousedown", { altKey: true });
            expect(onValueChangeSpy.calledOnceWith(0.001, "0.001"));
            onValueChangeSpy.resetHistory();

            // now try a smaller step size, and expect no truncation
            component.setProps({ minorStepSize: 0.0001 });
            incrementButton = component.find(Button).first();
            incrementButton.simulate("mousedown", { altKey: true });
            expect(onValueChangeSpy.calledOnceWith(0.0002, "0.0002"));
            onValueChangeSpy.resetHistory();

            // now try a larger step size, and expect more truncation than before
            component.setProps({ minorStepSize: 0.1 });
            incrementButton = component.find(Button).first();
            incrementButton.simulate("mousedown", { altKey: true });
            expect(onValueChangeSpy.calledOnceWith(0.01, "0.01"));
            onValueChangeSpy.resetHistory();
        });

        it("must not call handleButtonClick if component is disabled", () => {
            const SPACE_KEYSTROKE = { key: " " };

            const component = mount(<NumericInput disabled={true} />);

            const incrementButton = component.find(Button).first();
            const handleButtonClickSpy = spy(component.instance(), "handleButtonClick" as any);

            incrementButton.simulate("mousedown");
            incrementButton.simulate("mousedown", { altKey: true });
            incrementButton.simulate("keyDown", SPACE_KEYSTROKE);
            incrementButton.simulate("keyDown", { ...SPACE_KEYSTROKE, altKey: true });

            const decrementButton = component.find(Button).last();
            decrementButton.simulate("mousedown");
            decrementButton.simulate("mousedown", { altKey: true });
            decrementButton.simulate("keyDown", SPACE_KEYSTROKE);
            decrementButton.simulate("keyDown", { ...SPACE_KEYSTROKE, altKey: true });

            expect(handleButtonClickSpy.notCalled).to.be.true;
        });
    });

    interface MockEvent {
        shiftKey?: boolean;
        altKey?: boolean;
        key?: string;
    }

    function createNumericInputForInteractionSuite(overrides: Partial<HTMLInputProps & NumericInputProps> = {}) {
        // allow `null` to override the default values here
        const majorStepSize = overrides.majorStepSize !== undefined ? overrides.majorStepSize : 20;
        const minorStepSize = overrides.minorStepSize !== undefined ? overrides.minorStepSize : 0.2;

        const controledWrapper = mount(
            <ControlledNumericInput
                majorStepSize={majorStepSize}
                minorStepSize={minorStepSize}
                stepSize={2}
                value={10}
            />,
        );
        return controledWrapper.find(NumericInput);
    }

    function runInteractionSuite(
        incrementDescription: string,
        decrementDescription: string,
        simulateIncrement: (component: ReactWrapper<any>, mockEvent?: Record<string, unknown>) => void,
        simulateDecrement: (component: ReactWrapper<any>, mockEvent?: Record<string, unknown>) => void,
    ) {
        it(`increments by stepSize on ${incrementDescription}`, () => {
            const component = createNumericInputForInteractionSuite();

            simulateIncrement(component);

            const newValue = component.state().value;
            expect(newValue).to.equal("12");
        });

        it(`decrements by stepSize on ${decrementDescription}`, () => {
            const component = createNumericInputForInteractionSuite();

            simulateDecrement(component);

            const newValue = component.state().value;
            expect(newValue).to.equal("8");
        });

        it(`increments by stepSize on Shift + ${incrementDescription} when majorStepSize is null`, () => {
            const component = createNumericInputForInteractionSuite({ majorStepSize: null });

            simulateIncrement(component, { shiftKey: true });

            const newValue = component.state().value;
            expect(newValue).to.equal("12");
        });

        it(`decrements by stepSize on Shift + ${incrementDescription} when majorStepSize is null`, () => {
            const component = createNumericInputForInteractionSuite({ majorStepSize: null });

            simulateDecrement(component, { shiftKey: true });

            const newValue = component.state().value;
            expect(newValue).to.equal("8");
        });

        it(`increments by stepSize on Alt + ${incrementDescription} when minorStepSize is null`, () => {
            const component = createNumericInputForInteractionSuite({ minorStepSize: null });

            simulateIncrement(component, { altKey: true });

            const newValue = component.state().value;
            expect(newValue).to.equal("12");
        });

        it(`decrements by stepSize on Alt + ${decrementDescription} when minorStepSize is null`, () => {
            const component = createNumericInputForInteractionSuite({ minorStepSize: null });

            simulateDecrement(component, { altKey: true });

            const newValue = component.state().value;
            expect(newValue).to.equal("8");
        });

        it(`increments by majorStepSize on Shift + ${incrementDescription}`, () => {
            const component = createNumericInputForInteractionSuite();

            simulateIncrement(component, { shiftKey: true });

            const newValue = component.state().value;
            expect(newValue).to.equal("30");
        });

        it(`decrements by majorStepSize on Shift + ${decrementDescription}`, () => {
            const component = createNumericInputForInteractionSuite();

            simulateDecrement(component, { shiftKey: true });

            const newValue = component.state().value;
            expect(newValue).to.equal("-10");
        });

        it(`increments by minorStepSize on Alt + ${incrementDescription}`, () => {
            const component = createNumericInputForInteractionSuite();

            simulateIncrement(component, { altKey: true });

            const newValue = component.state().value;
            expect(newValue).to.equal("10.2");
        });

        it(`decrements by minorStepSize on Alt + ${incrementDescription}`, () => {
            const component = createNumericInputForInteractionSuite();

            simulateDecrement(component, { altKey: true });

            const newValue = component.state().value;
            expect(newValue).to.equal("9.8");
        });

        it(`increments by majorStepSize on Shift + Alt + ${incrementDescription}`, () => {
            const component = createNumericInputForInteractionSuite();

            simulateIncrement(component, { shiftKey: true, altKey: true });

            const newValue = component.state().value;
            expect(newValue).to.equal("30");
        });

        it(`decrements by majorStepSize on Shift + Alt + ${decrementDescription}`, () => {
            const component = createNumericInputForInteractionSuite();

            simulateDecrement(component, { shiftKey: true, altKey: true });

            const newValue = component.state().value;
            expect(newValue).to.equal("-10");
        });

        it(`increments by minorStepSize on Shift + Alt + ${incrementDescription} when majorStepSize is null`, () => {
            const component = createNumericInputForInteractionSuite({ majorStepSize: null });

            simulateIncrement(component, { shiftKey: true, altKey: true });

            const newValue = component.state().value;
            expect(newValue).to.equal("10.2");
        });

        it(`decrements by minorStepSize on Shift + Alt + ${incrementDescription} when majorStepSize is null`, () => {
            const component = createNumericInputForInteractionSuite({ majorStepSize: null });

            simulateDecrement(component, { shiftKey: true, altKey: true });

            const newValue = component.state().value;
            expect(newValue).to.equal("9.8");
        });

        it(`increments by stepSize on Shift + Alt + ${incrementDescription} when \
            majorStepSize and minorStepSize are null`, () => {
            const component = createNumericInputForInteractionSuite({
                majorStepSize: null,
                minorStepSize: null,
            });

            simulateIncrement(component, { shiftKey: true, altKey: true });

            const newValue = component.state().value;
            expect(newValue).to.equal("12");
        });

        it(`decrements by stepSize on Shift + Alt + ${incrementDescription} when \
            majorStepSize and minorStepSize are null`, () => {
            const component = createNumericInputForInteractionSuite({
                majorStepSize: null,
                minorStepSize: null,
            });

            simulateDecrement(component, { shiftKey: true, altKey: true });

            const newValue = component.state().value;
            expect(newValue).to.equal("8");
        });

        it(`resolves scientific notation to a number before incrementing when allowNumericCharactersOnly=true`, () => {
            const component = createNumericInputForInteractionSuite({
                allowNumericCharactersOnly: true,
                majorStepSize: null,
                minorStepSize: null,
            });

            setNextValue(component, "3e2"); // i.e. 300

            simulateIncrement(component);

            const newValue = component.state().value;
            expect(newValue).to.equal("302");
        });
    }

    function stringToCharArray(str: string) {
        return str == null ? [] : str.split("");
    }

    function runTextInputSuite(
        invalidKeyNames: string[],
        expectDefaultPrevented: boolean,
        eventOptions?: Partial<KeyboardEvent>,
        allowNumericCharactersOnly?: boolean,
    ) {
        const onKeyPressSpy = spy();
        const component = mount(
            <NumericInput allowNumericCharactersOnly={allowNumericCharactersOnly} onKeyPress={onKeyPressSpy} />,
        );
        const inputField = component.find("input");

        invalidKeyNames.forEach((keyName, i) => {
            inputField.simulate("keypress", { key: keyName, ...eventOptions });
            const event = onKeyPressSpy.getCall(i).args[0] as KeyboardEvent;
            const valueToCheck = expectDefaultPrevented === true ? event.defaultPrevented : !event.defaultPrevented; // can be undefined, so just check that it's falsey.
            expect(valueToCheck).to.be.true;
        });
    }

    // instance.setState() doesn't work like it used to, so we use this helper function to
    // limit the places where we reach into NumericInput internals
    function setNextValue(wrapper: ReactWrapper, value: string) {
        const numericInput = wrapper.find(NumericInput);

        try {
            if (numericInput.exists()) {
                (numericInput.instance() as any).handleNextValue(value);
            } else {
                (wrapper.instance() as any).handleNextValue(value);
            }
        } catch (e) {
            if (e instanceof ReferenceError) {
                assert.fail("Unable to set next value on mounted NumericInput");
            }
            throw e;
        }
    }
});

/**
 * Wraps NumericInput to make it behave like a controlled component, treating props.value as a default value
 */
class ControlledNumericInput extends React.PureComponent<NumericInputProps, { value?: string }> {
    public state = {
        // treat value as "defaultValue"
        value: this.props.value?.toString(),
    };

    public render() {
        return <NumericInput {...this.props} value={this.state.value} onValueChange={this.handleValueChange} />;
    }

    private handleValueChange = (_valueAsNumber: number, value: string) => {
        this.setState({ value });
    };
}

================================================================================

File: test\controls\radioGroupTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { type EnzymePropSelector, mount, type ReactWrapper } from "enzyme";
import * as React from "react";
import { spy, stub } from "sinon";

import { type OptionProps, Radio, RadioGroup } from "../../src";
import { RADIOGROUP_WARN_CHILDREN_OPTIONS_MUTEX } from "../../src/common/errors";

describe("<RadioGroup>", () => {
    const emptyHandler = () => {
        return;
    };

    it("nothing is selected by default", () => {
        const group = mount(
            <RadioGroup onChange={emptyHandler}>
                <Radio value="one" label="One" />
                <Radio value="two" label="Two" />
            </RadioGroup>,
        );
        assert.lengthOf(group.find({ checked: true }), 0);
    });

    it("selectedValue checks that value", () => {
        const group = mount(
            <RadioGroup onChange={emptyHandler} selectedValue="two">
                <Radio value="one" label="One" />
                <Radio value="two" label="Two" />
            </RadioGroup>,
        );
        assert.isTrue(findInput(group, { checked: true }).is({ value: "two" }));
    });

    it("invokes onChange handler when a radio is clicked", () => {
        const changeSpy = spy();
        const group = mount(
            <RadioGroup onChange={changeSpy}>
                <Radio value="one" label="One" />
                <Radio value="two" label="Two" />
            </RadioGroup>,
        );
        findInput(group, { value: "one" }).simulate("change");
        findInput(group, { value: "two" }).simulate("change");
        assert.equal(changeSpy.callCount, 2);
    });

    it("renders options as radio buttons", () => {
        const OPTIONS: OptionProps[] = [
            { className: "foo", label: "A", value: "a" },
            { label: "B", value: "b" },
            { disabled: true, label: "C", value: "c" },
        ];
        const group = mount(<RadioGroup onChange={emptyHandler} options={OPTIONS} selectedValue="b" />);
        const radios = group.find(Radio);
        assert.isTrue(radios.at(0).hasClass("foo"), "className");
        assert.isTrue(radios.at(1).is({ checked: true }), "selectedValue");
        assert.isTrue(radios.at(2).prop("disabled"), "disabled");
    });

    it("options label defaults to value", () => {
        const OPTIONS = [{ value: "text" }, { value: 23 }];
        const group = mount(<RadioGroup onChange={emptyHandler} options={OPTIONS} selectedValue="b" />);
        OPTIONS.forEach(props => {
            assert.strictEqual(findInput(group, props).parents().first().text(), props.value.toString());
        });
    });

    it("uses options if given both options and children (with conosle warning)", () => {
        const warnSpy = stub(console, "warn");
        const group = mount(
            <RadioGroup onChange={emptyHandler} options={[]}>
                <Radio value="one" />
            </RadioGroup>,
        );
        assert.lengthOf(group.find(Radio), 0);
        assert.isTrue(warnSpy.alwaysCalledWith(RADIOGROUP_WARN_CHILDREN_OPTIONS_MUTEX));
        warnSpy.restore();
    });

    it("renders non-Radio children too", () => {
        const group = mount(
            <RadioGroup onChange={emptyHandler}>
                <Radio />
                <address />
                <Radio />
            </RadioGroup>,
        );
        assert.lengthOf(group.find("address"), 1);
        assert.lengthOf(group.find(Radio), 2);
    });

    function findInput(wrapper: ReactWrapper<any, any>, props: EnzymePropSelector) {
        return wrapper.find("input").filter(props);
    }
});

================================================================================

File: test\dialog\dialogTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount } from "enzyme";
import * as React from "react";
import { spy } from "sinon";

import { Button, Classes, Dialog, DialogBody, DialogFooter, type DialogProps } from "../../src";

const COMMON_PROPS: Partial<DialogProps> = {
    icon: "inbox",
    isOpen: true,
    title: "Dialog header",
    usePortal: false,
};

describe("<Dialog>", () => {
    it("renders its content correctly", () => {
        const dialog = mount(<Dialog {...COMMON_PROPS}>{renderDialogBodyAndFooter()}</Dialog>);
        [
            Classes.DIALOG,
            Classes.DIALOG_BODY,
            Classes.DIALOG_FOOTER,
            Classes.DIALOG_FOOTER_ACTIONS,
            Classes.DIALOG_HEADER,
            Classes.OVERLAY_BACKDROP,
        ].forEach(className => {
            assert.lengthOf(dialog.find(`.${className}`), 1, `missing ${className}`);
        });
    });

    it("portalClassName appears on Portal", () => {
        const TEST_CLASS = "test-class";
        const dialog = mount(
            <Dialog {...COMMON_PROPS} usePortal={true} portalClassName={TEST_CLASS}>
                {renderDialogBodyAndFooter()}
            </Dialog>,
        );
        assert.isDefined(document.querySelector(`.${Classes.PORTAL}.${TEST_CLASS}`));
        dialog.unmount();
    });

    it("renders contents to specified container correctly", () => {
        const container = document.createElement("div");
        document.body.appendChild(container);
        mount(
            <Dialog {...COMMON_PROPS} usePortal={true} portalContainer={container}>
                {renderDialogBodyAndFooter()}
            </Dialog>,
        );
        assert.lengthOf(container.getElementsByClassName(Classes.DIALOG), 1, `missing ${Classes.DIALOG}`);
        document.body.removeChild(container);
    });

    it("attempts to close when overlay backdrop element is moused down", () => {
        const onClose = spy();
        const dialog = mount(
            <Dialog {...COMMON_PROPS} onClose={onClose}>
                {renderDialogBodyAndFooter()}
            </Dialog>,
        );
        dialog.find(`.${Classes.OVERLAY_BACKDROP}`).simulate("mousedown");
        assert.isTrue(onClose.calledOnce);
    });

    it("doesn't close when canOutsideClickClose=false and overlay backdrop element is moused down", () => {
        const onClose = spy();
        const dialog = mount(
            <Dialog {...COMMON_PROPS} canOutsideClickClose={false} onClose={onClose}>
                {renderDialogBodyAndFooter()}
            </Dialog>,
        );
        dialog.find(`.${Classes.OVERLAY_BACKDROP}`).simulate("mousedown");
        assert.isTrue(onClose.notCalled);
    });

    it("doesn't close when canEscapeKeyClose=false and escape key is pressed", () => {
        const onClose = spy();
        const dialog = mount(
            <Dialog {...COMMON_PROPS} canEscapeKeyClose={false} onClose={onClose}>
                {renderDialogBodyAndFooter()}
            </Dialog>,
        );
        dialog.simulate("keydown", { key: "Escape" });
        assert.isTrue(onClose.notCalled);
    });

    it("supports overlay lifecycle props", () => {
        const onOpening = spy();
        mount(
            <Dialog {...COMMON_PROPS} onOpening={onOpening}>
                body
            </Dialog>,
        );
        assert.isTrue(onOpening.calledOnce);
    });

    describe("header", () => {
        it(`renders .${Classes.DIALOG_HEADER} if title prop is given`, () => {
            const dialog = mount(
                <Dialog {...COMMON_PROPS} title="Hello!">
                    dialog body
                </Dialog>,
            );
            assert.match(dialog.find(`.${Classes.DIALOG_HEADER}`).text(), /^Hello!/);
        });

        it(`renders close button if isCloseButtonShown={true}`, () => {
            const dialog = mount(
                <Dialog {...COMMON_PROPS} isCloseButtonShown={true}>
                    dialog body
                </Dialog>,
            );
            assert.lengthOf(dialog.find(`.${Classes.DIALOG_HEADER}`).find(Button), 1);

            dialog.setProps({ isCloseButtonShown: false });
            assert.lengthOf(dialog.find(`.${Classes.DIALOG_HEADER}`).find(Button), 0);
        });

        it("clicking close button triggers onClose", () => {
            const onClose = spy();
            const dialog = mount(
                <Dialog {...COMMON_PROPS} isCloseButtonShown={true} onClose={onClose}>
                    dialog body
                </Dialog>,
            );
            dialog.find(`.${Classes.DIALOG_HEADER}`).find(Button).simulate("click");
            assert.isTrue(onClose.calledOnce, "onClose not called");
        });
    });

    it("only adds its className in one location", () => {
        const dialog = mount(<Dialog {...COMMON_PROPS} className="foo" />);
        assert.lengthOf(dialog.find(".foo").hostNodes(), 1);
    });

    describe("accessibility features", () => {
        const mountDialog = (props: Partial<DialogProps>) => {
            return mount(
                <Dialog {...COMMON_PROPS} {...props}>
                    {renderDialogBodyAndFooter()}
                </Dialog>,
            );
        };

        it("renders with role={dialog}", () => {
            const dialog = mountDialog({ className: "check-role" });
            assert.equal(dialog.find(`.check-role`).hostNodes().prop("role"), "dialog", "missing dialog role!!");
        });

        it("renders with provided aria-labelledby and aria-described by from props", () => {
            const dialog = mountDialog({
                "aria-describedby": "dialog-description",
                "aria-labelledby": "dialog-title",
                className: "renders-with-props",
            });
            const dialogElement = dialog.find(`.renders-with-props`).hostNodes();
            assert.equal(dialogElement.prop("aria-labelledby"), "dialog-title");
            assert.equal(dialogElement.prop("aria-describedby"), "dialog-description");
        });

        it("uses title as default aria-labelledby", () => {
            const dialog = mountDialog({ className: "default-title", title: "Title by props" });
            // test existence here because id is generated
            assert.exists(dialog.find(".default-title").hostNodes().prop("aria-labelledby"));
        });

        it("does not apply default aria-labelledby if no title", () => {
            const dialog = mountDialog({ className: "no-default-if-no-title", title: null });
            // test existence here because id is generated
            assert.notExists(dialog.find(".no-default-if-no-title").hostNodes().prop("aria-labelledby"));
        });

        it("supports ref objects attached to container", done => {
            const containerRef = React.createRef<HTMLDivElement>();
            mountDialog({ containerRef });

            // wait for the whole lifecycle to run
            setTimeout(() => {
                assert.isTrue(containerRef.current?.classList.contains(Classes.DIALOG_CONTAINER));
                done();
            });
        });
    });

    // N.B. everything else about Dialog is tested by Overlay2

    function renderDialogBodyAndFooter(): React.JSX.Element[] {
        return [
            <DialogBody key="body">
                <p id="dialog-description">
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore
                    et dolore magna alqua. Ut enim ad minimum veniam, quis nostrud exercitation ullamco laboris nisi ut
                    aliquip ex ea commodo consequat.
                </p>
            </DialogBody>,
            <DialogFooter
                key="footer"
                actions={
                    <>
                        <Button text="Secondary" />
                        <Button className={Classes.INTENT_PRIMARY} type="submit" text="Primary" />
                    </>
                }
            />,
        ];
    }
});

================================================================================

File: test\drawer\drawerTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, type ReactWrapper } from "enzyme";
import * as React from "react";
import { spy } from "sinon";

import { Button, Classes, Drawer, type DrawerProps, Position } from "../../src";

describe("<Drawer>", () => {
    let drawer: ReactWrapper<DrawerProps, any>;
    let isMounted = false;
    const testsContainerElement = document.createElement("div");
    document.documentElement.appendChild(testsContainerElement);

    /**
     * Mount the `content` into `testsContainerElement` and assign to local `wrapper` variable.
     * Use this method in this suite instead of Enzyme's `mount` method.
     */
    function mountDrawer(content: React.JSX.Element) {
        drawer = mount(content, { attachTo: testsContainerElement });
        isMounted = true;
        return drawer;
    }

    afterEach(() => {
        if (isMounted) {
            // clean up wrapper after each test, if it was used
            drawer?.unmount();
            drawer?.detach();
            isMounted = false;
        }
    });

    it("renders its content correctly", () => {
        mountDrawer(
            <Drawer isOpen={true} usePortal={false}>
                {createDrawerContents()}
            </Drawer>,
        );
        [Classes.DRAWER, Classes.DRAWER_BODY, Classes.DRAWER_FOOTER, Classes.OVERLAY_BACKDROP].forEach(className => {
            assert.lengthOf(drawer.find(`.${className}`), 1, `missing ${className}`);
        });
    });

    describe("position", () => {
        describe("RIGHT", () => {
            it("position right, size becomes width", () => {
                mountDrawer(
                    <Drawer isOpen={true} usePortal={false} position={Position.RIGHT} size={100}>
                        {createDrawerContents()}
                    </Drawer>,
                );
                assert.equal(drawer.find(`.${Classes.DRAWER}`).prop("style")?.width, 100);
            });

            it("position right, adds appropriate classes (default behavior)", () => {
                mountDrawer(
                    <Drawer isOpen={true} usePortal={false} position={Position.RIGHT}>
                        {createDrawerContents()}
                    </Drawer>,
                );
                assert.isTrue(drawer.find(`.${Classes.POSITION_RIGHT}`).exists());
            });
        });

        describe("TOP", () => {
            it("position top, size becomes height", () => {
                mountDrawer(
                    <Drawer isOpen={true} usePortal={false} position={Position.TOP} size={100}>
                        {createDrawerContents()}
                    </Drawer>,
                );
                assert.equal(drawer.find(`.${Classes.DRAWER}`).prop("style")?.height, 100);
            });

            it("position top, adds appropriate classes (vertical, reverse)", () => {
                mountDrawer(
                    <Drawer isOpen={true} usePortal={false} position={Position.TOP}>
                        {createDrawerContents()}
                    </Drawer>,
                );
                assert.isTrue(drawer.find(`.${Classes.POSITION_TOP}`).exists());
            });
        });

        describe("BOTTOM", () => {
            it("position bottom, size becomes height", () => {
                mountDrawer(
                    <Drawer isOpen={true} usePortal={false} position={Position.BOTTOM} size={100}>
                        {createDrawerContents()}
                    </Drawer>,
                );
                assert.equal(drawer.find(`.${Classes.DRAWER}`).prop("style")?.height, 100);
            });

            it("position bottom, adds appropriate classes (vertical)", () => {
                mountDrawer(
                    <Drawer isOpen={true} usePortal={false} position={Position.BOTTOM}>
                        {createDrawerContents()}
                    </Drawer>,
                );
                assert.isTrue(drawer.find(`.${Classes.POSITION_BOTTOM}`).exists());
            });
        });

        describe("LEFT", () => {
            it("position left, size becomes width", () => {
                mountDrawer(
                    <Drawer isOpen={true} usePortal={false} position={Position.LEFT} size={100}>
                        {createDrawerContents()}
                    </Drawer>,
                );
                assert.equal(drawer.find(`.${Classes.DRAWER}`).prop("style")?.width, 100);
            });

            it("position left, adds appropriate classes (reverse)", () => {
                mountDrawer(
                    <Drawer isOpen={true} usePortal={false} position={Position.LEFT}>
                        {createDrawerContents()}
                    </Drawer>,
                );
                assert.isTrue(drawer.find(`.${Classes.POSITION_LEFT}`).exists());
            });
        });
    });

    it("size becomes width", () => {
        mountDrawer(
            <Drawer isOpen={true} usePortal={false} size={100}>
                {createDrawerContents()}
            </Drawer>,
        );
        assert.equal(drawer.find(`.${Classes.DRAWER}`).prop("style")?.width, 100);
    });

    it("portalClassName appears on Portal", () => {
        const TEST_CLASS = "test-class";
        mountDrawer(
            <Drawer isOpen={true} portalClassName={TEST_CLASS}>
                {createDrawerContents()}
            </Drawer>,
        );
        assert.isDefined(document.querySelector(`.${Classes.PORTAL}.${TEST_CLASS}`));
    });

    it("renders contents to specified container correctly", () => {
        const container = document.createElement("div");
        document.body.appendChild(container);
        mountDrawer(
            <Drawer isOpen={true} portalContainer={container}>
                {createDrawerContents()}
            </Drawer>,
        );
        drawer.unmount();
        document.body.removeChild(container);
        const onClose = spy();
        mountDrawer(
            <Drawer isOpen={true} onClose={onClose} usePortal={false}>
                {createDrawerContents()}
            </Drawer>,
        );
        drawer.find(`.${Classes.OVERLAY_BACKDROP}`).simulate("mousedown");
        assert.isTrue(onClose.calledOnce);
    });

    it("doesn't close when canOutsideClickClose=false and overlay backdrop element is moused down", () => {
        const onClose = spy();
        mountDrawer(
            <Drawer canOutsideClickClose={false} isOpen={true} onClose={onClose} usePortal={false}>
                {createDrawerContents()}
            </Drawer>,
        );
        drawer.find(`.${Classes.OVERLAY_BACKDROP}`).simulate("mousedown");
        assert.isTrue(onClose.notCalled);
    });

    it("doesn't close when canEscapeKeyClose=false and escape key is pressed", () => {
        const onClose = spy();
        mountDrawer(
            <Drawer canEscapeKeyClose={false} isOpen={true} onClose={onClose} usePortal={false}>
                {createDrawerContents()}
            </Drawer>,
        );
        drawer.simulate("keydown", { key: "Escape" });
        assert.isTrue(onClose.notCalled);
    });

    it("supports overlay lifecycle props", () => {
        const onOpening = spy();
        mountDrawer(
            <Drawer isOpen={true} onOpening={onOpening}>
                body
            </Drawer>,
        );
        assert.isTrue(onOpening.calledOnce);
    });

    describe("header", () => {
        it(`does not render .${Classes.DRAWER_HEADER} if title omitted`, () => {
            mountDrawer(
                <Drawer isOpen={true} usePortal={false}>
                    drawer body
                </Drawer>,
            );
            assert.isFalse(drawer.find(`.${Classes.DRAWER_HEADER}`).exists());
        });

        it(`renders .${Classes.DRAWER_HEADER} if title prop is given`, () => {
            mountDrawer(
                <Drawer isOpen={true} title="Hello!" usePortal={false}>
                    drawer body
                </Drawer>,
            );
            assert.match(drawer.find(`.${Classes.DRAWER_HEADER}`).text(), /^Hello!/);
        });

        it(`renders close button if isCloseButtonShown={true}`, () => {
            mountDrawer(
                <Drawer isCloseButtonShown={true} isOpen={true} title="Hello!" usePortal={false}>
                    drawer body
                </Drawer>,
            );
            assert.lengthOf(drawer.find(`.${Classes.DRAWER_HEADER}`).find(Button), 1);

            drawer.setProps({ isCloseButtonShown: false });
            assert.lengthOf(drawer.find(`.${Classes.DRAWER_HEADER}`).find(Button), 0);
        });

        it("clicking close button triggers onClose", () => {
            const onClose = spy();
            mountDrawer(
                <Drawer isCloseButtonShown={true} isOpen={true} onClose={onClose} title="Hello!" usePortal={false}>
                    drawer body
                </Drawer>,
            );
            drawer.find(`.${Classes.DRAWER_HEADER}`).find(Button).simulate("click");
            assert.isTrue(onClose.calledOnce, "onClose not called");
        });
    });

    it("only adds its className in one location", () => {
        mountDrawer(<Drawer className="foo" isOpen={true} title="title" usePortal={false} />);
        assert.lengthOf(drawer.find(".foo").hostNodes(), 1);
    });

    // everything else about Drawer is tested by Overlay

    function createDrawerContents(): React.JSX.Element[] {
        return [
            <div className={Classes.DRAWER_BODY} key={1}>
                <p>
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore
                    et dolore magna alqua. Ut enim ad minimum veniam, quis nostrud exercitation ullamco laboris nisi ut
                    aliquip ex ea commodo consequat.
                </p>
            </div>,
            <div className={Classes.DRAWER_FOOTER} key={2}>
                <div style={{ display: "flex", justifyContent: "flex-end", gap: "10px" }}>
                    <Button text="Secondary" />
                    <Button className={Classes.INTENT_PRIMARY} type="submit" text="Primary" />
                </div>
            </div>,
        ];
    }
});

================================================================================

File: test\editable-text\editableTextTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, type ReactWrapper, shallow } from "enzyme";
import * as React from "react";
import { spy } from "sinon";

import { EditableText } from "../../src";

describe("<EditableText>", () => {
    it("renders value", () => {
        assert.equal(shallow(<EditableText value="alphabet" />).text(), "alphabet");
    });

    it("renders defaultValue", () => {
        assert.equal(shallow(<EditableText defaultValue="default" />).text(), "default");
    });

    it("renders placeholder", () => {
        assert.equal(shallow(<EditableText placeholder="Edit..." />).text(), "Edit...");
    });

    it("cannot be edited when disabled", () => {
        const editable = shallow(<EditableText disabled={true} isEditing={true} />);
        assert.isFalse(editable.state("isEditing"));
    });

    it("allows resetting controlled value to undefined or null", () => {
        const editable = shallow(<EditableText isEditing={false} placeholder="placeholder" value="alphabet" />);
        assert.strictEqual(editable.text(), "alphabet");
        editable.setProps({ value: null });
        assert.strictEqual(editable.text(), "placeholder");
    });

    it("passes an ID to the underlying span", () => {
        const editable = shallow(<EditableText disabled={true} isEditing={true} contentId="my-id" />).find("span");
        assert.strictEqual(editable.prop("id"), "my-id");
    });

    describe("when editing", () => {
        it('renders <input type="text"> when editing', () => {
            const input = shallow(<EditableText isEditing={true} />).find("input");
            assert.lengthOf(input, 1);
            assert.strictEqual(input.prop("type"), "text");
        });

        it("unrenders input when done editing", () => {
            const wrapper = shallow(<EditableText isEditing={true} placeholder="Edit..." value="alphabet" />);
            assert.lengthOf(wrapper.find("input"), 1);
            wrapper.setProps({ isEditing: false });
            assert.lengthOf(wrapper.find("input"), 0);
        });

        it("calls onChange when input is changed", () => {
            const changeSpy = spy();
            const wrapper = mount(
                <EditableText isEditing={true} onChange={changeSpy} placeholder="Edit..." value="alphabet" />,
            );
            wrapper
                .find("input")
                .simulate("change", { target: { value: "hello" } })
                .simulate("change", { target: { value: " " } })
                .simulate("change", { target: { value: "world" } });
            assert.isTrue(changeSpy.calledThrice, "onChange not called thrice");
            assert.deepEqual(changeSpy.args, [["hello"], [" "], ["world"]]);
        });

        it("calls onChange when escape key pressed and value is unconfirmed", () => {
            const changeSpy = spy();
            mount(<EditableText isEditing={true} onChange={changeSpy} placeholder="Edit..." defaultValue="alphabet" />)
                .find("input")
                .simulate("change", { target: { value: "hello" } })
                .simulate("keydown", { key: "Escape" });
            assert.equal(changeSpy.callCount, 2, "onChange not called twice"); // change & escape
            assert.deepEqual(changeSpy.args[1], ["alphabet"], `unexpected argument "${changeSpy.args[1][0]}"`);
        });

        it("calls onCancel, does not call onConfirm, and reverts value when escape key pressed", () => {
            const cancelSpy = spy();
            const confirmSpy = spy();

            const OLD_VALUE = "alphabet";
            const NEW_VALUE = "hello";

            const component = mount<EditableText>(
                <EditableText isEditing={true} onCancel={cancelSpy} onConfirm={confirmSpy} defaultValue={OLD_VALUE} />,
            );
            component
                .find("input")
                .simulate("change", { target: { value: NEW_VALUE } })
                .simulate("keydown", { key: "Escape" });

            assert.isTrue(confirmSpy.notCalled, "onConfirm called");
            assert.isTrue(cancelSpy.calledOnce, "onCancel not called once");
            assert.isTrue(cancelSpy.calledWith(OLD_VALUE), `unexpected argument "${cancelSpy.args[0][0]}"`);
            assert.strictEqual(component.state().value, OLD_VALUE, "did not revert to original value");
        });

        it("calls onConfirm, does not call onCancel, and saves value when enter key pressed", () => {
            const cancelSpy = spy();
            const confirmSpy = spy();

            const OLD_VALUE = "alphabet";
            const NEW_VALUE = "hello";

            const component = mount<EditableText>(
                <EditableText isEditing={true} onCancel={cancelSpy} onConfirm={confirmSpy} defaultValue={OLD_VALUE} />,
            );
            component
                .find("input")
                .simulate("change", { target: { value: NEW_VALUE } })
                .simulate("keydown", { key: "Enter" });

            assert.isTrue(cancelSpy.notCalled, "onCancel called");
            assert.isTrue(confirmSpy.calledOnce, "onConfirm not called once");
            assert.isTrue(confirmSpy.calledWith(NEW_VALUE), `unexpected argument "${confirmSpy.args[0][0]}"`);
            assert.strictEqual(component.state().value, NEW_VALUE, "did not save new value");
        });

        it("calls onConfirm when enter key pressed even if value didn't change", () => {
            const cancelSpy = spy();
            const confirmSpy = spy();

            const OLD_VALUE = "alphabet";
            const NEW_VALUE = "hello";

            const component = mount(
                <EditableText isEditing={true} onCancel={cancelSpy} onConfirm={confirmSpy} defaultValue={OLD_VALUE} />,
            );
            component
                .find("input")
                .simulate("change", { target: { value: NEW_VALUE } }) // change
                .simulate("change", { target: { value: OLD_VALUE } }) // revert
                .simulate("keydown", { key: "Enter" });

            assert.isTrue(cancelSpy.notCalled, "onCancel called");
            assert.isTrue(confirmSpy.calledOnce, "onConfirm not called once");
            assert.isTrue(confirmSpy.calledWith(OLD_VALUE), `unexpected argument "${confirmSpy.args[0][0]}"`);
        });

        it("calls onEdit when entering edit mode and passes the initial value to the callback", () => {
            const editSpy = spy();
            const INIT_VALUE = "hello";
            mount(<EditableText onEdit={editSpy} defaultValue={INIT_VALUE} />)
                .find("div")
                .simulate("focus");
            assert.isTrue(editSpy.calledOnce, "onEdit called once");
            assert.isTrue(editSpy.calledWith(INIT_VALUE), `unexpected argument "${editSpy.args[0][0]}"`);
        });

        it("stops editing when disabled", () => {
            const wrapper = mount(<EditableText isEditing={true} disabled={true} />);
            assert.isFalse(wrapper.state("isEditing"));
        });

        it("caret is placed at the end of the input box", () => {
            // mount into a DOM element so we can get the input to inspect its HTML props
            const containerElement = document.createElement("div");
            mount(<EditableText isEditing={true} value="alphabet" />, { attachTo: containerElement });
            const input = containerElement.querySelector<HTMLInputElement>("input")!;
            assert.strictEqual(input.selectionStart, 8);
            assert.strictEqual(input.selectionEnd, 8);
        });

        it("controlled mode can only change value via props", () => {
            let expected = "alphabet";
            const wrapper = mount(<EditableText isEditing={true} value={expected} />);
            const inputElement = wrapper.getDOMNode().querySelector<HTMLInputElement>("input")!;

            const input = wrapper.find("input");
            input.simulate("change", { target: { value: "hello" } });
            assert.strictEqual(inputElement.value, expected, "controlled mode can only change via props");

            expected = "hello world";
            wrapper.setProps({ value: expected });
            assert.strictEqual(inputElement.value, expected, "controlled mode should be changeable via props");
        });

        it("applies defaultValue only on initial render", () => {
            const wrapper = mount(<EditableText isEditing={true} defaultValue="default" placeholder="placeholder" />);
            assert.strictEqual(wrapper.state("value"), "default");
            // type new value, then change a prop to cause re-render
            wrapper.find("input").simulate("change", { target: { value: "hello" } });
            wrapper.setProps({ placeholder: "new placeholder" });
            assert.strictEqual(wrapper.state("value"), "hello");
        });

        it("the full input box is highlighted when selectAllOnFocus is true", () => {
            const containerElement = document.createElement("div");
            mount(<EditableText isEditing={true} selectAllOnFocus={true} value="alphabet" />, {
                attachTo: containerElement,
            });
            const input = containerElement.querySelector<HTMLInputElement>("input")!;
            assert.strictEqual(input.selectionStart, 0);
            assert.strictEqual(input.selectionEnd, 8);
        });
    });

    describe("multiline", () => {
        it("renders a <textarea> when editing", () => {
            assert.lengthOf(mount(<EditableText isEditing={true} multiline={true} />).find("textarea"), 1);
        });

        it("does not call onConfirm when enter key is pressed", () => {
            const confirmSpy = spy();
            mount(<EditableText isEditing={true} onConfirm={confirmSpy} multiline={true} />)
                .find("textarea")
                .simulate("change", { target: { value: "hello" } })
                .simulate("keydown", { key: "Enter" });
            assert.isTrue(confirmSpy.notCalled, "onConfirm called");
        });

        it("calls onConfirm when cmd+, ctrl+, shift+, or alt+ enter is pressed", () => {
            const confirmSpy = spy();
            const wrapper = mount(<EditableText isEditing={true} onConfirm={confirmSpy} multiline={true} />);
            simulateHelper(wrapper, "control", { ctrlKey: true, key: "Enter" });
            wrapper.setState({ isEditing: true });
            simulateHelper(wrapper, "meta", { metaKey: true, key: "Enter" });
            wrapper.setState({ isEditing: true });
            simulateHelper(wrapper, "shift", {
                key: "Enter",
                preventDefault: (): void => undefined,
                shiftKey: true,
            });
            wrapper.setState({ isEditing: true });
            simulateHelper(wrapper, "alt", {
                altKey: true,
                key: "Enter",
                preventDefault: (): void => undefined,
            });
            assert.isFalse(wrapper.state("isEditing"));
            assert.strictEqual(confirmSpy.callCount, 4, "onConfirm not called four times");
            assert.strictEqual(confirmSpy.firstCall.args[0], "control");
            assert.strictEqual(confirmSpy.secondCall.args[0], "meta");
            assert.strictEqual(confirmSpy.thirdCall.args[0], "shift");
            assert.strictEqual(confirmSpy.lastCall.args[0], "alt");
        });

        it("confirmOnEnterKey={true} calls onConfirm when enter is pressed", () => {
            const confirmSpy = spy();
            const wrapper = mount(
                <EditableText isEditing={true} onConfirm={confirmSpy} multiline={true} confirmOnEnterKey={true} />,
            );
            simulateHelper(wrapper, "control", { key: "Enter" });
            assert.isFalse(wrapper.state("isEditing"));
            assert.isTrue(confirmSpy.calledOnce, "onConfirm not called");
            assert.strictEqual(confirmSpy.firstCall.args[0], "control");
        });

        it("confirmOnEnterKey={true} adds newline when cmd+, ctrl+, shift+, or alt+ enter is pressed", () => {
            const confirmSpy = spy();
            const wrapper = mount(
                <EditableText isEditing={true} onConfirm={confirmSpy} multiline={true} confirmOnEnterKey={true} />,
            );
            const textarea = wrapper.getDOMNode().querySelector<HTMLTextAreaElement>("textarea")!;
            simulateHelper(wrapper, "", { ctrlKey: true, target: textarea, key: "Enter" });
            assert.strictEqual(textarea.value, "\n");
            simulateHelper(wrapper, "", { metaKey: true, target: textarea, key: "Enter" });
            assert.strictEqual(textarea.value, "\n");
            simulateHelper(wrapper, "", {
                key: "Enter",
                preventDefault: (): void => undefined,
                shiftKey: true,
                target: textarea,
            });
            assert.strictEqual(textarea.value, "\n");
            simulateHelper(wrapper, "", {
                altKey: true,
                key: "Enter",
                preventDefault: (): void => undefined,
                target: textarea,
            });
            assert.strictEqual(textarea.value, "\n");
            assert.isTrue(wrapper.state("isEditing"));
            assert.isTrue(confirmSpy.notCalled, "onConfirm called");
        });

        // fake interface because React's KeyboardEvent properties are not optional
        interface FakeKeyboardEvent {
            altKey?: boolean;
            ctrlKey?: boolean;
            key?: string;
            metaKey?: boolean;
            shiftKey?: boolean;
            target?: HTMLTextAreaElement;
            preventDefault?(): void;
        }

        function simulateHelper(wrapper: ReactWrapper<any>, value: string, e: FakeKeyboardEvent) {
            wrapper.find("textarea").simulate("change", { target: { value } }).simulate("keydown", e);
        }
    });
});

================================================================================

File: test\entity-title\entityTitleTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount } from "enzyme";
import * as React from "react";

import { Tag } from "@blueprintjs/core";
import { IconNames } from "@blueprintjs/icons";

import { Classes, EntityTitle, H5 } from "../../src";

describe("<EntityTitle>", () => {
    let containerElement: HTMLElement | undefined;

    beforeEach(() => {
        containerElement = document.createElement("div");
        document.body.appendChild(containerElement);
    });
    afterEach(() => {
        containerElement?.remove();
    });

    it("supports className", () => {
        const wrapper = mount(<EntityTitle className="foo" title="title" />, { attachTo: containerElement });
        assert.isFalse(wrapper.find(H5).exists(), "expected no H5");
        assert.isTrue(wrapper.find(`.foo`).exists());
    });

    it("renders title", () => {
        const wrapper = mount(<EntityTitle title="title" />, {
            attachTo: containerElement,
        });
        assert.isTrue(wrapper.find(`.${Classes.ENTITY_TITLE_TITLE}`).exists());
    });

    it("renders title in heading", () => {
        const wrapper = mount(<EntityTitle heading={H5} title="title" />, {
            attachTo: containerElement,
        });
        assert.isTrue(wrapper.find(H5).exists());
        assert.strictEqual(wrapper.find(H5).text(), "title");
    });

    it("supports icon", () => {
        const wrapper = mount(<EntityTitle icon={IconNames.GRAPH} title="title" />, { attachTo: containerElement });
        assert.isTrue(wrapper.find(`[data-icon="${IconNames.GRAPH}"]`).exists());
    });

    it("omitting icon prop removes icon from DOM", () => {
        const wrapper = mount(<EntityTitle title="title" />, { attachTo: containerElement });
        assert.isFalse(wrapper.find(`[data-icon]`).exists());
    });

    it("supports tag", () => {
        const wrapper = mount(<EntityTitle title="title" tags={<Tag>Tag</Tag>} />, { attachTo: containerElement });
        assert.isTrue(wrapper.find(`.${Classes.ENTITY_TITLE_TAGS_CONTAINER}`).exists());
    });

    it("renders optional subtitle element", () => {
        const wrapper = mount(<EntityTitle title="title" subtitle="subtitle" />, { attachTo: containerElement });
        assert.isTrue(wrapper.find(`.${Classes.ENTITY_TITLE_SUBTITLE}`).exists());
    });

    it("renders titleURL in an anchor", () => {
        const wrapper = mount(<EntityTitle title="title" titleURL="https://blueprintjs.com/" />, {
            attachTo: containerElement,
        });
        assert.isTrue(wrapper.find(`a[href="https://blueprintjs.com/"]`).exists());
        assert.isTrue(wrapper.find(`.${Classes.ENTITY_TITLE_TITLE}`).exists());
    });

    it("supports ellipsize on Text", () => {
        const wrapper = mount(<EntityTitle title="title" ellipsize={true} />, { attachTo: containerElement });
        assert.isTrue(wrapper.find(`.${Classes.TEXT_OVERFLOW_ELLIPSIS}`).exists());
    });

    it("supports ellipsize on heading", () => {
        const wrapper = mount(<EntityTitle title="title" ellipsize={true} heading={H5} />, {
            attachTo: containerElement,
        });
        assert.isTrue(wrapper.find(H5).hasClass(Classes.TEXT_OVERFLOW_ELLIPSIS));
    });

    it("supports loading", () => {
        const wrapper = mount(<EntityTitle title="title" loading={true} />, {
            attachTo: containerElement,
        });
        assert.isTrue(wrapper.find(`.${Classes.SKELETON}`).exists());
    });
});

================================================================================

File: test\forms\asyncControllableInputTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2020 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable max-classes-per-file */

import { assert } from "chai";
import { mount } from "enzyme";
import * as React from "react";
import { spy } from "sinon";

// this component is not part of the public API, but we want to test its implementation in isolation
import { AsyncControllableInput } from "../../src/components/forms/asyncControllableInput";
import { AsyncControllableTextArea } from "../../src/components/forms/asyncControllableTextArea";
import { ASYNC_CONTROLLABLE_VALUE_COMPOSITION_END_DELAY } from "../../src/hooks/useAsyncControllableValue";
import { sleep } from "../utils";

/*
 * NOTE: AsyncControllableInput & AsyncControllableTextArea are very similar, so we test them together.
 * The only difference for now is that the AsyncControllableInput is implemented via class component & getDerivedStateFromProps
 * lifecycle while the AsyncControllableTextArea is implemented via wrapping a `useAsyncControllableValue` hook.
 */

describe("asyncControllable tests", () => {
    const tests = [
        {
            COMPOSITION_END_DELAY: AsyncControllableInput.COMPOSITION_END_DELAY,
            Component: AsyncControllableInput,
            element: "input",
            type: "text",
        },
        {
            COMPOSITION_END_DELAY: ASYNC_CONTROLLABLE_VALUE_COMPOSITION_END_DELAY,
            Component: AsyncControllableTextArea,
            element: "textarea",
            type: undefined,
        },
    ];

    tests.forEach(({ Component, element, type, COMPOSITION_END_DELAY }) =>
        describe(element, () => {
            describe("uncontrolled mode", () => {
                it(`renders a ${element}`, () => {
                    const handleChangeSpy = spy();
                    const wrapper = mount(<Component defaultValue="hi" onChange={handleChangeSpy} type={type} />);
                    assert.strictEqual(wrapper.childAt(0).type(), element);
                });

                it("triggers onChange", () => {
                    const handleChangeSpy = spy();
                    const wrapper = mount(<Component defaultValue="hi" onChange={handleChangeSpy} type={type} />);
                    const input = wrapper.find(element);
                    input.simulate("change", { target: { value: "bye" } });
                    const simulatedEvent: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement> =
                        handleChangeSpy.getCall(0).lastArg;
                    assert.strictEqual(simulatedEvent.target.value, "bye");
                });
            });

            describe("controlled mode", () => {
                it(`renders a ${element}`, () => {
                    const wrapper = mount(<Component value="hi" type={type} />);
                    assert.strictEqual(wrapper.childAt(0).type(), element);
                });

                it("accepts controlled update 'hi' -> 'bye'", () => {
                    const wrapper = mount(<Component value="hi" type={type} />);
                    assert.strictEqual(wrapper.find(element).prop("value"), "hi");
                    wrapper.setProps({ value: "bye" });
                    assert.strictEqual(wrapper.find(element).prop("value"), "bye");
                });

                it("triggers onChange events during composition", () => {
                    const handleChangeSpy = spy();
                    const wrapper = mount(<Component value="hi" onChange={handleChangeSpy} type={type} />);
                    const input = wrapper.find(element);

                    input.simulate("compositionstart", { data: "" });
                    input.simulate("compositionupdate", { data: " " });
                    // some browsers trigger this change event during composition, so we test to ensure that our wrapper component does too
                    input.simulate("change", { target: { value: "hi " } });
                    input.simulate("compositionupdate", { data: " ." });
                    input.simulate("change", { target: { value: "hi ." } });
                    input.simulate("compositionend", { data: " ." });

                    assert.strictEqual(handleChangeSpy.callCount, 2);
                });

                it("external updates DO NOT override in-progress composition", async () => {
                    const wrapper = mount(<Component value="hi" type={type} />);
                    const input = wrapper.find(element);

                    input.simulate("compositionstart", { data: "" });
                    input.simulate("compositionupdate", { data: " " });
                    input.simulate("change", { target: { value: "hi " } });

                    await Promise.resolve();
                    wrapper.setProps({ value: "bye" }).update();

                    assert.strictEqual(wrapper.find(element).prop("value"), "hi ");
                });

                it("external updates DO NOT flush with immediately ongoing compositions", async () => {
                    const wrapper = mount(<Component value="hi" type={type} />);
                    const input = wrapper.find(element);

                    input.simulate("compositionstart", { data: "" });
                    input.simulate("compositionupdate", { data: " " });
                    input.simulate("change", { target: { value: "hi " } });

                    wrapper.setProps({ value: "bye" }).update();

                    input.simulate("compositionend", { data: " " });
                    input.simulate("compositionstart", { data: "" });

                    // Wait for the composition ending delay to pass
                    await new Promise(resolve => setTimeout(() => resolve(null), COMPOSITION_END_DELAY + 5));

                    assert.strictEqual(wrapper.find(element).prop("value"), "hi ");
                });

                it("external updates flush after composition ends", async () => {
                    const wrapper = mount(<Component value="hi" type={type} />);
                    const input = wrapper.find(element);

                    input.simulate("compositionstart", { data: "" });
                    input.simulate("compositionupdate", { data: " " });
                    input.simulate("change", { target: { value: "hi " } });
                    input.simulate("compositionend", { data: " " });

                    // Wait for the composition ending delay to pass
                    await new Promise(resolve => setTimeout(() => resolve(null), COMPOSITION_END_DELAY + 5));

                    // we are "rejecting" the composition here by supplying a different controlled value
                    wrapper.setProps({ value: "bye" }).update();

                    assert.strictEqual(wrapper.find(element).prop("value"), "bye");
                });

                it("accepts async controlled update, optimistically rendering new value while waiting for update", async () => {
                    class TestComponent extends React.PureComponent<{ initialValue: string }, { value: string }> {
                        public state = { value: this.props.initialValue };

                        public render() {
                            return <Component value={this.state.value} onChange={this.handleChange} type={type} />;
                        }

                        private handleChange = (e: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>) => {
                            const newValue = e.target.value;
                            window.setTimeout(() => this.setState({ value: newValue }), 10);
                        };
                    }

                    const wrapper = mount(<TestComponent initialValue="hi" />);
                    assert.strictEqual(wrapper.find(element).prop("value"), "hi");

                    wrapper.find(element).simulate("change", { target: { value: "hi " } });
                    wrapper.update();

                    assert.strictEqual(
                        wrapper.find(Component).prop("value"),
                        "hi",
                        "local state should still have initial value",
                    );
                    // but rendered input should optimistically show new value
                    assert.strictEqual(
                        wrapper.find(element).prop("value"),
                        "hi ",
                        `rendered <${element}> should optimistically show new value`,
                    );

                    // after async delay, confirm the update
                    await sleep(20);
                    assert.strictEqual(
                        wrapper.find(element).prop("value"),
                        "hi ",
                        `rendered <${element}> should still show new value`,
                    );
                    return;
                });
            });
        }),
    );
});

================================================================================

File: test\forms\fileInputTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, type ReactWrapper, shallow, type ShallowWrapper } from "enzyme";
import * as React from "react";
import sinon from "sinon";

import { Classes, FileInput } from "../../src";

describe("<FileInput>", () => {
    it("supports className, fill, & large", () => {
        const CUSTOM_CLASS = "foo";
        const wrapper = shallow(<FileInput className={CUSTOM_CLASS} fill={true} large={true} />);
        assert.isTrue(wrapper.hasClass(Classes.FILE_INPUT), "Classes.FILE_INPUT");
        assert.isTrue(wrapper.hasClass(CUSTOM_CLASS), CUSTOM_CLASS);
        assert.isTrue(wrapper.hasClass(Classes.FILL), "Classes.FILL");
        assert.isTrue(wrapper.hasClass(Classes.LARGE), "Classes.LARGE");
    });

    it("supports custom input props", () => {
        const wrapper = mount(
            <FileInput
                inputProps={{
                    className: "bar",
                    required: true,
                    type: "text", // overridden by type="file"
                }}
            />,
        );
        const input = getInput(wrapper);

        assert.isTrue(input.hasClass("bar"), "has custom class");
        assert.isTrue(input.prop("required"), "required attribute");
        assert.strictEqual(input.prop("type"), "file", "type attribute");
    });

    it("applies top-level disabled prop to the root and input (overriding inputProps.disabled)", () => {
        const wrapper = mount(<FileInput disabled={true} inputProps={{ disabled: false }} />);

        // should ignore inputProps.disabled in favor of the top-level prop
        assert.isTrue(wrapper.children().hasClass(Classes.DISABLED), "wrapper has disabled class");
        assert.isTrue(getInput(wrapper).prop("disabled"), "input is disabled");

        wrapper.setProps({ disabled: false, inputProps: { disabled: true } });

        // ensure inputProps.disabled is overriden in this case too
        assert.isFalse(wrapper.children().hasClass(Classes.DISABLED), "wrapper no longer has disabled class");
        assert.isFalse(getInput(wrapper).prop("disabled"), "input no longer disabled");
    });

    it("renders default or custom text", () => {
        const wrapper = mount(<FileInput />);
        const span = wrapper.find(`.${Classes.FILE_UPLOAD_INPUT}`);

        // default text
        assert.strictEqual(span.text(), "Choose file...");

        // custom text
        wrapper.setProps({ text: "Input file..." });
        assert.strictEqual(span.text(), "Input file...");
    });

    it("invokes change callbacks", () => {
        const inputProps = { onChange: sinon.spy() };
        const onChange = sinon.spy();
        const onInputChange = sinon.spy();

        const wrapper = shallow(<FileInput {...{ onChange, onInputChange, inputProps }} />);
        const input = getInput(wrapper);
        input.simulate("change");

        assert.isFalse(onChange.called, "onChange not called"); // because it's spread to the label, not the input
        assert.isTrue(onInputChange.calledOnce, "onInputChange called");
        assert.isTrue(inputProps.onChange.calledOnce, "inputProps.onChange called");
    });
});

function getInput(wrapper: ShallowWrapper<any, any> | ReactWrapper<any, any>) {
    return wrapper.find("input");
}

================================================================================

File: test\forms\formGroupTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { shallow } from "enzyme";
import * as React from "react";

import { Classes, FormGroup, Intent } from "../../src";

describe("<FormGroup>", () => {
    it("supports className & intent", () => {
        const wrapper = shallow(<FormGroup className="foo" intent={Intent.SUCCESS} />);
        assert.isTrue(wrapper.hasClass(Classes.FORM_GROUP));
        assert.isTrue(wrapper.hasClass(Classes.INTENT_SUCCESS));
        assert.isTrue(wrapper.hasClass("foo"));
    });

    it("renders children in form content", () => {
        const wrapper = shallow(
            <FormGroup>
                <input id="yes" />
            </FormGroup>,
        );
        const content = wrapper.find(`.${Classes.FORM_CONTENT}`);
        assert.strictEqual(content.find("input").prop("id"), "yes");
    });

    it("renders label & labelFor", () => {
        const labelText = "This is the label.";
        const label = shallow(<FormGroup label={labelText} labelFor="foo" />).find("label");
        // remove space to separate from labelInfo (does not appear in DOM)
        assert.strictEqual(label.text().trim(), labelText);
        assert.strictEqual(label.prop("htmlFor"), "foo");
    });

    it("hides label when falsy", () => {
        const label = shallow(<FormGroup />).find("label");
        assert.strictEqual(label.length, 0);
    });

    it("labelInfo=JSX renders JSX content in label", () => {
        const info = <em>fill me out</em>;
        const label = shallow(<FormGroup label="label" labelInfo={info} />).find("label");
        assert.isTrue(label.containsMatchingElement(info));
    });

    it("renders helperText", () => {
        const helperText = "Help me out";
        const wrapper = shallow(<FormGroup helperText={helperText} />);
        const helper = wrapper.find(`.${Classes.FORM_HELPER_TEXT}`);
        assert.strictEqual(helper.text(), helperText);
    });
});

================================================================================

File: test\forms\textAreaTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount } from "enzyme";
import * as React from "react";
import * as ReactDOM from "react-dom";

import { TextArea } from "../../src";

describe("<TextArea>", () => {
    let containerElement: HTMLElement | undefined;

    beforeEach(() => {
        containerElement = document.createElement("div");
        containerElement.setAttribute("style", "width: 1000px; height: 1000px;");
        document.body.appendChild(containerElement);
    });

    afterEach(() => {
        ReactDOM.unmountComponentAtNode(containerElement!);
        containerElement!.remove();
    });

    it("No manual resizes when autoResize enabled", () => {
        const wrapper = mount(<TextArea autoResize={true} />, { attachTo: containerElement });
        const textarea = wrapper.find("textarea");

        textarea.simulate("change", { target: { scrollHeight: 500 } });

        assert.notEqual(textarea.getDOMNode<HTMLElement>().style.height, "500px");
    });

    it("resizes with large initial input when autoResize enabled", () => {
        const initialValue = `Lorem ipsum dolor sit amet, consectetur adipiscing elit.
        Aenean finibus eget enim non accumsan.
        Nunc lobortis luctus magna eleifend consectetur.
        Suspendisse ut semper sem, quis efficitur felis.
        Praesent suscipit nunc non semper tempor.
        Sed eros sapien, semper sed imperdiet sed,
        dictum eget purus. Donec porta accumsan pretium.
        Fusce at felis mattis, tincidunt erat non, varius erat.`;
        const wrapper = mount(<TextArea value={initialValue} autoResize={true} />, { attachTo: containerElement });
        const textarea = wrapper.find("textarea");

        const scrollHeightInPixels = `${textarea.getDOMNode<HTMLElement>().scrollHeight}px`;

        assert.equal(textarea.getDOMNode<HTMLElement>().style.height, scrollHeightInPixels);
    });

    it("resizes with long text input when autoResize enabled", () => {
        const initialValue = "A";
        const nextValue = `Lorem ipsum dolor sit amet, consectetur adipiscing elit.
        Aenean finibus eget enim non accumsan.
        Nunc lobortis luctus magna eleifend consectetur.
        Suspendisse ut semper sem, quis efficitur felis.
        Praesent suscipit nunc non semper tempor.
        Sed eros sapien, semper sed imperdiet sed,
        dictum eget purus. Donec porta accumsan pretium.
        Fusce at felis mattis, tincidunt erat non, varius erat.`;
        const wrapper = mount(<TextArea value={initialValue} autoResize={true} />, { attachTo: containerElement });
        const textarea = wrapper.find("textarea");

        const scrollHeightInPixelsBefore = `${textarea.getDOMNode<HTMLElement>().scrollHeight}px`;
        wrapper.setProps({ value: nextValue }).update();
        const scrollHeightInPixelsAfter = `${textarea.getDOMNode<HTMLElement>().scrollHeight}px`;

        assert.notEqual(scrollHeightInPixelsBefore, scrollHeightInPixelsAfter);
    });

    // HACKHACK: skipped test, see https://github.com/palantir/blueprint/issues/5976
    // Note that growVertically is deprecated as of 28/07/2023
    it.skip("can resize automatically", () => {
        const wrapper = mount(<TextArea growVertically={true} />, { attachTo: containerElement });
        const textarea = wrapper.find("textarea");

        textarea.simulate("change", { target: { scrollHeight: 500 } });

        assert.equal(textarea.getDOMNode<HTMLElement>().style.height, "500px");
    });

    it("doesn't resize by default", () => {
        const wrapper = mount(<TextArea />, { attachTo: containerElement });
        const textarea = wrapper.find("textarea");

        textarea.simulate("change", {
            target: {
                scrollHeight: textarea.getDOMNode().scrollHeight,
            },
        });

        assert.equal(textarea.getDOMNode<HTMLElement>().style.height, "");
    });

    it("doesn't clobber user-supplied styles", () => {
        const wrapper = mount(<TextArea autoResize={true} style={{ marginTop: 10 }} />, {
            attachTo: containerElement,
        });
        const textarea = wrapper.find("textarea");

        textarea.simulate("change", { target: { scrollHeight: 500 } });

        assert.equal(textarea.getDOMNode<HTMLElement>().style.marginTop, "10px");
    });

    // HACKHACK: skipped test, see https://github.com/palantir/blueprint/issues/5976
    // Note that growVertically is deprecated as of 28/07/2023
    it.skip("can fit large initial content", () => {
        const initialValue = `Lorem ipsum dolor sit amet, consectetur adipiscing elit.
        Aenean finibus eget enim non accumsan.
        Nunc lobortis luctus magna eleifend consectetur.
        Suspendisse ut semper sem, quis efficitur felis.
        Praesent suscipit nunc non semper tempor.
        Sed eros sapien, semper sed imperdiet sed,
        dictum eget purus. Donec porta accumsan pretium.
        Fusce at felis mattis, tincidunt erat non, varius erat.`;
        const wrapper = mount(<TextArea growVertically={true} value={initialValue} style={{ marginTop: 10 }} />, {
            attachTo: containerElement,
        });
        const textarea = wrapper.find("textarea");
        const scrollHeightInPixels = `${textarea.getDOMNode<HTMLElement>().scrollHeight}px`;
        assert.equal(textarea.getDOMNode<HTMLElement>().style.height, scrollHeightInPixels);
    });

    it("updates on ref change", () => {
        let textArea: HTMLTextAreaElement | null = null;
        let textAreaNew: HTMLTextAreaElement | null = null;
        let callCount = 0;
        let newCallCount = 0;
        const textAreaRefCallback = (ref: HTMLTextAreaElement | null) => {
            callCount += 1;
            textArea = ref;
        };
        const textAreaNewRefCallback = (ref: HTMLTextAreaElement | null) => {
            newCallCount += 1;
            textAreaNew = ref;
        };

        const textAreawrapper = mount(<TextArea inputRef={textAreaRefCallback} />, { attachTo: containerElement });
        assert.instanceOf(textArea, HTMLTextAreaElement);
        assert.strictEqual(callCount, 1);

        textAreawrapper.setProps({ inputRef: textAreaNewRefCallback });
        textAreawrapper.update();
        assert.strictEqual(callCount, 2);
        assert.isNull(textArea);
        assert.strictEqual(newCallCount, 1);
        assert.instanceOf(textAreaNew, HTMLTextAreaElement);
    });

    it("accepts object refs created with React.createRef and updates on change", () => {
        const textAreaRef = React.createRef<HTMLTextAreaElement>();
        const textAreaNewRef = React.createRef<HTMLTextAreaElement>();

        const textAreawrapper = mount(<TextArea inputRef={textAreaRef} />, { attachTo: containerElement });
        assert.instanceOf(textAreaRef.current, HTMLTextAreaElement);

        textAreawrapper.setProps({ inputRef: textAreaNewRef });
        assert.isNull(textAreaRef.current);
        assert.instanceOf(textAreaNewRef.current, HTMLTextAreaElement);
    });

    // HACKHACK: skipped test, see https://github.com/palantir/blueprint/issues/5976
    // Note that growVertically is deprecated as of 28/07/2023
    it.skip("resizes when props change if growVertically is true", () => {
        const initialText = "A";
        const longText = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
        const wrapper = mount(<TextArea growVertically={true} value={initialText} />, { attachTo: containerElement });
        const initialHeight = wrapper.find("textarea").getDOMNode<HTMLElement>().style.height;
        wrapper.setProps({ value: longText }).update();
        const newHeight = wrapper.find("textarea").getDOMNode<HTMLElement>().style.height;
        assert.notEqual(newHeight, initialHeight);
    });
});

================================================================================

File: test\hooks\useHotkeysTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { render, screen } from "@testing-library/react";
import { expect } from "chai";
import * as React from "react";
import { type SinonStub, spy, stub } from "sinon";

// N.B. { fireEvent } from "@testing-library/react" does not generate "real" enough events which
// work with our hotkey parser implementation (worth investigating...)
import { dispatchTestKeyboardEvent } from "@blueprintjs/test-commons";

import { InputGroup } from "../../src/components/forms/inputGroup";
import { HotkeysProvider } from "../../src/context";
import { useHotkeys } from "../../src/hooks";

interface TestComponentProps extends TestComponentContainerProps {
    onKeyA: () => void;
    onKeyB: () => void;
}

interface TestComponentContainerProps {
    bindExtraKeys?: boolean;
    isInputReadOnly?: boolean;
}

const TestComponent: React.FC<TestComponentProps> = ({ bindExtraKeys, isInputReadOnly, onKeyA, onKeyB }) => {
    const hotkeys = React.useMemo(() => {
        const keys = [
            {
                combo: "A",
                label: "A",
                onKeyDown: onKeyA,
            },
            {
                combo: "B",
                global: true,
                label: "B",
                onKeyDown: onKeyB,
            },
        ];
        if (bindExtraKeys) {
            keys.push(
                {
                    combo: "shift+A",
                    label: "shift+A",
                    onKeyDown: onKeyA,
                },
                {
                    combo: "shift+B",
                    global: true,
                    label: "shift+B",
                    onKeyDown: onKeyB,
                },
            );
        }
        return keys;
    }, [bindExtraKeys, onKeyA, onKeyB]);

    const { handleKeyDown, handleKeyUp } = useHotkeys(hotkeys);

    return (
        <div onKeyDown={handleKeyDown} onKeyUp={handleKeyUp}>
            <div data-testid="target-inside-component" />
            <InputGroup data-testid="input-target" readOnly={isInputReadOnly} />
        </div>
    );
};

describe("useHotkeys", () => {
    const onKeyASpy = spy();
    const onKeyBSpy = spy();

    const TestComponentContainer = (props: TestComponentContainerProps) => {
        return (
            <>
                <div data-testid="target-outside-component" />
                <TestComponent {...props} onKeyA={onKeyASpy} onKeyB={onKeyBSpy} />
            </>
        );
    };

    afterEach(() => {
        onKeyASpy.resetHistory();
        onKeyBSpy.resetHistory();
    });

    it("binds local hotkey", () => {
        render(<TestComponentContainer />);
        const target = screen.getByTestId("target-inside-component");
        dispatchTestKeyboardEvent(target, "keydown", "a");
        expect(onKeyASpy.callCount).to.equal(1, "hotkey a should be called once");
    });

    it("binds global hotkey", () => {
        render(<TestComponentContainer />);
        const target = screen.getByTestId("target-outside-component");
        dispatchTestKeyboardEvent(target, "keydown", "b");
        expect(onKeyBSpy.callCount).to.equal(1, "hotkey b should be called once");
    });

    it("binds new local hotkeys when hook arg is updated", () => {
        const { rerender } = render(<TestComponentContainer />);
        rerender(<TestComponentContainer bindExtraKeys={true} />);
        const target = screen.getByTestId("target-inside-component");
        dispatchTestKeyboardEvent(target, "keydown", "a", true);
        expect(onKeyASpy.callCount).to.equal(1, "hotkey A should be called once");
    });

    it("binds new global hotkeys when hook arg is updated", () => {
        const { rerender } = render(<TestComponentContainer />);
        rerender(<TestComponentContainer bindExtraKeys={true} />);
        const target = screen.getByTestId("target-outside-component");
        dispatchTestKeyboardEvent(target, "keydown", "b", true);
        expect(onKeyBSpy.callCount).to.equal(1, "hotkey B should be called once");
    });

    it("removes local hotkeys when hook arg is updated", () => {
        const { rerender } = render(<TestComponentContainer bindExtraKeys={true} />);
        rerender(<TestComponentContainer />);
        const target = screen.getByTestId("target-inside-component");
        dispatchTestKeyboardEvent(target, "keydown", "a", true);
        expect(onKeyASpy.callCount).to.equal(0, "hotkey A should not be called");
    });

    it("removes global hotkeys when hook arg is updated", () => {
        const { rerender } = render(<TestComponentContainer bindExtraKeys={true} />);
        rerender(<TestComponentContainer />);
        const target = screen.getByTestId("target-outside-component");
        dispatchTestKeyboardEvent(target, "keydown", "b", true);
        expect(onKeyBSpy.callCount).to.equal(0, "hotkey B should not be called");
    });

    it("does not trigger hotkeys inside text inputs", () => {
        render(<TestComponentContainer />);
        const target = screen.getByTestId("input-target");
        dispatchTestKeyboardEvent(target, "keydown", "a");
        expect(onKeyASpy.callCount).to.equal(0, "hotkey A should not be called");
    });

    it("does trigger hotkeys inside readonly text inputs", () => {
        render(<TestComponentContainer isInputReadOnly={true} />);
        const target = screen.getByTestId("input-target");
        dispatchTestKeyboardEvent(target, "keydown", "a");
        expect(onKeyASpy.callCount).to.equal(1, "hotkey A should be called once");
    });

    describe("working with HotkeysProvider", () => {
        let warnSpy: SinonStub | undefined;

        before(() => (warnSpy = stub(console, "warn")));
        afterEach(() => warnSpy?.resetHistory());
        after(() => warnSpy?.restore());

        it("logs a warning when used outside of HotkeysProvider context", () => {
            render(<TestComponentContainer />);
            expect(warnSpy?.calledOnce).to.be.true;
        });

        it("does NOT log a warning when used inside a HotkeysProvider context", () => {
            render(
                <HotkeysProvider>
                    <TestComponentContainer />
                </HotkeysProvider>,
            );
            expect(warnSpy?.notCalled).to.be.true;
        });
    });
});

================================================================================

File: test\hooks\useOverlayStackTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { render } from "@testing-library/react";
import { expect } from "chai";
import * as React from "react";
import { useUID } from "react-uid";
import { spy } from "sinon";

import type { OverlayProps } from "../../src/components/overlay/overlayProps";
import type { OverlayInstance } from "../../src/components/overlay2/overlayInstance";
import { OverlaysProvider } from "../../src/context";
import { useOverlayStack, usePrevious } from "../../src/hooks";
import { modifyGlobalStack } from "../../src/hooks/overlays/useLegacyOverlayStack";

interface TestComponentProps extends OverlayProps {
    handleLastOpenedChange?: (lastOpened: OverlayInstance | undefined) => void;
    containerRef: React.RefObject<HTMLDivElement>;
}

const TestComponentWithoutProvider: React.FC<TestComponentProps> = ({
    autoFocus,
    children,
    enforceFocus,
    containerRef: containerElement,
    handleLastOpenedChange,
    hasBackdrop,
    isOpen,
    usePortal,
}) => {
    const { openOverlay, getLastOpened, closeOverlay } = useOverlayStack();

    const id = useUID();
    const instance = React.useMemo<OverlayInstance>(
        () => ({
            containerElement,
            id,
            props: {
                autoFocus,
                enforceFocus,
                hasBackdrop,
                usePortal,
            },
        }),
        [autoFocus, containerElement, enforceFocus, hasBackdrop, id, usePortal],
    );

    const prevIsOpen = usePrevious(isOpen) ?? false;
    React.useEffect(() => {
        if (!prevIsOpen && isOpen) {
            // just opened
            openOverlay(instance);
        }

        if (prevIsOpen && !isOpen) {
            // just closed
            closeOverlay(id);
        }
    }, [isOpen, openOverlay, closeOverlay, prevIsOpen, instance, id]);

    // run once on unmount
    React.useEffect(() => {
        return () => {
            if (isOpen) {
                closeOverlay(id);
            }
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    const lastOpened = getLastOpened();
    const prevLastOpened = usePrevious(lastOpened);
    React.useEffect(() => {
        if (prevLastOpened !== lastOpened) {
            handleLastOpenedChange?.(lastOpened);
        }
    }, [handleLastOpenedChange, lastOpened, prevLastOpened]);

    return <div ref={containerElement}>{children}</div>;
};

const TestComponentWithProvider: React.FC<TestComponentProps> = props => {
    return (
        <OverlaysProvider>
            <TestComponentWithoutProvider {...props} />
        </OverlaysProvider>
    );
};

describe("useOverlayStack()", () => {
    const handleLastOpenedChange = spy();
    const containerRef = React.createRef<HTMLDivElement>();
    const TEST_PROPS_CLOSED: TestComponentProps = {
        autoFocus: true,
        containerRef,
        enforceFocus: true,
        handleLastOpenedChange,
        hasBackdrop: true,
        isOpen: false,
        usePortal: true,
    };
    const TEST_PROPS_OPEN: TestComponentProps = {
        ...TEST_PROPS_CLOSED,
        isOpen: true,
    };

    afterEach(() => {
        handleLastOpenedChange.resetHistory();
    });

    describe("with <OverlaysProvider>", () => {
        it("should render without crashing", () => {
            render(<TestComponentWithProvider {...TEST_PROPS_CLOSED} />);
        });

        it("opening an overlay should change the result of getLastOpened()", () => {
            const { rerender } = render(<TestComponentWithProvider {...TEST_PROPS_CLOSED} />);
            // we need to re-render twice: the overlay is added to the stack _after_ the first re-render completes,
            // so it wont' trigger a change in getLastOpened() until the second re-render.
            rerender(<TestComponentWithProvider {...TEST_PROPS_OPEN} />);
            rerender(<TestComponentWithProvider {...TEST_PROPS_OPEN} />);
            expect(
                handleLastOpenedChange.calledOnce,
                `expected getLastOpened() result to change after re-rendering with isOpen={true}`,
            ).to.be.true;
            const lastOpenedInstance = handleLastOpenedChange.getCall(0).args[0] as OverlayInstance;
            expect(lastOpenedInstance).to.exist;
            expect(containerRef.current).to.exist;
            expect(lastOpenedInstance.containerElement.current).to.equal(containerRef.current);
        });
    });

    describe("without <OverlaysProvider>", () => {
        before(() => {
            // ensure there is a clean global state that might be polluted by other test suites
            modifyGlobalStack(s => s.splice(0, s.length));
        });

        it("should render without crashing", () => {
            render(<TestComponentWithoutProvider {...TEST_PROPS_CLOSED} />);
        });

        it("opening an overlay should change the result of getLastOpened()", () => {
            const { rerender } = render(<TestComponentWithoutProvider {...TEST_PROPS_CLOSED} />);
            // we need to re-render twice: the overlay is added to the stack _after_ the first re-render completes,
            // so it wont' trigger a change in getLastOpened() until the second re-render.
            rerender(<TestComponentWithoutProvider {...TEST_PROPS_OPEN} />);
            rerender(<TestComponentWithoutProvider {...TEST_PROPS_OPEN} />);
            expect(
                handleLastOpenedChange.callCount > 0,
                `expected getLastOpened() result to change after re-rendering with isOpen={true}`,
            ).to.be.true;
            const lastOpenedInstance = handleLastOpenedChange.getCall(0).args[0] as OverlayInstance;
            expect(lastOpenedInstance).to.exist;
            expect(containerRef.current).to.exist;
            expect(
                lastOpenedInstance.containerElement.current === containerRef.current,
                "expected last opened overlay container element ref to be the same as the ref passed through props",
            ).to.be.true;
        });
    });
});

================================================================================

File: test\hotkeys\hotkeysParserTests.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { expect } from "chai";

import {
    comboMatches,
    getKeyCombo,
    getKeyComboString,
    type KeyCombo,
    normalizeKeyCombo,
    parseKeyCombo,
} from "../../src/components/hotkeys/hotkeyParser";

describe("HotkeysParser", () => {
    // N.B. we test these two functions together to match how they are used in useHotkeys()
    describe("getKeyCombo + parseKeyCombo", () => {
        interface ComboTest {
            combo: string;
            stringKeyCombo: string;
            eventKeyCombo: KeyCombo;
            parsedKeyCombo: KeyCombo;
        }

        const makeComboTest = (combo: string, event: Partial<KeyboardEvent>) => {
            return {
                combo,
                eventKeyCombo: getKeyCombo(event as KeyboardEvent),
                parsedKeyCombo: parseKeyCombo(combo),
                stringKeyCombo: getKeyComboString(event as KeyboardEvent),
            };
        };

        const verifyCombos = (tests: ComboTest[], verifyStrings = true) => {
            for (const test of tests) {
                if (verifyStrings) {
                    expect(test.stringKeyCombo).to.equal(test.combo, "getKeyComboString");
                }
                expect(comboMatches(test.parsedKeyCombo, test.eventKeyCombo)).to.be.true;
            }
        };

        it("matches lowercase alphabet chars", () => {
            const alpha = 65;
            verifyCombos(
                Array.apply(null, Array(26)).map((_: any, i: number) => {
                    const charString = String.fromCharCode(alpha + i).toLowerCase();
                    const combo = charString;
                    return makeComboTest(combo, { key: charString, code: `Key${charString.toUpperCase()}` });
                }),
            );
        });

        it("bare alphabet chars ignore case", () => {
            const alpha = 65;
            verifyCombos(
                Array.apply(null, Array(26)).map((_: any, i: number) => {
                    const charString = String.fromCharCode(alpha + i).toLowerCase();
                    const combo = charString.toUpperCase();
                    return makeComboTest(combo, { key: charString, code: `Key${charString.toUpperCase()}` });
                }),
                false,
            ); // don't compare string combos
        });

        it("matches uppercase alphabet chars using shift", () => {
            const alpha = 65;
            verifyCombos(
                Array.apply(null, Array(26)).map((_: any, i: number) => {
                    const charString = String.fromCharCode(alpha + i).toLowerCase();
                    const combo = "shift + " + charString;
                    return makeComboTest(combo, {
                        code: `Key${charString.toUpperCase()}`,
                        key: charString,
                        shiftKey: true,
                    });
                }),
            );
        });

        it("matches modifiers only", () => {
            const tests = [] as ComboTest[];
            tests.push(makeComboTest("shift", { shiftKey: true, code: "ShiftLeft" } as any));
            tests.push(
                makeComboTest("ctrl + alt + shift", {
                    altKey: true,
                    code: "ShiftLeft",
                    ctrlKey: true,
                    shiftKey: true,
                } as any as KeyboardEvent),
            );
            tests.push(
                makeComboTest("ctrl + meta", {
                    code: "MetaLeft",
                    ctrlKey: true,
                    metaKey: true,
                } as any as KeyboardEvent),
            );
            verifyCombos(tests);
        });

        // these tests no longer make sense with the migration from key codes to named keys, they can likely be deleted
        it.skip("adds Shift to keys that imply it", () => {
            const tests = [] as ComboTest[];
            tests.push(makeComboTest("!", { shiftKey: true, key: "!", code: "Digit1" }));
            tests.push(makeComboTest("@", { shiftKey: true, key: "@", code: "Digit2" }));
            tests.push(makeComboTest("{", { shiftKey: true, key: "{", code: "BracketLeft" }));
            // don't verify the strings because these will be converted to
            // `Shift + 1`, etc.
            verifyCombos(tests, false);
        });

        it("handles space key", () => {
            const tests = [] as ComboTest[];
            tests.push(
                makeComboTest("space", { key: " ", code: "Space" }),
                makeComboTest("ctrl + space", { ctrlKey: true, key: " ", code: "Space" }),
            );
            verifyCombos(tests);
        });

        it("handles alt modifier key", () => {
            const tests = [] as ComboTest[];
            tests.push(makeComboTest("alt + a", { altKey: true, key: "a", code: "KeyA" }));
            verifyCombos(tests);
        });
    });

    describe("parseKeyCombo", () => {
        it("handles 'plus' key identifier", () => {
            expect(() => parseKeyCombo("ctrl + +")).to.throw(/failed to parse/i);
            expect(comboMatches(parseKeyCombo("cmd + plus"), parseKeyCombo("meta + plus"))).to.be.true;
        });

        it("applies aliases", () => {
            expect(comboMatches(parseKeyCombo("return"), parseKeyCombo("enter"))).to.be.true;
            expect(comboMatches(parseKeyCombo("win + F"), parseKeyCombo("meta + f"))).to.be.true;
            // regression test for https://github.com/palantir/blueprint/issues/6471
            expect(comboMatches(parseKeyCombo("esc"), parseKeyCombo("escape"))).to.be.true;
        });
    });

    describe("normalizeKeyCombo", () => {
        it("refers to meta key as 'ctrl' on Windows", () => {
            expect(normalizeKeyCombo("meta + s", "Win32")).to.deep.equal(["ctrl", "s"]);
        });

        it("refers to meta key as 'cmd' on Mac", () => {
            expect(normalizeKeyCombo("meta + s", "Mac")).to.deep.equal(["cmd", "s"]);
            expect(normalizeKeyCombo("meta + s", "iPhone")).to.deep.equal(["cmd", "s"]);
            expect(normalizeKeyCombo("meta + s", "iPod")).to.deep.equal(["cmd", "s"]);
            expect(normalizeKeyCombo("meta + s", "iPad")).to.deep.equal(["cmd", "s"]);
        });

        it("refers to meta key as 'ctrl' on Linux and other platforms", () => {
            expect(normalizeKeyCombo("meta + s", "linux")).to.deep.equal(["ctrl", "s"]);
        });
    });
});

================================================================================

File: test\hotkeys\hotkeyTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { render, screen } from "@testing-library/react";
import { expect } from "chai";
import * as React from "react";
import { type SinonStub, stub } from "sinon";

import { Hotkey } from "../../src/components/hotkeys";

describe("Hotkey", () => {
    it("renders hotkey label", () => {
        render(<Hotkey combo="cmd+C" label="test copy me" group="editing" />);
        expect(screen.getByText("test copy me")).not.to.be.undefined;
    });

    describe("validation", () => {
        let consoleError: SinonStub;

        before(() => (consoleError = stub(console, "error")));
        afterEach(() => consoleError.resetHistory());
        after(() => consoleError.restore());

        it("logs an error for non-global hotkey without a group", () => {
            render(<Hotkey combo="cmd+C" label="test copy me" />);
            expect(consoleError.callCount).to.equal(1);
        });
    });
});

================================================================================

File: test\hotkeys\keyComboTagTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { render, screen } from "@testing-library/react";
import { expect } from "chai";
import * as React from "react";

import { KeyComboTag } from "../../src/components/hotkeys";

describe("KeyCombo", () => {
    it("renders key combo", () => {
        render(<KeyComboTag combo="cmd+C" />);
        expect(screen.getByText("C")).not.to.be.undefined;
    });
});

================================================================================

File: test\html\htmlTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { mount } from "enzyme";
import * as React from "react";

import { Label } from "../../src";

describe("HTML components", () => {
    describe("<Label>", () => {
        it("supports htmlFor prop", () => {
            mount(
                <div>
                    <Label htmlFor="foo" />
                    <input id="foo" />
                </div>,
            );
        });
    });
});

================================================================================

File: test\html-select\htmlSelectTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount } from "enzyme";
import * as React from "react";

import { HTMLSelect, type OptionProps } from "../../src";

describe("<HtmlSelect>", () => {
    const emptyHandler = () => true;

    it("renders options strings", () => {
        const options = mount(<HTMLSelect onChange={emptyHandler} options={["a", "b"]} />).find("option");
        assert.equal(options.at(0).text(), "a");
        assert.equal(options.at(1).text(), "b");
    });

    it("renders options props", () => {
        const OPTIONS: OptionProps[] = [
            { value: "a" },
            { value: "b", className: "foo" },
            { value: "c", disabled: true },
            { value: "d", label: "Dog" },
        ];
        const options = mount(<HTMLSelect onChange={emptyHandler} options={OPTIONS} />).find("option");
        assert.equal(options.at(0).text(), "a", "value");
        assert.isTrue(options.at(1).hasClass("foo"), "className");
        assert.isTrue(options.at(2).prop("disabled"), "disabled");
        assert.equal(options.at(3).text(), "Dog", "label");
    });
});

================================================================================

File: test\icon\iconTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount } from "enzyme";
import * as React from "react";
import { type SinonStub, stub } from "sinon";

import { type IconName, Icons, IconSize } from "@blueprintjs/icons";
// tslint:disable-next-line no-submodule-imports
import { Add, Airplane, Calendar, Graph } from "@blueprintjs/icons/lib/cjs/generated/16px/paths";

import { Classes, Icon, type IconProps, Intent } from "../../src";

describe("<Icon>", () => {
    let iconLoader: SinonStub;

    before(() => {
        stub(Icons, "load").resolves(undefined);
        // stub the dynamic icon loader with a synchronous, static one
        iconLoader = stub(Icons, "getPaths");
        iconLoader.returns(undefined);
        iconLoader.withArgs("add").returns(Add);
        iconLoader.withArgs("airplane").returns(Airplane);
        iconLoader.withArgs("calendar").returns(Calendar);
        iconLoader.withArgs("graph").returns(Graph);
    });

    afterEach(() => {
        iconLoader?.resetHistory();
    });

    it("tagName dictates HTML tag", async () => {
        const wrapper = mount(<Icon icon="calendar" tagName="i" />);
        wrapper.update();
        assert.isTrue(wrapper.find("i").exists());
    });

    it("size=16 renders standard size", async () =>
        assertIconSize(<Icon icon="graph" size={IconSize.STANDARD} />, IconSize.STANDARD));

    it("size=20 renders large size", async () =>
        assertIconSize(<Icon icon="graph" size={IconSize.LARGE} />, IconSize.LARGE));

    it("renders intent class", async () => {
        const wrapper = mount(<Icon icon="add" intent={Intent.DANGER} />);
        assert.isTrue(wrapper.find(`.${Classes.INTENT_DANGER}`).exists());
    });

    it("renders icon name", async () => {
        assertIconHasPath(<Icon icon="calendar" />, "calendar");
    });

    it("renders icon without color", async () => {
        assertIconColor(<Icon icon="add" />);
    });

    it("renders icon color", async () => {
        assertIconColor(<Icon icon="add" color="red" />, "red");
    });

    it("unknown icon name renders blank icon", async () => {
        const wrapper = mount(<Icon icon={"unknown" as any} />);
        wrapper.update();
        assert.lengthOf(wrapper.find("path"), 0);
    });

    it("prefixed icon renders blank icon", async () => {
        const wrapper = mount(<Icon icon={Classes.iconClass("airplane") as any} />);
        wrapper.update();
        assert.lengthOf(wrapper.find("path"), 0);
    });

    it("icon element passes through unchanged", async () => {
        // NOTE: This is supported to simplify usage of this component in other
        // Blueprint components which accept `icon?: IconName | React.JSX.Element`.
        const onClick = () => true;
        const wrapper = mount(<Icon icon={<article onClick={onClick} />} />);
        wrapper.update();
        assert.isTrue(wrapper.childAt(0).is("article"));
        assert.strictEqual(wrapper.find("article").prop("onClick"), onClick);
    });

    it("icon=undefined renders nothing", async () => {
        const wrapper = mount(<Icon icon={undefined} />);
        wrapper.update();
        assert.isTrue(wrapper.isEmptyRender());
    });

    it("title sets content of <title> element", async () => {
        const wrapper = mount(<Icon icon="airplane" title="bird" />);
        wrapper.update();
        assert.equal(wrapper.find("title").text(), "bird");
    });

    it("does not add desc if title is not provided", () => {
        const icon = mount(<Icon icon="airplane" />);
        assert.isEmpty(icon.find("desc"));
    });

    it("applies aria-hidden=true if title is not defined", () => {
        const icon = mount(<Icon icon="airplane" />);
        assert.isTrue(icon.find(`.${Classes.ICON}`).hostNodes().prop("aria-hidden"));
    });

    it("supports mouse event handlers of type React.MouseEventHandler", () => {
        const handleClick: React.MouseEventHandler = () => undefined;
        mount(<Icon icon="add" onClick={handleClick} />);
    });

    it("accepts HTML attributes", () => {
        mount(<Icon<HTMLSpanElement> icon="drag-handle-vertical" draggable={false} />);
    });

    it("accepts generic type param specifying the type of the root element", () => {
        const handleClick: React.MouseEventHandler<HTMLSpanElement> = () => undefined;
        mount(<Icon<HTMLSpanElement> icon="add" onClick={handleClick} />);
    });

    it("allows specifying the root element as <svg> when tagName={null}", () => {
        const handleClick: React.MouseEventHandler<SVGSVGElement> = () => undefined;
        mount(<Icon<SVGSVGElement> icon="add" onClick={handleClick} tagName={null} />);
    });

    /** Asserts that rendered icon has an SVG path. */
    async function assertIconHasPath(icon: React.ReactElement<IconProps>, iconName: IconName) {
        const wrapper = mount(icon);
        wrapper.update();
        assert.strictEqual(wrapper.text(), iconName);
        assert.isAbove(wrapper.find("path").length, 0, "should find at least one path element");
    }

    /** Asserts that rendered icon has width/height equal to size. */
    async function assertIconSize(icon: React.ReactElement<IconProps>, size: number) {
        const wrapper = mount(icon);
        wrapper.update();
        const svg = wrapper.find("svg");
        assert.strictEqual(svg.prop("width"), size);
        assert.strictEqual(svg.prop("height"), size);
    }

    /** Asserts that rendered icon has color equal to color. */
    async function assertIconColor(icon: React.ReactElement<IconProps>, color?: string) {
        const wrapper = mount(icon);
        wrapper.update();
        const svg = wrapper.find("svg");
        assert.deepEqual(svg.prop("fill"), color);
    }
});

================================================================================

File: test\menu\menuItemTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, type ReactWrapper, shallow, type ShallowWrapper } from "enzyme";
import * as React from "react";
import { spy } from "sinon";

import { dispatchTestKeyboardEvent } from "@blueprintjs/test-commons";

import {
    Button,
    Classes,
    Icon,
    MenuItem,
    type MenuItemProps,
    type MenuProps,
    Popover,
    PopoverInteractionKind,
    Text,
} from "../../src";

describe("MenuItem", () => {
    it("basic rendering", () => {
        const wrapper = shallow(<MenuItem icon="graph" text="Graph" />);
        assert.isTrue(wrapper.find(Icon).exists());
        assert.strictEqual(findText(wrapper).text(), "Graph");
    });

    it("supports HTML props", () => {
        const mouseHandler = (_event: React.MouseEvent<HTMLElement>) => false;
        const keyHandler = (_event: React.KeyboardEvent<HTMLElement>) => false;
        const item = shallow(
            <MenuItem text="text" onClick={mouseHandler} onKeyDown={keyHandler} onMouseMove={mouseHandler} />,
        ).find("a");
        assert.strictEqual(item.prop("onClick"), mouseHandler);
        assert.strictEqual(item.prop("onKeyDown"), keyHandler);
        assert.strictEqual(item.prop("onMouseMove"), mouseHandler);
    });

    it("children appear in submenu", () => {
        const wrapper = shallow(
            <MenuItem icon="style" text="Style">
                <MenuItem icon="bold" text="Bold" />
                <MenuItem icon="italic" text="Italic" />
                <MenuItem icon="underline" text="Underline" />
            </MenuItem>,
        );
        const submenu = findSubmenu(wrapper);
        assert.lengthOf(submenu.props.children, 3);
    });

    it("default role prop structure is correct for a menuitem that is a an item of a ul with role=menu", () => {
        const wrapper = mount(<MenuItem text="Roles" />);
        assert.equal(wrapper.find("li").prop("role"), "none");
        assert.equal(wrapper.find("a").prop("role"), "menuitem");
    });

    it("can set roleStructure to change role prop structure to that of a listbox or select item", () => {
        const wrapper = mount(<MenuItem text="Roles" roleStructure="listoption" />);
        assert.equal(wrapper.find("li").prop("role"), "option");
        assert.equal(wrapper.find("a").prop("role"), undefined);
    });

    it("can set roleStructure to change role prop structure to that of a list item", () => {
        const wrapper = mount(<MenuItem text="Roles" roleStructure="listitem" />);
        assert.equal(wrapper.find("li").prop("role"), undefined);
        assert.equal(wrapper.find("a").prop("role"), undefined);
    });

    it('can set roleStructure to change role prop structure to void li role (set role="none")', () => {
        const wrapper = mount(<MenuItem text="Roles" roleStructure="none" />);
        assert.equal(wrapper.find("li").prop("role"), "none");
        assert.equal(wrapper.find("a").prop("role"), undefined);
    });

    it("disabled MenuItem will not show its submenu", () => {
        const wrapper = shallow(
            <MenuItem disabled={true} icon="style" text="Style">
                <MenuItem icon="bold" text="Bold" />
                <MenuItem icon="italic" text="Italic" />
                <MenuItem icon="underline" text="Underline" />
            </MenuItem>,
        );
        assert.isTrue(wrapper.find(Popover).prop("disabled"));
    });

    it("disabled MenuItem blocks mouse listeners", () => {
        const mouseSpy = spy();
        mount(<MenuItem disabled={true} text="disabled" onClick={mouseSpy} onMouseEnter={mouseSpy} />)
            .simulate("click")
            .simulate("mouseenter")
            .simulate("click");
        assert.strictEqual(mouseSpy.callCount, 0);
    });

    it("clicking MenuItem triggers onClick prop", () => {
        const onClick = spy();
        shallow(<MenuItem text="Graph" onClick={onClick} />)
            .find("a")
            .simulate("click");
        assert.isTrue(onClick.calledOnce);
    });

    it("pressing enter on MenuItem triggers onClick prop", () => {
        const testsContainerElement = document.createElement("div");
        document.documentElement.appendChild(testsContainerElement);
        const onClick = spy();
        const wrapper = mount(<MenuItem text="Graph" onClick={onClick} />, { attachTo: testsContainerElement });
        dispatchTestKeyboardEvent(wrapper.find("a").getDOMNode(), "keydown", "Enter");
        assert.isTrue(onClick.calledOnce);
    });

    it("clicking disabled MenuItem does not trigger onClick prop", () => {
        const onClick = spy();
        shallow(<MenuItem disabled={true} text="Graph" onClick={onClick} />)
            .find("a")
            .simulate("click");
        assert.isTrue(onClick.notCalled);
    });

    it("shouldDismissPopover=false prevents a clicked MenuItem from closing the Popover automatically", () => {
        const handleClose = spy();
        const menu = <MenuItem text="Graph" shouldDismissPopover={false} />;
        const wrapper = mount(
            <Popover content={menu} isOpen={true} onInteraction={handleClose} usePortal={false}>
                <Button />
            </Popover>,
        );
        wrapper.find(MenuItem).find("a").simulate("click");
        assert.isTrue(handleClose.notCalled);
    });

    it("submenuProps are forwarded to the Menu", () => {
        const submenuProps = { "aria-label": "test-menu" };
        const wrapper = shallow(
            <MenuItem icon="style" text="Style" submenuProps={submenuProps}>
                <MenuItem text="one" />
                <MenuItem text="two" />
            </MenuItem>,
        );
        const submenu = findSubmenu(wrapper);
        assert.strictEqual(submenu.props["aria-label"], submenuProps["aria-label"]);
    });

    it("popoverProps (except content) are forwarded to Popover", () => {
        // Ensures that popover props are passed to Popover component, except content property
        const popoverProps = {
            content: "CUSTOM_CONTENT",
            interactionKind: PopoverInteractionKind.CLICK,
            popoverClassName: "CUSTOM_POPOVER_CLASS_NAME",
        };
        const wrapper = shallow(
            <MenuItem icon="style" text="Style" popoverProps={popoverProps}>
                <MenuItem text="one" />
                <MenuItem text="two" />
            </MenuItem>,
        );
        assert.strictEqual(wrapper.find(Popover).prop("interactionKind"), popoverProps.interactionKind);
        assert.notStrictEqual(
            wrapper.find(Popover).prop("popoverClassName")!.indexOf(popoverProps.popoverClassName),
            0,
        );
        assert.notStrictEqual(wrapper.find(Popover).prop("content"), popoverProps.content);
    });

    it("multiline prop determines if long content is ellipsized", () => {
        const wrapper = mount(
            <MenuItem multiline={false} text="multiline prop determines if long content is ellipsized." />,
        );
        function assertOverflow(expected: boolean) {
            assert.strictEqual(findText(wrapper).hasClass(Classes.TEXT_OVERFLOW_ELLIPSIS), expected);
        }

        assertOverflow(true);
        wrapper.setProps({ multiline: true });
        assertOverflow(false);
    });

    it(`label and labelElement are rendered in .${Classes.MENU_ITEM_LABEL}`, () => {
        const wrapper = shallow(
            <MenuItem text="text" label="label text" labelElement={<article>label element</article>} />,
        );
        const label = wrapper.find(`.${Classes.MENU_ITEM_LABEL}`);
        assert.match(label.text(), /^label text/);
        assert.strictEqual(label.find("article").text(), "label element");
    });
});

function findSubmenu(wrapper: ShallowWrapper<any, any>) {
    return wrapper.find(Popover).prop("content") as React.ReactElement<
        MenuProps & { children: Array<React.ReactElement<MenuItemProps>> }
    >;
}

function findText(wrapper: ShallowWrapper | ReactWrapper) {
    return wrapper.find(Text).children();
}

================================================================================

File: test\menu\menuTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { shallow } from "enzyme";
import * as React from "react";

import { Classes, H6, Menu, MenuDivider, MenuItem } from "../../src";

describe("<MenuDivider>", () => {
    it("React renders MenuDivider", () => {
        const divider = shallow(<MenuDivider />);
        assert.isTrue(divider.hasClass(Classes.MENU_DIVIDER));
        assert.isFalse(divider.hasClass(Classes.MENU_HEADER));
        assert.isFalse(divider.find(H6).exists());
    });

    it("React renders MenuDivider with title", () => {
        const divider = shallow(<MenuDivider title="Subject" />);
        assert.isFalse(divider.hasClass(Classes.MENU_DIVIDER));
        assert.isTrue(divider.hasClass(Classes.MENU_HEADER));
        assert.isTrue(divider.find(H6).exists());
    });
});

describe("<Menu>", () => {
    it("React renders Menu with children", () => {
        const menu = shallow(
            <Menu>
                <MenuItem icon="graph" text="Graph" />
            </Menu>,
        );
        assert.isTrue(menu.hasClass(Classes.MENU));
        assert.lengthOf(menu.find(MenuItem), 1);
    });
});

================================================================================

File: test\multistep-dialog\multistepDialogTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2020 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, type ReactWrapper } from "enzyme";
import * as React from "react";

import { dispatchTestKeyboardEvent } from "@blueprintjs/test-commons";

import { AnchorButton, Classes, DialogStep, MultistepDialog } from "../../src";

// TODO: button selectors in these tests should not be tied so closely to implementation; we shouldn't
// need to reference AnchorButton directly
const findButtonWithText = (wrapper: ReactWrapper, text: string) => wrapper.find(AnchorButton).find(`[text='${text}']`);

describe("<MultistepDialog>", () => {
    it("renders its content correctly", () => {
        const dialog = mount(
            <MultistepDialog isOpen={true} usePortal={false}>
                <DialogStep id="one" title="Step 1" panel={<Panel />} />
            </MultistepDialog>,
        );
        [
            Classes.DIALOG,
            Classes.MULTISTEP_DIALOG_PANELS,
            Classes.MULTISTEP_DIALOG_LEFT_PANEL,
            Classes.MULTISTEP_DIALOG_RIGHT_PANEL,
            Classes.DIALOG_STEP,
            Classes.DIALOG_STEP_CONTAINER,
            Classes.DIALOG_STEP_ICON,
            Classes.DIALOG_STEP_TITLE,
            Classes.DIALOG_FOOTER_ACTIONS,
        ].forEach(className => {
            assert.lengthOf(dialog.find(`.${className}`).hostNodes(), 1, `missing ${className}`);
        });
        dialog.unmount();
    });

    it("initially selected step is first step", () => {
        const dialog = mount(
            <MultistepDialog isOpen={true} usePortal={false}>
                <DialogStep id="one" title="Step 1" panel={<Panel />} />
                <DialogStep id="two" title="Step 2" panel={<Panel />} />
            </MultistepDialog>,
        );
        assert.strictEqual(dialog.state("selectedIndex"), 0);
        const steps = dialog.find(`.${Classes.DIALOG_STEP_CONTAINER}`);
        assert.strictEqual(steps.at(0).find(`.${Classes.ACTIVE}`).length, 1);
        assert.strictEqual(steps.at(1).find(`.${Classes.ACTIVE}`).length, 0);
        dialog.unmount();
    });

    it("clicking next should move to the next step", () => {
        const dialog = mount(
            <MultistepDialog isOpen={true} usePortal={false}>
                <DialogStep id="one" title="Step 1" panel={<Panel />} />
                <DialogStep id="two" title="Step 2" panel={<Panel />} />
            </MultistepDialog>,
        );
        findButtonWithText(dialog, "Next").simulate("click");
        assert.strictEqual(dialog.state("selectedIndex"), 1);
        const steps = dialog.find(`.${Classes.DIALOG_STEP_CONTAINER}`);
        assert.strictEqual(steps.at(0).find(`.${Classes.DIALOG_STEP_VIEWED}`).length, 1);
        assert.strictEqual(steps.at(1).find(`.${Classes.ACTIVE}`).length, 1);
        dialog.unmount();
    });

    it("clicking back should move to the prev step", () => {
        const dialog = mount(
            <MultistepDialog isOpen={true} usePortal={false}>
                <DialogStep id="one" title="Step 1" panel={<Panel />} />
                <DialogStep id="two" title="Step 2" panel={<Panel />} />
            </MultistepDialog>,
        );

        findButtonWithText(dialog, "Next").simulate("click");
        assert.strictEqual(dialog.state("selectedIndex"), 1);
        const steps = dialog.find(`.${Classes.DIALOG_STEP_CONTAINER}`);
        assert.strictEqual(steps.at(0).find(`.${Classes.DIALOG_STEP_VIEWED}`).length, 1);
        assert.strictEqual(steps.at(1).find(`.${Classes.ACTIVE}`).length, 1);

        findButtonWithText(dialog, "Back").simulate("click");
        const newSteps = dialog.find(`.${Classes.DIALOG_STEP_CONTAINER}`);
        assert.strictEqual(dialog.state("selectedIndex"), 0);
        assert.strictEqual(newSteps.at(0).find(`.${Classes.ACTIVE}`).length, 1);
        assert.strictEqual(newSteps.at(1).find(`.${Classes.DIALOG_STEP_VIEWED}`).length, 1);
        dialog.unmount();
    });

    it("footer on last step of multiple steps should contain back and submit buttons", () => {
        const dialog = mount(
            <MultistepDialog isOpen={true} usePortal={false}>
                <DialogStep id="one" title="Step 1" panel={<Panel />} />
                <DialogStep id="two" title="Step 2" panel={<Panel />} />
            </MultistepDialog>,
        );
        findButtonWithText(dialog, "Next").simulate("click");
        assert.strictEqual(dialog.state("selectedIndex"), 1);
        assert.strictEqual(findButtonWithText(dialog, "Back").length, 1);
        assert.strictEqual(findButtonWithText(dialog, "Next").length, 0);
        assert.strictEqual(findButtonWithText(dialog, "Submit").length, 1);
        dialog.unmount();
    });

    it("footer on first step of multiple steps should contain next button only", () => {
        const dialog = mount(
            <MultistepDialog isOpen={true} usePortal={false}>
                <DialogStep id="one" title="Step 1" panel={<Panel />} />
                <DialogStep id="two" title="Step 2" panel={<Panel />} />
            </MultistepDialog>,
        );

        assert.strictEqual(dialog.state("selectedIndex"), 0);
        assert.strictEqual(findButtonWithText(dialog, "Back").length, 0);
        assert.strictEqual(findButtonWithText(dialog, "Next").length, 1);
        assert.strictEqual(findButtonWithText(dialog, "Submit").length, 0);
        dialog.unmount();
    });

    it("footer on first step of single step should contain submit button only", () => {
        const dialog = mount(
            <MultistepDialog isOpen={true} usePortal={false}>
                <DialogStep id="one" title="Step 1" panel={<Panel />} />
            </MultistepDialog>,
        );

        assert.strictEqual(dialog.state("selectedIndex"), 0);
        assert.strictEqual(findButtonWithText(dialog, "Back").length, 0);
        assert.strictEqual(findButtonWithText(dialog, "Next").length, 0);
        assert.strictEqual(findButtonWithText(dialog, "Submit").length, 1);
        dialog.unmount();
    });

    it("selecting older step should leave already viewed steps active", () => {
        const dialog = mount(
            <MultistepDialog isOpen={true} usePortal={false}>
                <DialogStep id="one" title="Step 1" panel={<Panel />} />
                <DialogStep id="two" title="Step 2" panel={<Panel />} />
            </MultistepDialog>,
        );
        assert.strictEqual(dialog.state("selectedIndex"), 0);
        findButtonWithText(dialog, "Next").simulate("click");
        assert.strictEqual(dialog.state("selectedIndex"), 1);
        const step = dialog.find(`.${Classes.DIALOG_STEP}`);
        step.at(0).simulate("click");
        const steps = dialog.find(`.${Classes.DIALOG_STEP_CONTAINER}`);
        assert.strictEqual(dialog.state("selectedIndex"), 0);
        assert.strictEqual(steps.at(0).find(`.${Classes.ACTIVE}`).length, 1);
        assert.strictEqual(steps.at(1).find(`.${Classes.DIALOG_STEP_VIEWED}`).length, 1);
        dialog.unmount();
    });

    it("pressing enter on older step takes effect", () => {
        const testsContainerElement = document.createElement("div");
        document.documentElement.appendChild(testsContainerElement);
        const dialog = mount(
            <MultistepDialog isOpen={true} usePortal={false}>
                <DialogStep id="one" title="Step 1" panel={<Panel />} />
                <DialogStep id="two" title="Step 2" panel={<Panel />} />
            </MultistepDialog>,
            { attachTo: testsContainerElement },
        );
        assert.strictEqual(dialog.state("selectedIndex"), 0);
        findButtonWithText(dialog, "Next").simulate("click");
        assert.strictEqual(dialog.state("selectedIndex"), 1);
        const step = dialog.find(`.${Classes.DIALOG_STEP}`);
        step.at(0).simulate("focus");
        dispatchTestKeyboardEvent(step.at(0).getDOMNode(), "keydown", "Enter");
        assert.strictEqual(dialog.state("selectedIndex"), 0);
        dialog.unmount();
        testsContainerElement.remove();
    });

    it("gets by without children", () => {
        assert.doesNotThrow(() => {
            const dialog = mount(<MultistepDialog isOpen={true} />);
            dialog.unmount();
        });
    });

    it("supports non-existent children", () => {
        assert.doesNotThrow(() => {
            const dialog = mount(
                <MultistepDialog>
                    {null}
                    <DialogStep id="one" panel={<Panel />} />
                    {undefined}
                    <DialogStep id="two" panel={<Panel />} />
                </MultistepDialog>,
            );
            dialog.unmount();
        });
    });

    it("enables next by default", () => {
        const dialog = mount(
            <MultistepDialog isOpen={true} usePortal={false}>
                <DialogStep id="one" title="Step 1" panel={<Panel />} />
                <DialogStep id="two" title="Step 2" panel={<Panel />} />
            </MultistepDialog>,
        );
        assert.strictEqual(findButtonWithText(dialog, "Next").prop("disabled"), undefined);
        dialog.unmount();
    });

    it("disables next if disabled on nextButtonProps is set to true", () => {
        const dialog = mount(
            <MultistepDialog nextButtonProps={{ disabled: true }} isOpen={true} usePortal={false}>
                <DialogStep id="one" title="Step 1" panel={<Panel />} />
                <DialogStep id="two" title="Step 2" panel={<Panel />} />
            </MultistepDialog>,
        );
        assert.strictEqual(findButtonWithText(dialog, "Next").prop("disabled"), true);
        dialog.unmount();
    });

    it("disables next for second step when disabled on nextButtonProps is set to true", () => {
        const dialog = mount(
            <MultistepDialog isOpen={true} usePortal={false}>
                <DialogStep id="one" title="Step 1" panel={<Panel />} />
                <DialogStep id="two" title="Step 2" panel={<Panel />} nextButtonProps={{ disabled: true }} />
                <DialogStep id="three" title="Step 3" panel={<Panel />} />
            </MultistepDialog>,
        );

        assert.strictEqual(dialog.state("selectedIndex"), 0);
        assert.strictEqual(findButtonWithText(dialog, "Next").prop("disabled"), undefined);
        findButtonWithText(dialog, "Next").simulate("click");
        assert.strictEqual(dialog.state("selectedIndex"), 1);
        assert.strictEqual(findButtonWithText(dialog, "Next").prop("disabled"), true);
        findButtonWithText(dialog, "Next").simulate("click");
        assert.strictEqual(dialog.state("selectedIndex"), 1);
        dialog.unmount();
    });

    it("disables back for second step when disabled on backButtonProps is set to true", () => {
        const dialog = mount(
            <MultistepDialog isOpen={true} usePortal={false}>
                <DialogStep id="one" title="Step 1" panel={<Panel />} />
                <DialogStep id="two" title="Step 2" panel={<Panel />} backButtonProps={{ disabled: true }} />
                <DialogStep id="three" title="Step 3" panel={<Panel />} />
            </MultistepDialog>,
        );

        assert.strictEqual(dialog.state("selectedIndex"), 0);
        findButtonWithText(dialog, "Next").simulate("click");
        assert.strictEqual(dialog.state("selectedIndex"), 1);
        assert.strictEqual(findButtonWithText(dialog, "Back").prop("disabled"), true);
        findButtonWithText(dialog, "Back").simulate("click");
        assert.strictEqual(dialog.state("selectedIndex"), 1);
        dialog.unmount();
    });
});

const Panel: React.FC = () => <strong> panel</strong>;

================================================================================

File: test\non-ideal-state\nonIdealStateTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { shallow } from "enzyme";
import * as React from "react";

import { Classes, H4, NonIdealState } from "../../src";

describe("<NonIdealState>", () => {
    it("renders its contents", () => {
        const wrapper = shallow(
            <NonIdealState
                action={<p>More text!</p>}
                description="An error occurred."
                title="ERROR"
                icon="folder-close"
            />,
        );
        assert.exists(wrapper.find(H4), "missing H4");
        [Classes.NON_IDEAL_STATE_VISUAL, Classes.ICON_MUTED, Classes.NON_IDEAL_STATE].forEach(className => {
            assert.exists(wrapper.find(`.${className}`), `missing ${className}`);
        });
    });

    it("does not apply icon muted style", () => {
        const wrapper = shallow(<NonIdealState title="ERROR" icon="folder-close" iconMuted={false} />);
        assert.isFalse(wrapper.find(`.${Classes.ICON_MUTED}`).exists(), `unexpected ${Classes.ICON_MUTED}`);
    });

    it("ensures description is wrapped in an element", () => {
        const wrapper = shallow(<NonIdealState action={<strong />} description="foo" />);
        const div = wrapper.find(`.${Classes.NON_IDEAL_STATE_TEXT}`).children().find("div");
        assert.lengthOf(div, 1);
        assert.strictEqual(div.text(), "foo");
    });
});

================================================================================

File: test\overflow-list\overflowListTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, type ReactWrapper } from "enzyme";
import * as React from "react";
import { spy } from "sinon";

import {
    OverflowList,
    type OverflowListProps,
    type OverflowListState,
} from "../../src/components/overflow-list/overflowList";

type OverflowProps = OverflowListProps<TestItemProps>;

interface TestItemProps {
    id: number;
}

const IDS = [0, 1, 2, 3, 4, 5];
const ITEMS: TestItemProps[] = IDS.map(id => ({ id }));

const TestItem: React.FC<TestItemProps> = () => <div style={{ height: 10, width: 10, flex: "0 0 auto" }} />;
const TestOverflow: React.FC<{ items: TestItemProps[] }> = () => <div />;

describe("<OverflowList>", function (this) {
    // these tests rely on DOM measurement which can be flaky, so we allow some retries
    this.retries(3);

    const onOverflowSpy = spy();
    let testsContainerElement: HTMLElement;
    let wrapper: OverflowListWrapper;

    beforeEach(() => {
        testsContainerElement = document.createElement("div");
        document.body.appendChild(testsContainerElement);
    });

    afterEach(() => {
        // clean up wrapper to remove Portal element from DOM
        wrapper?.unmount();
        wrapper?.detach();
        testsContainerElement.remove();
        onOverflowSpy.resetHistory();
    });

    it("adds className to itself", () => {
        assert.isTrue(overflowList(30, { className: "winner" }).find(".winner").exists());
    });

    it("uses custom tagName", () => {
        assert.lengthOf(overflowList(undefined, { tagName: "section" }).find("section"), 1);
    });

    it("overflows correctly on initial mount", () => {
        overflowList().assertVisibleItemSplit(4);
    });

    it("overflows correctly on initial mount with large number of items", () => {
        overflowList(45, { items: new Array(10000).fill(0).map((_, i) => ({ id: i })) }).assertVisibleItemSplit(4);
    });

    it("shows more after growing", async () => {
        overflowList(15);
        wrapper.assertVisibleItemSplit(1);

        await wrapper.setWidth(35).waitForResize();
        wrapper.assertVisibleItemSplit(3);

        await wrapper.setWidth(200).waitForResize();
        wrapper.assertVisibleItems(...IDS);
    });

    it("shows fewer after shrinking", async () => {
        overflowList(45).assertVisibleItemSplit(4);
        await wrapper.setWidth(15).waitForResize();
        wrapper.assertVisibleItemSplit(1);
    });

    it("shows at least minVisibleItems", () => {
        overflowList(15, { minVisibleItems: 5 }).assertVisibleItemSplit(5);
    });

    it("shows more after increasing minVisibleItems", () => {
        overflowList(35, { minVisibleItems: 2 });
        wrapper.assertVisibleItemSplit(3);

        wrapper.setProps({ minVisibleItems: 5 });
        wrapper.update();
        wrapper.assertVisibleItemSplit(5);
    });

    it("does not render the overflow if all items are displayed", () => {
        overflowList(200).assertHasOverflow(false);
    });

    it("renders the overflow if not all items are displayed", () => {
        overflowList().assertHasOverflow(true);
    });

    it("should render overflow if alwaysRenderOverflow props is true", () => {
        overflowList(200, { alwaysRenderOverflow: true }).assertHasOverflow(true);
    });

    it("renders overflow items in the correct order (collapse from start)", () => {
        overflowList(45, { collapseFrom: "start" }).assertOverflowItems(0, 1);
    });

    it("renders overflow items in the correct order (collapse from end)", () => {
        overflowList(45, { collapseFrom: "end" }).assertOverflowItems(4, 5);
    });

    describe("onOverflow", () => {
        it("invoked on initial render if has overflow", async () => {
            await overflowList(22).waitForResize();
            wrapper.assertLastOnOverflowArgs([0, 1, 2, 3]);
        });

        it("not invoked on initial render if all visible", async () => {
            await overflowList(200).waitForResize();
            assert.isTrue(onOverflowSpy.notCalled, "not called");
        });

        it("invoked once per resize", async () => {
            // initial render shows all items (empty overflow)
            await overflowList(200).waitForResize();
            // assert that at given width, onOverflow receives given Ds
            const tests = [
                { width: 15, overflowIds: [0, 1, 2, 3, 4] },
                { width: 55, overflowIds: [0] },
                { width: 25, overflowIds: [0, 1, 2, 3] },
                { width: 35, overflowIds: [0, 1, 2] },
            ];
            for (const { overflowIds, width } of tests) {
                (await wrapper.setWidth(width).waitForResize()).assertLastOnOverflowArgs(overflowIds);
            }
            // ensure onOverflow is not called additional times.
            assert.equal(onOverflowSpy.callCount, tests.length, "should invoke once per resize");
        });

        it("not invoked if resize doesn't change overflow", async () => {
            // show a few items
            await overflowList(22).waitForResize();
            // small adjustments don't change overflow state, but it is recomputed internally.
            // assert that the callback was not invoked because the appearance hasn't changed.
            onOverflowSpy.resetHistory();
            await wrapper.setWidth(25).waitForResize();
            await wrapper.setWidth(28).waitForResize();
            await wrapper.setWidth(29).waitForResize();
            await wrapper.setWidth(26).waitForResize();
            await wrapper.setWidth(22).waitForResize();
            assert.isTrue(onOverflowSpy.notCalled, "should not invoke");
        });

        it("invoked when items change", async () => {
            await overflowList(22).waitForResize();
            // copy of same items so overflow state should end up the same.
            await wrapper.setProps({ items: [...ITEMS] }).waitForResize();
            assert.isTrue(onOverflowSpy.calledTwice, "should be called twice");
            const [one, two] = onOverflowSpy.args;
            assert.sameDeepMembers(one, two, "items should be the same");
        });
    });

    function renderOverflow(items: TestItemProps[]) {
        return <TestOverflow items={items} />;
    }

    function renderVisibleItem(item: TestItemProps, index: number) {
        return <TestItem key={index} {...item} />;
    }

    interface OverflowListWrapper
        extends ReactWrapper<OverflowListProps<TestItemProps>, OverflowListState<TestItemProps>> {
        assertHasOverflow(exists: boolean): OverflowListWrapper;
        assertLastOnOverflowArgs(ids: number[]): OverflowListWrapper;
        assertVisibleItemSplit(visibleCount: number): OverflowListWrapper;
        assertOverflowItems(...ids: number[]): OverflowListWrapper;
        assertVisibleItems(...ids: number[]): OverflowListWrapper;
        // setProps<K extends keyof OverflowProps>(newProps: Pick<OverflowProps, K>): OverflowListWrapper;
        setWidth(width: number): OverflowListWrapper;
        waitForResize(): Promise<OverflowListWrapper>;
    }

    function overflowList(initialWidth = 45, props: Partial<OverflowProps> = {}) {
        wrapper = mount<OverflowProps, OverflowListState<TestItemProps>>(
            <OverflowList
                items={ITEMS}
                onOverflow={onOverflowSpy}
                overflowRenderer={renderOverflow}
                visibleItemRenderer={renderVisibleItem}
                style={{ height: 10, width: initialWidth }}
                {...props}
            />,
            // measuring elements only works in the DOM, so this element actually needs to be attached
            { attachTo: testsContainerElement },
        ) as OverflowListWrapper;
        wrapper = wrapper.update();

        wrapper.assertHasOverflow = (exists: boolean) => {
            assert.equal(wrapper.find(TestOverflow).exists(), exists, "has overflow");
            return wrapper;
        };

        /** Asserts that the last call to `onOverflow` received the given item Ds. */
        wrapper.assertLastOnOverflowArgs = (ids: number[]) => {
            assert.sameMembers(
                onOverflowSpy.lastCall.args[0].map((i: TestItemProps) => i.id),
                ids,
            );
            return wrapper;
        };

        /**
         * Invokes both assertions below with the expected visible and
         * overflow Dsassuming `collapseFrom="start"`.
         */
        wrapper.assertVisibleItemSplit = (visibleCount: number) => {
            const ids = (props.items ?? ITEMS).map(it => it.id);
            return wrapper
                .assertOverflowItems(...ids.slice(0, -visibleCount))
                .assertVisibleItems(...ids.slice(-visibleCount));
        };

        /** Assert ordered Dsof overflow items. */
        wrapper.assertOverflowItems = (...ids: number[]) => {
            const overflowItems = wrapper.find(TestOverflow).prop("items");
            assert.sameMembers(
                overflowItems.map(it => it.id),
                ids,
                "overflow items",
            );
            return wrapper;
        };

        /** Assert ordered Dsof visible items. */
        wrapper.assertVisibleItems = (...ids: number[]) => {
            const visibleItems = wrapper.find(TestItem).map(div => div.prop("id"));
            assert.sameMembers(visibleItems, ids, "visible items");
            return wrapper;
        };

        wrapper.setWidth = (width: number) => {
            return wrapper.setProps({ style: { width } });
        };

        /** Promise that resolves after DOM has a chance to settle. */
        wrapper.waitForResize = async () => {
            return new Promise<OverflowListWrapper>(resolve =>
                setTimeout(() => {
                    wrapper.update();
                    resolve(wrapper);
                }, 30),
            );
        };

        return wrapper;
    }
});

================================================================================

File: test\overlay\overlayTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview This component is DEPRECATED, and the code is frozen.
 * All changes & bugfixes should be made to Overlay2 instead.
 */

/* eslint-disable deprecation/deprecation, @blueprintjs/no-deprecated-components */

import { assert } from "chai";
import { mount, type ReactWrapper, shallow } from "enzyme";
import * as React from "react";
import { spy } from "sinon";

import { dispatchMouseEvent } from "@blueprintjs/test-commons";

import { Classes, Overlay, type OverlayProps, Portal, Utils } from "../../src";
import { findInPortal } from "../utils";

const BACKDROP_SELECTOR = `.${Classes.OVERLAY_BACKDROP}`;

/*
IMPORTANT NOTE: It is critical that every <Overlay> wrapper be unmounted after the test, to avoid
polluting the DOM with leftover overlay elements. This was the cause of the Overlay test flakes of
late 2017/early 2018 and was resolved by ensuring that every wrapper is unmounted.

The `wrapper` variable below and the `mountWrapper` method should be used for full enzyme mounts.
For shallow mounts, be sure to call `shallowWrapper.unmount()` after the assertions.
*/
describe("<Overlay>", () => {
    let wrapper: ReactWrapper<OverlayProps, any>;
    let isMounted = false;
    const testsContainerElement = document.createElement("div");
    document.documentElement.appendChild(testsContainerElement);

    /**
     * Mount the `content` into `testsContainerElement` and assign to local `wrapper` variable.
     * Use this method in this suite instead of Enzyme's `mount` method.
     */
    function mountWrapper(content: React.JSX.Element) {
        wrapper = mount(content, { attachTo: testsContainerElement });
        isMounted = true;
        return wrapper;
    }

    afterEach(() => {
        if (isMounted) {
            // clean up wrapper after each test, if it was used
            wrapper?.unmount();
            wrapper?.detach();
            isMounted = false;
        }
    });

    after(() => {
        document.documentElement.removeChild(testsContainerElement);
    });

    it("renders its content correctly", () => {
        const overlay = shallow(
            <Overlay isOpen={true} usePortal={false}>
                {createOverlayContents()}
            </Overlay>,
        );
        assert.lengthOf(overlay.find("strong"), 1);
        assert.lengthOf(overlay.find(BACKDROP_SELECTOR), 1);
        overlay.unmount();
    });

    it("renders contents to specified container correctly", () => {
        const CLASS_TO_TEST = "bp-test-content";
        const container = document.createElement("div");
        document.body.appendChild(container);
        mountWrapper(
            <Overlay isOpen={true} portalContainer={container}>
                <p className={CLASS_TO_TEST}>test</p>
            </Overlay>,
        );
        assert.lengthOf(container.getElementsByClassName(CLASS_TO_TEST), 1);
        document.body.removeChild(container);
    });

    it("sets aria-live", () => {
        // Using an open Overlay because an initially closed Overlay will not render anything to the
        // DOM
        mountWrapper(<Overlay className="aria-test" isOpen={true} usePortal={false} />);
        const overlayElement = document.querySelector(".aria-test");
        assert.exists(overlayElement);
        // Element#ariaLive not supported in Firefox or IE
        assert.equal(overlayElement?.getAttribute("aria-live"), "polite");
    });

    it("portalClassName appears on Portal", () => {
        const CLASS_TO_TEST = "bp-test-content";
        mountWrapper(
            <Overlay isOpen={true} portalClassName={CLASS_TO_TEST}>
                <p>test</p>
            </Overlay>,
        );
        // search document for portal container element.
        assert.isDefined(document.querySelector(`.${Classes.PORTAL}.${CLASS_TO_TEST}`));
    });

    it("renders Portal after first opened", () => {
        mountWrapper(<Overlay isOpen={false}>{createOverlayContents()}</Overlay>);
        assert.lengthOf(wrapper.find(Portal), 0, "unexpected Portal");
        wrapper.setProps({ isOpen: true });
        assert.lengthOf(wrapper.find(Portal), 1, "expected Portal");
    });

    it("supports non-element children", () => {
        assert.doesNotThrow(() =>
            shallow(
                <Overlay isOpen={true} usePortal={false}>
                    {null} {undefined}
                </Overlay>,
            ).unmount(),
        );
    });

    it("hasBackdrop=false does not render backdrop", () => {
        const overlay = shallow(
            <Overlay hasBackdrop={false} isOpen={true} usePortal={false}>
                {createOverlayContents()}
            </Overlay>,
        );
        assert.lengthOf(overlay.find("strong"), 1);
        assert.lengthOf(overlay.find(BACKDROP_SELECTOR), 0);
        overlay.unmount();
    });

    it("renders portal attached to body when not inline after first opened", () => {
        mountWrapper(<Overlay isOpen={false}>{createOverlayContents()}</Overlay>);
        assert.lengthOf(wrapper.find(Portal), 0, "unexpected Portal");
        wrapper.setProps({ isOpen: true });
        assert.lengthOf(wrapper.find(Portal), 1, "expected Portal");
    });

    describe("onClose", () => {
        it("invoked on backdrop mousedown when canOutsideClickClose=true", () => {
            const onClose = spy();
            const overlay = shallow(
                <Overlay canOutsideClickClose={true} isOpen={true} onClose={onClose} usePortal={false}>
                    {createOverlayContents()}
                </Overlay>,
            );
            overlay.find(BACKDROP_SELECTOR).simulate("mousedown");
            assert.isTrue(onClose.calledOnce);
            overlay.unmount();
        });

        it("not invoked on backdrop mousedown when canOutsideClickClose=false", () => {
            const onClose = spy();
            const overlay = shallow(
                <Overlay canOutsideClickClose={false} isOpen={true} onClose={onClose} usePortal={false}>
                    {createOverlayContents()}
                </Overlay>,
            );
            overlay.find(BACKDROP_SELECTOR).simulate("mousedown");
            assert.isTrue(onClose.notCalled);
            overlay.unmount();
        });

        it("invoked on document mousedown when hasBackdrop=false", () => {
            const onClose = spy();
            // mounting cuz we need document events + lifecycle
            mountWrapper(
                <Overlay hasBackdrop={false} isOpen={true} onClose={onClose} usePortal={false}>
                    {createOverlayContents()}
                </Overlay>,
            );

            dispatchMouseEvent(document.documentElement, "mousedown");
            assert.isTrue(onClose.calledOnce);
        });

        it("not invoked on document mousedown when hasBackdrop=false and canOutsideClickClose=false", () => {
            const onClose = spy();
            mountWrapper(
                <Overlay
                    canOutsideClickClose={false}
                    hasBackdrop={false}
                    isOpen={true}
                    onClose={onClose}
                    usePortal={false}
                >
                    {createOverlayContents()}
                </Overlay>,
            );

            dispatchMouseEvent(document.documentElement, "mousedown");
            assert.isTrue(onClose.notCalled);
        });

        it("not invoked on click of a nested overlay", () => {
            const onClose = spy();
            mountWrapper(
                <Overlay isOpen={true} onClose={onClose}>
                    <div id="outer-element">
                        {createOverlayContents()}
                        <Overlay isOpen={true}>
                            <div id="inner-element">{createOverlayContents()}</div>
                        </Overlay>
                    </div>
                </Overlay>,
            );
            // this hackery is necessary for React 15 support, where Portals break trees.
            findInPortal(findInPortal(wrapper, "#outer-element"), "#inner-element").simulate("mousedown");
            assert.isTrue(onClose.notCalled);
        });

        it("invoked on escape key", () => {
            const onClose = spy();
            mountWrapper(
                <Overlay isOpen={true} onClose={onClose} usePortal={false}>
                    {createOverlayContents()}
                </Overlay>,
            );
            wrapper.simulate("keydown", { key: "Escape" });
            assert.isTrue(onClose.calledOnce);
        });

        it("not invoked on escape key when canEscapeKeyClose=false", () => {
            const onClose = spy();
            const overlay = shallow(
                <Overlay canEscapeKeyClose={false} isOpen={true} onClose={onClose} usePortal={false}>
                    {createOverlayContents()}
                </Overlay>,
            );
            overlay.simulate("keydown", { key: "Escape" });
            assert.isTrue(onClose.notCalled);
            overlay.unmount();
        });

        it("renders portal attached to body when not inline", () => {
            const overlay = shallow(
                <Overlay isOpen={true} usePortal={true}>
                    {createOverlayContents()}
                </Overlay>,
            );
            const portal = overlay.find(Portal);
            assert.isTrue(portal.exists(), "missing Portal");
            assert.lengthOf(portal.find("strong"), 1, "missing h1");
            overlay.unmount();
        });
    });

    describe("Focus management", () => {
        const overlayClassName = "test-overlay";

        it("brings focus to overlay if autoFocus=true", done => {
            mountWrapper(
                <Overlay className={overlayClassName} autoFocus={true} isOpen={true} usePortal={true}>
                    <input type="text" />
                </Overlay>,
            );
            assertFocusIsInOverlayWithTimeout(done);
        });

        it("does not bring focus to overlay if autoFocus=false and enforceFocus=false", done => {
            mountWrapper(
                <div>
                    <button>something outside overlay for browser to focus on</button>
                    <Overlay
                        className={overlayClassName}
                        autoFocus={false}
                        enforceFocus={false}
                        isOpen={true}
                        usePortal={true}
                    >
                        <input type="text" />
                    </Overlay>
                </div>,
            );
            assertFocusWithTimeout("body", done);
        });

        // React implements autoFocus itself so our `[autofocus]` logic never fires.
        // Still, worth testing we can control where the focus goes.
        it("autoFocus element inside overlay gets the focus", done => {
            mountWrapper(
                <Overlay className={overlayClassName} isOpen={true} usePortal={true}>
                    <input autoFocus={true} type="text" />
                </Overlay>,
            );
            assertFocusWithTimeout("input", done);
        });

        it("returns focus to overlay if enforceFocus=true", done => {
            const buttonRef = React.createRef<HTMLButtonElement>();
            const inputRef = React.createRef<HTMLInputElement>();
            mountWrapper(
                <div>
                    <button ref={buttonRef} />
                    <Overlay className={overlayClassName} enforceFocus={true} isOpen={true} usePortal={true}>
                        <input autoFocus={true} ref={inputRef} />
                    </Overlay>
                </div>,
            );
            assert.strictEqual(document.activeElement, inputRef.current);
            buttonRef.current?.focus();
            assertFocusIsInOverlayWithTimeout(done);
        });

        it("returns focus to overlay after clicking the backdrop if enforceFocus=true", done => {
            mountWrapper(
                <Overlay
                    className={overlayClassName}
                    enforceFocus={true}
                    canOutsideClickClose={false}
                    isOpen={true}
                    usePortal={false}
                >
                    {createOverlayContents()}
                </Overlay>,
            );
            wrapper.find(BACKDROP_SELECTOR).simulate("mousedown");
            assertFocusIsInOverlayWithTimeout(done);
        });

        it("returns focus to overlay after clicking an outside element if enforceFocus=true", done => {
            mountWrapper(
                <div>
                    <Overlay
                        enforceFocus={true}
                        canOutsideClickClose={false}
                        className={overlayClassName}
                        isOpen={true}
                        usePortal={false}
                        hasBackdrop={false}
                    >
                        {createOverlayContents()}
                    </Overlay>
                    <button id="buttonId" />
                </div>,
            );
            wrapper.find("#buttonId").simulate("click");
            assertFocusIsInOverlayWithTimeout(done);
        });

        it("does not result in maximum call stack if two overlays open with enforceFocus=true", () => {
            const anotherContainer = document.createElement("div");
            document.documentElement.appendChild(anotherContainer);
            const temporaryWrapper = mount(
                <Overlay className={overlayClassName} enforceFocus={true} isOpen={true} usePortal={false}>
                    <input type="text" />
                </Overlay>,
                { attachTo: anotherContainer },
            );

            mountWrapper(
                <Overlay className={overlayClassName} enforceFocus={true} isOpen={false} usePortal={false}>
                    <input id="inputId" type="text" />
                </Overlay>,
            );
            // ES6 class property vs prototype, see: https://github.com/airbnb/enzyme/issues/365
            const bringFocusSpy = spy(wrapper.instance() as Overlay, "bringFocusInsideOverlay");
            wrapper.setProps({ isOpen: true });

            // triggers the infinite recursion
            wrapper.find("#inputId").simulate("click");
            assert.isTrue(bringFocusSpy.calledOnce);

            // don't need spy.restore() since the wrapper will be destroyed after test anyways
            temporaryWrapper.unmount();
            document.documentElement.removeChild(anotherContainer);
        });

        it("does not return focus to overlay if enforceFocus=false", done => {
            let buttonRef: HTMLElement | null;
            const focusBtnAndAssert = () => {
                buttonRef?.focus();
                assert.strictEqual(buttonRef, document.activeElement);
                done();
            };

            mountWrapper(
                <div>
                    <button ref={ref => (buttonRef = ref)} />
                    <Overlay className={overlayClassName} enforceFocus={false} isOpen={true} usePortal={true}>
                        <input ref={ref => ref && setTimeout(focusBtnAndAssert)} />
                    </Overlay>
                </div>,
            );
        });

        it("doesn't focus overlay if focus is already inside overlay", done => {
            let textarea: HTMLTextAreaElement | null;
            mountWrapper(
                <Overlay className={overlayClassName} isOpen={true} usePortal={true}>
                    <textarea ref={ref => (textarea = ref)} />
                </Overlay>,
            );
            textarea!.focus();
            assertFocusWithTimeout("textarea", done);
        });

        it("does not focus overlay when closed", done => {
            mountWrapper(
                <div>
                    <button ref={ref => ref && ref.focus()} />
                    <Overlay className={overlayClassName} isOpen={false} usePortal={true} />
                </div>,
            );
            assertFocusWithTimeout("button", done);
        });

        it("does not crash while trying to return focus to overlay if user clicks outside the document", () => {
            mountWrapper(
                <Overlay
                    className={overlayClassName}
                    enforceFocus={true}
                    canOutsideClickClose={false}
                    isOpen={true}
                    usePortal={false}
                >
                    {createOverlayContents()}
                </Overlay>,
            );

            // this is a fairly custom / nonstandard event dispatch, trying to simulate what happens in some browsers when a user clicks
            // on the browser toolbar (outside the document), but a focus event is still dispatched to document
            // see https://github.com/palantir/blueprint/issues/3928
            const event = new FocusEvent("focus");
            Object.defineProperty(event, "target", { value: window });

            try {
                document.dispatchEvent(event);
            } catch (e) {
                assert.fail("threw uncaught error");
            }
        });

        function assertFocusWithTimeout(selector: string | (() => void), done: Mocha.Done) {
            // the behavior being tested relies on requestAnimationFrame.
            // setTimeout for a few frames later to let things settle (to reduce flakes).
            setTimeout(() => {
                wrapper.update();
                if (Utils.isFunction(selector)) {
                    selector();
                } else {
                    assert.strictEqual(document.querySelector(selector), document.activeElement);
                }
                done();
            }, 40);
        }

        function assertFocusIsInOverlayWithTimeout(done: Mocha.Done) {
            assertFocusWithTimeout(() => {
                const overlayElement = document.querySelector(`.${overlayClassName}`);
                assert.isTrue(overlayElement?.contains(document.activeElement));
            }, done);
        }
    });

    describe("Background scrolling", () => {
        beforeEach(() => {
            // force-reset Overlay stack state between tests
            (Overlay as any).openStack = [];
            document.body.classList.remove(Classes.OVERLAY_OPEN);
        });

        it("disables document scrolling by default", done => {
            wrapper = mountWrapper(renderBackdropOverlay());
            assertBodyScrollingDisabled(true, done);
        });

        it("disables document scrolling if hasBackdrop=true and usePortal=true", done => {
            wrapper = mountWrapper(renderBackdropOverlay(true, true));
            assertBodyScrollingDisabled(true, done);
        });

        it("does not disable document scrolling if hasBackdrop=true and usePortal=false", done => {
            wrapper = mountWrapper(renderBackdropOverlay(true, false));
            assertBodyScrollingDisabled(false, done);
        });

        it("does not disable document scrolling if hasBackdrop=false and usePortal=true", done => {
            wrapper = mountWrapper(renderBackdropOverlay(false, true));
            assertBodyScrollingDisabled(false, done);
        });

        it("does not disable document scrolling if hasBackdrop=false and usePortal=false", done => {
            wrapper = mountWrapper(renderBackdropOverlay(false, false));
            assertBodyScrollingDisabled(false, done);
        });

        it("keeps scrolling disabled if hasBackdrop=true overlay exists following unmount", done => {
            const backdropOverlay = mount(renderBackdropOverlay(true));
            wrapper = mountWrapper(renderBackdropOverlay(true));
            backdropOverlay.unmount();

            assertBodyScrollingDisabled(true, done);
        });

        it("doesn't keep scrolling disabled if no hasBackdrop=true overlay exists following unmount", done => {
            const backdropOverlay = mount(renderBackdropOverlay(true));
            wrapper = mountWrapper(renderBackdropOverlay(false));
            backdropOverlay.unmount();

            assertBodyScrollingDisabled(false, done);
        });

        function renderBackdropOverlay(hasBackdrop?: boolean, usePortal?: boolean) {
            return (
                <Overlay hasBackdrop={hasBackdrop} isOpen={true} usePortal={usePortal}>
                    <div>Some overlay content</div>
                </Overlay>
            );
        }

        function assertBodyScrollingDisabled(disabled: boolean, done: Mocha.Done) {
            // wait for the DOM to settle before checking body classes
            setTimeout(() => {
                const hasClass = document.body.classList.contains(Classes.OVERLAY_OPEN);
                assert.equal(hasClass, disabled);
                done();
            });
        }
    });

    it("lifecycle methods called as expected", done => {
        // these lifecycles are passed directly to CSSTransition from react-transition-group
        // so we do not need to test these extensively. one integration test should do.
        const onClosed = spy();
        const onClosing = spy();
        const onOpened = spy();
        const onOpening = spy();
        wrapper = mountWrapper(
            <Overlay
                {...{ onClosed, onClosing, onOpened, onOpening }}
                isOpen={true}
                usePortal={false}
                // transition duration shorter than timeout below to ensure it's done
                transitionDuration={8}
            >
                {createOverlayContents()}
            </Overlay>,
        );
        assert.isTrue(onOpening.calledOnce, "onOpening");
        assert.isFalse(onOpened.calledOnce, "onOpened not called yet");

        setTimeout(() => {
            // on*ed called after transition completes
            assert.isTrue(onOpened.calledOnce, "onOpened");

            wrapper.setProps({ isOpen: false });
            // on*ing called immediately when prop changes
            assert.isTrue(onClosing.calledOnce, "onClosing");
            assert.isFalse(onClosed.calledOnce, "onClosed not called yet");

            setTimeout(() => {
                assert.isTrue(onClosed.calledOnce, "onOpened");
                done();
            }, 10);
        }, 10);
    });

    let index = 0;
    function createOverlayContents() {
        return (
            <strong id={`overlay-${index++}`} tabIndex={0}>
                Overlay content!
            </strong>
        );
    }
});

================================================================================

File: test\overlay2\overlay2-test-debugging.scss
--------------------------------------------------------------------------------
// Copyright 2024 Palantir Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0.

@import "@blueprintjs/colors/lib/scss/colors";
@import "@blueprintjs/core/src/common/variables";

body {
  min-width: 500px;
  min-height: 500px;
}

================================================================================

File: test\overlay2\overlay2Tests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, type ReactWrapper } from "enzyme";
import * as React from "react";
import { spy } from "sinon";

import { dispatchMouseEvent } from "@blueprintjs/test-commons";

import {
    Classes,
    Overlay2,
    type Overlay2Props,
    type OverlayInstance,
    OverlaysProvider,
    Portal,
    Utils,
} from "../../src";
import { findInPortal } from "../utils";

import "./overlay2-test-debugging.scss";

const BACKDROP_SELECTOR = `.${Classes.OVERLAY_BACKDROP}`;

/**
 * Testable `<Overlay2>` wrapper harness which includes the necessary context providers.
 */
function OverlayWrapper(props: Overlay2Props) {
    return (
        <OverlaysProvider>
            <Overlay2 transitionDuration={0} {...props} />
        </OverlaysProvider>
    );
}

interface MultipleOverlaysWrapperProps {
    first: Overlay2Props;
    second: Overlay2Props;
}

function MultipleOverlaysWrapper(props: MultipleOverlaysWrapperProps) {
    return (
        <OverlaysProvider>
            <Overlay2 transitionDuration={0} {...props.first} />
            <Overlay2 transitionDuration={0} {...props.second} />
        </OverlaysProvider>
    );
}

/*
 * IMPORTANT NOTE: It is critical that every <Overlay2> wrapper be unmounted after the test, to avoid
 * polluting the DOM with leftover overlay elements. This was the cause of the Overlay test flakes of
 * late 2017/early 2018 and was resolved by ensuring that every wrapper is unmounted.
 *
 * The `wrapper` variable below and the `mountWrapper` method should be used for full enzyme mounts.
 * For shallow mounts, be sure to call `shallowWrapper.unmount()` after the assertions.
 */
describe("<Overlay2>", () => {
    let wrapper: ReactWrapper<Overlay2Props, any>;
    let isWrapperMounted = false;
    const testsContainerElement = document.createElement("div");
    document.documentElement.appendChild(testsContainerElement);

    /**
     * Mount the `content` into `testsContainerElement` and assign to local `wrapper` variable.
     * Use this method in this suite instead of Enzyme's `mount` method.
     */
    function mountWrapper<T = Overlay2Props>(content: React.JSX.Element): ReactWrapper<T, any> {
        wrapper = mount(content, { attachTo: testsContainerElement });
        isWrapperMounted = true;
        return wrapper as unknown as ReactWrapper<T, any>;
    }

    afterEach(() => {
        if (isWrapperMounted) {
            // clean up wrapper after each test, if it was used
            wrapper?.unmount();
            wrapper?.detach();
            isWrapperMounted = false;
        }
    });

    after(() => {
        document.documentElement.removeChild(testsContainerElement);
    });

    it("renders its content correctly", () => {
        const overlay = mountWrapper(
            <OverlayWrapper isOpen={true} usePortal={false}>
                {createOverlayContents()}
            </OverlayWrapper>,
        );
        assert.lengthOf(overlay.find("strong"), 1);
        assert.lengthOf(overlay.find(BACKDROP_SELECTOR), 1);
    });

    it("renders contents to specified container correctly", () => {
        const CLASS_TO_TEST = "bp-test-content";
        const container = document.createElement("div");
        document.body.appendChild(container);
        mountWrapper(
            <OverlayWrapper isOpen={true} portalContainer={container}>
                <p className={CLASS_TO_TEST}>test</p>
            </OverlayWrapper>,
        );
        assert.lengthOf(container.getElementsByClassName(CLASS_TO_TEST), 1);
        document.body.removeChild(container);
    });

    it("sets aria-live", () => {
        // Using an open Overlay2 because an initially closed Overlay2 will not render anything to the
        // DOM
        mountWrapper(<OverlayWrapper className="aria-test" isOpen={true} usePortal={false} />);
        const overlayElement = document.querySelector(".aria-test");
        assert.exists(overlayElement);
        // Element#ariaLive not supported in Firefox or IE
        assert.equal(overlayElement?.getAttribute("aria-live"), "polite");
    });

    it("portalClassName appears on Portal", () => {
        const CLASS_TO_TEST = "bp-test-content";
        mountWrapper(
            <OverlayWrapper isOpen={true} portalClassName={CLASS_TO_TEST}>
                <p>test</p>
            </OverlayWrapper>,
        );
        // search document for portal container element.
        assert.isDefined(document.querySelector(`.${Classes.PORTAL}.${CLASS_TO_TEST}`));
    });

    it("renders Portal after first opened", () => {
        mountWrapper(<OverlayWrapper isOpen={false}>{createOverlayContents()}</OverlayWrapper>);
        assert.lengthOf(wrapper.find(Portal), 0, "unexpected Portal");
        wrapper.setProps({ isOpen: true }).update();
        assert.lengthOf(wrapper.find(Portal), 1, "expected Portal");
    });

    it("supports non-element children", () => {
        assert.doesNotThrow(() => {
            mountWrapper(
                <OverlayWrapper isOpen={true} usePortal={false}>
                    {null} {undefined}
                </OverlayWrapper>,
            );
        });
    });

    it("hasBackdrop=false does not render backdrop", () => {
        const overlay = mountWrapper(
            <OverlayWrapper hasBackdrop={false} isOpen={true} usePortal={false}>
                {createOverlayContents()}
            </OverlayWrapper>,
        );
        assert.lengthOf(overlay.find("strong"), 1);
        assert.lengthOf(overlay.find(BACKDROP_SELECTOR), 0);
    });

    it("renders portal attached to body when not inline after first opened", () => {
        mountWrapper(<OverlayWrapper isOpen={false}>{createOverlayContents()}</OverlayWrapper>);
        assert.lengthOf(wrapper.find(Portal), 0, "unexpected Portal");
        wrapper.setProps({ isOpen: true }).update();
        assert.lengthOf(wrapper.find(Portal), 1, "expected Portal");
    });

    describe("onClose", () => {
        it("invoked on backdrop mousedown when canOutsideClickClose=true", () => {
            const onClose = spy();
            const overlay = mountWrapper(
                <OverlayWrapper canOutsideClickClose={true} isOpen={true} onClose={onClose} usePortal={false}>
                    {createOverlayContents()}
                </OverlayWrapper>,
            );

            // ensure onClose can be updated
            const onClose2 = spy();
            overlay.setProps({ onClose: onClose2 });
            overlay.find(BACKDROP_SELECTOR).simulate("mousedown");
            assert.isTrue(onClose.notCalled);
            assert.isTrue(onClose2.calledOnce);
        });

        it("not invoked on backdrop mousedown when canOutsideClickClose=false", () => {
            const onClose = spy();
            const overlay = mountWrapper(
                <OverlayWrapper canOutsideClickClose={false} isOpen={true} onClose={onClose} usePortal={false}>
                    {createOverlayContents()}
                </OverlayWrapper>,
            );
            overlay.find(BACKDROP_SELECTOR).simulate("mousedown");
            assert.isTrue(onClose.notCalled);
        });

        it("invoked on document mousedown when hasBackdrop=false", () => {
            const onClose = spy();
            const overlay = mountWrapper(
                <OverlayWrapper isOpen={true} onClose={onClose} usePortal={false} hasBackdrop={false}>
                    {createOverlayContents()}
                </OverlayWrapper>,
            );

            // ensure onClose can be updated
            const onClose2 = spy();
            overlay.setProps({ onClose: onClose2 });
            dispatchMouseEvent(document.documentElement, "mousedown");
            assert.isTrue(onClose.notCalled);
            assert.isTrue(onClose2.calledOnce);
        });

        it("not invoked on document mousedown when hasBackdrop=false and canOutsideClickClose=false", () => {
            const onClose = spy();
            mountWrapper(
                <OverlayWrapper
                    canOutsideClickClose={false}
                    hasBackdrop={false}
                    isOpen={true}
                    onClose={onClose}
                    usePortal={false}
                >
                    {createOverlayContents()}
                </OverlayWrapper>,
            );

            dispatchMouseEvent(document.documentElement, "mousedown");
            assert.isTrue(onClose.notCalled);
        });

        it("not invoked on click of a nested overlay", () => {
            const onClose = spy();
            mountWrapper(
                <OverlayWrapper isOpen={true} onClose={onClose}>
                    <div id="outer-element">
                        {createOverlayContents()}
                        <OverlayWrapper isOpen={true}>
                            <div id="inner-element">{createOverlayContents()}</div>
                        </OverlayWrapper>
                    </div>
                </OverlayWrapper>,
            );
            // this hackery is necessary for React 15 support, where Portals break trees.
            findInPortal(findInPortal(wrapper, "#outer-element"), "#inner-element").simulate("mousedown");
            assert.isTrue(onClose.notCalled);
        });

        it("invoked on escape key", () => {
            const onClose = spy();
            const overlay = mountWrapper(
                <OverlayWrapper isOpen={true} onClose={onClose} usePortal={false}>
                    {createOverlayContents()}
                </OverlayWrapper>,
            );

            // ensure onClose can be updated
            const onClose2 = spy();
            overlay.setProps({ onClose: onClose2 });
            wrapper.simulate("keydown", { key: "Escape" });
            assert.isTrue(onClose.notCalled);
            assert.isTrue(onClose2.calledOnce);
        });

        it("not invoked on escape key when canEscapeKeyClose=false", () => {
            const onClose = spy();
            const overlay = mountWrapper(
                <OverlayWrapper canEscapeKeyClose={false} isOpen={true} onClose={onClose} usePortal={false}>
                    {createOverlayContents()}
                </OverlayWrapper>,
            );
            overlay.simulate("keydown", { key: "Escape" });
            assert.isTrue(onClose.notCalled);
        });

        it("renders portal attached to body when not inline", () => {
            const overlay = mountWrapper(
                <OverlayWrapper isOpen={true} usePortal={true}>
                    {createOverlayContents()}
                </OverlayWrapper>,
            );
            const portal = overlay.find(Portal);
            assert.isTrue(portal.exists(), "missing Portal");
            assert.lengthOf(portal.find("strong"), 1, "missing h1");
        });
    });

    describe("Focus management", () => {
        const overlayClassName = "test-overlay";

        it("brings focus to overlay if autoFocus=true", done => {
            mountWrapper(
                <OverlayWrapper className={overlayClassName} autoFocus={true} isOpen={true} usePortal={true}>
                    <input type="text" />
                </OverlayWrapper>,
            );
            assertFocusIsInOverlayWithTimeout(done);
        });

        it("does not bring focus to overlay if autoFocus=false and enforceFocus=false", done => {
            mountWrapper(
                <div>
                    <button>something outside overlay for browser to focus on</button>
                    <OverlayWrapper
                        className={overlayClassName}
                        autoFocus={false}
                        enforceFocus={false}
                        isOpen={true}
                        usePortal={true}
                    >
                        <input type="text" />
                    </OverlayWrapper>
                </div>,
            );
            assertFocusWithTimeout("body", done);
        });

        // React implements autoFocus itself so our `[autofocus]` logic never fires.
        // Still, worth testing we can control where the focus goes.
        it("autoFocus element inside overlay gets the focus", done => {
            mountWrapper(
                <OverlayWrapper className={overlayClassName} isOpen={true} usePortal={true}>
                    <input autoFocus={true} type="text" />
                </OverlayWrapper>,
            );
            assertFocusWithTimeout("input", done);
        });

        it("returns focus to overlay if enforceFocus=true", done => {
            const buttonRef = React.createRef<HTMLButtonElement>();
            const inputRef = React.createRef<HTMLInputElement>();
            mountWrapper(
                <div>
                    <button ref={buttonRef} />
                    <OverlayWrapper className={overlayClassName} enforceFocus={true} isOpen={true} usePortal={true}>
                        <div>
                            <input autoFocus={true} ref={inputRef} />
                        </div>
                    </OverlayWrapper>
                </div>,
            );
            assert.strictEqual(document.activeElement, inputRef.current);
            buttonRef.current?.focus();
            assertFocusIsInOverlayWithTimeout(done);
        });

        it("returns focus to overlay after clicking the backdrop if enforceFocus=true", done => {
            mountWrapper(
                <OverlayWrapper
                    className={overlayClassName}
                    enforceFocus={true}
                    canOutsideClickClose={false}
                    isOpen={true}
                    usePortal={false}
                >
                    {createOverlayContents()}
                </OverlayWrapper>,
            );
            wrapper.find(BACKDROP_SELECTOR).simulate("mousedown");
            assertFocusIsInOverlayWithTimeout(done);
        });

        it("returns focus to overlay after clicking an outside element if enforceFocus=true", done => {
            mountWrapper(
                <div>
                    <OverlayWrapper
                        enforceFocus={true}
                        canOutsideClickClose={false}
                        className={overlayClassName}
                        isOpen={true}
                        usePortal={false}
                        hasBackdrop={false}
                    >
                        {createOverlayContents()}
                    </OverlayWrapper>
                    <button id="buttonId" />
                </div>,
            );
            wrapper.find("#buttonId").simulate("click");
            assertFocusIsInOverlayWithTimeout(done);
        });

        it("does not result in maximum call stack if two overlays open with enforceFocus=true", () => {
            const firstOverlayInstance = React.createRef<OverlayInstance>();
            const secondOverlayInputID = "inputId";

            const firstOverlay = {
                children: <input type="text" />,
                className: overlayClassName,
                isOpen: true,
                ref: firstOverlayInstance,
                usePortal: false,
            };
            const secondOverlay = {
                children: <input id={secondOverlayInputID} type="text" />,
                className: overlayClassName,
                isOpen: false,
                usePortal: false,
            };
            const multipleWrapper = mount(<MultipleOverlaysWrapper first={firstOverlay} second={secondOverlay} />, {
                attachTo: testsContainerElement,
            });

            assert.isNotNull(firstOverlayInstance.current, "ref should be set");

            // open the second overlay
            multipleWrapper.setProps({ second: { ...secondOverlay, isOpen: true } }).update();

            const secondOverlayInputElement = multipleWrapper.find(`#${secondOverlayInputID}`);
            assert.isNotNull(
                secondOverlayInputElement,
                `<input id="${secondOverlayInputID}"> in second overlay should be found in DOM`,
            );

            // this click potentially triggers infinite recursion if both overlays try to bring focus back to themselves
            secondOverlayInputElement.simulate("click").update();
            // previous test suites for Overlay spied on bringFocusInsideOverlay and asserted it was called once here,
            // but that is more difficult to test with function components and breaches the abstraction of Overlay2.

            multipleWrapper.unmount();
            multipleWrapper.detach();
        });

        it("does not return focus to overlay if enforceFocus=false", done => {
            let buttonRef: HTMLElement | null;
            const focusBtnAndAssert = () => {
                buttonRef?.focus();
                assert.strictEqual(buttonRef, document.activeElement);
                done();
            };

            mountWrapper(
                <div>
                    <button ref={ref => (buttonRef = ref)} />
                    <OverlayWrapper className={overlayClassName} enforceFocus={false} isOpen={true} usePortal={true}>
                        <div>
                            <input ref={ref => ref && setTimeout(focusBtnAndAssert)} />
                        </div>
                    </OverlayWrapper>
                </div>,
            );
        });

        it("doesn't focus overlay if focus is already inside overlay", done => {
            let textarea: HTMLTextAreaElement | null;
            mountWrapper(
                <OverlayWrapper className={overlayClassName} isOpen={true} usePortal={true}>
                    <div>
                        <textarea ref={ref => (textarea = ref)} />
                    </div>
                </OverlayWrapper>,
            );
            textarea!.focus();
            assertFocusWithTimeout("textarea", done);
        });

        it("does not focus overlay when closed", done => {
            mountWrapper(
                <div>
                    <button ref={ref => ref && ref.focus()} />
                    <OverlayWrapper className={overlayClassName} isOpen={false} usePortal={true} />
                </div>,
            );
            assertFocusWithTimeout("button", done);
        });

        it("does not crash while trying to return focus to overlay if user clicks outside the document", () => {
            mountWrapper(
                <OverlayWrapper
                    className={overlayClassName}
                    enforceFocus={true}
                    canOutsideClickClose={false}
                    isOpen={true}
                    usePortal={false}
                >
                    {createOverlayContents()}
                </OverlayWrapper>,
            );

            // this is a fairly custom / nonstandard event dispatch, trying to simulate what happens in some browsers when a user clicks
            // on the browser toolbar (outside the document), but a focus event is still dispatched to document
            // see https://github.com/palantir/blueprint/issues/3928
            const event = new FocusEvent("focus");
            Object.defineProperty(event, "target", { value: window });

            try {
                document.dispatchEvent(event);
            } catch (e) {
                assert.fail("threw uncaught error");
            }
        });

        function assertFocusWithTimeout(selector: string | (() => void), done: Mocha.Done) {
            // the behavior being tested relies on requestAnimationFrame.
            // setTimeout for a few frames later to let things settle (to reduce flakes).
            setTimeout(() => {
                wrapper.update();
                if (Utils.isFunction(selector)) {
                    selector();
                } else {
                    assert.strictEqual(document.querySelector(selector), document.activeElement);
                }
                done();
            }, 40);
        }

        function assertFocusIsInOverlayWithTimeout(done: Mocha.Done) {
            assertFocusWithTimeout(() => {
                const overlayElement = document.querySelector(`.${overlayClassName}`);
                assert.isTrue(overlayElement?.contains(document.activeElement));
            }, done);
        }
    });

    describe("Background scrolling", () => {
        // force-reset Overlay2 stack state between tests
        afterEach(() => {
            document.body.classList.remove(Classes.OVERLAY_OPEN);
        });

        describe("upon mount", () => {
            it("disables document scrolling by default", () => {
                wrapper = mountWrapper(renderBackdropOverlay());
                assertBodyScrollingDisabled(true);
            });

            it("disables document scrolling if hasBackdrop=true and usePortal=true", () => {
                wrapper = mountWrapper(renderBackdropOverlay(true, true));
                assertBodyScrollingDisabled(true);
            });

            it("does not disable document scrolling if hasBackdrop=true and usePortal=false", () => {
                wrapper = mountWrapper(renderBackdropOverlay(true, false));
                assertBodyScrollingDisabled(false);
            });

            it("does not disable document scrolling if hasBackdrop=false and usePortal=true", () => {
                wrapper = mountWrapper(renderBackdropOverlay(false, true));
                assertBodyScrollingDisabled(false);
            });

            it("does not disable document scrolling if hasBackdrop=false and usePortal=false", () => {
                wrapper = mountWrapper(renderBackdropOverlay(false, false));
                assertBodyScrollingDisabled(false);
            });
        });

        describe("after closing (no overlays remaining)", () => {
            // N.B. this tests some of the behavior of useOverlaysProvider(), which we might want to extract
            // to a separate test suite
            it("restores body scrolling", () => {
                wrapper = mountWrapper(
                    <OverlayWrapper isOpen={true} usePortal={true}>
                        {createOverlayContents()}
                    </OverlayWrapper>,
                );
                wrapper.setProps({ isOpen: false });
                assert.isFalse(
                    wrapper.getDOMNode().classList.contains(Classes.OVERLAY_OPEN),
                    `expected overlay element to not have ${Classes.OVERLAY_OPEN} class`,
                );
                assertBodyScrollingDisabled(false);
            });
        });

        describe("after closing (but some overlays remain open)", () => {
            let multipleWrapper: ReactWrapper<MultipleOverlaysWrapperProps, any>;
            let isMultipleWrapperMounted = false;

            afterEach(() => {
                if (isMultipleWrapperMounted) {
                    multipleWrapper.unmount();
                    multipleWrapper.detach();
                    isMultipleWrapperMounted = false;
                }
            });

            function mountMultipleWrapper(el: React.ReactElement<MultipleOverlaysWrapperProps>) {
                multipleWrapper = mount<MultipleOverlaysWrapperProps>(el, {
                    attachTo: testsContainerElement,
                });
                isMultipleWrapperMounted = true;
                return multipleWrapper;
            }

            it("keeps scrolling disabled if some overlay with hasBackdrop=true exists", () => {
                const firstOverlay = {
                    children: createOverlayContents(),
                    hasBackdrop: true,
                    isOpen: true,
                    usePortal: true,
                };
                const secondOverlay = {
                    children: createOverlayContents(),
                    hasBackdrop: true,
                    isOpen: true,
                    usePortal: true,
                };
                multipleWrapper = mountMultipleWrapper(
                    <MultipleOverlaysWrapper first={firstOverlay} second={secondOverlay} />,
                );

                // close the first overlay which has a backdrop
                multipleWrapper.setProps({ first: { ...firstOverlay, isOpen: false } }).update();

                // the second overlay with a backdrop should still be open
                assertBodyScrollingDisabled(true);
            });

            it("doesn't keep scrolling disabled if no overlay exists with hasBackdrop=true", () => {
                const firstOverlay = {
                    children: createOverlayContents(),
                    hasBackdrop: true,
                    isOpen: true,
                    usePortal: true,
                };
                const secondOverlay = {
                    children: createOverlayContents(),
                    hasBackdrop: false,
                    isOpen: true,
                    usePortal: true,
                };
                multipleWrapper = mountMultipleWrapper(
                    <MultipleOverlaysWrapper first={firstOverlay} second={secondOverlay} />,
                );

                // close the first overlay which has a backdrop
                multipleWrapper.setProps({ first: { ...firstOverlay, isOpen: false } });

                // the second overlay should still be open, but it has no backdrop
                assertBodyScrollingDisabled(false);
            });
        });

        describe("after closing by navigating out of the view", () => {
            it("doesn't keep scrolling disabled if user navigated from the component where Overlay was opened", () => {
                function WrapperWithNavigation(props: { renderOverlayView: boolean; isOverlayOpen: boolean }) {
                    return (
                        <div>
                            {/* Emulating the router behavior */}
                            {props.renderOverlayView ? (
                                <OverlayWrapper isOpen={props.isOverlayOpen}>{createOverlayContents()}</OverlayWrapper>
                            ) : (
                                <div>Another View</div>
                            )}
                        </div>
                    );
                }

                // Rendering the component with closed overlay (how it will happen in most of the real apps)
                const wrapperWithNavigation = mount(
                    <WrapperWithNavigation renderOverlayView={true} isOverlayOpen={false} />,
                    {
                        attachTo: testsContainerElement,
                    },
                );

                // Opening the overlay manually to emulate the real app behavior
                wrapperWithNavigation.setProps({ isOverlayOpen: true });
                assert.isTrue(
                    document.body.classList.contains(Classes.OVERLAY_OPEN),
                    `expected overlay element to have ${Classes.OVERLAY_OPEN} class`,
                );
                assertBodyScrollingDisabled(true);

                // Emulating the user navigation to another view
                wrapperWithNavigation.setProps({ renderOverlayView: false });
                assert.isFalse(
                    document.body.classList.contains(Classes.OVERLAY_OPEN),
                    `expected overlay element to not have ${Classes.OVERLAY_OPEN} class`,
                );
                assertBodyScrollingDisabled(false);
            });
        });

        function renderBackdropOverlay(hasBackdrop?: boolean, usePortal?: boolean) {
            return (
                <OverlayWrapper hasBackdrop={hasBackdrop} isOpen={true} usePortal={usePortal}>
                    {createOverlayContents()}
                </OverlayWrapper>
            );
        }

        // N.B. previous iterations of this test used a `setTimeout()` to wait for DOM updates to be
        // flushed before checking the body classes. This is no longer necessary with Overlay2 and
        // the `useOverlayStack()` hook.
        function assertBodyScrollingDisabled(disabled: boolean) {
            const hasClass = document.body.classList.contains(Classes.OVERLAY_OPEN);
            assert.equal(
                hasClass,
                disabled,
                `expected <body> element to ${disabled ? "have" : "not have"} ${Classes.OVERLAY_OPEN} class`,
            );
        }
    });

    it("lifecycle methods called as expected", done => {
        // these lifecycles are passed directly to CSSTransition from react-transition-group
        // so we do not need to test these extensively. one integration test should do.
        const onClosed = spy();
        const onClosing = spy();
        const onOpened = spy();
        const onOpening = spy();
        wrapper = mountWrapper(
            <OverlayWrapper
                {...{ onClosed, onClosing, onOpened, onOpening }}
                isOpen={true}
                usePortal={false}
                // transition duration shorter than timeout below to ensure it's done
                transitionDuration={8}
            >
                {createOverlayContents()}
            </OverlayWrapper>,
        );
        assert.isTrue(onOpening.calledOnce, "onOpening");
        assert.isFalse(onOpened.calledOnce, "onOpened not called yet");

        setTimeout(() => {
            // on*ed called after transition completes
            assert.isTrue(onOpened.calledOnce, "onOpened");

            wrapper.setProps({ isOpen: false });
            // on*ing called immediately when prop changes
            assert.isTrue(onClosing.calledOnce, "onClosing");
            assert.isFalse(onClosed.calledOnce, "onClosed not called yet");

            setTimeout(() => {
                assert.isTrue(onClosed.calledOnce, "onOpened");
                done();
            }, 10);
        }, 10);
    });

    let index = 0;
    function createOverlayContents() {
        return (
            <strong id={`overlay-${index++}`} tabIndex={0}>
                Overlay2 content!
            </strong>
        );
    }
});

================================================================================

File: test\panel-stack\panelStackTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview This component is DEPRECATED, and the code is frozen.
 * All changes & bugfixes should be made to PanelStack2 instead.
 */

/* eslint-disable deprecation/deprecation */

import { assert } from "chai";
import { mount, type ReactWrapper } from "enzyme";
import * as React from "react";
import { spy } from "sinon";

import { Classes, type IPanel, type IPanelProps, PanelStack, type PanelStackProps } from "../../src";

export class TestPanel extends React.Component<IPanelProps> {
    public render() {
        return (
            <div>
                <button id="new-panel-button" onClick={this.openPanel} />
                <button id="close-panel-button" onClick={this.props.closePanel} />
            </div>
        );
    }

    private openPanel = () => this.props.openPanel({ component: TestPanel, title: "New Panel 1" });
}

describe("<PanelStack>", () => {
    let testsContainerElement: HTMLElement;
    let panelStackWrapper: PanelStackWrapper;

    const initialPanel: IPanel = {
        component: TestPanel,
        props: {},
        title: "Test Title",
    };

    const emptyTitleInitialPanel: IPanel = {
        component: TestPanel,
        props: {},
    };

    beforeEach(() => {
        testsContainerElement = document.createElement("div");
        document.body.appendChild(testsContainerElement);
    });

    afterEach(() => {
        panelStackWrapper?.unmount();
        panelStackWrapper?.detach();
        testsContainerElement.remove();
    });

    it("renders a basic panel and allows opening and closing", () => {
        panelStackWrapper = renderPanelStack({ initialPanel });
        assert.exists(panelStackWrapper);

        const newPanelButton = panelStackWrapper.find("#new-panel-button");
        assert.exists(newPanelButton);
        newPanelButton.simulate("click");

        const newPanelHeader = panelStackWrapper.findClass(Classes.HEADING);
        assert.exists(newPanelHeader);
        assert.equal(newPanelHeader.at(0).text(), "New Panel 1");

        const backButton = panelStackWrapper.findClass(Classes.PANEL_STACK_HEADER_BACK);
        assert.exists(backButton);
        backButton.simulate("click");

        const oldPanelHeader = panelStackWrapper.findClass(Classes.HEADING);
        assert.exists(oldPanelHeader);
        assert.equal(oldPanelHeader.at(1).text(), "Test Title");
    });

    it("renders a panel stack without header and allows opening and closing", () => {
        panelStackWrapper = renderPanelStack({ initialPanel, showPanelHeader: false });
        assert.exists(panelStackWrapper);

        const newPanelButton = panelStackWrapper.find("#new-panel-button");
        assert.exists(newPanelButton);
        newPanelButton.simulate("click");

        const newPanelHeader = panelStackWrapper.findClass(Classes.HEADING);
        assert.lengthOf(newPanelHeader, 0);

        const backButton = panelStackWrapper.findClass(Classes.PANEL_STACK_HEADER_BACK);
        assert.lengthOf(backButton, 0);

        const closePanel = panelStackWrapper.find("#close-panel-button");
        assert.exists(closePanel);
        closePanel.last().simulate("click");

        const oldPanelHeader = panelStackWrapper.findClass(Classes.HEADING);
        assert.lengthOf(oldPanelHeader, 0);
    });

    it("does not call the callback handler onClose when there is only a single panel on the stack", () => {
        const onClose = spy();
        panelStackWrapper = renderPanelStack({ initialPanel, onClose });

        const closePanel = panelStackWrapper.find("#close-panel-button");
        assert.exists(closePanel);

        closePanel.simulate("click");
        assert.equal(onClose.callCount, 0);
    });

    it("calls the callback handlers onOpen and onClose", () => {
        const onOpen = spy();
        const onClose = spy();
        panelStackWrapper = renderPanelStack({ initialPanel, onClose, onOpen });

        const newPanelButton = panelStackWrapper.find("#new-panel-button");
        assert.exists(newPanelButton);
        newPanelButton.simulate("click");
        assert.isTrue(onOpen.calledOnce);
        assert.isFalse(onClose.calledOnce);

        const backButton = panelStackWrapper.findClass(Classes.PANEL_STACK_HEADER_BACK);
        assert.exists(backButton);
        backButton.simulate("click");
        assert.isTrue(onClose.calledOnce);
        assert.isTrue(onOpen.calledOnce);
    });

    it("does not have the back button when only a single panel is on the stack", () => {
        panelStackWrapper = renderPanelStack({ initialPanel });
        const backButton = panelStackWrapper.findClass(Classes.PANEL_STACK_HEADER_BACK);
        assert.equal(backButton.length, 0);
    });

    it("assigns the class to TransitionGroup", () => {
        const TEST_CLASS_NAME = "TEST_CLASS_NAME";
        panelStackWrapper = renderPanelStack({ initialPanel, className: TEST_CLASS_NAME });
        assert.isTrue(panelStackWrapper.hasClass(TEST_CLASS_NAME));

        const transitionGroupClassName = panelStackWrapper.findClass(TEST_CLASS_NAME).props().className;
        assert.exists(transitionGroupClassName);
        assert.equal(transitionGroupClassName!.indexOf(Classes.PANEL_STACK), 0);
    });

    it("can render a panel without a title", () => {
        panelStackWrapper = renderPanelStack({ initialPanel: emptyTitleInitialPanel });
        assert.exists(panelStackWrapper);

        const newPanelButton = panelStackWrapper.find("#new-panel-button");
        assert.exists(newPanelButton);
        newPanelButton.simulate("click");

        const backButtonWithoutTitle = panelStackWrapper.findClass(Classes.PANEL_STACK_HEADER_BACK);
        assert.equal(
            backButtonWithoutTitle.prop("aria-label"),
            "Back",
            "expected icon-only back button to have accessible label",
        );

        const newPanelButtonOnNotEmpty = panelStackWrapper.find("#new-panel-button").hostNodes().at(1);
        assert.exists(newPanelButtonOnNotEmpty);
        newPanelButtonOnNotEmpty.simulate("click");

        const backButtonWithTitle = panelStackWrapper.findClass(Classes.PANEL_STACK_HEADER_BACK).hostNodes().at(1);
        assert.equal(
            backButtonWithTitle.prop("aria-label"),
            "Back",
            "expected icon-only back button to have accessible label",
        );
    });

    it("can render a panel stack in controlled mode", () => {
        const stack = [initialPanel];
        panelStackWrapper = renderPanelStack({ stack });
        assert.exists(panelStackWrapper);

        const newPanelButton = panelStackWrapper.find("#new-panel-button");
        assert.exists(newPanelButton);
        newPanelButton.simulate("click");

        // Expect the same panel as before since onOpen is not handled
        const newPanelHeader = panelStackWrapper.findClass(Classes.HEADING);
        assert.exists(newPanelHeader);
        assert.equal(newPanelHeader.at(0).text(), "Test Title");
    });

    it("can open a panel in controlled mode", () => {
        let stack = [initialPanel];
        panelStackWrapper = renderPanelStack({
            onOpen: panel => (stack = [...stack, panel]),
            stack,
        });
        assert.exists(panelStackWrapper);

        const newPanelButton = panelStackWrapper.find("#new-panel-button");
        assert.exists(newPanelButton);
        newPanelButton.simulate("click");
        panelStackWrapper.setProps({ stack });
        panelStackWrapper.update();

        const newPanelHeader = panelStackWrapper.findClass(Classes.HEADING);
        assert.exists(newPanelHeader);
        assert.equal(newPanelHeader.at(0).text(), "New Panel 1");
    });

    it("can render a panel stack with multiple initial panels and close one", () => {
        let stack: Array<IPanel<any>> = [initialPanel, { component: TestPanel, title: "New Panel 1" }];
        panelStackWrapper = renderPanelStack({
            onClose: () => {
                const newStack = stack.slice();
                newStack.pop();
                stack = newStack;
            },
            stack,
        });
        assert.exists(panelStackWrapper);

        const panelHeader = panelStackWrapper.findClass(Classes.HEADING);
        assert.exists(panelHeader);
        assert.equal(panelHeader.at(0).text(), "New Panel 1");

        const backButton = panelStackWrapper.findClass(Classes.PANEL_STACK_HEADER_BACK);
        assert.exists(backButton);
        backButton.simulate("click");
        panelStackWrapper.setProps({ stack });
        panelStackWrapper.update();

        const firstPanelHeader = panelStackWrapper.findClass(Classes.HEADING);
        assert.exists(firstPanelHeader);
        assert.equal(firstPanelHeader.at(0).text(), "Test Title");
    });

    it("renders only one panel by default", () => {
        const stack = [
            { component: TestPanel, title: "Panel A" },
            { component: TestPanel, title: "Panel B" },
        ];
        panelStackWrapper = renderPanelStack({ stack });

        const panelHeaders = panelStackWrapper.findClass(Classes.HEADING);
        assert.exists(panelHeaders);
        assert.equal(panelHeaders.length, 1);
        assert.equal(panelHeaders.at(0).text(), stack[1].title);
    });

    it("renders all panels with renderActivePanelOnly disabled", () => {
        const stack = [
            { component: TestPanel, title: "Panel A" },
            { component: TestPanel, title: "Panel B" },
        ];
        panelStackWrapper = renderPanelStack({ renderActivePanelOnly: false, stack });

        const panelHeaders = panelStackWrapper.findClass(Classes.HEADING);
        assert.exists(panelHeaders);
        assert.equal(panelHeaders.length, 2);
        assert.equal(panelHeaders.at(0).text(), stack[0].title);
        assert.equal(panelHeaders.at(1).text(), stack[1].title);
    });

    interface PanelStackWrapper extends ReactWrapper<PanelStackProps, any> {
        findClass(className: string): ReactWrapper<React.HTMLAttributes<HTMLElement>, any>;
    }

    function renderPanelStack(props: PanelStackProps): PanelStackWrapper {
        panelStackWrapper = mount(<PanelStack {...props} />, {
            attachTo: testsContainerElement,
        }) as PanelStackWrapper;
        panelStackWrapper.findClass = (className: string) => panelStackWrapper.find(`.${className}`).hostNodes();
        return panelStackWrapper;
    }
});

================================================================================

File: test\panel-stack2\panelStack2Tests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, type ReactWrapper } from "enzyme";
import * as React from "react";
import { spy } from "sinon";

import { Classes, NumericInput, type Panel, type PanelProps, PanelStack2, type PanelStack2Props } from "../../src";

// eslint-disable-next-line @typescript-eslint/ban-types
type TestPanelInfo = {};
type TestPanelType = Panel<TestPanelInfo>;

const TestPanel: React.FC<PanelProps<TestPanelInfo>> = props => {
    const [counter, setCounter] = React.useState(0);
    const newPanel = { renderPanel: TestPanel, title: "New Panel 1" };

    return (
        <div>
            <button id="new-panel-button" onClick={() => props.openPanel(newPanel)} />
            {/* eslint-disable-next-line @typescript-eslint/unbound-method */}
            <button id="close-panel-button" onClick={props.closePanel} />
            <span aria-label="counter value">{counter}</span>
            <NumericInput value={counter} stepSize={1} onValueChange={setCounter} />
        </div>
    );
};

describe("<PanelStack2>", () => {
    let testsContainerElement: HTMLElement;
    let panelStackWrapper: PanelStack2Wrapper<TestPanelType>;

    const initialPanel: Panel<TestPanelInfo> = {
        props: {},
        renderPanel: TestPanel,
        title: "Test Title",
    };

    const emptyTitleInitialPanel: Panel<TestPanelInfo> = {
        props: {},
        renderPanel: TestPanel,
    };

    beforeEach(() => {
        testsContainerElement = document.createElement("div");
        document.body.appendChild(testsContainerElement);
    });

    afterEach(() => {
        panelStackWrapper?.unmount();
        panelStackWrapper?.detach();
        testsContainerElement.remove();
    });

    describe("uncontrolled mode", () => {
        it("renders a basic panel and allows opening and closing", () => {
            panelStackWrapper = renderPanelStack({ initialPanel });
            assert.exists(panelStackWrapper);

            const newPanelButton = panelStackWrapper.find("#new-panel-button");
            assert.exists(newPanelButton);
            newPanelButton.simulate("click");

            const newPanelHeader = panelStackWrapper.findClass(Classes.HEADING);
            assert.exists(newPanelHeader);
            assert.equal(newPanelHeader.at(0).text(), "New Panel 1");

            const backButton = panelStackWrapper.findClass(Classes.PANEL_STACK2_HEADER_BACK);
            assert.exists(backButton);
            backButton.simulate("click");

            const oldPanelHeader = panelStackWrapper.findClass(Classes.HEADING);
            assert.exists(oldPanelHeader);
            assert.equal(oldPanelHeader.at(1).text(), "Test Title");
        });

        it("renders a panel stack without header and allows opening and closing", () => {
            panelStackWrapper = renderPanelStack({ initialPanel, showPanelHeader: false });
            assert.exists(panelStackWrapper);

            const newPanelButton = panelStackWrapper.find("#new-panel-button");
            assert.exists(newPanelButton);
            newPanelButton.simulate("click");

            const newPanelHeader = panelStackWrapper.findClass(Classes.HEADING);
            assert.lengthOf(newPanelHeader, 0);

            const backButton = panelStackWrapper.findClass(Classes.PANEL_STACK2_HEADER_BACK);
            assert.lengthOf(backButton, 0);

            const closePanel = panelStackWrapper.find("#close-panel-button");
            assert.exists(closePanel);
            closePanel.last().simulate("click");

            const oldPanelHeader = panelStackWrapper.findClass(Classes.HEADING);
            assert.lengthOf(oldPanelHeader, 0);
        });

        it("does not call the callback handler onClose when there is only a single panel on the stack", () => {
            const onClose = spy();
            panelStackWrapper = renderPanelStack({ initialPanel, onClose });

            const closePanel = panelStackWrapper.find("#close-panel-button");
            assert.exists(closePanel);

            closePanel.simulate("click");
            assert.equal(onClose.callCount, 0);
        });

        it("calls the callback handlers onOpen and onClose", () => {
            const onOpen = spy();
            const onClose = spy();
            panelStackWrapper = renderPanelStack({ initialPanel, onClose, onOpen });

            const newPanelButton = panelStackWrapper.find("#new-panel-button");
            assert.exists(newPanelButton);
            newPanelButton.simulate("click");
            assert.isTrue(onOpen.calledOnce);
            assert.isFalse(onClose.calledOnce);

            const backButton = panelStackWrapper.findClass(Classes.PANEL_STACK2_HEADER_BACK);
            assert.exists(backButton);
            backButton.simulate("click");
            assert.isTrue(onClose.calledOnce);
            assert.isTrue(onOpen.calledOnce);
        });

        it("does not have the back button when only a single panel is on the stack", () => {
            panelStackWrapper = renderPanelStack({ initialPanel });
            const backButton = panelStackWrapper.findClass(Classes.PANEL_STACK2_HEADER_BACK);
            assert.equal(backButton.length, 0);
        });

        it("assigns the class to TransitionGroup", () => {
            const TEST_CLASS_NAME = "TEST_CLASS_NAME";
            panelStackWrapper = renderPanelStack({ initialPanel, className: TEST_CLASS_NAME });
            assert.isTrue(panelStackWrapper.hasClass(TEST_CLASS_NAME));

            const transitionGroupClassName = panelStackWrapper.findClass(TEST_CLASS_NAME).props().className;
            assert.exists(transitionGroupClassName);
            assert.equal(transitionGroupClassName!.indexOf(Classes.PANEL_STACK2), 0);
        });

        it("can render a panel without a title", () => {
            panelStackWrapper = renderPanelStack({ initialPanel: emptyTitleInitialPanel });
            assert.exists(panelStackWrapper);

            const newPanelButton = panelStackWrapper.find("#new-panel-button");
            assert.exists(newPanelButton);
            newPanelButton.simulate("click");

            const backButtonWithoutTitle = panelStackWrapper.findClass(Classes.PANEL_STACK2_HEADER_BACK);
            assert.equal(
                backButtonWithoutTitle.prop("aria-label"),
                "Back",
                "expected icon-only back button to have accessible label",
            );

            const newPanelButtonOnNotEmpty = panelStackWrapper.find("#new-panel-button").hostNodes().at(1);
            assert.exists(newPanelButtonOnNotEmpty);
            newPanelButtonOnNotEmpty.simulate("click");

            const backButtonWithTitle = panelStackWrapper.findClass(Classes.PANEL_STACK2_HEADER_BACK).hostNodes().at(1);
            assert.equal(
                backButtonWithTitle.prop("aria-label"),
                "Back",
                "expected icon-only back button to have accessible label",
            );
        });
    });

    describe("controlled mode", () => {
        it("can render a panel stack in controlled mode", () => {
            const stack = [initialPanel];
            panelStackWrapper = renderPanelStack({ stack });
            assert.exists(panelStackWrapper);

            const newPanelButton = panelStackWrapper.find("#new-panel-button");
            assert.exists(newPanelButton);
            newPanelButton.simulate("click");

            // Expect the same panel as before since onOpen is not handled
            const newPanelHeader = panelStackWrapper.findClass(Classes.HEADING);
            assert.exists(newPanelHeader);
            assert.equal(newPanelHeader.at(0).text(), "Test Title");
        });

        it("can open a panel in controlled mode", () => {
            let stack = [initialPanel];
            panelStackWrapper = renderPanelStack({
                onOpen: panel => {
                    stack = [...stack, panel];
                },
                stack,
            });
            assert.exists(panelStackWrapper);

            const newPanelButton = panelStackWrapper.find("#new-panel-button");
            assert.exists(newPanelButton);
            newPanelButton.simulate("click");
            panelStackWrapper.setProps({ stack });

            const newPanelHeader = panelStackWrapper.findClass(Classes.HEADING);
            assert.exists(newPanelHeader);
            assert.equal(newPanelHeader.at(0).text(), "New Panel 1");
        });

        it("can render a panel stack with multiple initial panels and close one", () => {
            let stack: Array<Panel<TestPanelInfo>> = [initialPanel, { renderPanel: TestPanel, title: "New Panel 1" }];
            panelStackWrapper = renderPanelStack({
                onClose: () => {
                    stack = stack.slice(0, -1);
                },
                stack,
            });
            assert.exists(panelStackWrapper);

            const panelHeader = panelStackWrapper.findClass(Classes.HEADING);
            assert.exists(panelHeader);
            assert.equal(panelHeader.at(0).text(), "New Panel 1");

            const backButton = panelStackWrapper.findClass(Classes.PANEL_STACK2_HEADER_BACK);
            assert.exists(backButton);
            backButton.simulate("click");
            panelStackWrapper.setProps({ stack });

            const firstPanelHeader = panelStackWrapper.findClass(Classes.HEADING);
            assert.exists(firstPanelHeader);
            assert.equal(firstPanelHeader.at(0).text(), "Test Title");
        });

        it("renders only one panel by default", () => {
            const stack = [
                { renderPanel: TestPanel, title: "Panel A" },
                { renderPanel: TestPanel, title: "Panel B" },
            ];
            panelStackWrapper = renderPanelStack({ stack });

            const panelHeaders = panelStackWrapper.findClass(Classes.HEADING);
            assert.exists(panelHeaders);
            assert.equal(panelHeaders.length, 1);
            assert.equal(panelHeaders.at(0).text(), stack[1].title);
        });

        describe("with renderActivePanelOnly={false}", () => {
            it("renders all panels", () => {
                const stack = [
                    { renderPanel: TestPanel, title: "Panel A" },
                    { renderPanel: TestPanel, title: "Panel B" },
                ];
                panelStackWrapper = renderPanelStack({ renderActivePanelOnly: false, stack });

                const panelHeaders = panelStackWrapper.findClass(Classes.HEADING);
                assert.exists(panelHeaders);
                assert.equal(panelHeaders.length, 2);
                assert.equal(panelHeaders.at(0).text(), stack[0].title);
                assert.equal(panelHeaders.at(1).text(), stack[1].title);
            });

            it("keeps panels mounted", () => {
                let stack = [initialPanel];
                panelStackWrapper = renderPanelStack({
                    onClose: () => {
                        stack = stack.slice(0, -1);
                    },
                    onOpen: panel => {
                        stack = [...stack, panel];
                    },
                    renderActivePanelOnly: false,
                    stack,
                });

                const incrementButton = panelStackWrapper.find(`[aria-label="increment"]`);
                assert.exists(incrementButton);
                incrementButton.hostNodes().simulate("mousedown");
                assert.equal(getFirstPanelCounterValue(), 1, "clicking increment button should increase counter");

                const newPanelButton = panelStackWrapper.find("#new-panel-button");
                newPanelButton.hostNodes().simulate("click");
                panelStackWrapper.setProps({ stack });

                const backButton = panelStackWrapper.find(`[aria-label="Back"]`);
                backButton.hostNodes().simulate("click");
                panelStackWrapper.setProps({ stack });
                assert.equal(
                    getFirstPanelCounterValue(),
                    1,
                    "first panel should retain its counter state when we return to it",
                );
            });

            function getFirstPanelCounterValue() {
                const counterValue = panelStackWrapper.find(`[aria-label="counter value"]`);
                assert.exists(counterValue);
                return parseInt(counterValue.hostNodes().first().text().trim(), 10);
            }
        });
    });

    // eslint-disable-next-line @typescript-eslint/ban-types
    interface PanelStack2Wrapper<T extends Panel<object>> extends ReactWrapper<PanelStack2Props<T>, any> {
        findClass(className: string): ReactWrapper<React.HTMLAttributes<HTMLElement>, any>;
    }

    function renderPanelStack(props: PanelStack2Props<TestPanelType>): PanelStack2Wrapper<TestPanelType> {
        panelStackWrapper = mount(<PanelStack2 {...props} />, {
            attachTo: testsContainerElement,
        }) as PanelStack2Wrapper<TestPanelType>;
        panelStackWrapper.findClass = (className: string) => panelStackWrapper.find(`.${className}`).hostNodes();
        return panelStackWrapper;
    }
});

================================================================================

File: test\popover\popoverTests.tsx
--------------------------------------------------------------------------------
/**
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, type ReactWrapper, shallow } from "enzyme";
import * as React from "react";
import sinon from "sinon";

import { dispatchMouseEvent } from "@blueprintjs/test-commons";

import { Classes } from "../../src/common";
import * as Errors from "../../src/common/errors";
import { Button, Overlay2, Portal } from "../../src/components";
import {
    Popover,
    PopoverInteractionKind,
    type PopoverProps,
    type PopoverState,
} from "../../src/components/popover/popover";
import { PopoverArrow } from "../../src/components/popover/popoverArrow";
import { PopupKind } from "../../src/components/popover/popupKind";
import { Tooltip } from "../../src/components/tooltip/tooltip";

const BUTTON_WITH_TEST_ID = <Button data-testid="target-button" text="Target" />;
const BUTTON_ID_SELECTOR = "[data-testid='target-button']";

describe("<Popover>", () => {
    let testsContainerElement: HTMLElement;
    let wrapper: PopoverWrapper | undefined;
    const onInteractionSpy = sinon.spy();

    beforeEach(() => {
        testsContainerElement = document.createElement("div");
        document.body.appendChild(testsContainerElement);
    });

    afterEach(() => {
        if (wrapper !== undefined) {
            // clean up wrapper to remove Portal element from DOM
            wrapper?.unmount();
            wrapper?.detach();
            wrapper = undefined;
        }
        testsContainerElement.remove();
        onInteractionSpy.resetHistory();
    });

    describe("validation", () => {
        let warnSpy: sinon.SinonStub;

        // use sinon.stub to prevent warnings from appearing in the test logs
        before(() => (warnSpy = sinon.stub(console, "warn")));
        beforeEach(() => warnSpy.resetHistory());
        after(() => warnSpy.restore());

        it("throws error if given no target", () => {
            shallow(<Popover />);
            assert.isTrue(warnSpy.calledWith(Errors.POPOVER_REQUIRES_TARGET));
        });

        it("warns if given > 1 target elements", () => {
            shallow(
                <Popover>
                    <Button />
                    <article />
                </Popover>,
            );
            assert.isTrue(warnSpy.calledWith(Errors.POPOVER_WARN_TOO_MANY_CHILDREN));
        });

        it("warns if given children and target prop", () => {
            shallow(<Popover renderTarget={() => <span>"boom"</span>}>pow</Popover>);
            assert.isTrue(warnSpy.calledWith(Errors.POPOVER_WARN_DOUBLE_TARGET));
        });

        it("warns if given targetProps and renderTarget", () => {
            shallow(<Popover targetProps={{ role: "none" }} renderTarget={() => <span>"boom"</span>} />);
            assert.isTrue(warnSpy.calledWith(Errors.POPOVER_WARN_TARGET_PROPS_WITH_RENDER_TARGET));
        });

        it("warns if attempting to open a popover with empty content", () => {
            shallow(
                <Popover content={undefined} isOpen={true}>
                    {"target"}
                </Popover>,
            );
            assert.isTrue(warnSpy.calledWith(Errors.POPOVER_WARN_EMPTY_CONTENT));
        });

        it("warns if backdrop enabled when rendering inline", () => {
            shallow(
                <Popover content={"content"} hasBackdrop={true} usePortal={false}>
                    {"target"}
                </Popover>,
            );
            assert.isTrue(warnSpy.calledWith(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE));
        });

        it("warns and disables if given empty content", () => {
            const popover = mount(
                <Popover content={undefined} isOpen={true}>
                    <Button />
                </Popover>,
            );
            assert.isFalse(popover.find(Overlay2).exists(), "not open for undefined content");
            assert.equal(warnSpy.callCount, 1);

            popover.setProps({ content: "    " });
            assert.isFalse(popover.find(Overlay2).exists(), "not open for white-space string content");
            assert.equal(warnSpy.callCount, 2);
        });

        describe("throws error if backdrop enabled with non-CLICK interactionKind", () => {
            runErrorTest("HOVER");
            runErrorTest("HOVER_TARGET_ONLY");
            runErrorTest("CLICK_TARGET_ONLY");

            it("doesn't throw error for CLICK", () => {
                assert.doesNotThrow(() => <Popover hasBackdrop={true} interactionKind="click" />);
            });

            function runErrorTest(interactionKindKey: keyof typeof PopoverInteractionKind) {
                it(interactionKindKey, () => {
                    mount(
                        <Popover
                            content={<div />}
                            hasBackdrop={true}
                            interactionKind={PopoverInteractionKind[interactionKindKey]}
                        >
                            <Button />
                        </Popover>,
                    );
                    assert.isTrue(warnSpy.calledWith(Errors.POPOVER_HAS_BACKDROP_INTERACTION));
                });
            }
        });
    });

    describe("rendering", () => {
        it("adds POPOVER_OPEN class to target when the popover is open", () => {
            wrapper = renderPopover();
            assert.isFalse(wrapper.findClass(Classes.POPOVER_TARGET).hasClass(Classes.POPOVER_OPEN));
            wrapper.setState({ isOpen: true });
            assert.isTrue(wrapper.findClass(Classes.POPOVER_TARGET).hasClass(Classes.POPOVER_OPEN));
        });

        it("renders Portal when usePortal=true", () => {
            wrapper = renderPopover({ isOpen: true, usePortal: true });
            assert.lengthOf(wrapper.find(Portal), 1);
        });

        it("renders to specified container correctly", () => {
            const container = document.createElement("div");
            document.body.appendChild(container);
            wrapper = renderPopover({ isOpen: true, usePortal: true, portalContainer: container });
            assert.lengthOf(container.getElementsByClassName(Classes.POPOVER_CONTENT), 1);
            document.body.removeChild(container);
        });

        it("does not render Portal when usePortal=false", () => {
            wrapper = renderPopover({ isOpen: true, usePortal: false });
            assert.lengthOf(wrapper.find(Portal), 0);
        });

        it("hasBackdrop=true renders backdrop element", () => {
            wrapper = renderPopover({ hasBackdrop: true, isOpen: true, usePortal: false });
            wrapper.assertFindClass(Classes.POPOVER_BACKDROP, true);
        });

        it("hasBackdrop=false does not render backdrop element", () => {
            wrapper = renderPopover({ hasBackdrop: false, isOpen: true, usePortal: false });
            wrapper.assertFindClass(Classes.POPOVER_BACKDROP, false);
        });

        it("targetTagName renders the right elements", () => {
            wrapper = renderPopover({
                isOpen: true,
                targetTagName: "address",
            });
            assert.isTrue(wrapper.find("address").hasClass(Classes.POPOVER_TARGET));
        });

        it("allows user to apply dark theme explicitly", () => {
            const { popoverElement } = renderPopover({
                isOpen: true,
                popoverClassName: Classes.DARK,
                usePortal: false,
            });
            assert.isNotNull(popoverElement.matches(`.${Classes.DARK}`));
        });

        it("renders with aria-haspopup attr", () => {
            wrapper = renderPopover({ isOpen: true });
            assert.isTrue(wrapper.find("[aria-haspopup='menu']").exists());
        });

        it("sets aria-haspopup attr base on popupKind", () => {
            wrapper = renderPopover({ isOpen: true, popupKind: PopupKind.DIALOG });
            assert.isTrue(wrapper.find("[aria-haspopup='dialog']").exists());
        });

        it("renders without aria-haspopup attr for hover interaction", () => {
            wrapper = renderPopover({ isOpen: true, interactionKind: PopoverInteractionKind.HOVER_TARGET_ONLY });
            assert.isFalse(wrapper.find("[aria-haspopup]").exists());
        });
    });

    describe("basic functionality", () => {
        it("inherits dark theme from trigger ancestor", () => {
            testsContainerElement.classList.add(Classes.DARK);
            wrapper = renderPopover({ inheritDarkTheme: true, isOpen: true, usePortal: true });
            assert.exists(wrapper.find(Portal).find(`.${Classes.DARK}`));
            testsContainerElement.classList.remove(Classes.DARK);
        });

        it("inheritDarkTheme=false disables inheriting dark theme from trigger ancestor", () => {
            testsContainerElement.classList.add(Classes.DARK);
            renderPopover({ inheritDarkTheme: false, isOpen: true, usePortal: true }).assertFindClass(
                Classes.DARK,
                false,
            );
            testsContainerElement.classList.remove(Classes.DARK);
        });

        it("supports overlay lifecycle props", () => {
            const onOpening = sinon.spy();
            wrapper = renderPopover({ isOpen: true, onOpening });
            assert.isTrue(onOpening.calledOnce);
        });
    });

    describe("focus management when shouldReturnFocusOnClose={true}", () => {
        const targetClassName = "test-target";
        const commonProps: Partial<PopoverProps> = {
            className: targetClassName,
            interactionKind: PopoverInteractionKind.CLICK,
            shouldReturnFocusOnClose: true,
            transitionDuration: 0,
            usePortal: true,
        };

        it("moves focus to overlay when opened", done => {
            function handleOpened() {
                assert.notEqual(document.activeElement, document.body, "body element should not have focus");
                assert.isTrue(
                    document.activeElement?.closest(`.${Classes.OVERLAY}`) !== null,
                    "focus should be inside overlay",
                );
                done();
            }

            wrapper = renderPopover({ ...commonProps, onOpened: handleOpened });
            wrapper.targetButton.focus();
            wrapper.simulateTarget("click");
        });

        it("returns focus to target element when closed", done => {
            function handleClosed(wrapper2: PopoverWrapper) {
                wrapper2.assertIsOpen(false);
                assert.notEqual(document.activeElement, document.body, "body element should not have focus");
                assert.isTrue(
                    document.activeElement?.closest(`.${targetClassName}`) != null,
                    "focus should be on target",
                );
            }

            wrapper = renderPopover(commonProps);
            wrapper.targetButton.focus();
            assert.strictEqual(
                document.activeElement,
                wrapper.targetElement.querySelector("button"),
                "button should have document focus",
            );

            wrapper.simulateTarget("click");
            // wait for it to open, then click again to close
            wrapper.then(
                w => {
                    w.assertIsOpen();
                    w.simulateTarget("click");
                },
                // wait for it to close
                () => wrapper?.then(handleClosed, done),
            );
        });
    });

    describe("openOnTargetFocus", () => {
        describe("if true (default)", () => {
            it('adds tabindex="0" to target\'s child node when interactionKind is HOVER', () => {
                assertPopoverTargetTabIndex(true, {
                    interactionKind: "hover",
                    openOnTargetFocus: true,
                });
            });

            it('adds tabindex="0" to target\'s child node when interactionKind is HOVER_TARGET_ONLY', () => {
                assertPopoverTargetTabIndex(true, {
                    interactionKind: "hover-target",
                    openOnTargetFocus: true,
                });
            });

            it("does not add tabindex to target's child node when interactionKind is CLICK", () => {
                assertPopoverTargetTabIndex(false, {
                    interactionKind: "click",
                    openOnTargetFocus: true,
                });
            });

            it("does not add tabindex to target's child node when interactionKind is CLICK_TARGET_ONLY", () => {
                assertPopoverTargetTabIndex(false, {
                    interactionKind: "click-target",
                    openOnTargetFocus: true,
                });
            });

            it("does not add tabindex to target's child node when disabled=true", () => {
                assertPopoverTargetTabIndex(false, {
                    disabled: true,
                    interactionKind: "hover",
                    openOnTargetFocus: true,
                });
            });

            it("opens popover on target focus when interactionKind is HOVER", () => {
                assertPopoverOpenStateForInteractionKind("hover", true);
            });

            it("opens popover on target focus when interactionKind is HOVER_TARGET_ONLY", () => {
                assertPopoverOpenStateForInteractionKind("hover-target", true);
            });

            it("does not open popover on target focus when interactionKind is CLICK", () => {
                assertPopoverOpenStateForInteractionKind("click", false);
            });

            it("does not open popover on target focus when interactionKind is CLICK_TARGET_ONLY", () => {
                assertPopoverOpenStateForInteractionKind("click-target", false);
            });

            it("closes popover on target blur if autoFocus={false}", () => {
                assertPopoverOpenStateForInteractionKind("click", false, {
                    autoFocus: false,
                });
            });
        });

        describe("if false", () => {
            it("does not add tabindex to target's child node when interactionKind is HOVER", () => {
                assertPopoverTargetTabIndex(false, {
                    interactionKind: "hover",
                    openOnTargetFocus: false,
                });
            });

            it("does not add tabindex to target's child node when interactionKind is HOVER_TARGET_ONLY", () => {
                assertPopoverTargetTabIndex(false, {
                    interactionKind: "hover-target",
                    openOnTargetFocus: false,
                });
            });

            it("does not add tabindex to target's child node when interactionKind is CLICK", () => {
                assertPopoverTargetTabIndex(false, {
                    interactionKind: "click",
                    openOnTargetFocus: false,
                });
            });

            it("does not add tabindex to target's child node when interactionKind is CLICK_TARGET_ONLY", () => {
                assertPopoverTargetTabIndex(false, {
                    interactionKind: "click-target",
                    openOnTargetFocus: false,
                });
            });

            it("does not open popover on target focus when interactionKind is HOVER", () => {
                assertPopoverOpenStateForInteractionKind("hover", false, {
                    openOnTargetFocus: false,
                });
            });

            it("does not open popover on target focus when interactionKind is HOVER_TARGET_ONLY", () => {
                assertPopoverOpenStateForInteractionKind("hover-target", false, {
                    openOnTargetFocus: false,
                });
            });

            it("does not open popover on target focus when interactionKind is CLICK", () => {
                assertPopoverOpenStateForInteractionKind("click", false, {
                    openOnTargetFocus: false,
                });
            });

            it("does not open popover on target focus when interactionKind is CLICK_TARGET_ONLY", () => {
                assertPopoverOpenStateForInteractionKind("click-target", false, {
                    openOnTargetFocus: false,
                });
            });
        });

        function assertPopoverOpenStateForInteractionKind(
            interactionKind: PopoverInteractionKind,
            isOpen: boolean,
            extraProps?: {
                autoFocus?: boolean;
                openOnTargetFocus?: boolean;
            },
        ) {
            wrapper = renderPopover({
                interactionKind,
                openOnTargetFocus: extraProps?.openOnTargetFocus,
                usePortal: true,
            });
            const targetElement = wrapper.findClass(Classes.POPOVER_TARGET);
            targetElement.simulate("focus");
            assert.equal(wrapper.state("isOpen"), isOpen);
        }
    });

    describe("in controlled mode", () => {
        it("state respects isOpen prop", () => {
            renderPopover().assertIsOpen(false).setProps({ isOpen: true }).update().assertIsOpen();
        });

        it("state does not update on user (click) interaction", () => {
            renderPopover({ isOpen: true })
                .simulateTarget("click")
                .assertIsOpen()
                .setProps({ isOpen: false })
                .simulateTarget("click")
                .assertIsOpen(false);
        });

        it("state does not update on user (key) interaction", () => {
            renderPopover({ canEscapeKeyClose: true, isOpen: true }).sendEscapeKey().assertIsOpen();
        });

        describe("disabled=true takes precedence over isOpen=true", () => {
            it("on mount", () => {
                renderPopover({ disabled: true, isOpen: true }).assertIsOpen(false);
            });

            it("onInteraction not called if changing from closed to open (b/c popover is still closed)", () => {
                renderPopover({ disabled: true, isOpen: false, onInteraction: onInteractionSpy })
                    .assertOnInteractionCalled(false)
                    .setProps({ isOpen: true })
                    .assertIsOpen(false)
                    .assertOnInteractionCalled(false);
            });

            it("onInteraction not called if changing from open to closed (b/c popover was already closed)", () => {
                renderPopover({ disabled: true, isOpen: true, onInteraction: onInteractionSpy })
                    .assertOnInteractionCalled(false)
                    .setProps({ isOpen: false })
                    .assertOnInteractionCalled(false);
            });

            it("onInteraction called if open and changing to disabled (b/c popover will close)", () => {
                renderPopover({ disabled: false, isOpen: true, onInteraction: onInteractionSpy })
                    .assertIsOpen()
                    .assertOnInteractionCalled(false)
                    .setProps({ disabled: true })
                    .assertOnInteractionCalled();
            });

            it("onInteraction called if open and changing to not-disabled (b/c popover will open)", () => {
                renderPopover({ disabled: true, isOpen: true, onInteraction: onInteractionSpy })
                    .assertOnInteractionCalled(false)
                    .setProps({ disabled: false })
                    .update()
                    .assertIsOpen()
                    .assertOnInteractionCalled();
            });
        });

        it("onClose is invoked with event when popover would close", () => {
            const onClose = sinon.spy();
            renderPopover({ isOpen: true, onClose }).simulateTarget("click");
            assert.isTrue(onClose.calledOnce);
            assert.isNotNull(onClose.args[0][0]);
        });

        describe("onInteraction()", () => {
            let onInteraction: sinon.SinonSpy;
            beforeEach(() => (onInteraction = sinon.spy()));

            it("is invoked with `true` when closed popover target is clicked", () => {
                renderPopover({ isOpen: false, onInteraction }).simulateTarget("click");
                assert.isTrue(onInteraction.calledOnce);
                assert.isTrue(onInteraction.calledWith(true));
            });

            it("is invoked with `false` when open popover target is clicked", () => {
                renderPopover({ isOpen: true, onInteraction }).simulateTarget("click");
                assert.isTrue(onInteraction.calledOnce);
                assert.isTrue(onInteraction.calledWith(false));
            });

            it("is invoked with `false` when open modal popover backdrop is clicked", () => {
                renderPopover({
                    backdropProps: { className: "test-hook" },
                    hasBackdrop: true,
                    isOpen: true,
                    onInteraction,
                    usePortal: true,
                });
                dispatchMouseEvent(document.getElementsByClassName("test-hook")[0], "mousedown");
                assert.isTrue(onInteraction.calledOnce, "A");
                assert.isTrue(onInteraction.calledWith(false), "B");
            });

            it("is invoked with `false` when clicking POPOVER_DISMISS", () => {
                renderPopover(
                    { isOpen: true, onInteraction },
                    <Button className={Classes.POPOVER_DISMISS} text="Dismiss" />,
                )
                    .findClass(Classes.POPOVER_DISMISS)
                    .simulate("click");
                assert.isTrue(onInteraction.calledOnce);
                assert.isTrue(onInteraction.calledWith(false));
            });

            it("is invoked with `false` when the document is mousedowned", () => {
                renderPopover({ isOpen: true, onInteraction });
                dispatchMouseEvent(document.documentElement, "mousedown");
                assert.isTrue(onInteraction.calledOnce);
                assert.isTrue(onInteraction.calledWith(false));
            });
        });

        it("does not apply active class to target when open", () => {
            wrapper = renderPopover({
                interactionKind: "click",
                isOpen: true,
            });
            wrapper.assertFindClass(Classes.ACTIVE, false);
        });
    });

    describe("in uncontrolled mode", () => {
        it("setting defaultIsOpen=true renders open popover", () => {
            renderPopover({ defaultIsOpen: true }).assertIsOpen();
        });

        it("with defaultIsOpen=true, popover can still be closed", () => {
            renderPopover({ defaultIsOpen: true }).assertIsOpen().simulateTarget("click").assertIsOpen(false);
        });

        it("CLICK_TARGET_ONLY works properly", () => {
            renderPopover({ interactionKind: "click-target" })
                .simulateTarget("click")
                .assertIsOpen()
                .simulateTarget("click")
                .assertIsOpen(false);
        });

        it("HOVER_TARGET_ONLY works properly", done => {
            renderPopover({
                interactionKind: "hover-target",
                usePortal: true,
            })
                .simulateTarget("mouseenter")
                .assertIsOpen()
                .simulateTarget("mouseleave")
                .then(popover => popover.assertIsOpen(false), done);
        });

        it("inline HOVER_TARGET_ONLY works properly when openOnTargetFocus={false}", done => {
            wrapper = renderPopover({
                interactionKind: "hover-target",
                openOnTargetFocus: false,
                usePortal: false,
            });

            wrapper.simulateTarget("mouseenter").assertIsOpen();
            wrapper.findClass(Classes.POPOVER).simulate("mouseenter");
            // Popover defers popover closing, so need to defer this check
            wrapper.then(() => wrapper!.assertIsOpen(false), done);
        });

        it("inline HOVER works properly", done => {
            wrapper = renderPopover({
                interactionKind: "hover",
                usePortal: false,
            });

            wrapper.simulateTarget("mouseenter").assertIsOpen();

            wrapper.findClass(Classes.POPOVER).simulate("mouseenter");
            wrapper.assertIsOpen();

            wrapper.findClass(Classes.POPOVER).simulate("mouseleave");
            // Popover defers popover closing, so need to defer this check
            wrapper.then(() => wrapper!.assertIsOpen(false), done);
        });

        it("clicking POPOVER_DISMISS closes popover when usePortal=true", () => {
            wrapper = renderPopover(
                { defaultIsOpen: true, usePortal: true },
                <Button className={Classes.POPOVER_DISMISS} text="Dismiss" />,
            );
            wrapper.find(Portal).find(`.${Classes.POPOVER_DISMISS}`).hostNodes().simulate("click");
            wrapper.update().assertIsOpen(false);
        });

        it("clicking POPOVER_DISMISS closes popover when usePortal=false", () => {
            wrapper = renderPopover(
                { defaultIsOpen: true, usePortal: false },
                <Button className={Classes.POPOVER_DISMISS} text="Dismiss" />,
            );
            wrapper.findClass(Classes.POPOVER_DISMISS).simulate("click");
            wrapper.assertIsOpen(false);
        });

        it("pressing Escape closes popover when canEscapeKeyClose=true and usePortal=false", () => {
            renderPopover({ canEscapeKeyClose: true, usePortal: false })
                .simulateTarget("click")
                .assertIsOpen()
                .sendEscapeKey()
                .assertIsOpen(false);
        });

        it("setting disabled=true prevents opening popover", () => {
            renderPopover({
                disabled: true,
                interactionKind: "click-target",
            })
                .simulateTarget("click")
                .assertIsOpen(false);
        });

        it("setting disabled=true hides open popover", () => {
            renderPopover({ interactionKind: "click-target" })
                .simulateTarget("click")
                .assertIsOpen()
                .setProps({ disabled: true })
                .update()
                .assertIsOpen(false);
        });

        it("console.warns if onInteraction is set", () => {
            const warnSpy = sinon.stub(console, "warn");
            renderPopover({ onInteraction: () => false });
            assert.strictEqual(warnSpy.firstCall.args[0], Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);
            warnSpy.restore();
        });

        it("does apply active class to target when open", () => {
            wrapper = renderPopover({ interactionKind: "click" });
            wrapper.simulateTarget("click");
            wrapper.assertFindClass(Classes.ACTIVE, true);
        });
    });

    describe("when composed with <Tooltip>", () => {
        let root: PopoverWrapper;
        beforeEach(() => {
            root = renderPopover(
                { hoverOpenDelay: 0, hoverCloseDelay: 0, usePortal: false },
                "popover",
                <Tooltip content="tooltip" hoverOpenDelay={0} hoverCloseDelay={0} usePortal={false}>
                    {BUTTON_WITH_TEST_ID}
                </Tooltip>,
            );
        });
        afterEach(() => root.detach());

        it("shows tooltip on hover", () => {
            root.find(`.${Classes.POPOVER_TARGET}`).last().simulate("mouseenter");
            assert.lengthOf(root.find(`.${Classes.TOOLTIP}`), 1);
        });

        it("shows popover on click", () => {
            root.find(`.${Classes.POPOVER_TARGET}`).first().simulate("click");
            assert.lengthOf(root.find(`.${Classes.POPOVER}`), 1);
        });

        it("the target is focusable", () => {
            assertTargetElementTabIndex(true, root.last().find(BUTTON_ID_SELECTOR).hostNodes().getDOMNode());
        });

        describe("when disabled=true", () => {
            beforeEach(() => {
                root.setProps({ disabled: true });
            });

            it("shows tooltip on hover", () => {
                root.find(`.${Classes.POPOVER_TARGET}`).last().simulate("mouseenter");
                assert.lengthOf(root.find(`.${Classes.TOOLTIP}`), 1);
            });

            it("does not show popover on click", () => {
                root.find(`.${Classes.POPOVER_TARGET}`).last().simulate("click");
                assert.lengthOf(root.find(`.${Classes.POPOVER}`), 0);
            });

            it("the target is focusable", () => {
                assertTargetElementTabIndex(true, root.last().find(BUTTON_ID_SELECTOR).hostNodes().getDOMNode());
            });
        });
    });

    describe("when composed with a disabled <Tooltip>", () => {
        let root: PopoverWrapper;
        beforeEach(() => {
            root = renderPopover(
                { hoverOpenDelay: 0, hoverCloseDelay: 0, usePortal: false },
                "popover",
                <Tooltip content="tooltip" disabled={true} hoverOpenDelay={0} hoverCloseDelay={0} usePortal={false}>
                    {BUTTON_WITH_TEST_ID}
                </Tooltip>,
            );
        });
        afterEach(() => root.detach());

        it("does not show tooltip on hover", () => {
            root.find(`.${Classes.POPOVER_TARGET}`).last().simulate("mouseenter");
            assert.lengthOf(root.find(`.${Classes.TOOLTIP}`), 0);
        });

        it("shows popover on click", () => {
            root.find(`.${Classes.POPOVER_TARGET}`).first().simulate("click");
            assert.lengthOf(root.find(`.${Classes.POPOVER}`), 1);
        });

        it("the target is not focusable", () => {
            assertTargetElementTabIndex(false, root.last().find(BUTTON_ID_SELECTOR).hostNodes().getDOMNode());
        });

        describe("when disabled=true", () => {
            beforeEach(() => {
                root.setProps({ disabled: true });
            });

            it("does not show tooltip on hover", () => {
                root.find(`.${Classes.POPOVER_TARGET}`).last().simulate("mouseenter");
                assert.lengthOf(root.find(`.${Classes.TOOLTIP}`), 0);
            });

            it("does not show popover on click", () => {
                root.find(`.${Classes.POPOVER_TARGET}`).last().simulate("click");
                assert.lengthOf(root.find(`.${Classes.POPOVER}`), 0);
            });

            it("the target is not focusable", () => {
                assertTargetElementTabIndex(false, root.last().find(BUTTON_ID_SELECTOR).hostNodes().getDOMNode());
            });
        });
    });

    describe("Popper.js integration", () => {
        it("renders arrow element by default", () => {
            wrapper = renderPopover({ isOpen: true });
            assert.lengthOf(wrapper.find(PopoverArrow), 1);
        });

        it("arrow can be disabled via modifiers", () => {
            wrapper = renderPopover({ isOpen: true, modifiers: { arrow: { enabled: false } } });
            assert.lengthOf(wrapper.find(PopoverArrow), 0);
        });

        it("arrow can be disabled via minimal prop", () => {
            wrapper = renderPopover({ minimal: true, isOpen: true });
            assert.lengthOf(wrapper.find(PopoverArrow), 0);
        });

        it("matches target width via custom modifier", () => {
            wrapper = renderPopover({ matchTargetWidth: true, isOpen: true, placement: "bottom" });
            const targetElement = wrapper.find(BUTTON_ID_SELECTOR).hostNodes().getDOMNode();
            const popoverElement = wrapper.find(`.${Classes.POPOVER}`).hostNodes().getDOMNode();
            assert.closeTo(
                popoverElement.clientWidth,
                targetElement.clientWidth,
                5,
                "content width should equal target width +/- 5px",
            );
        });
    });

    describe("closing on click", () => {
        it("Classes.POPOVER_DISMISS closes on click", () =>
            assertClickToClose(<Button className={Classes.POPOVER_DISMISS} id="btn" text="Dismiss" />, false));

        it("Classes.POPOVER_DISMISS_OVERRIDE does not close", () =>
            assertClickToClose(
                <span className={Classes.POPOVER_DISMISS}>
                    <Button className={Classes.POPOVER_DISMISS_OVERRIDE} id="btn" text="Dismiss" />
                </span>,
                true,
            ));

        it(":disabled does not close", () =>
            assertClickToClose(
                <Button className={Classes.POPOVER_DISMISS} disabled={true} id="btn" text="Dismiss" />,
                true,
            ));

        it("Classes.DISABLED does not close", () =>
            assertClickToClose(
                // testing nested behavior too
                <div className={Classes.DISABLED}>
                    <Button className={Classes.POPOVER_DISMISS} id="btn" text="Dismiss" />
                </div>,
                true,
            ));

        it("captureDismiss={true} inner dismiss does not close outer popover", () =>
            assertClickToClose(
                <Popover
                    captureDismiss={true}
                    defaultIsOpen={true}
                    usePortal={false}
                    content={<Button className={Classes.POPOVER_DISMISS} id="btn" text="Dismiss" />}
                >
                    <Button text="Target" />
                </Popover>,
                true,
            ));

        it("captureDismiss={false} inner dismiss closes outer popover", () =>
            assertClickToClose(
                <Popover
                    captureDismiss={false}
                    defaultIsOpen={true}
                    usePortal={false}
                    content={<Button className={Classes.POPOVER_DISMISS} id="btn" text="Dismiss" />}
                >
                    <Button text="Target" />
                </Popover>,
                false,
            ));

        function assertClickToClose(children: React.ReactNode, expectedIsOpen: boolean) {
            wrapper = renderPopover({ defaultIsOpen: true }, children);
            wrapper.find("#btn").hostNodes().simulate("click");
            wrapper.assertIsOpen(expectedIsOpen);
        }
    });

    describe("clicking on target", () => {
        /**
         * @see https://github.com/palantir/blueprint/issues/3010
         */
        it("does not close a HOVER interaction popover", done => {
            const onCloseSpy = sinon.spy();
            const setOpenStateSpy = sinon.spy(Popover.prototype as any, "setOpenState");

            wrapper = renderPopover({
                interactionKind: "hover",
                onClose: onCloseSpy,
                usePortal: true,
            })
                .simulateTarget("mouseenter")
                .assertIsOpen();

            wrapper.then(() => {
                setOpenStateSpy.resetHistory();
                // need to trigger a real event because the click handler will be on the document
                dispatchMouseEvent(wrapper!.targetElement);

                assert(onCloseSpy.notCalled, "onClose prop callback should not be called");
                assert(setOpenStateSpy.notCalled, "setOpenState private method should not be called");

                setOpenStateSpy.restore();
            }, done);
        });
    });

    describe("key interactions on Button target", () => {
        const SPACE_KEYSTROKE = { key: " " };

        describe("Enter key down opens click interaction popover", () => {
            it("when autoFocus={true}", done => {
                wrapper = renderPopover({ autoFocus: true });
                const button = wrapper.find(BUTTON_ID_SELECTOR).hostNodes();
                (button.getDOMNode() as HTMLElement).focus();
                button.simulate("keyDown", SPACE_KEYSTROKE);
                // Wait for focus to change
                wrapper.then(wrap => {
                    // Expect focus is now within popover, so keyup would not happen on the button
                    assert.isFalse(
                        wrap.targetElement.contains(document.activeElement),
                        "Focus was unexpectedly in target",
                    );
                    wrap.simulateContent("keyUp", SPACE_KEYSTROKE);
                    wrap.assertIsOpen();
                }, done);
            });

            it("when autoFocus={false}", done => {
                wrapper = renderPopover({ autoFocus: false });
                const button = wrapper.find(BUTTON_ID_SELECTOR).hostNodes();
                (button.getDOMNode() as HTMLElement).focus();
                button.simulate("keyDown", SPACE_KEYSTROKE);

                // Wait for focus to change (it shouldn't)
                wrapper.then(wrap => {
                    // Expect focus is still on button
                    assert.isTrue(
                        wrap.targetElement.contains(document.activeElement),
                        "Focus was expected to be in target",
                    );
                    wrap.simulateContent("keyUp", SPACE_KEYSTROKE);
                    wrap.assertIsOpen();
                }, done);
            });
        });
    });

    describe("compatibility", () => {
        it("renderTarget type definition allows sending props to child components", () => {
            mount(
                <Popover
                    usePortal={false}
                    hoverCloseDelay={0}
                    hoverOpenDelay={0}
                    content="content"
                    popoverClassName={Classes.POPOVER_CONTENT_SIZING}
                    renderTarget={({ isOpen, ref, ...props }) => (
                        <Button
                            data-testid="target-button"
                            ref={ref}
                            onClick={props.onClick}
                            text="Target"
                            {...props}
                        />
                    )}
                />,
                { attachTo: testsContainerElement },
            );
        });
    });

    function assertPopoverTargetTabIndex(shouldTabIndexExist: boolean, popoverProps: Partial<PopoverProps>) {
        wrapper = renderPopover({ ...popoverProps, usePortal: true });
        const targetElement = wrapper?.find(BUTTON_ID_SELECTOR).hostNodes().getDOMNode();
        assertTargetElementTabIndex(shouldTabIndexExist, targetElement);
    }

    function assertTargetElementTabIndex(shouldTabIndexExist: boolean, targetElement: Element | undefined) {
        if (shouldTabIndexExist) {
            assert.equal(targetElement?.getAttribute("tabindex"), "0");
        } else {
            assert.isNull(targetElement?.getAttribute("tabindex"));
        }
    }

    interface PopoverWrapper extends ReactWrapper<PopoverProps, PopoverState> {
        popoverElement: HTMLElement;
        targetElement: HTMLElement;
        targetButton: HTMLButtonElement;
        assertFindClass(className: string, expected?: boolean, msg?: string): this;
        assertIsOpen(isOpen?: boolean): this;
        assertOnInteractionCalled(called?: boolean): this;
        simulateContent(eventName: string, ...args: any[]): this;
        /** Careful: simulating "focus" is unsupported by Enzyme, see https://stackoverflow.com/a/56892875/7406866 */
        simulateTarget(eventName: string, ...args: any[]): this;
        findClass(className: string): ReactWrapper<React.HTMLAttributes<HTMLElement>, any>;
        sendEscapeKey(): this;
        then(next: (wrap: PopoverWrapper) => void, done: Mocha.Done): this;
    }

    function renderPopover(
        props: Partial<PopoverProps> = {},
        content?: any,
        children: React.JSX.Element = BUTTON_WITH_TEST_ID,
    ) {
        const contentElement = (
            <div tabIndex={0} className="test-content">
                Text {content}
            </div>
        );

        wrapper = mount(
            <Popover usePortal={false} {...props} hoverCloseDelay={0} hoverOpenDelay={0} content={contentElement}>
                {children}
            </Popover>,
            { attachTo: testsContainerElement },
        ) as PopoverWrapper;

        const instance = wrapper.instance() as Popover<React.HTMLProps<HTMLButtonElement>>;
        wrapper.popoverElement = instance.popoverElement!;
        wrapper.targetElement = instance.targetRef.current!;
        wrapper.targetButton = wrapper.find(BUTTON_ID_SELECTOR).hostNodes().getDOMNode<HTMLButtonElement>();
        wrapper.assertFindClass = (className: string, expected = true, msg = className) => {
            const actual = wrapper!.findClass(className);
            if (expected) {
                assert.isTrue(actual.exists(), msg);
            } else {
                assert.isFalse(actual.exists(), msg);
            }
            return wrapper!;
        };
        wrapper.assertIsOpen = (isOpen = true, index = 0) => {
            const overlay = wrapper!.find(Overlay2).at(index);
            assert.equal(overlay.prop("isOpen"), isOpen, "PopoverWrapper#assertIsOpen()");
            return wrapper!;
        };
        wrapper.assertOnInteractionCalled = (called = true) => {
            assert.strictEqual(onInteractionSpy.called, called, "PopoverWrapper#assertOnInteractionCalled()");
            return wrapper!;
        };
        wrapper.findClass = (className: string) => wrapper!.find(`.${className}`).hostNodes();
        wrapper.simulateContent = (eventName: string, ...args) => {
            wrapper!.findClass("test-content").simulate(eventName, ...args);
            return wrapper!;
        };
        wrapper.simulateTarget = (eventName: string, ...args) => {
            wrapper!.findClass(Classes.POPOVER_TARGET).simulate(eventName, ...args);
            return wrapper!;
        };
        wrapper.sendEscapeKey = () => {
            wrapper!.findClass(Classes.OVERLAY_OPEN).simulate("keydown", {
                key: "Escape",
                nativeEvent: new KeyboardEvent("keydown"),
            });
            return wrapper!;
        };
        wrapper.then = (next, done) => {
            setTimeout(() => {
                wrapper!.update();
                next(wrapper!);
                done();
            }, 40);
            return wrapper!;
        };
        return wrapper;
    }
});

================================================================================

File: test\popover\popperUtilTests.ts
--------------------------------------------------------------------------------
/**
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { BasePlacement } from "@popperjs/core";
import { expect } from "chai";

import { getAlignment, getOppositePlacement } from "../../src/components/popover/popperUtils";

describe("Popper utils", () => {
    it("getOppositePlacement returns opposite", () => {
        [
            ["top", "bottom"],
            ["left", "right"],
        ].map(([a, b]) => {
            expect(getOppositePlacement(a as BasePlacement)).to.equal(b);
            expect(getOppositePlacement(b as BasePlacement)).to.equal(a);
        });
    });

    it("getAlignment returns alignment", () => {
        expect(getAlignment("bottom-start")).to.equal("left");
        expect(getAlignment("top-end")).to.equal("right");
        expect(getAlignment("left")).to.equal("center");
    });
});

================================================================================

File: test\portal\portalTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, type ReactWrapper } from "enzyme";
import * as React from "react";

import { Classes, Portal, type PortalProps, PortalProvider } from "../../src";

describe("<Portal>", () => {
    let rootElement: HTMLElement | undefined;
    let portal: ReactWrapper<PortalProps>;

    beforeEach(() => {
        rootElement = document.createElement("div");
        document.body.appendChild(rootElement);
    });
    afterEach(() => {
        portal?.unmount();
        rootElement?.remove();
    });

    it("attaches contents to document.body", () => {
        const CLASS_TO_TEST = "bp-test-content";
        portal = mount(
            <Portal>
                <p className={CLASS_TO_TEST}>test</p>
            </Portal>,
            { attachTo: rootElement },
        );
        assert.lengthOf(document.getElementsByClassName(CLASS_TO_TEST), 1);
    });

    it("attaches contents to specified container", () => {
        const CLASS_TO_TEST = "bp-test-content";
        const container = document.createElement("div");
        document.body.appendChild(container);
        portal = mount(
            <Portal container={container}>
                <p className={CLASS_TO_TEST}>test</p>
            </Portal>,
            { attachTo: rootElement },
        );
        assert.lengthOf(container.getElementsByClassName(CLASS_TO_TEST), 1);
        document.body.removeChild(container);
    });

    it("propagates className to portal element", () => {
        const CLASS_TO_TEST = "bp-test-klass";
        portal = mount(
            <Portal className={CLASS_TO_TEST}>
                <p>test</p>
            </Portal>,
            { attachTo: rootElement },
        );

        const portalChild = document.querySelector(`.${Classes.PORTAL}.${CLASS_TO_TEST}`);
        assert.exists(portalChild);
    });

    it("updates className on portal element", () => {
        portal = mount(
            <Portal className="class-one">
                <p>test</p>
            </Portal>,
            { attachTo: rootElement },
        );
        assert.exists(portal.find(".class-one"));
        portal.setProps({ className: "class-two" });
        assert.exists(portal.find(".class-two"));
    });

    it("respects portalClassName on <PortalProvider> context", () => {
        const CLASS_TO_TEST = "bp-test-klass bp-other-class";
        portal = mount(
            <PortalProvider portalClassName={CLASS_TO_TEST}>
                <Portal>
                    <p>test</p>
                </Portal>
            </PortalProvider>,
            { attachTo: rootElement },
        );

        const portalElement = document.querySelector(`.${CLASS_TO_TEST.replace(" ", ".")}`);
        assert.isTrue(portalElement?.classList.contains(Classes.PORTAL));
    });

    it("does not crash when removing multiple classes from className", () => {
        portal = mount(
            <Portal className="class-one class-two">
                <p>test</p>
            </Portal>,
            { attachTo: rootElement },
        );
        portal.setProps({ className: undefined });
        // no assertion necessary - will crash on incorrect code
    });

    it("does not crash when an empty string is provided for className", () => {
        portal = mount(
            <Portal className="">
                <p>test</p>
            </Portal>,
            { attachTo: rootElement },
        );
        portal.setProps({ className: "class-one" });
        // no assertion necessary - will crash on incorrect code
    });

    it("children mount before onChildrenMount invoked", done => {
        function handleChildrenMount() {
            // can't use `portal` in here as `mount()` has not finished, so we query DOM directly instead
            assert.exists(document.querySelector("p"));
            done();
        }
        portal = mount(
            <Portal onChildrenMount={handleChildrenMount}>
                <p>test</p>
            </Portal>,
            { attachTo: rootElement },
        );
    });

    // TODO: remove legacy context support in Blueprint v6.0
    it("respects blueprintPortalClassName on legacy context", () => {
        const CLASS_TO_TEST = "bp-test-klass bp-other-class";
        portal = mount(
            <Portal>
                <p>test</p>
            </Portal>,
            { attachTo: rootElement, context: { blueprintPortalClassName: CLASS_TO_TEST } },
        );

        const portalElement = document.querySelector(`.${CLASS_TO_TEST.replace(" ", ".")}`);
        assert.isTrue(portalElement?.classList.contains(Classes.PORTAL));
    });
});

================================================================================

File: test\progress\progressBarTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount } from "enzyme";
import * as React from "react";

import { Classes, ProgressBar } from "../../src";

describe("ProgressBar", () => {
    it("renders a PROGRESS_BAR", () => {
        assert.lengthOf(mount(<ProgressBar />).find("." + Classes.PROGRESS_BAR), 1);
    });

    it("does not set width by default", () => {
        const root = mount(<ProgressBar />);
        assert.isUndefined(root.find("." + Classes.PROGRESS_METER).prop("style")!.width);
    });

    it("value sets width percentage", () => {
        const root = mount(<ProgressBar value={0.35} />);
        assert.strictEqual(root.find("." + Classes.PROGRESS_METER).prop("style")!.width, "35%");
    });
});

================================================================================

File: test\resize-sensor\resizeSensorTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, type ReactWrapper } from "enzyme";
import * as React from "react";
import { spy } from "sinon";

import { ResizeSensor, type ResizeSensorProps } from "../../src/components/resize-sensor/resizeSensor";

describe("<ResizeSensor>", () => {
    // this scope variable is assigned in mountResizeSensor() and used in resize()
    let wrapper: ReactWrapper<ResizeTesterProps, any> | undefined;
    const testsContainerElement = document.createElement("div");
    document.documentElement.appendChild(testsContainerElement);

    afterEach(() => {
        // clean up wrapper after each test, if it was used
        wrapper?.unmount();
        wrapper?.detach();
    });

    after(() => testsContainerElement.remove());

    it("onResize is called when size changes", async () => {
        const onResize = spy();
        mountResizeSensor({ onResize });
        await resize({ width: 200 });
        await resize({ height: 100 });
        await resize({ width: 55 });
        assert.equal(onResize.callCount, 3);
        assertResizeArgs(onResize, ["200x0", "200x100", "55x100"]);
    });

    it("onResize is NOT called redundantly when size is unchanged", async () => {
        const onResize = spy();
        mountResizeSensor({ onResize });
        await resize({ width: 200 });
        await resize({ width: 200 }); // this one should be ignored
        assert.equal(onResize.callCount, 1);
        assertResizeArgs(onResize, ["200x0"]);
    });

    it("onResize is called when element changes", async () => {
        const onResize = spy();
        mountResizeSensor({ onResize });
        await resize({ width: 200, id: 1 });
        await resize({ width: 200, id: 2 }); // not ignored bc element recreated
        await resize({ width: 55, id: 3 });
        assertResizeArgs(onResize, ["200x0", "200x0", "55x0"]);
    });

    it("onResize can be changed", async () => {
        const onResize1 = spy();
        mountResizeSensor({ onResize: onResize1 });
        await resize({ width: 200, id: 1 });

        const onResize2 = spy();
        wrapper!.setProps({ onResize: onResize2 });
        await resize({ height: 100, id: 2 });
        await resize({ width: 55, id: 3 });

        assert.equal(onResize1.callCount, 1, "first callback should have been called exactly once");
        assert.equal(onResize2.callCount, 2, "second callback should have been called exactly twice");
    });

    it("still works when user sets their own targetRef", async () => {
        const onResize = spy();
        const targetRef = React.createRef<HTMLElement>();
        const RESIZE_WIDTH = 200;
        mountResizeSensor({ onResize, targetRef });
        await resize({ width: RESIZE_WIDTH });
        assert.equal(onResize.callCount, 1, "onResize should be called");
        assertResizeArgs(onResize, [`${RESIZE_WIDTH}x0`]);
        assert.isNotNull(targetRef.current, "user-provided targetRef should be set");
        assert.strictEqual(targetRef.current?.clientWidth, RESIZE_WIDTH, "user-provided targetRef.current.clientWidth");
    });

    function mountResizeSensor(props: Omit<ResizeSensorProps, "children">) {
        return (wrapper = mount<ResizeTesterProps>(
            <ResizeTester id={0} {...props} />,
            // must be in the DOM for measurement
            { attachTo: testsContainerElement },
        ));
    }

    function resize(size: SizeProps) {
        wrapper!.setProps(size);
        wrapper!.update();
        return new Promise(resolve => setTimeout(resolve, 30));
    }

    function assertResizeArgs(onResize: sinon.SinonSpy, sizes: string[]) {
        assert.sameMembers(
            onResize.args
                .map(args => (args[0] as ResizeObserverEntry[])[0].contentRect)
                .map(r => `${r.width}x${r.height}`),
            sizes,
        );
    }
});

interface SizeProps {
    /** Used as React `key`, so changing it will force a new element to be created. */
    id?: number;
    width?: number;
    height?: number;
}

type ResizeTesterProps = Omit<ResizeSensorProps, "children"> & SizeProps;
const ResizeTester: React.FC<ResizeTesterProps> = ({ id, width, height, ...sensorProps }) => (
    <ResizeSensor {...sensorProps}>
        <div key={id} style={{ width, height }} ref={sensorProps.targetRef as React.RefObject<HTMLDivElement>} />
    </ResizeSensor>
);

================================================================================

File: test\section\sectionTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, type ReactWrapper } from "enzyme";
import * as React from "react";

import { IconNames } from "@blueprintjs/icons";

import { Classes, H5, H6, Section, SectionCard } from "../../src";

describe("<Section>", () => {
    let containerElement: HTMLElement | undefined;

    const isOpenSelector = `[data-icon="${IconNames.CHEVRON_UP}"]`;
    const isClosedSelector = `[data-icon="${IconNames.CHEVRON_DOWN}"]`;

    const assertIsOpen = (wrapper: ReactWrapper) => {
        assert.isTrue(wrapper.find(isOpenSelector).exists());
    };

    const assertIsClosed = (wrapper: ReactWrapper) => {
        assert.isTrue(wrapper.find(isClosedSelector).exists());
    };

    beforeEach(() => {
        containerElement = document.createElement("div");
        document.body.appendChild(containerElement);
    });
    afterEach(() => {
        containerElement?.remove();
    });

    it("supports className", () => {
        const wrapper = mount(<Section className="foo" />, {
            attachTo: containerElement,
        });
        assert.isTrue(wrapper.find(`.${Classes.SECTION}`).hostNodes().exists());
        assert.isTrue(wrapper.find(`.foo`).hostNodes().exists());
    });

    it("supports icon", () => {
        const wrapper = mount(<Section icon={IconNames.GRAPH} title="title" />, {
            attachTo: containerElement,
        });
        assert.isTrue(wrapper.find(`[data-icon="${IconNames.GRAPH}"]`).exists());
    });

    it("renders optional title element", () => {
        const wrapper = mount(<Section title="title" />, {
            attachTo: containerElement,
        });
        assert.isTrue(wrapper.find(H6).exists());
    });

    it("renders optional sub-title element", () => {
        const wrapper = mount(<Section title="title" subtitle="subtitle" />, {
            attachTo: containerElement,
        });
        assert.isTrue(wrapper.find(`.${Classes.SECTION_HEADER_SUB_TITLE}`).hostNodes().exists());
    });

    it("renders custom title element with titleRenderer", () => {
        const wrapper = mount(<Section title="title" titleRenderer={H5} />, {
            attachTo: containerElement,
        });
        assert.isTrue(wrapper.find(H5).exists());
    });

    describe("uncontrolled collapse mode", () => {
        it("collapsible is open when defaultIsOpen={undefined}", () => {
            const wrapper = mount(
                <Section collapsible={true} collapseProps={{ defaultIsOpen: undefined }} title="Test">
                    <SectionCard>is open</SectionCard>
                </Section>,
                { attachTo: containerElement },
            );
            assertIsOpen(wrapper);
        });

        it("collapsible is open when defaultIsOpen={true}", () => {
            const wrapper = mount(
                <Section collapsible={true} collapseProps={{ defaultIsOpen: true }} title="Test">
                    <SectionCard>is open</SectionCard>
                </Section>,
                { attachTo: containerElement },
            );
            assertIsOpen(wrapper);
        });

        it("collapsible is closed when defaultIsOpen={false}", () => {
            const wrapper = mount(
                <Section collapsible={true} collapseProps={{ defaultIsOpen: false }} title="Test">
                    <SectionCard>is closed</SectionCard>
                </Section>,
                { attachTo: containerElement },
            );
            assertIsClosed(wrapper);
        });
    });

    describe("controlled collapse mode", () => {
        it("collapsible is open when isOpen={true}", () => {
            const wrapper = mount(
                <Section collapsible={true} collapseProps={{ isOpen: true }} title="Test">
                    <SectionCard>is open</SectionCard>
                </Section>,
                { attachTo: containerElement },
            );
            assertIsOpen(wrapper);
        });

        it("collapsible is closed when isOpen={false}", () => {
            const wrapper = mount(
                <Section collapsible={true} collapseProps={{ isOpen: false }} title="Test">
                    <SectionCard>is closed</SectionCard>
                </Section>,
                { attachTo: containerElement },
            );
            assertIsClosed(wrapper);
        });
    });
});

================================================================================

File: test\segmented-control\segmentedControlTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount } from "enzyme";
import * as React from "react";

import { Classes, type OptionProps, SegmentedControl } from "../../src";

const OPTIONS: Array<OptionProps<string>> = [
    {
        label: "List",
        value: "list",
    },
    {
        label: "Grid",
        value: "grid",
    },
    {
        label: "Gallery",
        value: "gallery",
    },
];

describe("<SegmentedControl>", () => {
    let containerElement: HTMLElement | undefined;

    beforeEach(() => {
        containerElement = document.createElement("div");
        document.body.appendChild(containerElement);
    });

    afterEach(() => {
        containerElement?.remove();
    });

    describe("basic rendering", () => {
        it("supports className", () => {
            const testClassName = "test-class-name";
            const wrapper = mount(<SegmentedControl className={testClassName} options={OPTIONS} />, {
                attachTo: containerElement,
            });
            assert.isTrue(wrapper.find(`.${Classes.SEGMENTED_CONTROL}`).hostNodes().exists());
            assert.isTrue(wrapper.find(`.${testClassName}`).hostNodes().exists());
        });
    });
});

================================================================================

File: test\slider\handleTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, type ReactWrapper } from "enzyme";
import * as React from "react";
import sinon from "sinon";

import { Handle, type HandleState, type InternalHandleProps } from "../../src/components/slider/handle";

import { DRAG_SIZE, simulateMovement } from "./sliderTestUtils";

const HANDLE_PROPS: InternalHandleProps = {
    disabled: false,
    label: "",
    max: 10,
    min: 0,
    stepSize: 1,
    tickSize: DRAG_SIZE,
    tickSizeRatio: 0.1,
    value: 0,
    vertical: false,
};

describe("<Handle>", () => {
    let testsContainerElement: HTMLElement;

    beforeEach(() => {
        // need an element in the document for tickSize to be a real number
        testsContainerElement = document.createElement("div");
        document.body.appendChild(testsContainerElement);
    });

    afterEach(() => testsContainerElement.remove());

    it("disabled handle never invokes event handlers", () => {
        const eventSpy = sinon.spy();
        const handle = mountHandle(0, { disabled: true, onChange: eventSpy, onRelease: eventSpy });
        simulateMovement(handle, { dragTimes: 3 });
        handle.simulate("keydown", { key: "ArrowUp" });
        assert.isTrue(eventSpy.notCalled);
    });

    describe("keyboard events", () => {
        it("pressing arrow key down reduces value by stepSize", () => {
            const onChange = sinon.spy();
            mountHandle(3, { onChange, stepSize: 2 }).simulate("keydown", { key: "ArrowDown" });
            assert.isTrue(onChange.calledWithExactly(1));
        });

        it("pressing arrow key up increases value by stepSize", () => {
            const onChange = sinon.spy();
            mountHandle(3, { onChange, stepSize: 4 }).simulate("keydown", { key: "ArrowUp" });
            assert.isTrue(onChange.calledWithExactly(7));
        });

        it("releasing arrow key calls onRelease with value", () => {
            const onRelease = sinon.spy();
            mountHandle(3, { onRelease, stepSize: 4 })
                .simulate("keydown", { key: "ArrowUp" })
                .simulate("keyup", { key: "ArrowUp" });
            assert.isTrue(onRelease.calledWithExactly(3));
        });
    });

    [false, true].forEach(vertical => {
        [false, true].forEach(touch => {
            describe(`${vertical ? "vertical " : ""}${touch ? "touch" : "mouse"} events`, () => {
                const options = { touch, vertical, verticalHeight: 0 };
                it("onChange is invoked each time movement changes value", () => {
                    const onChange = sinon.spy();
                    simulateMovement(mountHandle(0, { onChange, vertical }), {
                        dragTimes: 3,
                        ...options,
                    });
                    assert.strictEqual(onChange.callCount, 3);
                    assert.deepEqual(onChange.args, [[1], [2], [3]]);
                });

                it("onChange is not invoked if new value === props.value", () => {
                    const onChange = sinon.spy();
                    // move around same value
                    simulateMovement(mountHandle(0, { onChange, vertical }), {
                        dragSize: 0.1,
                        dragTimes: 4,
                        ...options,
                    });
                    assert.strictEqual(onChange.callCount, 0);
                });

                it("onRelease is invoked once on mouseup", () => {
                    const onRelease = sinon.spy();
                    simulateMovement(mountHandle(0, { onRelease, vertical }), {
                        dragTimes: 3,
                        ...options,
                    });
                    assert.strictEqual(onRelease.callCount, 1);
                    assert.strictEqual(onRelease.args[0][0], 3);
                });

                it("onRelease is invoked if new value === props.value", () => {
                    const onRelease = sinon.spy();
                    simulateMovement(mountHandle(0, { onRelease, vertical }), {
                        dragTimes: 0,
                        ...options,
                    });
                    assert.strictEqual(onRelease.callCount, 1);
                    assert.isTrue(onRelease.calledWithExactly(0));
                });
            });
        });
    });

    function mountHandle(
        value: number,
        props: Partial<InternalHandleProps> = {},
    ): ReactWrapper<InternalHandleProps, HandleState> {
        return mount(<Handle {...HANDLE_PROPS} label={value.toString()} value={value} {...props} />, {
            attachTo: testsContainerElement,
        });
    }
});

================================================================================

File: test\slider\multiSliderTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, type ReactWrapper } from "enzyme";
import * as React from "react";
import * as ReactDOM from "react-dom";
import sinon from "sinon";

import { expectPropValidationError } from "@blueprintjs/test-commons";

import { Classes, MultiSlider, type MultiSliderProps } from "../../src";
import { Handle } from "../../src/components/slider/handle";

import { mouseUpHorizontal, simulateMovement } from "./sliderTestUtils";

const STEP_SIZE = 20;

describe("<MultiSlider>", () => {
    let testsContainerElement: HTMLElement;

    let onChange: sinon.SinonSpy;
    let onRelease: sinon.SinonSpy;

    beforeEach(() => {
        // need an element in the document for tickSize to be a real number
        testsContainerElement = document.createElement("div");
        // default min-max is 0-10 so there are 10 steps
        testsContainerElement.style.width = `${STEP_SIZE * 10}px`;
        document.body.appendChild(testsContainerElement);

        onChange = sinon.spy();
        onRelease = sinon.spy();
    });

    afterEach(() => {
        ReactDOM.unmountComponentAtNode(testsContainerElement);
        testsContainerElement.remove();
    });

    describe("handles", () => {
        it("handle values are automatically sorted", () => {
            const slider = renderSlider({ values: [5, 10, 0], onRelease });
            slider.find(Handle).first().simulate("mousedown", { clientX: 0 });
            mouseUpHorizontal(0);
            assert.equal(onRelease.callCount, 1);
            assert.deepEqual(onRelease.firstCall.args[0], [0, 5, 10]);
        });

        it("propagates className to the handles", () => {
            const slider = mount(
                <MultiSlider>
                    <MultiSlider.Handle value={3} className="testClass" />
                    <MultiSlider.Handle value={5} />
                </MultiSlider>,
                { attachTo: testsContainerElement },
            );
            assert.lengthOf(slider.find("span.testClass"), 1);
        });

        it("moving mouse on the first handle updates the first value", () => {
            const slider = renderSlider({ onChange });
            simulateMovement(slider, { dragSize: STEP_SIZE, dragTimes: 4, handleIndex: 0 });
            // called 3 times for the move to 1, 2, 3, and 4
            assert.equal(onChange.callCount, 4);
            assert.deepEqual(
                onChange.args.map(arg => arg[0]),
                [
                    [1, 5, 10],
                    [2, 5, 10],
                    [3, 5, 10],
                    [4, 5, 10],
                ],
            );
        });

        it("moving mouse on the middle handle updates the middle value", () => {
            const slider = renderSlider({ onChange });
            simulateMovement(slider, {
                dragSize: STEP_SIZE,
                dragTimes: 4,
                from: STEP_SIZE * 5,
                handleIndex: 1,
            });
            // called 3 times for the move to 6, 7, 8, and 9
            assert.equal(onChange.callCount, 4);
            assert.deepEqual(
                onChange.args.map(arg => arg[0]),
                [
                    [0, 6, 10],
                    [0, 7, 10],
                    [0, 8, 10],
                    [0, 9, 10],
                ],
            );
        });

        it("moving mouse on the last handle updates the last value", () => {
            const slider = renderSlider({ onChange });
            simulateMovement(slider, {
                dragSize: -STEP_SIZE,
                dragTimes: 4,
                from: STEP_SIZE * 10,
                handleIndex: 2,
            });
            // called 3 times for the move to 9, 8, 7, and 6
            assert.equal(onChange.callCount, 4);
            assert.deepEqual(
                onChange.args.map(arg => arg[0]),
                [
                    [0, 5, 9],
                    [0, 5, 8],
                    [0, 5, 7],
                    [0, 5, 6],
                ],
            );
        });

        it("releasing mouse on a track value closer to the first handle moves the first handle", () => {
            const slider = renderSlider({ onChange });
            slider.simulate("mousedown", { clientX: STEP_SIZE });
            assert.equal(onChange.callCount, 1);
            assert.deepEqual(onChange.firstCall.args[0], [1, 5, 10]);
        });

        it("releasing mouse on a track value slightly below the middle handle moves the middle handle", () => {
            const slider = renderSlider({ onChange });
            slider.simulate("mousedown", { clientX: STEP_SIZE * 4 });
            assert.equal(onChange.callCount, 1);
            assert.deepEqual(onChange.firstCall.args[0], [0, 4, 10]);
        });

        it("releasing mouse on a track value slightly above the middle handle moves the middle handle", () => {
            const slider = renderSlider({ onChange });
            slider.simulate("mousedown", { clientX: STEP_SIZE * 6 });
            assert.equal(onChange.callCount, 1);
            assert.deepEqual(onChange.firstCall.args[0], [0, 6, 10]);
        });

        it("releasing mouse on a track value closer to the last handle moves the last handle", () => {
            const slider = renderSlider({ onChange });
            slider.simulate("mousedown", { clientX: STEP_SIZE * 9 });
            assert.equal(onChange.callCount, 1);
            assert.deepEqual(onChange.firstCall.args[0], [0, 5, 9]);
        });

        it("when values are equal, releasing mouse on a track still moves the nearest handle", () => {
            const slider = renderSlider({ values: [5, 5, 7], onChange });

            slider.simulate("mousedown", { clientX: STEP_SIZE * 1 });
            assert.equal(onChange.callCount, 1, "one lower handle invokes onChange");
            assert.deepEqual(onChange.firstCall.args[0], [1, 5, 7], "one lower handle moves");
            onChange.resetHistory();

            slider.simulate("mousedown", { clientX: STEP_SIZE * 9 });
            assert.equal(onChange.callCount, 1, "higher handle invokes onChange");
            assert.deepEqual(onChange.firstCall.args[0], [5, 5, 9], "higher handle moves");
        });

        it("values outside of bounds are clamped", () => {
            const slider = renderSlider({ values: [-1, 5, 12] });
            slider.find(`.${Classes.SLIDER_PROGRESS}`).forEach(progress => {
                const { left, right } = progress.prop("style")!;
                // CSS properties are percentage strings, but parsing will ignore trailing "%".
                // percentages should be in 0-100% range.
                assert.isAtLeast(parseFloat(left!.toString()), 0);
                assert.isAtMost(parseFloat(right!.toString()), 100);
            });
        });
    });

    describe("labels", () => {
        it("renders label with labelStepSize fallback of 1 when not provided", () => {
            // [0 1 2 3 4 5]
            const wrapper = renderSlider({ min: 0, max: 5 });
            assertLabelCount(wrapper, 6);
        });

        it("renders label for value and for each labelStepSize", () => {
            // [0  10  20  30  40  50]
            const wrapper = renderSlider({ min: 0, max: 50, labelStepSize: 10 });
            assertLabelCount(wrapper, 6);
        });

        it("renders labels provided in labelValues prop", () => {
            const labelValues = [0, 30, 50, 60];
            const wrapper = renderSlider({ min: 0, max: 50, labelValues });
            assertLabelCount(wrapper, 4);
        });

        it("renders all labels even when floating point approx would cause the last one to be skipped", () => {
            // [0  0.14  0.28  0.42  0.56  0.70]
            const wrapper = renderSlider({ min: 0, max: 0.7, labelStepSize: 0.14 });
            assertLabelCount(wrapper, 6);
        });

        it("renders result of labelRenderer() in each label", () => {
            const labelRenderer = (val: number) => val + "#";
            const wrapper = renderSlider({ min: 0, max: 50, labelStepSize: 10, labelRenderer });
            assert.strictEqual(wrapper.find(`.${Classes.SLIDER}-axis`).text(), "0#10#20#30#40#50#");
        });

        it("renders result of labelRenderer() in each label with labelValues", () => {
            const labelRenderer = (val: number) => val + "#";
            const wrapper = renderSlider({ min: 0, max: 50, labelValues: [20, 40, 50], labelRenderer });
            assert.strictEqual(wrapper.find(`.${Classes.SLIDER}-axis`).text(), "20#40#50#");
        });

        it("default labelRenderer() fixes decimal places to labelPrecision", () => {
            const wrapper = renderSlider({ labelPrecision: 1, values: [0.99 / 10, 1, 1] });
            const firstHandle = wrapper.find(Handle).first();
            assert.strictEqual(firstHandle.text(), "0.1");
        });

        it("infers precision of default labelRenderer from stepSize", () => {
            const wrapper = renderSlider({ stepSize: 0.01 });
            assert.strictEqual(wrapper.state("labelPrecision"), 2);
        });

        it("labelRenderer={false} removes all labels", () => {
            const wrapper = renderSlider({ labelRenderer: false });
            assertLabelCount(wrapper, 0);
        });

        function assertLabelCount(wrapper: ReactWrapper, expected: number) {
            assert.lengthOf(wrapper.find(`.${Classes.SLIDER}-axis`).find(`.${Classes.SLIDER_LABEL}`), expected);
        }
    });

    describe("track", () => {
        let slider: ReactWrapper;
        beforeEach(() => {
            slider = mount(
                <MultiSlider defaultTrackIntent="warning">
                    <MultiSlider.Handle value={3} intentBefore="primary" intentAfter="danger" />
                    <MultiSlider.Handle value={5} intentBefore="primary" intentAfter="danger" />
                    <MultiSlider.Handle value={7} intentBefore="primary" />
                </MultiSlider>,
                { attachTo: testsContainerElement },
            );
        });

        it("progress bars are rendered between all handles", () => {
            // N values = N+1 track segments
            assert.lengthOf(slider.find(`.${Classes.SLIDER_PROGRESS}`), 4);
        });

        it("intentAfter beats intentBefore", () => {
            const intents = slider.find(`.${Classes.SLIDER_PROGRESS}`).map(segment => {
                const match = segment.prop("className")?.match(/-intent-(\w+)/) || [];
                return match[1];
            });
            // last segment has default intent
            assert.deepEqual(intents, ["primary", "danger", "danger", "warning"]);
        });

        it("showTrackFill=false ignores track intents", () => {
            slider.setProps({ showTrackFill: false });
            slider.find(`.${Classes.SLIDER_PROGRESS}`).map(segment => {
                // segments rendered but they nave no intent
                assert.isNull(segment.prop("className")?.match(/-intent-(\w+)/));
            });
        });

        it("track section positioning is correct", () => {
            slider = mount(
                <MultiSlider max={1}>
                    <MultiSlider.Handle value={1.2e-7} intentBefore="warning" intentAfter="warning" />
                    <MultiSlider.Handle value={0.2} intentBefore="danger" intentAfter="success" />
                </MultiSlider>,
            );
            const locations = slider.find(`.${Classes.SLIDER_PROGRESS}`).map(segment => {
                const match = segment.prop("style")!;
                return [match.left, match.right];
            });
            assert.deepEqual(locations, [
                ["0.00%", "100.00%"],
                ["0.00%", "80.00%"],
                ["20.00%", "0.00%"],
            ]);
        });

        it("trackStyleBefore and trackStyleAfter work as intended", () => {
            slider = mount(
                <MultiSlider>
                    <MultiSlider.Handle
                        value={1}
                        trackStyleBefore={{ background: "red" }}
                        trackStyleAfter={{ background: "yellow" }}
                    />
                    <MultiSlider.Handle
                        value={2}
                        trackStyleBefore={{ background: "blue" }}
                        trackStyleAfter={{ background: "purple" }}
                    />
                </MultiSlider>,
            );

            const trackBackgrounds = slider
                .find(`.${Classes.SLIDER_PROGRESS}`)
                .map(segment => segment.prop("style")?.background);

            assert.equal(trackBackgrounds[0], "red");
            assert.equal(trackBackgrounds[1], "yellow");
            assert.equal(trackBackgrounds[2], "purple");
        });
    });

    describe("validation", () => {
        it("throws an error if a child is not a slider handle", () => {
            expectPropValidationError(MultiSlider, { children: (<span>Bad</span>) as any });
        });

        it("throws error if stepSize <= 0", () => {
            [0, -10].forEach(stepSize => {
                expectPropValidationError(MultiSlider, { stepSize }, "greater than zero");
            });
        });

        it("throws error if labelStepSize <= 0", () => {
            [0, -10].forEach(labelStepSize => {
                expectPropValidationError(MultiSlider, { labelStepSize }, "greater than zero");
            });
        });

        it("throws an error if the min value is not finite", () => {
            expectPropValidationError(
                MultiSlider,
                { min: Number.NEGATIVE_INFINITY },
                "min prop must be a finite number",
            );
        });

        it("throws an error if the max value is not finite", () => {
            expectPropValidationError(
                MultiSlider,
                { max: Number.POSITIVE_INFINITY },
                "max prop must be a finite number",
            );
        });
    });

    function renderSlider(joinedProps: MultiSliderProps & { values?: [number, number, number] } = {}) {
        const { values = [0, 5, 10], ...props } = joinedProps;
        return mount(
            <MultiSlider {...props}>
                <MultiSlider.Handle value={values[0]} />
                <MultiSlider.Handle value={values[1]} />
                <MultiSlider.Handle value={values[2]} />
            </MultiSlider>,
            { attachTo: testsContainerElement },
        );
    }
});

================================================================================

File: test\slider\rangeSliderTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount } from "enzyme";
import * as React from "react";
import sinon from "sinon";

import { expectPropValidationError } from "@blueprintjs/test-commons";

import { Classes, RangeSlider } from "../../src";
import { Handle } from "../../src/components/slider/handle";

const STEP_SIZE = 20;

describe("<RangeSlider>", () => {
    let testsContainerElement: HTMLElement;

    beforeEach(() => {
        // need an element in the document for tickSize to be a real number
        testsContainerElement = document.createElement("div");
        // default min-max is 0-10 so there are 10 steps
        testsContainerElement.style.width = `${STEP_SIZE * 10}px`;
        document.body.appendChild(testsContainerElement);
    });

    afterEach(() => testsContainerElement.remove());

    it("renders two interactive <Handle>s", () => {
        const handles = renderSlider(<RangeSlider />).find(Handle);
        assert.lengthOf(handles, 2);
    });

    it("renders primary track segment between two values", () => {
        const track = renderSlider(<RangeSlider value={[2, 5]} />).find(
            `.${Classes.SLIDER_PROGRESS}.${Classes.INTENT_PRIMARY}`,
        );
        assert.lengthOf(track, 1);
        assert.equal(track.getDOMNode().getBoundingClientRect().width, STEP_SIZE * 3);
    });

    it("throws error if range value contains null", () => {
        expectPropValidationError(RangeSlider, {
            // @ts-expect-error
            value: [null, 5],
        });
        expectPropValidationError(RangeSlider, {
            // @ts-expect-error
            value: [100, null],
        });
    });

    it("disabled slider does not respond to key presses", () => {
        const changeSpy = sinon.spy();
        const handles = renderSlider(<RangeSlider disabled={true} onChange={changeSpy} />).find(Handle);
        handles.first().simulate("keydown", { key: "ArrowDown" });
        handles.last().simulate("keydown", { key: "ArrowDown" });
        assert.isTrue(changeSpy.notCalled, "onChange was called when disabled");
    });

    function renderSlider(slider: React.JSX.Element) {
        return mount(slider, { attachTo: testsContainerElement });
    }
});

================================================================================

File: test\slider\sliderTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount } from "enzyme";
import * as React from "react";
import sinon from "sinon";

import { Classes, Slider } from "../../src";
import { Handle } from "../../src/components/slider/handle";

import { simulateMovement } from "./sliderTestUtils";

const STEP_SIZE = 20;
const TRACK_SELECTOR = `.${Classes.SLIDER_TRACK}`;

describe("<Slider>", () => {
    let testsContainerElement: HTMLElement;

    beforeEach(() => {
        // need an element in the document for tickSize to be a real number
        testsContainerElement = document.createElement("div");
        // default min-max is 0-10 so there are 10 steps
        testsContainerElement.style.width = `${STEP_SIZE * 10}px`;
        document.body.appendChild(testsContainerElement);
    });

    afterEach(() => testsContainerElement.remove());

    it("renders one interactive <Handle>", () => {
        const handles = renderSlider(<Slider />).find(Handle);
        assert.lengthOf(handles, 1);
    });

    it("renders primary track segment between initialValue and value", () => {
        const tracks = renderSlider(<Slider showTrackFill={true} initialValue={2} value={5} />).find(
            `.${Classes.SLIDER_PROGRESS}.${Classes.INTENT_PRIMARY}`,
        );
        assert.lengthOf(tracks, 1);
        assert.equal(tracks.getDOMNode().getBoundingClientRect().width, STEP_SIZE * 3);
    });

    it("renders primary track segment between initialValue and value when value is less than initial value", () => {
        const tracks = renderSlider(<Slider showTrackFill={true} initialValue={5} value={2} />).find(
            `.${Classes.SLIDER_PROGRESS}.${Classes.INTENT_PRIMARY}`,
        );
        assert.lengthOf(tracks, 1);
        assert.equal(tracks.getDOMNode().getBoundingClientRect().width, STEP_SIZE * 3);
    });

    it("renders no primary track segment when value equals initial value", () => {
        const tracks = renderSlider(<Slider showTrackFill={true} initialValue={2} value={2} min={0} max={5} />).find(
            `.${Classes.SLIDER_PROGRESS}.${Classes.INTENT_PRIMARY}`,
        );
        assert.lengthOf(tracks, 0);
    });

    it("renders result of labelRenderer() in each label and differently in handle", () => {
        const labelRenderer = (val: number, opts?: { isHandleTooltip: boolean }) =>
            val + (opts?.isHandleTooltip ? "!" : "#");
        const wrapper = renderSlider(
            <Slider min={0} max={50} value={10} labelStepSize={10} labelRenderer={labelRenderer} />,
        );
        assert.strictEqual(wrapper.find(`.${Classes.SLIDER}-axis`).text(), "0#10#20#30#40#50#");
        assert.strictEqual(wrapper.find(`.${Classes.SLIDER_HANDLE}`).find(`.${Classes.SLIDER_LABEL}`).text(), "10!");
    });

    it("moving mouse calls onChange with nearest value", () => {
        const changeSpy = sinon.spy();
        simulateMovement(renderSlider(<Slider onChange={changeSpy} />), {
            dragSize: STEP_SIZE,
            dragTimes: 4,
        });
        // called 4 times, for the move to 1, 2, 3, and 4
        assert.equal(changeSpy.callCount, 4, "call count");
        assert.deepEqual(changeSpy.args, [[1], [2], [3], [4]]);
    });

    it("releasing mouse calls onRelease with nearest value", () => {
        const releaseSpy = sinon.spy();
        simulateMovement(renderSlider(<Slider onRelease={releaseSpy} />), {
            dragSize: STEP_SIZE,
            dragTimes: 1,
        });
        assert.isTrue(releaseSpy.calledOnce, "onRelease not called exactly once");
        assert.equal(releaseSpy.args[0][0], 1);
    });

    it("disabled slider never invokes event handlers", () => {
        const eventSpy = sinon.spy();
        const slider = renderSlider(<Slider disabled={true} onChange={eventSpy} onRelease={eventSpy} />);
        // handle drag and keys
        simulateMovement(slider, { dragTimes: 3 });
        slider.simulate("keydown", { key: "ArrowUp" });
        // track click
        slider
            .find(TRACK_SELECTOR)
            .simulate("mousedown", { target: testsContainerElement.querySelector(TRACK_SELECTOR) });
        assert.isTrue(eventSpy.notCalled);
    });

    function renderSlider(slider: React.JSX.Element) {
        return mount(slider, { attachTo: testsContainerElement });
    }
});

================================================================================

File: test\slider\sliderTestUtils.ts
--------------------------------------------------------------------------------
/*
 * Copyright 2018 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ReactWrapper } from "enzyme";

import { dispatchMouseEvent, dispatchTouchEvent } from "@blueprintjs/test-commons";

import { Handle, type InternalHandleProps } from "../../src/components/slider/handle";

interface MoveOptions {
    /** Size in pixels of one drag event. Direction of drag is determined by `vertical` option. */
    dragSize?: number;
    /** Number of drag events of length `dragSize` to perform. */
    dragTimes: number;
    /** Initial pixel of drag operation: where the mouse is initially pressed. */
    from?: number;
    /** Index of `Handle` to move. */
    handleIndex?: number;
    /** Whether to use touch events. */
    touch?: boolean;
    /** Whether to use vertical events. */
    vertical?: boolean;
    /** Height of slider when vertical. */
    verticalHeight?: number;
}

export const DRAG_SIZE = 20;

/**
 * Simulates a full move of a slider handle: engage, move, release.
 * Supports touch and vertical events. Use options to configure exact movement.
 */
export function simulateMovement(wrapper: ReactWrapper<InternalHandleProps>, options: MoveOptions) {
    const { from = 0, handleIndex = 0, touch = false } = options;
    const handle = wrapper.find(Handle).at(handleIndex);
    const eventData =
        options.vertical !== undefined && options.verticalHeight !== undefined
            ? { clientY: options.verticalHeight - from }
            : { clientX: from };
    if (touch) {
        handle.simulate("touchstart", { changedTouches: [eventData] });
    } else {
        handle.simulate("mousedown", eventData);
    }
    genericMove(options);
    genericRelease(options);
    return wrapper;
}

/** Release the mouse at the given clientX pixel. Useful for ending a drag interaction. */
export const mouseUpHorizontal = (clientX: number) => genericRelease({ dragTimes: 0, from: clientX });

// Private helpers
// ===============

function genericMove(options: MoveOptions) {
    const { dragSize = DRAG_SIZE, from = 0, dragTimes = 1, touch } = options;
    const eventName = touch ? "touchmove" : "mousemove";
    for (let i = 0; i < dragTimes; i += 1) {
        const clientPixel = from + i * dragSize;
        dispatchEvent(options, eventName, clientPixel);
    }
}

function genericRelease(options: MoveOptions) {
    const { dragSize = DRAG_SIZE, from = 0, dragTimes = 1, touch } = options;
    const eventName = touch ? "touchend" : "mouseup";
    const clientPixel = from + dragTimes * dragSize;
    dispatchEvent(options, eventName, clientPixel);
}

function dispatchEvent(options: MoveOptions, eventName: string, clientPixel: number) {
    const { touch, vertical, verticalHeight = 0 } = options;
    const dispatchFn = touch ? dispatchTouchEvent : dispatchMouseEvent;
    if (vertical) {
        // vertical sliders go from bottom-up, so everything is backward
        dispatchFn(document, eventName, undefined, verticalHeight - clientPixel);
    } else {
        dispatchFn(document, eventName, clientPixel, undefined);
    }
}

================================================================================

File: test\spinner\spinnerTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, type ReactWrapper, shallow } from "enzyme";
import * as React from "react";
import { stub } from "sinon";

import { Classes, Spinner, SpinnerSize } from "../../src";
import { SPINNER_WARN_CLASSES_SIZE } from "../../src/common/errors";

describe("Spinner", () => {
    it("renders a spinner and two paths", () => {
        const root = mount(<Spinner />);
        assert.lengthOf(root.find(`.${Classes.SPINNER}`), 1);
        assert.lengthOf(root.find("path"), 2);
    });

    describe("accessibility", () => {
        it("sets 'aria-valuenow' attribute", () => {
            const VALUE = 0.4;
            const spinner = shallow(<Spinner value={VALUE} />);
            assert.strictEqual(spinner.prop("aria-valuenow"), VALUE * 100);
        });

        it("supports arbitrary ARIA HTML attributes", () => {
            const LABEL = "widget loading";
            const spinner = shallow(<Spinner aria-label={LABEL} />);
            assert.strictEqual(spinner.prop("aria-label"), LABEL);
        });
    });

    it("tagName determines both container elements", () => {
        const tagName = "article";
        const root = mount(<Spinner tagName={tagName} />);
        assert.isTrue(root.is({ tagName }));
        assert.lengthOf(root.find(tagName), 2);
    });

    it("Classes.LARGE/SMALL determine default size", () => {
        const root = mount(<Spinner className={Classes.SMALL} />);
        assert.equal(root.find("svg").prop("height"), SpinnerSize.SMALL, "small");

        root.setProps({ className: Classes.LARGE });
        assert.equal(root.find("svg").prop("height"), SpinnerSize.LARGE, "large");
    });

    it("size overrides Classes.LARGE/SMALL", () => {
        const warnSpy = stub(console, "warn");
        const root = mount(<Spinner className={Classes.SMALL} size={32} />);
        assert.equal(root.find("svg").prop("height"), 32, "size prop");
        assert.equal(warnSpy.args[0][0], SPINNER_WARN_CLASSES_SIZE);
        warnSpy.restore();
    });

    it("defaults to spinning quarter circle", () => {
        const root = mount(<Spinner />);
        assert.isFalse(root.find(`.${Classes.SPINNER}`).hasClass(Classes.SPINNER_NO_SPIN));
        assertStrokePercent(root, 0.25);
    });

    it("value sets stroke-dashoffset", () => {
        // dash offset = X * (1 - value)
        const root = mount(<Spinner value={0.35} />);
        assert.isTrue(
            root.find(`.${Classes.SPINNER}`).hasClass(Classes.SPINNER_NO_SPIN),
            `missing class ${Classes.SPINNER_NO_SPIN}`,
        );
        assertStrokePercent(root, 0.35);
    });

    it("viewBox adjusts based on size", () => {
        function viewBox(size: number) {
            return mount(<Spinner size={size} />)
                .find("svg")
                .prop("viewBox");
        }
        assert.notEqual(viewBox(SpinnerSize.SMALL), viewBox(SpinnerSize.LARGE), "expected different viewBoxes");
    });

    function assertStrokePercent(wrapper: ReactWrapper<any>, percent: number) {
        const head = wrapper.find(`.${Classes.SPINNER_HEAD}`);
        // NOTE: strokeDasharray is string "X X", but parseInt terminates at non-numeric character
        const pathLength = parseInt(head.prop("strokeDasharray")!.toString(), 10);
        const offset = head.prop("strokeDashoffset");
        assert.strictEqual(offset, pathLength * (1 - percent));
    }
});

================================================================================

File: test\tabs\tabsTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, type ReactWrapper } from "enzyme";
import * as React from "react";
import { spy } from "sinon";

import { Classes } from "../../src/common";
import { Tab } from "../../src/components/tabs/tab";
import { Tabs, type TabsProps, type TabsState } from "../../src/components/tabs/tabs";
import { generateTabPanelId, generateTabTitleId } from "../../src/components/tabs/tabTitle";

describe("<Tabs>", () => {
    const ID = "tabsTests";
    // default tabs content is generated from these Dsin each test
    const TAB_IDS = ["first", "second", "third"];

    // selectors using ARIA role
    const TAB_SELECTOR = "[role='tab']";
    const TAB_LIST_SELECTOR = "[role='tablist']";
    const TAB_PANEL_SELECTOR = "[role='tabpanel']";

    let testsContainerElement: HTMLElement;

    beforeEach(() => {
        testsContainerElement = document.createElement("div");
        document.body.appendChild(testsContainerElement);
    });

    afterEach(() => testsContainerElement.remove());

    it("gets by without children", () => {
        assert.doesNotThrow(() => mount(<Tabs id="childless" />));
    });

    it("supports non-existent children", () => {
        assert.doesNotThrow(() =>
            mount(
                <Tabs id={ID}>
                    {null}
                    <Tab id="one" />
                    {undefined}
                    <Tab id="two" />
                </Tabs>,
            ),
        );
    });

    it("default selectedTabId is first non-null Tab id", () => {
        const wrapper = mount(
            <Tabs id={ID}>
                {null}
                {<button id="btn" />}
                {getTabsContents()}
            </Tabs>,
        );
        assert.lengthOf(wrapper.find(TAB_SELECTOR), 3);
        assert.strictEqual(wrapper.state("selectedTabId"), TAB_IDS[0]);
    });

    it("renders one TabTitle and one TabPanel for each Tab, aria roles are correct", () => {
        const wrapper = mount(<Tabs id={ID}>{getTabsContents()}</Tabs>);
        assert.lengthOf(wrapper.find(TAB_SELECTOR), 3);
        assert.lengthOf(wrapper.find(TAB_LIST_SELECTOR), 1);
        assert.lengthOf(wrapper.find(TAB_PANEL_SELECTOR), 3);
    });

    it("renders all Tab children, active is not aria-hidden", () => {
        const activeIndex = 1;
        const wrapper = mount(<Tabs id={ID}>{getTabsContents()}</Tabs>);
        wrapper.setState({ selectedTabId: TAB_IDS[activeIndex] });
        const tabPanels = wrapper.find(TAB_PANEL_SELECTOR);
        assert.lengthOf(tabPanels, 3);
        for (let i = 0; i < TAB_IDS.length; i++) {
            // hidden unless it is active
            assert.equal(tabPanels.at(i).prop("aria-hidden"), i !== activeIndex);
        }
    });

    it(`renders without ${Classes.LARGE} when by default`, () => {
        const wrapper = mount(<Tabs id={ID}>{getTabsContents()}</Tabs>);
        assert.lengthOf(wrapper.find(`${TAB_LIST_SELECTOR}.${Classes.LARGE}`), 0);
    });

    it(`renders using ${Classes.LARGE} when large={true}`, () => {
        const wrapper = mount(
            <Tabs id={ID} large={true}>
                {getTabsContents()}
            </Tabs>,
        );
        assert.lengthOf(wrapper.find(`${TAB_LIST_SELECTOR}.${Classes.LARGE}`), 1);
    });

    it("attaches className to both tab and panel container if set", () => {
        const tabClassName = "tabClassName";
        const wrapper = mount(
            <Tabs id={ID}>
                <Tab id="first" title="First" className={tabClassName} panel={<Panel title="first" />} />
                ,
                <Tab id="second" title="Second" className={tabClassName} panel={<Panel title="second" />} />
                ,
                <Tab id="third" title="Third" className={tabClassName} panel={<Panel title="third" />} />,
            </Tabs>,
        );
        const NUM_TABS = 3;
        assert.lengthOf(wrapper.find(TAB_SELECTOR), NUM_TABS);
        assert.lengthOf(wrapper.find(TAB_PANEL_SELECTOR), NUM_TABS);
        assert.lengthOf(wrapper.find(`.${tabClassName}`).hostNodes(), NUM_TABS * 2);
    });

    it("attaches panelClassName to panel container if set", () => {
        const panelClassName = "secondPanelClassName";
        const wrapper = mount(
            <Tabs id={ID}>
                <Tab id="first" title="First" panel={<Panel title="first" />} />,
                <Tab id="second" title="Second" panelClassName={panelClassName} panel={<Panel title="second" />} />
                ,
                <Tab id="third" title="Third" panel={<Panel title="third" />} />,
            </Tabs>,
        );
        const NUM_TABS = 3;
        assert.lengthOf(wrapper.find(TAB_SELECTOR), NUM_TABS);
        assert.lengthOf(wrapper.find(TAB_PANEL_SELECTOR), NUM_TABS);
        assert.lengthOf(wrapper.find(`.${panelClassName}`), 1);
    });

    it("passes correct tabTitleId and tabPanelId to panel renderer", () => {
        mount(
            <Tabs id={ID}>
                <Tab
                    id="first"
                    panel={({ tabTitleId, tabPanelId }) => {
                        assert.equal(tabTitleId, generateTabTitleId(ID, "first"));
                        assert.equal(tabPanelId, generateTabPanelId(ID, "first"));
                        return <Panel title="a" />;
                    }}
                />
            </Tabs>,
        );
    });

    it("renderActiveTabPanelOnly only renders active tab panel", () => {
        const wrapper = mount(
            <Tabs id={ID} renderActiveTabPanelOnly={true}>
                {getTabsContents()}
            </Tabs>,
        );
        for (const selectedTabId of TAB_IDS) {
            wrapper.setState({ selectedTabId });
            assert.lengthOf(wrapper.find("strong"), 1);
        }
    });

    it("sets aria-* attributes with matching IDs", () => {
        const wrapper = mount(<Tabs id={ID}>{getTabsContents()}</Tabs>);
        wrapper.find(TAB_SELECTOR).forEach(title => {
            // title "controls" tab element
            const titleControls = title.prop("aria-controls");
            const tab = wrapper.find(`#${titleControls}`);
            // tab element "labelled by" title element
            assert.isTrue(tab.is(TAB_PANEL_SELECTOR), "aria-controls isn't TAB_PANEL");
            assert.deepEqual(tab.prop("aria-labelledby"), title.prop("id"), "mismatched IDs");
        });
    });

    it("sets arbitrary data-* attributes on Tab elements", () => {
        const tabs = TAB_IDS.map(id => (
            <Tab id={id} key={id} panel={<Panel title={id} />} title={id} data-arbitrary-attr="foo" />
        ));
        const wrapper = mount(<Tabs id={ID}>{tabs}</Tabs>);
        wrapper.find(TAB_SELECTOR).forEach(title => {
            assert.strictEqual((title.getDOMNode() as HTMLElement).getAttribute("data-arbitrary-attr"), "foo");
        });
    });

    it("clicking selected tab still fires onChange", () => {
        const tabId = TAB_IDS[0];
        const changeSpy = spy();
        const wrapper = mount(
            <Tabs defaultSelectedTabId={tabId} id={ID} onChange={changeSpy}>
                {getTabsContents()}
            </Tabs>,
            { attachTo: testsContainerElement },
        );
        findTabById(wrapper, tabId).simulate("click");
        assert.isTrue(changeSpy.calledWith(tabId, tabId));
    });

    it("clicking nested tab should not affect parent", () => {
        const changeSpy = spy();
        const wrapper = mount(
            <Tabs id={ID} onChange={changeSpy}>
                {getTabsContents()}
                <Tabs id="nested">
                    <Tab id="last" title="Click me" />
                </Tabs>
            </Tabs>,
            { attachTo: testsContainerElement },
        );
        assert.equal(wrapper.state("selectedTabId"), TAB_IDS[0]);
        // last Tab is inside nested
        wrapper.find(TAB_SELECTOR).last().simulate("click");
        assert.equal(wrapper.state("selectedTabId"), TAB_IDS[0]);
        assert.isTrue(changeSpy.notCalled, "onChange invoked");
    });

    it("changes tab focus when arrow keys are pressed", () => {
        const wrapper = mount(
            <Tabs id={ID}>
                <Tab id="first" title="First" panel={<Panel title="first" />} />,
                <Tab disabled={true} id="second" title="Second" panel={<Panel title="second" />} />,
                <Tab id="third" title="Third" panel={<Panel title="third" />} />,
            </Tabs>,
            { attachTo: testsContainerElement },
        );

        const tabList = wrapper.find(TAB_LIST_SELECTOR);
        const tabElements = testsContainerElement.querySelectorAll<HTMLElement>(TAB_SELECTOR);
        tabElements[0].focus();

        tabList.simulate("keydown", { key: "ArrowRight" });
        assert.equal(document.activeElement, tabElements[2], "move right and skip disabled");
        tabList.simulate("keydown", { key: "ArrowRight" });
        assert.equal(document.activeElement, tabElements[0], "wrap around to first tab");
        tabList.simulate("keydown", { key: "ArrowLeft" });
        assert.equal(document.activeElement, tabElements[2], "wrap around to last tab");
        tabList.simulate("keydown", { key: "ArrowLeft" });
        assert.equal(document.activeElement, tabElements[0], "move left and skip disabled");
    });

    it("enter and space keys click focused tab", () => {
        const changeSpy = spy();
        const wrapper = mount(
            <Tabs id={ID} onChange={changeSpy}>
                {getTabsContents()}
            </Tabs>,
            { attachTo: testsContainerElement },
        );
        const tabList = wrapper.find(TAB_LIST_SELECTOR);
        const tabElements = testsContainerElement.querySelectorAll<HTMLElement>(TAB_SELECTOR);

        // must target different elements each time as onChange is only called when id changes
        tabList.simulate("keypress", { target: tabElements[1], key: "Enter" });
        tabList.simulate("keypress", { target: tabElements[2], key: " " });

        assert.equal(changeSpy.callCount, 2);
        assert.includeDeepMembers(changeSpy.args[0], [TAB_IDS[1], TAB_IDS[0]]);
        assert.includeDeepMembers(changeSpy.args[1], [TAB_IDS[2], TAB_IDS[1]]);
    });

    it("animate=false removes moving indicator element", () => {
        const wrapper = mount<Tabs>(
            <Tabs id={ID} animate={false}>
                {getTabsContents()}
            </Tabs>,
        );
        assert.isUndefined(wrapper.state().indicatorWrapperStyle);
        assert.equal(wrapper.find(`.${Classes.TAB_INDICATOR}`).length, 0);
    });

    it("removes indicator element when selected tab is removed", () => {
        const wrapper = mount<Tabs>(<Tabs id={ID}>{getTabsContents()}</Tabs>);
        // first tab is selected by default. now remove it.
        const tabIdsWithoutFirstTab = TAB_IDS.slice(1);
        wrapper.setProps({ children: getTabsContents(tabIdsWithoutFirstTab) });
        const indicatorStyle = wrapper.state().indicatorWrapperStyle;
        assert.deepEqual(indicatorStyle, { display: "none" }, "indicator should be hidden");
    });

    it("leaves indicator element in place when non-selected tab is removed", () => {
        const wrapper = mount(<Tabs id={ID}>{getTabsContents()}</Tabs>);
        // first tab is selected by default. now remove the last one.
        const lastTabIndex = TAB_IDS.length - 1;
        const tabIdsWithoutLastTab = TAB_IDS.slice(0, lastTabIndex - 1);
        wrapper.setProps({ children: getTabsContents(tabIdsWithoutLastTab) });
        assertIndicatorPosition(wrapper, "first");
    });

    describe("when state is managed internally", () => {
        const TAB_ID_TO_SELECT = TAB_IDS[1];

        it("defaultSelectedTabId is initially selected", () => {
            const wrapper = mount(
                <Tabs id={ID} defaultSelectedTabId={TAB_ID_TO_SELECT}>
                    {getTabsContents()}
                </Tabs>,
            );
            assert.isTrue(findTabById(wrapper, TAB_ID_TO_SELECT).prop("aria-selected"));
        });

        it("unknown tab ID hides moving indicator element", () => {
            const wrapper = mount<Tabs>(
                <Tabs id={ID} defaultSelectedTabId="unknown">
                    {getTabsContents()}
                </Tabs>,
            );
            const style = wrapper.state().indicatorWrapperStyle;
            assert.deepEqual(style, { display: "none" });
        });

        it("does not reset selected tab to defaultSelectedTabId after a selection is made", () => {
            const wrapper = mount(
                <Tabs id={ID} defaultSelectedTabId={TAB_ID_TO_SELECT}>
                    {getTabsContents()}
                </Tabs>,
            );
            findTabById(wrapper, TAB_ID_TO_SELECT).simulate("click");
            wrapper.update();
            assert.isTrue(findTabById(wrapper, TAB_ID_TO_SELECT).prop("aria-selected"));
        });

        it("invokes onChange() callback", () => {
            const onChangeSpy = spy();
            const wrapper = mount(
                <Tabs id={ID} onChange={onChangeSpy}>
                    {getTabsContents()}
                </Tabs>,
            );

            findTabById(wrapper, TAB_ID_TO_SELECT).simulate("click");
            assert.isTrue(onChangeSpy.calledOnce);
            // initial selection is first tab
            assert.isTrue(onChangeSpy.calledWith(TAB_ID_TO_SELECT, TAB_IDS[0]));
        });

        it("moves indicator as expected", () => {
            const wrapper = mount(<Tabs id={ID}>{getTabsContents()}</Tabs>);
            assertIndicatorPosition(wrapper, TAB_IDS[0]);

            wrapper.setProps({ selectedTabId: TAB_ID_TO_SELECT });
            assertIndicatorPosition(wrapper, TAB_ID_TO_SELECT);
        });
    });

    describe("when state is managed externally (selectedTabId prop is provided)", () => {
        const TAB_ID_TO_SELECT = TAB_IDS[1];
        const SELECTED_TAB_ID = TAB_IDS[2];

        it("prefers selectedTabId over defaultSelectedTabId", () => {
            const tabs = mount(
                <Tabs id={ID} defaultSelectedTabId={TAB_ID_TO_SELECT} selectedTabId={SELECTED_TAB_ID}>
                    {getTabsContents()}
                </Tabs>,
            );
            assert.strictEqual(tabs.state("selectedTabId"), SELECTED_TAB_ID);
        });

        it("selects nothing if invalid id provided", () => {
            const tabs = mount(
                <Tabs id={ID} selectedTabId="unknown">
                    {getTabsContents()}
                </Tabs>,
            );

            assert.strictEqual(tabs.state("selectedTabId"), "unknown");
            assert.isFalse(tabs.find("[aria-selected=true]").exists(), "a tab was selected");
        });

        it("invokes onChange() callback but does not change state", () => {
            const onChangeSpy = spy();
            const tabs = mount(
                <Tabs id={ID} selectedTabId={SELECTED_TAB_ID} onChange={onChangeSpy}>
                    {getTabsContents()}
                </Tabs>,
            );

            findTabById(tabs, TAB_ID_TO_SELECT).simulate("click");
            assert.isTrue(onChangeSpy.calledOnce);
            // old selection is 0
            assert.includeDeepMembers(onChangeSpy.args[0], [TAB_ID_TO_SELECT, SELECTED_TAB_ID]);
            assert.deepEqual(tabs.state("selectedTabId"), SELECTED_TAB_ID);
        });

        it("state is synced with selectedTabId prop", () => {
            const tabs = mount(
                <Tabs id={ID} selectedTabId={SELECTED_TAB_ID}>
                    {getTabsContents()}
                </Tabs>,
            );
            assert.deepEqual(tabs.state("selectedTabId"), SELECTED_TAB_ID);
            tabs.setProps({ selectedTabId: TAB_ID_TO_SELECT });
            tabs.update();
            assert.deepEqual(tabs.state("selectedTabId"), TAB_ID_TO_SELECT);
        });

        it("indicator moves correctly if tabs switch externally via the selectedTabId prop", done => {
            const wrapper = mount(
                <Tabs id={ID} selectedTabId={SELECTED_TAB_ID}>
                    {getTabsContents()}
                </Tabs>,
                { attachTo: testsContainerElement },
            );
            wrapper.setProps({ selectedTabId: TAB_ID_TO_SELECT });
            wrapper.update();
            // indicator moves via componentDidUpdate
            setTimeout(() => {
                assertIndicatorPosition(wrapper, TAB_ID_TO_SELECT);
                done();
            });
        });
    });

    function findTabById(wrapper: ReactWrapper<TabsProps>, id: string) {
        // Need this to get the right overload signature
        // eslint-disable-line @typescript-eslint/consistent-type-assertions
        return wrapper.find(TAB_SELECTOR).filter({ "data-tab-id": id } as React.HTMLAttributes<HTMLElement>);
    }

    function assertIndicatorPosition(wrapper: ReactWrapper<TabsProps, TabsState>, selectedTabId: string) {
        const style = wrapper.state().indicatorWrapperStyle;
        assert.isDefined(style, "Tabs should have a indicatorWrapperStyle prop set");
        const node = wrapper.getDOMNode();
        const expected = node.querySelector<HTMLLIElement>(
            `${TAB_SELECTOR}[data-tab-id='${selectedTabId}']`,
        )!.offsetLeft;
        assert.isTrue(style?.transform?.indexOf(`${expected}px`) !== -1, "indicator has not moved correctly");
    }

    function getTabsContents(tabIds: string[] = TAB_IDS): Array<React.ReactElement<any>> {
        return tabIds.map(id => <Tab id={id} key={id} panel={<Panel title={id} />} title={id} />);
    }
});

const Panel: React.FC<{ title: string }> = ({ title }) => <strong>{title} panel</strong>;

================================================================================

File: test\tag\compoundTagTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, shallow } from "enzyme";
import * as React from "react";
import { spy } from "sinon";

import { Classes, CompoundTag, Icon } from "../../src";

describe("<CompoundTag>", () => {
    it("renders its text", () => {
        assert.strictEqual(
            shallow(<CompoundTag leftContent="Hello">World</CompoundTag>)
                .find(`.${Classes.COMPOUND_TAG_RIGHT_CONTENT}`)
                .prop("children"),
            "World",
        );
    });

    it("renders icons", () => {
        const wrapper = shallow(
            <CompoundTag icon="tick" rightIcon="airplane" leftContent="Hello">
                World
            </CompoundTag>,
        );
        assert.lengthOf(wrapper.find(Icon), 2);
    });

    it("renders close button when onRemove is a function", () => {
        const wrapper = mount(
            <CompoundTag onRemove={spy()} leftContent="Hello">
                World
            </CompoundTag>,
        );
        assert.lengthOf(wrapper.find(`.${Classes.TAG_REMOVE}`), 1);
    });

    it("clicking close button triggers onRemove", () => {
        const handleRemove = spy();
        mount(
            <CompoundTag onRemove={handleRemove} leftContent="Hello">
                World
            </CompoundTag>,
        )
            .find(`.${Classes.TAG_REMOVE}`)
            .simulate("click");
        assert.isTrue(handleRemove.calledOnce);
    });

    it(`passes other props onto .${Classes.COMPOUND_TAG} element`, () => {
        const element = mount(
            <CompoundTag title="baz qux" leftContent="Hello">
                World
            </CompoundTag>,
        ).find(`.${Classes.COMPOUND_TAG}`);
        assert.deepEqual(element.prop("title"), "baz qux");
    });

    it("passes all props to the onRemove handler", () => {
        const handleRemove = spy();
        const DATA_ATTR_FOO = "data-foo";
        const tagProps = {
            onRemove: handleRemove,
            [DATA_ATTR_FOO]: {
                bar: "baz",
                foo: 5,
            },
        };
        mount(
            <CompoundTag {...tagProps} leftContent="Hello">
                World
            </CompoundTag>,
        )
            .find(`.${Classes.TAG_REMOVE}`)
            .simulate("click");
        assert.isTrue(handleRemove.args.length > 0 && handleRemove.args[0].length === 2);
        assert.isTrue(handleRemove.args[0][1][DATA_ATTR_FOO] !== undefined);
        assert.deepEqual(handleRemove.args[0][1][DATA_ATTR_FOO], tagProps[DATA_ATTR_FOO]);
    });

    it("supports ref objects", done => {
        const elementRef = React.createRef<HTMLSpanElement>();
        const wrapper = mount(
            <CompoundTag ref={elementRef} leftContent="Hello">
                World
            </CompoundTag>,
        );

        // wait for the whole lifecycle to run
        setTimeout(() => {
            assert.equal(elementRef.current, wrapper.find(`.${Classes.TAG}`).getDOMNode<HTMLSpanElement>());
            done();
        }, 0);
    });
});

================================================================================

File: test\tag\tagTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, shallow } from "enzyme";
import * as React from "react";
import { spy } from "sinon";

import { Classes, Icon, Tag, Text } from "../../src";

describe("<Tag>", () => {
    it("renders its text", () => {
        assert.strictEqual(
            shallow(<Tag>Hello</Tag>)
                .find(Text)
                .prop("children"),
            "Hello",
        );
    });

    it("text is not rendered if omitted", () => {
        assert.isFalse(
            shallow(<Tag icon="tick" />)
                .find(Text)
                .exists(),
        );
    });

    it("renders icons", () => {
        const wrapper = shallow(<Tag icon="tick" rightIcon="airplane" />);
        assert.lengthOf(wrapper.find(Icon), 2);
    });

    it("renders close button when onRemove is a function", () => {
        const wrapper = mount(<Tag onRemove={spy()}>Hello</Tag>);
        assert.lengthOf(wrapper.find(`.${Classes.TAG_REMOVE}`), 1);
    });

    it("clicking close button triggers onRemove", () => {
        const handleRemove = spy();
        mount(<Tag onRemove={handleRemove}>Hello</Tag>)
            .find(`.${Classes.TAG_REMOVE}`)
            .simulate("click");
        assert.isTrue(handleRemove.calledOnce);
    });

    it(`passes other props onto .${Classes.TAG} element`, () => {
        const element = shallow(<Tag title="baz qux">Hello</Tag>).find("." + Classes.TAG);
        assert.deepEqual(element.prop("title"), "baz qux");
    });

    it("passes all props to the onRemove handler", () => {
        const handleRemove = spy();
        const DATA_ATTR_FOO = "data-foo";
        const tagProps = {
            onRemove: handleRemove,
            [DATA_ATTR_FOO]: {
                bar: "baz",
                foo: 5,
            },
        };
        mount(<Tag {...tagProps}>Hello</Tag>)
            .find(`.${Classes.TAG_REMOVE}`)
            .simulate("click");
        assert.isTrue(handleRemove.args.length > 0 && handleRemove.args[0].length === 2);
        assert.isTrue(handleRemove.args[0][1][DATA_ATTR_FOO] !== undefined);
        assert.deepEqual(handleRemove.args[0][1][DATA_ATTR_FOO], tagProps[DATA_ATTR_FOO]);
    });

    it("supports ref objects", done => {
        const elementRef = React.createRef<HTMLSpanElement>();
        const wrapper = mount(<Tag ref={elementRef}>Hello</Tag>);

        // wait for the whole lifecycle to run
        setTimeout(() => {
            assert.equal(elementRef.current, wrapper.find(`.${Classes.TAG}`).getDOMNode<HTMLSpanElement>());
            done();
        }, 0);
    });
});

================================================================================

File: test\tag-input\tagInputTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert, expect } from "chai";
import { type MountRendererProps, type ReactWrapper, mount as untypedMount } from "enzyme";
import * as React from "react";
import sinon from "sinon";

import { Button, Classes, Intent, Tag, TagInput, type TagInputProps } from "../../src";

/**
 * @see https://github.com/DefinitelyTyped/DefinitelyTyped/issues/26979#issuecomment-465304376
 */
const mount = (el: React.ReactElement<TagInputProps>, options?: MountRendererProps) =>
    untypedMount<TagInput>(el, options);

const VALUES = ["one", "two", "three"];

describe("<TagInput>", () => {
    it("passes inputProps to input element", () => {
        const onBlur = sinon.spy();
        const input = mount(<TagInput values={VALUES} inputProps={{ autoFocus: true, onBlur }} />).find("input");
        assert.isTrue(input.prop("autoFocus"));
        // check that event handler is proxied
        const fakeEvent = { flag: "yes" };
        input.prop("onBlur")?.(fakeEvent as any);
        assert.strictEqual(onBlur.args[0][0], fakeEvent);
    });

    it("renders a Tag for each value", () => {
        const wrapper = mount(<TagInput values={VALUES} />);
        assert.lengthOf(wrapper.find(Tag), VALUES.length);
    });

    it("values can be valid JSX nodes", () => {
        const values = [
            <strong key="al">Albert</strong>,
            undefined,
            ["Bar", <em key="thol">thol</em>, "omew"],
            "Casper",
        ];
        const wrapper = mount(<TagInput values={values} />);
        // undefined does not produce a tag
        assert.lengthOf(wrapper.find(Tag), values.length - 1);
        assert.lengthOf(wrapper.find("strong"), 1);
        assert.lengthOf(wrapper.find("em"), 1);
    });

    it("leftIcon renders an icon as first child", () => {
        const leftIcon = "add";
        const wrapper = mount(<TagInput leftIcon={leftIcon} values={VALUES} />);

        assert.isTrue(
            wrapper
                .childAt(0) // TagInput's root <div> element
                .childAt(0) // left-icon React wrapper
                .childAt(0) // left-icon <div> element
                .find(`.${Classes.ICON}`)
                .hasClass(Classes.iconClass(leftIcon)),
            `Expected .${Classes.ICON} element to have .${Classes.iconClass(leftIcon)} class`,
        );
    });

    it("rightElement appears as last child", () => {
        const wrapper = mount(<TagInput rightElement={<Button />} values={VALUES} />);
        assert.isTrue(
            wrapper
                .childAt(0) // TagInput's root <div> element
                .children()
                .last()
                .is(Button),
        );
    });

    it("tagProps object is applied to each Tag", () => {
        const wrapper = mount(<TagInput tagProps={{ intent: Intent.PRIMARY }} values={VALUES} />);
        const intents = wrapper.find(Tag).map(tag => tag.prop("intent"));
        assert.deepEqual(intents, [Intent.PRIMARY, Intent.PRIMARY, Intent.PRIMARY]);
    });

    it("tagProps function is invoked for each Tag", () => {
        const tagProps = sinon.spy();
        mount(<TagInput tagProps={tagProps} values={VALUES} />);
        assert.isTrue(tagProps.calledThrice);
    });

    it("clicking Tag remove button invokes onRemove with that value", () => {
        const onRemove = sinon.spy();
        // requires full mount to support data attributes and parentElement
        const wrapper = mount(<TagInput onRemove={onRemove} values={VALUES} />);
        wrapper.find("button").at(1).simulate("click");
        assert.isTrue(onRemove.calledOnce);
        assert.sameMembers(onRemove.args[0], [VALUES[1], 1]);
    });

    describe("onAdd", () => {
        const NEW_VALUE = "new item";

        it("is not invoked on enter when input is empty", () => {
            const onAdd = sinon.stub();
            const wrapper = mountTagInput(onAdd);
            pressEnterInInput(wrapper, "");
            assert.isTrue(onAdd.notCalled);
        });

        it("is not invoked on enter when input is composing", () => {
            const onAdd = sinon.stub();
            const wrapper = mountTagInput(onAdd);
            pressEnterInInputWhenComposing(wrapper, "构成");
            assert.isTrue(onAdd.notCalled);
        });

        it("is invoked on enter", () => {
            const onAdd = sinon.stub();
            const wrapper = mountTagInput(onAdd);
            pressEnterInInput(wrapper, NEW_VALUE);
            assert.isTrue(onAdd.calledOnce);
            assert.deepEqual(onAdd.args[0][0], [NEW_VALUE]);
            assert.deepEqual(onAdd.args[0][1], "default");
        });

        it("is invoked on blur when addOnBlur=true", done => {
            const onAdd = sinon.stub();
            const wrapper = mount(<TagInput values={VALUES} addOnBlur={true} onAdd={onAdd} />);
            // simulate typing input text
            wrapper.setProps({ inputProps: { value: NEW_VALUE } });
            wrapper.find("input").simulate("change", { currentTarget: { value: NEW_VALUE } });
            wrapper.simulate("blur");

            // Need setTimeout here to wait for focus to change after blur event
            setTimeout(() => {
                assert.isTrue(onAdd.calledOnce);
                assert.deepEqual(onAdd.args[0][0], [NEW_VALUE]);
                assert.equal(onAdd.args[0][1], "blur");
                done();
            }, 50);
        });

        it("is not invoked on blur when addOnBlur=true but inputValue is empty", done => {
            const onAdd = sinon.stub();
            const wrapper = mount(<TagInput values={VALUES} addOnBlur={true} onAdd={onAdd} />);
            wrapper.simulate("blur");
            // Need setTimeout here to wait for focus to change after blur event
            setTimeout(() => {
                assert.isTrue(onAdd.notCalled);
                done();
            });
        });

        it("is not invoked on blur when addOnBlur=false", done => {
            const onAdd = sinon.stub();
            const wrapper = mount(<TagInput values={VALUES} inputProps={{ value: NEW_VALUE }} onAdd={onAdd} />);
            wrapper.simulate("blur");
            // Need setTimeout here to wait for focus to change after blur event
            setTimeout(() => {
                assert.isTrue(onAdd.notCalled);
                done();
            });
        });

        describe("when addOnPaste=true", () => {
            it("is invoked on paste if the text contains a delimiter between values", () => {
                const text = "pasted\ntext";
                const onAdd = sinon.stub();
                const wrapper = mount(<TagInput values={VALUES} addOnPaste={true} onAdd={onAdd} />);
                wrapper.find("input").simulate("paste", { clipboardData: { getData: () => text } });
                assert.isTrue(onAdd.calledOnce);
                assert.deepEqual(onAdd.args[0][0], ["pasted", "text"]);
            });

            it("is invoked on paste if the text contains a trailing delimiter", () => {
                const text = "pasted\n";
                const onAdd = sinon.stub();
                const wrapper = mount(<TagInput values={VALUES} addOnPaste={true} onAdd={onAdd} />);
                wrapper.find("input").simulate("paste", { clipboardData: { getData: () => text } });
                assert.isTrue(onAdd.calledOnce);
                assert.deepEqual(onAdd.args[0][0], ["pasted"]);
                assert.equal(onAdd.args[0][1], "paste");
            });

            it("is not invoked on paste if the text does not include a delimiter", () => {
                const text = "pasted";
                const onAdd = sinon.stub();
                const wrapper = mount(<TagInput values={VALUES} addOnPaste={true} onAdd={onAdd} />);
                wrapper.find("input").simulate("paste", { clipboardData: { getData: () => text } });
                assert.isTrue(onAdd.notCalled);
            });
        });

        it("is not invoked on paste when addOnPaste=false", () => {
            const text = "pasted\ntext";
            const onAdd = sinon.stub();
            const wrapper = mount(<TagInput values={VALUES} addOnPaste={false} onAdd={onAdd} />);
            wrapper.find("input").simulate("paste", { clipboardData: { getData: () => text } });
            assert.isTrue(onAdd.notCalled);
        });

        it("does not clear the input if onAdd returns false", () => {
            const onAdd = sinon.stub().returns(false);
            const wrapper = mountTagInput(onAdd);
            wrapper.setState({ inputValue: NEW_VALUE });
            pressEnterInInput(wrapper, NEW_VALUE);
            assert.strictEqual(wrapper.state().inputValue, NEW_VALUE);
        });

        it("clears the input if onAdd returns true", () => {
            const onAdd = sinon.stub().returns(true);
            const wrapper = mountTagInput(onAdd);
            wrapper.setState({ inputValue: NEW_VALUE });
            pressEnterInInput(wrapper, NEW_VALUE);
            assert.strictEqual(wrapper.state().inputValue, "");
        });

        it("clears the input if onAdd returns nothing", () => {
            const onAdd = sinon.stub();
            const wrapper = mountTagInput(onAdd);
            wrapper.setState({ inputValue: NEW_VALUE });
            pressEnterInInput(wrapper, NEW_VALUE);
            assert.strictEqual(wrapper.state().inputValue, "");
        });

        it("does not clear the input if the input is controlled", () => {
            const wrapper = mountTagInput(sinon.stub(), { inputValue: NEW_VALUE });
            pressEnterInInput(wrapper, NEW_VALUE);
            assert.strictEqual(wrapper.state().inputValue, NEW_VALUE);
        });

        it("splits input value on separator RegExp", () => {
            const onAdd = sinon.stub();
            // this is actually the defaultProps value, but reproducing here for explicitness
            const wrapper = mountTagInput(onAdd, { separator: /,\s*/g });
            // various forms of whitespace properly ignored
            pressEnterInInput(wrapper, [NEW_VALUE, NEW_VALUE, "    ", NEW_VALUE].join(",   "));
            assert.deepEqual(onAdd.args[0][0], [NEW_VALUE, NEW_VALUE, NEW_VALUE]);
        });

        it("splits input value on separator string", () => {
            const onAdd = sinon.stub();
            const wrapper = mountTagInput(onAdd, { separator: "  |  " });
            pressEnterInInput(wrapper, "1 |  2  |   3   |    4    |  \t  |   ");
            assert.deepEqual(onAdd.args[0][0], ["1 |  2", "3", "4"]);
        });

        it("separator=false emits one-element values array", () => {
            const value = "one, two, three";
            const onAdd = sinon.stub();
            const wrapper = mountTagInput(onAdd, { separator: false });
            pressEnterInInput(wrapper, value);
            assert.deepEqual(onAdd.args[0][0], [value]);
        });

        function mountTagInput(onAdd: sinon.SinonStub, props?: Partial<TagInputProps>) {
            return mount(<TagInput onAdd={onAdd} values={VALUES} {...props} />);
        }
    });

    describe("onRemove", () => {
        it("pressing backspace focuses last item", () => {
            const onRemove = sinon.spy();
            const wrapper = mount(<TagInput onRemove={onRemove} values={VALUES} />);
            wrapper.find("input").simulate("keydown", { key: "Backspace" });

            assert.equal(wrapper.state("activeIndex"), VALUES.length - 1);
            assert.isTrue(onRemove.notCalled);
        });

        it("pressing backspace again removes last item", () => {
            const onRemove = sinon.spy();
            const wrapper = mount(<TagInput onRemove={onRemove} values={VALUES} />);
            wrapper.find("input").simulate("keydown", { key: "Backspace" }).simulate("keydown", { key: "Backspace" });

            assert.equal(wrapper.state("activeIndex"), VALUES.length - 2);
            assert.isTrue(onRemove.calledOnce);
            const lastIndex = VALUES.length - 1;
            assert.sameMembers(onRemove.args[0], [VALUES[lastIndex], lastIndex]);
        });

        it("pressing left arrow key navigates active item and backspace removes it", () => {
            const onRemove = sinon.spy();
            const wrapper = mount(<TagInput onRemove={onRemove} values={VALUES} />);
            // select and remove middle item
            wrapper
                .find("input")
                .simulate("keydown", { key: "ArrowLeft" })
                .simulate("keydown", { key: "ArrowLeft" })
                .simulate("keydown", { key: "Backspace" });

            assert.equal(wrapper.state("activeIndex"), 0);
            assert.isTrue(onRemove.calledOnce);
            assert.sameMembers(onRemove.args[0], [VALUES[1], 1]);
        });

        it("pressing left arrow key navigates active item and delete removes it", () => {
            const onRemove = sinon.spy();
            const wrapper = mount(<TagInput onRemove={onRemove} values={VALUES} />);
            // select and remove middle item
            wrapper
                .find("input")
                .simulate("keydown", { key: "ArrowLeft" })
                .simulate("keydown", { key: "ArrowLeft" })
                .simulate("keydown", { key: "Delete" });

            // in this case we're not moving into the previous item but
            // we rather "take the place" of the item we just removed
            assert.equal(wrapper.state("activeIndex"), 1);
            assert.isTrue(onRemove.calledOnce);
            assert.sameMembers(onRemove.args[0], [VALUES[1], 1]);
        });

        it("pressing delete with no selection does nothing", () => {
            const onRemove = sinon.spy();
            const wrapper = mount(<TagInput onRemove={onRemove} values={VALUES} />);

            wrapper.find("input").simulate("keydown", { key: "Delete" });

            assert.equal(wrapper.state("activeIndex"), -1);
            assert.isTrue(onRemove.notCalled);
        });

        it("pressing right arrow key in initial state does nothing", () => {
            const wrapper = mount(<TagInput values={VALUES} />);
            wrapper.find("input").simulate("keydown", { key: "ArrowRight" });
            assert.equal(wrapper.state("activeIndex"), -1);
        });
    });

    describe("onChange", () => {
        const NEW_VALUE = "new item";

        it("is not invoked on enter when input is empty", () => {
            const onChange = sinon.stub();
            const wrapper = mount(<TagInput onChange={onChange} values={VALUES} />);
            pressEnterInInput(wrapper, "");
            assert.isTrue(onChange.notCalled);
        });

        it("is invoked on enter with non-empty input", () => {
            const onChange = sinon.stub();
            const wrapper = mount(<TagInput onChange={onChange} values={VALUES} />);
            pressEnterInInput(wrapper, NEW_VALUE);
            assert.isTrue(onChange.calledOnce);
            assert.deepEqual(onChange.args[0][0], [...VALUES, NEW_VALUE]);
        });

        it("can add multiple tags at once with separator", () => {
            const onChange = sinon.stub();
            const wrapper = mount(<TagInput onChange={onChange} values={VALUES} />);
            pressEnterInInput(wrapper, [NEW_VALUE, NEW_VALUE, NEW_VALUE].join(", "));
            assert.isTrue(onChange.calledOnce);
            assert.deepEqual(onChange.args[0][0], [...VALUES, NEW_VALUE, NEW_VALUE, NEW_VALUE]);
        });

        it("is invoked when a tag is removed by clicking", () => {
            const onChange = sinon.stub();
            const wrapper = mount(<TagInput onChange={onChange} values={VALUES} />);
            wrapper.find("button").at(1).simulate("click");
            assert.isTrue(onChange.calledOnce);
            assert.deepEqual(onChange.args[0][0], [VALUES[0], VALUES[2]]);
        });

        it("is invoked when a tag is removed by backspace", () => {
            const onChange = sinon.stub();
            const wrapper = mount(<TagInput onChange={onChange} values={VALUES} />);
            wrapper.find("input").simulate("keydown", { key: "Backspace" }).simulate("keydown", { key: "Backspace" });
            assert.isTrue(onChange.calledOnce);
            assert.deepEqual(onChange.args[0][0], [VALUES[0], VALUES[1]]);
        });

        it("does not clear the input if onChange returns false", () => {
            const onChange = sinon.stub().returns(false);
            const wrapper = mount(<TagInput onChange={onChange} values={VALUES} />);
            wrapper.setState({ inputValue: NEW_VALUE });
            pressEnterInInput(wrapper, NEW_VALUE);
            assert.strictEqual(wrapper.state().inputValue, NEW_VALUE);
        });

        it("clears the input if onChange returns true", () => {
            const onChange = sinon.stub().returns(true);
            const wrapper = mount(<TagInput onChange={onChange} values={VALUES} />);
            wrapper.setState({ inputValue: NEW_VALUE });
            pressEnterInInput(wrapper, NEW_VALUE);
            assert.strictEqual(wrapper.state().inputValue, "");
        });

        it("clears the input if onChange returns nothing", () => {
            const onChange = sinon.spy();
            const wrapper = mount(<TagInput onChange={onChange} values={VALUES} />);
            wrapper.setState({ inputValue: NEW_VALUE });
            pressEnterInInput(wrapper, NEW_VALUE);
            assert.strictEqual(wrapper.state().inputValue, "");
        });

        it("does not clear the input if the input is controlled", () => {
            const onChange = sinon.stub();
            const wrapper = mount(<TagInput onChange={onChange} values={VALUES} inputValue={NEW_VALUE} />);
            pressEnterInInput(wrapper, NEW_VALUE);
            assert.strictEqual(wrapper.state().inputValue, NEW_VALUE);
        });
    });

    describe("onKeyDown", () => {
        it("emits the active tag index on key down", () => {
            runKeyPressTest("onKeyDown", 1, 1);
        });

        it("emits undefined on key down if active index == NONE (-1)", () => {
            runKeyPressTest("onKeyDown", -1, undefined);
        });
    });

    describe("onKeyUp", () => {
        it("emits the active tag index on key down", () => {
            runKeyPressTest("onKeyUp", 1, 1);
        });

        it("emits undefined on key down if active index == NONE (-1)", () => {
            runKeyPressTest("onKeyUp", -1, undefined);
        });
    });

    describe("placeholder", () => {
        it("appears only when values is empty", () => {
            const wrapper = mount(<TagInput placeholder="hold the door" values={[]} />);
            assert.strictEqual(wrapper.find("input").prop("placeholder"), "hold the door", "empty array");
            wrapper.setProps({ values: [undefined] });
            assert.strictEqual(wrapper.find("input").prop("placeholder"), "hold the door", "[undefined]");
            wrapper.setProps({ values: VALUES });
            assert.isUndefined(wrapper.find("input").prop("placeholder"), "normal values");
        });

        it("inputProps.placeholder appears all the time", () => {
            const wrapper = mount(<TagInput inputProps={{ placeholder: "hold the door" }} values={[]} />);
            assert.strictEqual(wrapper.find("input").prop("placeholder"), "hold the door");
            wrapper.setProps({ values: VALUES });
            assert.strictEqual(wrapper.find("input").prop("placeholder"), "hold the door");
        });

        it("setting both shows placeholder when empty and inputProps.placeholder otherwise", () => {
            const wrapper = mount(
                <TagInput inputProps={{ placeholder: "inputProps" }} placeholder="props" values={[]} />,
            );
            assert.strictEqual(wrapper.find("input").prop("placeholder"), "props");
            wrapper.setProps({ values: VALUES });
            assert.strictEqual(wrapper.find("input").prop("placeholder"), "inputProps");
        });
    });

    describe("when input is not empty", () => {
        it("pressing backspace does not remove item", () => {
            const onRemove = sinon.spy();
            const wrapper = mount(<TagInput onRemove={onRemove} values={VALUES} />);
            wrapper.find("input").simulate("keydown", createInputKeydownEventMetadata("text", "Backspace", false));
            assert.isTrue(onRemove.notCalled);
        });
    });

    it("arrow key interactions ignore falsy values", () => {
        const MIXED_VALUES = [
            undefined,
            <strong key="al">Albert</strong>,
            false,
            ["Bar", <em key="thol">thol</em>, "omew"],
            null,
            "Casper",
            undefined,
        ];

        const onChange = sinon.spy();
        const wrapper = mount(<TagInput onChange={onChange} values={MIXED_VALUES} />);
        assert.lengthOf(wrapper.find(Tag), 3, "should render only real values");
        const input = wrapper.find("input");

        function keydownAndAssertIndex(key: string, activeIndex: number) {
            input.simulate("keydown", { key });
            assert.equal(wrapper.state("activeIndex"), activeIndex);
        }
        keydownAndAssertIndex("ArrowLeft", 5);
        keydownAndAssertIndex("ArrowRight", 7);
        keydownAndAssertIndex("ArrowLeft", 5);
        keydownAndAssertIndex("ArrowLeft", 3);
        keydownAndAssertIndex("Backspace", 1);

        assert.isTrue(onChange.calledOnce);
        assert.lengthOf(
            onChange.args[0][0],
            MIXED_VALUES.length - 1,
            "should remove one item and preserve other falsy values",
        );
    });

    it("is non-interactive when disabled", () => {
        const wrapper = mount(<TagInput values={VALUES} disabled={true} />);

        assert.isTrue(
            // the wrapper is a React element; the first child is rendered <div>.
            wrapper.childAt(0).hasClass(Classes.DISABLED),
            `.${Classes.DISABLED} should be applied to tag-input`,
        );
        assert.isTrue(wrapper.find(`.${Classes.INPUT_GHOST}`).first().prop("disabled"), "input should be disabled");
        wrapper.find(Tag).forEach(tag => {
            assert.lengthOf(tag.find("." + Classes.TAG_REMOVE), 0, "tag should not have tag-remove button");
        });
    });

    describe("onInputChange", () => {
        it("is not invoked on enter when input is empty", () => {
            const onInputChange = sinon.stub();
            const wrapper = mount(<TagInput onInputChange={onInputChange} values={VALUES} />);
            pressEnterInInput(wrapper, "");
            assert.isTrue(onInputChange.notCalled);
        });

        it("is invoked when input text changes", () => {
            const changeSpy: any = sinon.spy();
            const wrapper = mount(<TagInput onInputChange={changeSpy} values={VALUES} />);
            wrapper.find("input").prop("onChange")?.({ currentTarget: { value: "hello" } } as any);
            assert.isTrue(changeSpy.calledOnce, "onChange called");
            assert.equal("hello", changeSpy.args[0][0].currentTarget.value);
        });
    });

    describe("inputValue", () => {
        const NEW_VALUE = "new item";
        it("passes initial inputValue to input element", () => {
            const input = mount(<TagInput values={VALUES} inputValue={NEW_VALUE} />).find("input");
            expect(input.prop("value")).to.equal(NEW_VALUE);
            expect(input.prop("value")).to.equal(NEW_VALUE);
        });

        it("prop changes are reflected in state", () => {
            const wrapper = mount(<TagInput inputValue="" values={VALUES} />);
            wrapper.setProps({ inputValue: "a" });
            expect(wrapper.state().inputValue).to.equal("a");
            wrapper.setProps({ inputValue: "b" });
            expect(wrapper.state().inputValue).to.equal("b");
            wrapper.setProps({ inputValue: "c" });
            expect(wrapper.state().inputValue).to.equal("c");
        });

        it("Updating inputValue updates input element", () => {
            const wrapper = mount(<TagInput inputValue="" values={VALUES} />);
            wrapper.setProps({ inputValue: NEW_VALUE });
            wrapper.update();
            expect(wrapper.find("input").prop("value")).to.equal(NEW_VALUE);
        });

        it("has a default empty string value", () => {
            const input = mount(<TagInput values={VALUES} />).find("input");
            expect(input.prop("value")).to.equal("");
        });
    });

    describe("when autoResize={true}", () => {
        it("passes inputProps to input element", () => {
            const onBlur = sinon.spy();
            const input = mount(
                <TagInput autoResize={true} values={VALUES} inputProps={{ autoFocus: true, onBlur }} />,
            ).find("input");
            assert.isTrue(input.prop("autoFocus"));
            // check that event handler is proxied
            const fakeEvent = { flag: "yes" };
            input.prop("onBlur")?.(fakeEvent as any);
            assert.strictEqual(onBlur.args[0][0], fakeEvent);
        });

        it("renders a Tag for each value", () => {
            const wrapper = mount(<TagInput autoResize={true} values={VALUES} />);
            assert.lengthOf(wrapper.find(Tag), VALUES.length);
        });
    });

    function pressEnterInInput(wrapper: ReactWrapper<any, any>, value: string) {
        wrapper.find("input").prop("onKeyDown")?.(createInputKeydownEventMetadata(value, "Enter", false) as any);
    }

    function pressEnterInInputWhenComposing(wrapper: ReactWrapper<any, any>, value: string) {
        wrapper.find("input").prop("onKeyDown")?.(createInputKeydownEventMetadata(value, "Enter", true) as any);
    }

    function createInputKeydownEventMetadata(value: string, key: string, isComposing: boolean) {
        return {
            currentTarget: { value },
            key,
            nativeEvent: {
                isComposing,
            },
            // Enzyme throws errors if we don't mock the stopPropagation method.
            stopPropagation: () => {
                return;
            },
        };
    }
});

function runKeyPressTest(callbackName: "onKeyDown" | "onKeyUp", startIndex: number, expectedIndex: number | undefined) {
    const callbackSpy = sinon.spy();
    const inputProps = { [callbackName]: sinon.spy() };
    const wrapper = mount(<TagInput values={VALUES} inputProps={inputProps} {...{ [callbackName]: callbackSpy }} />);

    wrapper.setState({ activeIndex: startIndex });

    const eventName = callbackName === "onKeyDown" ? "keydown" : "keyup";
    wrapper.find("input").simulate("focus").simulate(eventName, { key: "Enter" });

    assert.strictEqual(callbackSpy.callCount, 1, "container callback call count");
    assert.strictEqual(callbackSpy.firstCall.args[0].key, "Enter", "first arg (event)");
    assert.strictEqual(callbackSpy.firstCall.args[1], expectedIndex, "second arg (active index)");
    // invokes inputProps.callbackSpy as well
    assert.strictEqual(inputProps[callbackName].callCount, 1, "inputProps.onKeyDown call count");
}

================================================================================

File: test\text\textTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount } from "enzyme";
import * as React from "react";

import { Classes, Text } from "../../src";

describe("<Text>", () => {
    it("adds the className prop", () => {
        const textContent = "textContent";
        const className = "bp-test-class";
        const wrapper = mount(<Text className={className}>{textContent}</Text>);
        const element = wrapper.find(`.${className}`).hostNodes();
        assert.lengthOf(element, 1, `expected to find 1 .${className}`);
        assert.strictEqual(element.text(), textContent, "content incorrect value");
    });

    it("uses given title", () => {
        const textContent = "textContent";
        const title = "Test title";
        const wrapper = mount(<Text title={title}>{textContent}</Text>);
        const element = wrapper.find("div").first();
        const actualTitle = element.prop("title");
        assert.strictEqual(actualTitle, title, "component title should equal title prop");
    });

    describe("if ellipsize true", () => {
        it("truncates string children", () => {
            const textContent = "textContent";
            const wrapper = mount(<Text ellipsize={true}>{textContent}</Text>);
            const element = wrapper.find(`.${Classes.TEXT_OVERFLOW_ELLIPSIS}`);
            assert.lengthOf(element, 1, `missing ${Classes.TEXT_OVERFLOW_ELLIPSIS}`);
            assert.strictEqual(element.text(), textContent, "content incorrect value");
        });

        it("truncates jsx children", () => {
            const children = (
                <span>
                    {"computed text "}
                    <span>text in a span</span>
                </span>
            );
            const textContent = "computed text text in a span";
            const wrapper = mount(<Text ellipsize={true}>{children}</Text>);
            const element = wrapper.find(`.${Classes.TEXT_OVERFLOW_ELLIPSIS}`);
            assert.lengthOf(element, 1, `missing ${Classes.TEXT_OVERFLOW_ELLIPSIS}`);
            assert.strictEqual(element.text(), textContent, "content incorrect value");
        });

        describe("title behavior", () => {
            let testsContainerElement: HTMLElement;

            beforeEach(() => {
                testsContainerElement = document.createElement("div");
                document.documentElement.appendChild(testsContainerElement);
            });

            afterEach(() => {
                testsContainerElement.remove();
            });

            it("adds the title attribute when text overflows", () => {
                const textContent = new Array(100).join("this will overflow ");
                const wrapper = mount(<Text ellipsize={true}>{textContent}</Text>, {
                    attachTo: testsContainerElement,
                });
                const actualTitle = wrapper.find(`.${Classes.TEXT_OVERFLOW_ELLIPSIS}`).prop("title");
                assert.strictEqual(actualTitle, textContent, "title should equal full text content");
            });

            it("does not add the title attribute when text does not overflow", () => {
                const textContent = "no overflow";
                let wrapper = mount(<Text ellipsize={true}>{textContent}</Text>, {
                    attachTo: testsContainerElement,
                });
                wrapper = wrapper.update();
                const actualTitle = wrapper.find(`.${Classes.TEXT_OVERFLOW_ELLIPSIS}`).prop("title");
                assert.strictEqual(actualTitle, undefined, "title should be undefined");
            });

            it("uses given title even if text overflows", () => {
                const textContent = new Array(100).join("this will overflow ");
                const title = "Test title";
                const wrapper = mount(
                    <Text ellipsize={true} title={title}>
                        {textContent}
                    </Text>,
                    {
                        attachTo: testsContainerElement,
                    },
                );
                const actualTitle = wrapper.find(`.${Classes.TEXT_OVERFLOW_ELLIPSIS}`).prop("title");
                assert.strictEqual(actualTitle, title, "component title should equal title prop");
            });
        });
    });

    describe("if ellipsize false", () => {
        it("doesn't truncate string children", () => {
            const textContent = "textContent";
            const wrapper = mount(<Text>{textContent}</Text>);
            const element = wrapper.find(`.${Classes.TEXT_OVERFLOW_ELLIPSIS}`);
            assert.lengthOf(element, 0, `unexpected ${Classes.TEXT_OVERFLOW_ELLIPSIS}`);
        });
    });
});

================================================================================

File: test\toast\overlayToasterTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount } from "enzyme";
import * as React from "react";
import * as ReactDOM from "react-dom";
import sinon, { spy } from "sinon";

import { expectPropValidationError } from "@blueprintjs/test-commons";

import { Classes, OverlayToaster, type OverlayToasterProps, type Toaster } from "../../src";
import { TOASTER_CREATE_NULL, TOASTER_MAX_TOASTS_INVALID } from "../../src/common/errors";

const SPECS = [
    {
        cleanup: unmountReact16Toaster,
        create: (props: OverlayToasterProps | undefined, containerElement: HTMLElement) =>
            OverlayToaster.create(props, containerElement),
        name: "create",
    },
    {
        cleanup: unmountReact16Toaster,
        create: (props: OverlayToasterProps | undefined, containerElement: HTMLElement) =>
            OverlayToaster.createAsync(props, { container: containerElement }),
        name: "createAsync",
    },
];

/**
 * Dynamically run describe blocks. The helper function here reduces indentation
 * width compared to inlining a for loop.
 *
 * https://mochajs.org/#dynamically-generating-tests
 */
function describeEach<T extends { name: string }>(specs: readonly T[], runner: (spec: T) => void) {
    for (const spec of specs) {
        describe(spec.name, () => runner(spec));
    }
}

/**
 * @param containerElement The container argument passed to OverlayToaster.create/OverlayToaster.createAsync
 */
function unmountReact16Toaster(containerElement: HTMLElement) {
    const toasterRenderRoot = containerElement.firstElementChild;
    if (toasterRenderRoot == null) {
        throw new Error("No elements were found under Toaster container.");
    }
    ReactDOM.unmountComponentAtNode(toasterRenderRoot);
}

describe("OverlayToaster", () => {
    let testsContainerElement: HTMLElement;
    let toaster: Toaster;

    describeEach(SPECS, spec => {
        describe("with default props", () => {
            before(async () => {
                testsContainerElement = document.createElement("div");
                document.documentElement.appendChild(testsContainerElement);
                toaster = await spec.create({}, testsContainerElement);
            });

            afterEach(() => {
                toaster.clear();
            });

            after(() => {
                spec.cleanup(testsContainerElement);
                document.documentElement.removeChild(testsContainerElement);
            });

            it("does not attach toast container to body on script load", () => {
                assert.lengthOf(
                    document.getElementsByClassName(Classes.TOAST_CONTAINER),
                    0,
                    "unexpected toast container",
                );
            });

            it("show() renders toast on next tick", done => {
                toaster.show({
                    message: "Hello world",
                });
                assert.lengthOf(toaster.getToasts(), 1, "expected 1 toast");

                // setState needs a tick to flush DOM updates
                setTimeout(() => {
                    assert.isNotNull(
                        document.querySelector(`.${Classes.TOAST_CONTAINER}.${Classes.OVERLAY_OPEN}`),
                        "expected toast container element to have 'overlay open' class name",
                    );
                    done();
                });
            });

            it("multiple show()s renders them all", () => {
                toaster.show({ message: "one" });
                toaster.show({ message: "two" });
                toaster.show({ message: "six" });
                assert.lengthOf(toaster.getToasts(), 3, "expected 3 toasts");
            });

            it("show() updates existing toast", () => {
                const key = toaster.show({ message: "one" });
                assert.deepEqual(toaster.getToasts()[0].message, "one");
                toaster.show({ message: "two" }, key);
                assert.lengthOf(toaster.getToasts(), 1, "expected 1 toast");
                assert.deepEqual(toaster.getToasts()[0].message, "two");
            });

            it("dismiss() removes just the toast in question", () => {
                toaster.show({ message: "one" });
                const key = toaster.show({ message: "two" });
                toaster.show({ message: "six" });
                toaster.dismiss(key);
                assert.deepEqual(
                    toaster.getToasts().map(t => t.message),
                    ["six", "one"],
                );
            });

            it("clear() removes all toasts", () => {
                toaster.show({ message: "one" });
                toaster.show({ message: "two" });
                toaster.show({ message: "six" });
                assert.lengthOf(toaster.getToasts(), 3, "expected 3 toasts");
                toaster.clear();
                assert.lengthOf(toaster.getToasts(), 0, "expected 0 toasts");
            });

            it("action onClick callback invoked when action clicked", () => {
                const onClick = spy();
                toaster.show({
                    action: { onClick, text: "action" },
                    message: "message",
                    timeout: 0,
                });
                // action is first descendant button
                const action = document.querySelector<HTMLElement>(`.${Classes.TOAST} .${Classes.BUTTON}`);
                action?.click();
                assert.isTrue(onClick.calledOnce, "expected onClick to be called once");
            });

            it("onDismiss callback invoked when close button clicked", () => {
                const handleDismiss = spy();
                toaster.show({
                    message: "dismiss",
                    onDismiss: handleDismiss,
                    timeout: 0,
                });
                // without action, dismiss is first descendant button
                const dismiss = document.querySelector<HTMLElement>(`.${Classes.TOAST} .${Classes.BUTTON}`);
                dismiss?.click();
                assert.isTrue(handleDismiss.calledOnce);
            });

            it("onDismiss callback invoked on toaster.dismiss()", () => {
                const onDismiss = spy();
                const key = toaster.show({ message: "dismiss me", onDismiss });
                toaster.dismiss(key);
                assert.isTrue(onDismiss.calledOnce, "onDismiss not called");
            });

            it("onDismiss callback invoked on toaster.clear()", () => {
                const onDismiss = spy();
                toaster.show({ message: "dismiss me", onDismiss });
                toaster.clear();
                assert.isTrue(onDismiss.calledOnce, "onDismiss not called");
            });

            it("reusing props object does not produce React errors", () => {
                const errorSpy = spy(console, "error");
                try {
                    // if Toaster doesn't clone the props object before injecting key then there will be a
                    // React error that both toasts have the same key, because both instances refer to the
                    // same object.
                    const toast = { message: "repeat" };
                    toaster.show(toast);
                    toaster.show(toast);
                    assert.isFalse(errorSpy.calledWithMatch("two children with the same key"), "mutation side effect!");
                } finally {
                    // Restore console.error. Otherwise other tests will fail
                    // with "TypeError: Attempted to wrap error which is already
                    // wrapped" when attempting to spy on console.error again.
                    sinon.restore();
                }
            });
        });

        describe("with maxToasts set to finite value", () => {
            before(async () => {
                testsContainerElement = document.createElement("div");
                document.documentElement.appendChild(testsContainerElement);
                toaster = await spec.create({ maxToasts: 3 }, testsContainerElement);
            });

            after(() => {
                unmountReact16Toaster(testsContainerElement);
                document.documentElement.removeChild(testsContainerElement);
            });

            it("does not exceed the maximum toast limit set", () => {
                toaster.show({ message: "one" });
                toaster.show({ message: "two" });
                toaster.show({ message: "three" });
                toaster.show({ message: "oh no" });
                assert.lengthOf(toaster.getToasts(), 3, "expected 3 toasts");
            });
        });

        describe("with autoFocus set to true", () => {
            before(async () => {
                testsContainerElement = document.createElement("div");
                document.documentElement.appendChild(testsContainerElement);
                toaster = await spec.create({ autoFocus: true }, testsContainerElement);
            });

            after(() => {
                spec.cleanup(testsContainerElement);
                document.documentElement.removeChild(testsContainerElement);
            });

            it("focuses inside toast container", done => {
                toaster.show({ message: "focus near me" });
                // small explicit timeout reduces flakiness of these tests
                setTimeout(() => {
                    const toastElement = testsContainerElement.querySelector(`.${Classes.TOAST_CONTAINER}`);
                    assert.isTrue(toastElement?.contains(document.activeElement));
                    done();
                }, 100);
            });
        });

        it("throws an error if used within a React lifecycle method", () => {
            testsContainerElement = document.createElement("div");

            class LifecycleToaster extends React.Component {
                public render() {
                    return React.createElement("div");
                }

                public componentDidMount() {
                    try {
                        spec.create({}, testsContainerElement);
                    } catch (err: any) {
                        assert.equal(err.message, TOASTER_CREATE_NULL);
                    } finally {
                        spec.cleanup(testsContainerElement);
                    }
                }
            }
            mount(React.createElement(LifecycleToaster));
        });
    });

    describe("validation", () => {
        it("throws an error when max toast is set to a number less than 1", () => {
            expectPropValidationError(OverlayToaster, { maxToasts: 0 }, TOASTER_MAX_TOASTS_INVALID);
        });
    });
});

================================================================================

File: test\toast\toast2Tests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2024 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, shallow } from "enzyme";
import * as React from "react";
import { type SinonSpy, spy } from "sinon";

import { AnchorButton, Button, Toast2 } from "../../src";

describe("<Toast2>", () => {
    it("renders only dismiss button by default", () => {
        const { action, dismiss } = wrap(<Toast2 message="Hello World" />);
        assert.lengthOf(action, 0);
        assert.lengthOf(dismiss, 1);
    });

    it("clicking dismiss button triggers onDismiss callback with `false`", () => {
        const handleDismiss = spy();
        wrap(<Toast2 message="Hello" onDismiss={handleDismiss} />).dismiss.simulate("click");
        assert.isTrue(handleDismiss.calledOnce, "onDismiss not called once");
        assert.isTrue(handleDismiss.calledWith(false), "onDismiss not called with false");
    });

    it("renders action button when action string prop provided", () => {
        // pluralize cuz now there are two buttons
        const { action } = wrap(<Toast2 action={{ text: "Undo" }} message="hello world" />);
        assert.lengthOf(action, 1);
        assert.equal(action.prop("text"), "Undo");
    });

    it("clicking action button triggers onClick callback", () => {
        const onClick = spy();
        wrap(<Toast2 action={{ onClick, text: "Undo" }} message="Hello" />).action.simulate("click");
        assert.isTrue(onClick.calledOnce, "action onClick not called once");
    });

    it("clicking action button also triggers onDismiss callback with `false`", () => {
        const handleDismiss = spy();
        wrap(<Toast2 action={{ text: "Undo" }} message="Hello" onDismiss={handleDismiss} />).action.simulate("click");
        assert.isTrue(handleDismiss.calledOnce, "onDismiss not called once");
        assert.isTrue(handleDismiss.calledWith(false), "onDismiss not called with false");
    });

    function wrap(toast: React.JSX.Element) {
        const root = shallow(toast);
        return {
            action: root.find(AnchorButton),
            dismiss: root.find(Button),
            root,
        };
    }

    describe("timeout", () => {
        let handleDismiss: SinonSpy;
        beforeEach(() => (handleDismiss = spy()));

        it("calls onDismiss automatically after timeout expires with `true`", done => {
            // mounting for lifecycle methods to start timeout
            mount(<Toast2 message="Hello" onDismiss={handleDismiss} timeout={20} />);
            setTimeout(() => {
                assert.isTrue(handleDismiss.calledOnce, "onDismiss not called once");
                assert.isTrue(handleDismiss.firstCall.args[0], "onDismiss not called with `true`");
                done();
            }, 20);
        });

        it("updating with timeout={0} cancels timeout", done => {
            mount(<Toast2 message="Hello" onDismiss={handleDismiss} timeout={20} />).setProps({
                timeout: 0,
            });
            setTimeout(() => {
                assert.isTrue(handleDismiss.notCalled, "onDismiss was called");
                done();
            }, 20);
        });

        it("updating timeout={0} with timeout={X} starts timeout", done => {
            mount(<Toast2 message="Hello" onDismiss={handleDismiss} timeout={0} />).setProps({
                timeout: 20,
            });
            setTimeout(() => {
                assert.isTrue(handleDismiss.calledOnce, "onDismiss not called once");
                assert.isTrue(handleDismiss.firstCall.args[0], "onDismiss not called with `true`");
                done();
            }, 20);
        });
    });
});

================================================================================

File: test\toast\toasterTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2023 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as ReactDOM from "react-dom";

import { Toaster } from "../../src";

describe("Toaster", () => {
    let testsContainerElement: HTMLElement;

    before(() => {
        testsContainerElement = document.createElement("div");
        document.documentElement.appendChild(testsContainerElement);
    });

    afterEach(() => {
        ReactDOM.unmountComponentAtNode(testsContainerElement);
    });

    describe("(v4.x backwards-compatibility)", () => {
        it("supports Toaster.create() method", () => {
            // eslint-disable-next-line deprecation/deprecation
            const toaster = Toaster.create({}, testsContainerElement);
            toaster.clear();
        });
    });
});

================================================================================

File: test\toast\toastTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview This component is DEPRECATED, and the code is frozen.
 * All changes & bugfixes should be made to Toast2 instead.
 */

/* eslint-disable deprecation/deprecation, @blueprintjs/no-deprecated-components */

import { assert } from "chai";
import { mount, shallow } from "enzyme";
import * as React from "react";
import { type SinonSpy, spy } from "sinon";

import { AnchorButton, Button, Toast } from "../../src";

describe("<Toast>", () => {
    it("renders only dismiss button by default", () => {
        const { action, dismiss } = wrap(<Toast message="Hello World" />);
        assert.lengthOf(action, 0);
        assert.lengthOf(dismiss, 1);
    });

    it("clicking dismiss button triggers onDismiss callback with `false`", () => {
        const handleDismiss = spy();
        wrap(<Toast message="Hello" onDismiss={handleDismiss} />).dismiss.simulate("click");
        assert.isTrue(handleDismiss.calledOnce, "onDismiss not called once");
        assert.isTrue(handleDismiss.calledWith(false), "onDismiss not called with false");
    });

    it("renders action button when action string prop provided", () => {
        // pluralize cuz now there are two buttons
        const { action } = wrap(<Toast action={{ text: "Undo" }} message="hello world" />);
        assert.lengthOf(action, 1);
        assert.equal(action.prop("text"), "Undo");
    });

    it("clicking action button triggers onClick callback", () => {
        const onClick = spy();
        wrap(<Toast action={{ onClick, text: "Undo" }} message="Hello" />).action.simulate("click");
        assert.isTrue(onClick.calledOnce, "action onClick not called once");
    });

    it("clicking action button also triggers onDismiss callback with `false`", () => {
        const handleDismiss = spy();
        wrap(<Toast action={{ text: "Undo" }} message="Hello" onDismiss={handleDismiss} />).action.simulate("click");
        assert.isTrue(handleDismiss.calledOnce, "onDismiss not called once");
        assert.isTrue(handleDismiss.calledWith(false), "onDismiss not called with false");
    });

    function wrap(toast: React.JSX.Element) {
        const root = shallow(toast);
        return {
            action: root.find(AnchorButton),
            dismiss: root.find(Button),
            root,
        };
    }

    describe("timeout", () => {
        let handleDismiss: SinonSpy;
        beforeEach(() => (handleDismiss = spy()));

        it("calls onDismiss automatically after timeout expires with `true`", done => {
            // mounting for lifecycle methods to start timeout
            mount(<Toast message="Hello" onDismiss={handleDismiss} timeout={20} />);
            setTimeout(() => {
                assert.isTrue(handleDismiss.calledOnce, "onDismiss not called once");
                assert.isTrue(handleDismiss.firstCall.args[0], "onDismiss not called with `true`");
                done();
            }, 20);
        });

        it("updating with timeout={0} cancels timeout", done => {
            mount(<Toast message="Hello" onDismiss={handleDismiss} timeout={20} />).setProps({
                timeout: 0,
            });
            setTimeout(() => {
                assert.isTrue(handleDismiss.notCalled, "onDismiss was called");
                done();
            }, 20);
        });

        it("updating timeout={0} with timeout={X} starts timeout", done => {
            mount(<Toast message="Hello" onDismiss={handleDismiss} timeout={0} />).setProps({
                timeout: 20,
            });
            setTimeout(() => {
                assert.isTrue(handleDismiss.calledOnce, "onDismiss not called once");
                assert.isTrue(handleDismiss.firstCall.args[0], "onDismiss not called with `true`");
                done();
            }, 20);
        });
    });
});

================================================================================

File: test\tooltip\tooltipTests.tsx
--------------------------------------------------------------------------------
/**
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount } from "enzyme";
import * as React from "react";
import { spy, stub } from "sinon";

import { Classes } from "../../src/common";
import { Button, Overlay2 } from "../../src/components";
import { Popover } from "../../src/components/popover/popover";
import { Tooltip, type TooltipProps } from "../../src/components/tooltip/tooltip";

const TARGET_SELECTOR = `.${Classes.POPOVER_TARGET}`;
const TOOLTIP_SELECTOR = `.${Classes.TOOLTIP}`;
const TEST_TARGET_ID = "test-target";

describe("<Tooltip>", () => {
    describe("rendering", () => {
        it("propogates class names correctly", () => {
            const tooltip = renderTooltip({
                className: "bar",
                isOpen: true,
                popoverClassName: "foo",
            });
            assert.isTrue(tooltip.find(TOOLTIP_SELECTOR).hasClass(tooltip.prop("popoverClassName")!), "tooltip");
            assert.isTrue(tooltip.find(`.${Classes.POPOVER_TARGET}`).hasClass(tooltip.prop("className")!), "wrapper");
        });

        it("targetTagName renders the right elements", () => {
            const tooltip = renderTooltip({
                isOpen: true,
                targetTagName: "address",
            });
            assert.isTrue(tooltip.find("address").hasClass(Classes.POPOVER_TARGET));
        });

        it("applies minimal class & hides arrow when minimal is true", () => {
            const tooltip = renderTooltip({ isOpen: true, minimal: true });
            assert.isTrue(tooltip.find(TOOLTIP_SELECTOR).hasClass(Classes.MINIMAL));
            assert.isFalse(tooltip.find(Popover).props().modifiers!.arrow!.enabled);
        });

        it("does not apply minimal class & shows arrow when minimal is false", () => {
            const tooltip = renderTooltip({ isOpen: true });
            // Minimal should be false by default.
            assert.isFalse(tooltip.props().minimal);
            assert.isFalse(tooltip.find(TOOLTIP_SELECTOR).hasClass(Classes.MINIMAL));
            assert.isTrue(tooltip.find(Popover).props().modifiers!.arrow!.enabled);
        });
    });

    describe("basic functionality", () => {
        it("supports overlay lifecycle props", () => {
            const onOpening = spy();
            renderTooltip({ isOpen: true, onOpening });
            assert.isTrue(onOpening.calledOnce);
        });
    });

    describe("in uncontrolled mode", () => {
        it("defaultIsOpen determines initial open state", () => {
            assert.lengthOf(renderTooltip({ defaultIsOpen: true }).find(TOOLTIP_SELECTOR), 1);
        });

        it("triggers on hover", () => {
            const tooltip = renderTooltip();
            assert.lengthOf(tooltip.find(TOOLTIP_SELECTOR), 0);

            tooltip.find(TARGET_SELECTOR).simulate("mouseenter");
            assert.lengthOf(tooltip.find(TOOLTIP_SELECTOR), 1);
        });

        it("triggers on focus", () => {
            const tooltip = renderTooltip();
            assert.lengthOf(tooltip.find(TOOLTIP_SELECTOR), 0);

            tooltip.find(TARGET_SELECTOR).simulate("focus");
            assert.lengthOf(tooltip.find(TOOLTIP_SELECTOR), 1);
        });

        it("does not trigger on focus if openOnTargetFocus={false}", () => {
            const tooltip = renderTooltip({ openOnTargetFocus: false });
            assert.lengthOf(tooltip.find(TOOLTIP_SELECTOR), 0);

            tooltip.find(Popover).simulate("focus");
            assert.lengthOf(tooltip.find(TOOLTIP_SELECTOR), 0);
        });

        it("empty content disables Popover and warns", () => {
            const warnSpy = stub(console, "warn");
            const tooltip = renderTooltip({ isOpen: true, content: "" });

            function assertDisabledPopover(content: string) {
                tooltip.setProps({ content });
                assert.isFalse(tooltip.find(Overlay2).exists(), `"${content}"`);
                assert.isTrue(warnSpy.called, "spy not called");
                warnSpy.resetHistory();
            }

            assertDisabledPopover("");
            assertDisabledPopover("   ");
            // @ts-expect-error
            assertDisabledPopover(null);
            warnSpy.restore();
        });

        it("setting disabled=true prevents opening tooltip", () => {
            const tooltip = renderTooltip({ disabled: true });
            tooltip.find(Popover).simulate("mouseenter");
            assert.lengthOf(tooltip.find(TOOLTIP_SELECTOR), 0);
        });
    });

    describe("in controlled mode", () => {
        it("renders when open", () => {
            const tooltip = renderTooltip({ isOpen: true });
            assert.lengthOf(tooltip.find(TOOLTIP_SELECTOR), 1);
        });

        it("doesn't render when not open", () => {
            const tooltip = renderTooltip({ isOpen: false });
            assert.lengthOf(tooltip.find(TOOLTIP_SELECTOR), 0);
        });

        it("empty content disables Popover and warns", () => {
            const warnSpy = stub(console, "warn");
            const tooltip = renderTooltip({ content: "", isOpen: true });
            assert.isFalse(tooltip.find(Overlay2).exists());
            assert.isTrue(warnSpy.called);
            warnSpy.restore();
        });

        describe("onInteraction()", () => {
            it("is invoked with `true` when closed tooltip target is hovered", () => {
                const handleInteraction = spy();
                renderTooltip({ isOpen: false, onInteraction: handleInteraction })
                    .find(TARGET_SELECTOR)
                    .simulate("mouseenter");
                assert.isTrue(handleInteraction.calledOnce, "called once");
                assert.isTrue(handleInteraction.calledWith(true), "call args");
            });
        });
    });

    function renderTooltip(props?: Partial<TooltipProps>) {
        return mount<TooltipProps>(
            <Tooltip content={<p>Text</p>} hoverOpenDelay={0} {...props} usePortal={false}>
                <Button id={TEST_TARGET_ID} text="target" />
            </Tooltip>,
        );
    }
});

================================================================================

File: test\tree\treeTests.tsx
--------------------------------------------------------------------------------
/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { assert } from "chai";
import { mount, type ReactWrapper } from "enzyme";
import * as React from "react";
import * as ReactDOM from "react-dom";
import { spy } from "sinon";

import { Classes, Tree, type TreeNodeInfo, type TreeProps } from "../../src";

describe("<Tree>", () => {
    let testsContainerElement: Element;

    before(() => {
        // this is essentially what TestUtils.renderIntoDocument does
        testsContainerElement = document.createElement("div");
        document.documentElement.appendChild(testsContainerElement);
    });

    afterEach(() => {
        ReactDOM.unmountComponentAtNode(testsContainerElement);
    });

    it("renders its contents", () => {
        const tree = renderTree({ contents: [{ id: 0, label: "Node" }] });
        assert.lengthOf(tree.find(`.${Classes.TREE}`), 1);
    });

    it("handles undefined input well", () => {
        const tree = renderTree({ contents: undefined });
        assert.lengthOf(tree.find(`.${Classes.TREE}`), 1);
    });

    it("handles empty input well", () => {
        const tree = renderTree({ contents: [] });
        assert.lengthOf(tree.find(`.${Classes.TREE}`), 1);
    });

    it("hasCaret forces a caret to be/not be displayed", () => {
        const contents = createDefaultContents();
        contents[0].hasCaret = contents[1].hasCaret = true;
        contents[2].hasCaret = contents[3].hasCaret = false;

        const tree = renderTree({ contents });
        assertNodeHasCaret(tree, "c0", true);
        assertNodeHasCaret(tree, "c1", true);
        assertNodeHasCaret(tree, "c2", false);
        assertNodeHasCaret(tree, "c3", false);
    });

    it("if not specified, caret visibility is determined by the presence of children", () => {
        const tree = renderTree();
        assertNodeHasCaret(tree, "c0", false);
        assertNodeHasCaret(tree, "c1", true);
        assertNodeHasCaret(tree, "c2", false);
        assertNodeHasCaret(tree, "c3", true);
    });

    it("caret direction is determined by node expansion", () => {
        const contents = [
            {
                childNodes: [{ id: 4, label: "" }],
                className: "c0",
                hasCaret: true,
                id: 1,
                isExpanded: false,
                label: "c0",
            },
            { id: 0, className: "c1", hasCaret: true, isExpanded: true, label: "c1" },
            { id: 2, className: "c2", hasCaret: true, isExpanded: false, label: "c2" },
            {
                childNodes: [{ id: 5, label: "c4" }],
                className: "c3",
                hasCaret: true,
                id: 3,
                isExpanded: true,
                label: "c3",
            },
        ];

        const tree = renderTree({ contents });
        assertNodeHasClass(tree, "c0", Classes.TREE_NODE_CARET_CLOSED);
        assertNodeHasClass(tree, "c1", Classes.TREE_NODE_CARET_OPEN);
        assertNodeHasClass(tree, "c2", Classes.TREE_NODE_CARET_CLOSED);
        assertNodeHasClass(tree, "c3", Classes.TREE_NODE_CARET_OPEN);
    });

    it("event callbacks are fired correctly", () => {
        const onNodeClick = spy();
        const onNodeCollapse = spy();
        const onNodeContextMenu = spy();
        const onNodeDoubleClick = spy();
        const onNodeExpand = spy();
        const onNodeMouseEnter = spy();
        const onNodeMouseLeave = spy();

        const contents = createDefaultContents();
        contents[3].isExpanded = true;

        const tree = renderTree({
            contents,
            onNodeClick,
            onNodeCollapse,
            onNodeContextMenu,
            onNodeDoubleClick,
            onNodeExpand,
            onNodeMouseEnter,
            onNodeMouseLeave,
        });

        tree.find(`.c0 > .${Classes.TREE_NODE_CONTENT}`).simulate("click");
        assert.isTrue(onNodeClick.calledOnce);
        assert.deepEqual(onNodeClick.args[0][1], [0]);

        findNodeClass(tree, "c1", Classes.TREE_NODE_CARET).simulate("click");
        assert.isTrue(onNodeExpand.calledOnce);
        assert.deepEqual(onNodeExpand.args[0][1], [1]);
        // make sure that onNodeClick isn't fired again, only onNodeExpand should be
        assert.isTrue(onNodeClick.calledOnce);

        tree.find(`.c6 > .${Classes.TREE_NODE_CONTENT}`).simulate("dblclick");
        assert.isTrue(onNodeDoubleClick.calledOnce);
        assert.deepEqual(onNodeDoubleClick.args[0][1], [3, 0]);

        findNodeClass(tree, "c3", Classes.TREE_NODE_CARET).simulate("click");
        assert.isTrue(onNodeCollapse.calledOnce);
        assert.deepEqual(onNodeCollapse.args[0][1], [3]);

        tree.find(`.c0 > .${Classes.TREE_NODE_CONTENT}`).simulate("contextmenu");
        assert.isTrue(onNodeContextMenu.calledOnce);
        assert.deepEqual(onNodeContextMenu.args[0][1], [0]);

        tree.find(`.c2 > .${Classes.TREE_NODE_CONTENT}`).simulate("mouseenter");
        assert.isTrue(onNodeMouseEnter.calledOnce);
        assert.deepEqual(onNodeMouseEnter.args[0][1], [2]);

        tree.find(`.c2 > .${Classes.TREE_NODE_CONTENT}`).simulate("mouseleave");
        assert.isTrue(onNodeMouseLeave.calledOnce);
        assert.deepEqual(onNodeMouseLeave.args[0][1], [2]);
    });

    it("if disabled, event callbacks are not fired", () => {
        const onNodeClick = spy();
        const onNodeCollapse = spy();
        const onNodeContextMenu = spy();
        const onNodeDoubleClick = spy();
        const onNodeExpand = spy();
        const onNodeMouseEnter = spy();
        const onNodeMouseLeave = spy();

        const contents = createDefaultContents();
        contents[0].disabled = true;
        contents[0].hasCaret = true;
        contents[0].isExpanded = false;

        const tree = renderTree({
            contents,
            onNodeClick,
            onNodeCollapse,
            onNodeContextMenu,
            onNodeDoubleClick,
            onNodeExpand,
            onNodeMouseEnter,
            onNodeMouseLeave,
        });

        const treeNode = tree.find(`.${Classes.TREE_NODE}.c0`);
        const treeNodeContent = treeNode.find(`.${Classes.TREE_NODE_CONTENT}`);
        const treeNodeCaret = treeNodeContent.find(`.${Classes.TREE_NODE_CARET}`).first();

        treeNodeContent.simulate("click");
        assert.isTrue(onNodeClick.notCalled);

        treeNodeContent.simulate("dblclick");
        assert.isTrue(onNodeDoubleClick.notCalled);

        treeNodeContent.simulate("contextmenu");
        assert.isTrue(onNodeContextMenu.notCalled);

        treeNodeContent.simulate("mouseenter");
        assert.isTrue(onNodeMouseEnter.notCalled);

        treeNodeContent.simulate("mouseleave");
        assert.isTrue(onNodeMouseLeave.notCalled);

        treeNodeCaret.simulate("click");
        assert.isTrue(onNodeExpand.notCalled);

        treeNodeCaret.simulate("click");
        assert.isTrue(onNodeCollapse.notCalled);
    });

    it("disabled nodes are rendered correctly", () => {
        const contents = createDefaultContents();
        contents[0].disabled = true;

        const tree = renderTree({ contents });
        const disabledTreeNode = tree.find(`.${Classes.TREE_NODE}.c0.${Classes.DISABLED}`);

        assert.equal(disabledTreeNode.length, 1);
    });

    it("icons are rendered correctly if present", () => {
        const contents = createDefaultContents();
        contents[1].icon = "document";
        contents[2].icon = "document";

        const tree = renderTree({ contents });
        assertNodeHasClass(tree, "c0", Classes.TREE_NODE_ICON, false);
        assertNodeHasClass(tree, "c1", Classes.TREE_NODE_ICON);
        assertNodeHasClass(tree, "c2", Classes.TREE_NODE_ICON);
    });

    it("isExpanded controls node expansion", () => {
        const contents = createDefaultContents();
        contents[3].isExpanded = false;
        contents[4].isExpanded = true;

        const nodes = renderTree({ contents }).find("li");
        assert.lengthOf(nodes.filter(`.c1.${Classes.TREE_NODE_EXPANDED}`), 0);
        assert.lengthOf(nodes.filter(".c5"), 0);
        assert.lengthOf(nodes.filter(`.c3.${Classes.TREE_NODE_EXPANDED}`), 0);
        assert.lengthOf(nodes.filter(".c6"), 0);
        assert.lengthOf(nodes.filter(`.c4.${Classes.TREE_NODE_EXPANDED}`), 1);
        assert.lengthOf(nodes.filter(".c7"), 1);
    });

    it("isSelected selects nodes", () => {
        const contents = createDefaultContents();
        contents[1].isSelected = false;
        contents[2].isSelected = true;

        const nodes = renderTree({ contents }).find("li");
        assert.lengthOf(nodes.filter(`.c0.${Classes.TREE_NODE_SELECTED}`), 0);
        assert.lengthOf(nodes.filter(`.c1.${Classes.TREE_NODE_SELECTED}`), 0);
        assert.lengthOf(nodes.filter(`.c2.${Classes.TREE_NODE_SELECTED}`), 1);
    });

    it("secondaryLabel renders correctly", () => {
        const contents = createDefaultContents();
        contents[1].secondaryLabel = "Secondary";
        contents[2].secondaryLabel = <p>Paragraph</p>;

        const tree = renderTree({ contents }).find("li");
        assertNodeHasClass(tree, "c0", Classes.TREE_NODE_SECONDARY_LABEL, false);
        assert.strictEqual(findNodeClass(tree, "c1", Classes.TREE_NODE_SECONDARY_LABEL).text(), "Secondary");
        assert.strictEqual(findNodeClass(tree, "c2", Classes.TREE_NODE_SECONDARY_LABEL).text(), "Paragraph");
    });

    it("getNodeContentElement returns references to underlying node elements", done => {
        const contents = createDefaultContents();
        contents[1].isExpanded = true;

        const wrapper = renderTree({ contents });
        const tree = wrapper.instance() as Tree;

        assert.strictEqual(
            tree.getNodeContentElement(5),
            wrapper.getDOMNode().querySelector<HTMLElement>(`.c5 > .${Classes.TREE_NODE_CONTENT}`),
        );
        assert.isUndefined(tree.getNodeContentElement(100));

        contents[1].isExpanded = false;
        wrapper.setProps({ contents });
        // wait for animation to finish
        setTimeout(() => {
            assert.isUndefined(tree.getNodeContentElement(5));
            done();
        }, 300);
    });

    it("allows nodes to be removed without throwing", () => {
        const contents = createDefaultContents();
        renderTree({ contents });

        const smallerContents = createDefaultContents().slice(0, -1);
        assert.doesNotThrow(() => renderTree({ contents: smallerContents }));
    });

    function findNodeClass(tree: ReactWrapper, nodeClass: string, childClass: string) {
        return tree.find(`.${nodeClass} > .${Classes.TREE_NODE_CONTENT} .${childClass}`).hostNodes();
    }

    function assertNodeHasClass(tree: ReactWrapper, nodeClass: string, childClass: string, expected = true) {
        assert.equal(findNodeClass(tree, nodeClass, childClass).exists(), expected);
    }

    function assertNodeHasCaret(tree: ReactWrapper, nodeClass: string, hasCaret: boolean) {
        return assertNodeHasClass(tree, nodeClass, hasCaret ? Classes.TREE_NODE_CARET : Classes.TREE_NODE_CARET_NONE);
    }

    function renderTree(props?: Partial<TreeProps>) {
        return mount(<Tree contents={createDefaultContents()} {...props} />);
    }

    // tslint:disable object-literal-sort-keys
    function createDefaultContents(): TreeNodeInfo[] {
        return [
            { id: 0, className: "c0", label: "Item 0" },
            {
                id: 1,
                className: "c1",
                label: "Item 1",
                childNodes: [{ id: 5, className: "c5", label: "Item 5" }],
            },
            { id: 2, className: "c2", label: "Item 2" },
            {
                id: 3,
                className: "c3",
                label: "Item 3",
                childNodes: [{ id: 6, className: "c6", label: "Item 6" }],
            },
            {
                id: 4,
                className: "c4",
                label: "Item 4",
                childNodes: [{ id: 7, className: "c7", label: "Item 7" }],
            },
        ];
    }
});

================================================================================

